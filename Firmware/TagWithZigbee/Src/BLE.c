#include <stdbool.h>
#include "string.h"
#include "BLE.h"
#include "ServiceUartIF.h"
#include "ZigBee.h"

#define BUFFER_SIZE 256  /* must be power of two */
#define COMMAND_BUFFER_SIZE 128

#define NUM_OF_MODULES 4

#define QUEUE_SIZE 60

typedef enum {DecodeAnchor, DecodeAntenna, DecodeRSSI, DecodeChannel} DecodePart;
typedef enum { Init = 0, ListeningAdv} BleState;


typedef struct
{
    uint8_t    rxBuffer[BUFFER_SIZE];
    uint16_t   lastProccessed;
    uint8_t    commandBuffer[COMMAND_BUFFER_SIZE];
    uint8_t    commandBufferIndex;
}COMM_MODULE;


typedef enum {Module1 = 0, Module2, Module3, Module4} Modules;

static COMM_MODULE modData;



static QueueItem queue[QUEUE_SIZE];
static uint8_t queueBottom;
static uint8_t queueTop;

static bool GetDataFromReport(uint8_t *inputString, uint8_t lenght, REPORT *decodedReport);

UART_HandleTypeDef* mod0;
UART_HandleTypeDef* mod1;
UART_HandleTypeDef* mod2;
UART_HandleTypeDef* mod3;

static BleState bleState;
static PositioningMode positioingMode = PositioningModeRemote;

static const uint8_t startCmdListen[] = "at+run \"movingTag\"\r";        //run as listening anchors
//static const uint8_t startCmdTrasmit[] = "at+run \"sAnchor\"\r";        //run as trasmitting anchors

static uint8_t *startCmd;

static bool filterEnable;
static uint64_t advAddr[255];
static uint16_t advAddrIndex;

static uint32_t tickReference;

static bool GetDataFromReport(uint8_t *inputString, uint8_t lenght, REPORT *decodedReport);
static void ProcessReport(REPORT *report, Modules module);
static void CheckForCompleteRecord(QueueItem* queue, uint16_t item);

#define ProcessModuleMessage(module, hdma) \
      if(mods[module].lastProccessed != hdma->Instance->NDTR) \
      { \
          char tmpChar = mods[module].rxBuffer[BUFFER_SIZE - mods[module].lastProccessed--]; \
          if(mods[module].lastProccessed == 0) \
          { \
              mods[module].lastProccessed = BUFFER_SIZE; \
          } \
          mods[module].commandBuffer[mods[module].commandBufferIndex++] = tmpChar; \
          if(tmpChar == '\r') \
          { \
              REPORT reportMod; \
              if (GetDataFromReport(mods[module].commandBuffer, mods[module].commandBufferIndex, &reportMod)) \
              { \
                  ProcessReport(&reportMod, module); \
              }\
              mods[module].commandBufferIndex = 0; \
          }else{ \
               \
          } \
      }
      
     
uint8_t anchorTmp;
uint8_t antennaTmp;      
void ProcessModuleMessage2()
{
    uint32_t dmaNDTR;
    __disable_irq();                        //requred for atomic operation
    dmaNDTR = mod0->hdmarx->Instance->NDTR;
    __enable_irq();
    
    if(modData.lastProccessed != dmaNDTR)
    {
        char tmpChar = modData.rxBuffer[BUFFER_SIZE - modData.lastProccessed--];
        if(modData.lastProccessed == 0)
        {
            modData.lastProccessed = BUFFER_SIZE;
        }
        modData.commandBuffer[modData.commandBufferIndex++] = tmpChar;
        
        if(tmpChar == 0)
        {
            antennaTmp = 10;
        }
        
        if(tmpChar == '\r')
        {
            if ((modData.commandBuffer[1] == 'A') && (modData.commandBuffer[3] == 'A'))      //following start line character (';') we expect "A0A0" for anchor0antenna0
            {
                anchorTmp = modData.commandBuffer[2] - '0';
                antennaTmp = modData.commandBuffer[4] - '0';
                if(anchorTmp != 0)
                {
                    anchorTmp = 5;
                }
            }
            
            
            
            
            
            REPORT reportMod;
            if (GetDataFromReport(modData.commandBuffer, modData.commandBufferIndex, &reportMod))
            {
                ProcessReport(&reportMod, 0);
            }
            modData.commandBufferIndex = 0;
        }else{

        }
    }
}


void BleInit(UART_HandleTypeDef* _mod0)
{
    mod0 = _mod0;
    __HAL_UART_FLUSH_DRREGISTER(mod0);     //discard any bytes in register which could be generated by power up routins of modules
    
    HAL_UART_Receive_DMA(mod0, modData.rxBuffer, BUFFER_SIZE);       //start receive DMA channels, RX chars are stored in ring buffer
    
    modData.lastProccessed = BUFFER_SIZE;

    
    uint8_t i;
    for(i = 0; i < QUEUE_SIZE; i++)
    {
      queue[i].NumOfRecords = -1;
      queue[i].rssi[0] = -110;
      queue[i].rssi[1] = -110;
      queue[i].rssi[2] = -110;
      queue[i].rssi[3] = -110;

      queue[i].channel[0] = 0;
      queue[i].channel[1] = 0;
      queue[i].channel[2] = 0;
      queue[i].channel[3] = 0;
      
    }
    
    startCmd = (uint8_t*)startCmdListen;
    bleState = Init;
    
}



void BleTask()
{
    switch(bleState)
    {
        case Init:
            HAL_UART_Transmit_DMA(mod0, startCmd, strlen((const char*)startCmd));
            HAL_Delay(132);
            bleState = ListeningAdv;
            break;
        
        case ListeningAdv:
            /*=== Process receive ring buffers of BLE modules ===*/
            ProcessModuleMessage2();


            uint8_t i;
            if (queueBottom != queueTop)
            {
                if(queueBottom < queueTop)
                {
                    for(i = queueBottom; i < queueTop; i++)
                    {
                      CheckForCompleteRecord(queue, i);
                    }
                }
                else // queue rolled over, not bottom is greater than top
                {
                    for(i = queueBottom; i < QUEUE_SIZE; i++)
                    {
                      CheckForCompleteRecord(queue, i);
                    }

                    for(i = 0; i < queueTop; i++)
                    {
                      CheckForCompleteRecord(queue, i);
                    }
                }
            }
        
            break;
        
        
        default:
            break;
    }
}


static bool GetDataFromReport(uint8_t *inputString, uint8_t lenght, REPORT *decodedReport)
{
    DecodePart decodePart;
    uint8_t c;
    
    uint64_t localId = 0;
    int8_t localRssi = 0;
    uint8_t localChannel = 0;
    
    uint8_t anchor;
    uint8_t antenna;
    
    int8_t applySign = 1;
    
    if(inputString[0] == ';')
    {
        uint8_t i;
        
        if ((inputString[1] == 'A') && (inputString[3] == 'A'))      //following ';' we expect "A0A0" for anchor0antenna0
        {
            anchor = inputString[2] - '0';
            antenna = inputString[4] - '0';
            if(anchor > 3)
            {
                anchor = 5;
            }
            decodedReport->anchor = inputString[2] - '0';
            decodedReport->AdvAddr = ((uint32_t)0x0A << 24) | (((uint32_t)anchor) << 16) | ((uint32_t)0x0A << 8) | ((uint32_t)antenna);
            decodePart = DecodeRSSI;
        }
        else
        {
            return false;               //'A', signalizing anchor is not in the message, do not proceed
        }
        
        for(i = 6; i < lenght; i++)
        {
            c = inputString[i]; 
            if((c == ',') || (c == '\r'))
            {
                switch(decodePart)
                {                    
                    case DecodeRSSI:
                        decodedReport->rssi = applySign * localRssi;
                        decodePart = DecodeChannel;
                        break;
                    
                    case DecodeChannel:
                        decodedReport->channel = localChannel;
                        //ServiceUartIFPrint("BLE report from: A%uA%u: %d, %d\n", anchor, antenna, localRssi, localChannel);
                        return true;
                }
            }
            else
            {
                switch(decodePart)
                {
                    case DecodeRSSI:
                        localRssi *= 10;
                        if ((c >= '0') && (c <= '9'))            
                        {
                            localRssi += (c - '0');
                        }
                        else if (c == '-')
                        {
                            applySign = -1;
                        }else{
                            return false;
                        }
                        break;
                        
                    case DecodeChannel:
                        if ((c >= '0') && (c <= '9'))            
                        {
                            localChannel = (c - '0');
                        }
                        else{
                            return false;
                        }
                        break;
                }
            }    
        }
    }
    return false;
}

static void ProcessReport(REPORT *report, Modules module)
{
    QueueItem *qi;
    
    if(filterEnable == true)
    {
        if (report->AdvAddr != advAddr[0])
        {
            return;
        }
    }    
    
    qi = FindItem(report->AdvAddr);
    if(qi != NULL)
    {
        uint32_t antennaAddr = report->AdvAddr & 0x03;
        
        if (qi->rssi[antennaAddr] == -110)
        {
            qi->channel[antennaAddr] = report->channel;
            qi->rssi[antennaAddr] = report->rssi;
            qi->NumOfRecords++;
        }
        else
        {
            
            //ServiceUartIFPrint("Atenna reports aleredy exists %d\n", antennaAddr);
        }
    }
    else
    {
        ServiceUartIFPrint("Queue: no free slots\n");
    }
}

QueueItem* FindItem(uint64_t advAddr)
{
    uint8_t itemsInQueue;
    uint8_t i;
    
    if(queueBottom != queueTop)
    {
        ServiceUartIFPrint("Search %x\n", (uint32_t)advAddr);
        if (queueBottom < queueTop)         //all ok bottom is under top
        {
            itemsInQueue = queueTop - queueBottom;
            for(i=queueBottom;i<queueTop;i++) //seach for AdvAddr in queue
            {
                if (queue[i].NumOfRecords != -1)
                {
                    if((advAddr & 0xFF0000) == (queue[i].AdvAddr & 0xFF0000))  //id found, return queue item
                    {
                        //ServiceUartIFPrint("Slot found:(%u/%u), %d\n", queueBottom, queueTop, i);
                        ServiceUartIFPrint("Found0 %x, items %d\n", (uint32_t)queue[i].AdvAddr, queue[i].NumOfRecords);
                        return &queue[i];
                    }
                }
            }
        }
        else
        {                              //there has been a overflow from top addres to 0, does not mean the queue is full
            itemsInQueue = QUEUE_SIZE - queueBottom + queueTop;
            
            for(i=queueBottom;i<QUEUE_SIZE;i++) //seach for AdvAddr in queue, bottom to top slots
            {
                if (queue[i].NumOfRecords != -1)
                {
                    if((advAddr & 0xFF0000) == (queue[i].AdvAddr & 0xFF0000))  //id found, return queue item
                    {
                        //ServiceUartIFPrint("Slot found: (%u/%u), %d\n", queueBottom, queueTop, i);
                        ServiceUartIFPrint("Found1 %x, items %d\n", (uint32_t)queue[i].AdvAddr, queue[i].NumOfRecords);
                        return &queue[i];
                    }
                }
            }
            
            for(i=0;i<queueTop;i++) //seach for AdvAddr in queue, form 0 to top slots
            {
                if (queue[i].NumOfRecords != -1)
                {
                    if((advAddr & 0xFF0000) == (queue[i].AdvAddr & 0xFF0000))  //id found, return queue item
                    {
                        //ServiceUartIFPrint("Slot found: (%u/%u), %d\n", queueBottom, queueTop, i);
                        ServiceUartIFPrint("Found2 %x, items %d\n", (uint32_t)queue[i].AdvAddr, queue[i].NumOfRecords);
                        return &queue[i];
                    }
                }
            }
        }
    }
    return GetFreeQueueItem(advAddr);    //queue is empty or AdvAddr was not found create a new entry for AdvAddr and return the queue slot
}

///Gets a spot in ReportQueue, fills created time (reports from four antennnas need to be received in 4 miliseconds to ensure that they comes from a single advertisement, 
///                            in case there is received less than 4 reports after 4 miliseconds only 3 reports are sent to system)
///                          , and fills AdvAddress (id)
///
QueueItem* GetFreeQueueItem(uint64_t id)
{
    uint8_t tmpQTop;
    if (queueBottom != queueTop)
    {
        if(queueBottom < queueTop)
        {
            if((queueTop - queueBottom) >= (QUEUE_SIZE - 1) )
            {
                return NULL;
            }
        }
        else
        {
            if( (QUEUE_SIZE - queueBottom + queueTop) >= (QUEUE_SIZE - 1) )
            {
                return NULL;
            }
        }
    }
    queue[queueTop].CreateTime = HAL_GetTick();
    queue[queueTop].AdvAddr = id;
    ServiceUartIFPrint("New addr %x\n", (uint32_t)queue[queueTop].AdvAddr);
    queue[queueTop].NumOfRecords = 0;
    //ServiceUartIFPrint("New slot %d\n", queueTop);
    tmpQTop = queueTop;
    queueTop++;
    if (queueTop >= QUEUE_SIZE)
    {
        queueTop = 0;
    }
    
    //ServiceUartIFPrint("New Queue Slot add: (%u / %u) > %d\n", queueBottom, queueTop, HAL_GetTick());
    return &queue[tmpQTop];
}

static void CheckForCompleteRecord(QueueItem* _queue, uint16_t item)
{
    QueueItem *queueItem = &_queue[item];
    
    
    //ServiceUartIFPrint("Ckecking: %d\n", item);
    
    if(queueItem->NumOfRecords != -1)
    {
        uint32_t tick = HAL_GetTick();
        //ServiceUartIFPrint("Time %d, elements %d\n", tick, queueItem->NumOfRecords);
        
        if (((queueItem->CreateTime + 200) < tick) || (queueItem->NumOfRecords == 4))    //send record if the timeout has elapsaed or all four records has been received
        {     
            ServiceUartIFPrint("CurAddr: %x\n", (uint32_t)queueItem->AdvAddr);            
            //note after reset this might be fired instatnly due to messages which were buffered during initialization, after that only some messages are received
            //within set window (queueItem->CreateTime + 4)
            
            //TransmitData(queue[i].rawData, 20);
            queueItem->CreateTime -= tickReference;     //during creation HAL_GetTick was used, subtract reference to get current time from last synchro reset time base
            queueItem->AdvAddr = ((uint32_t)queueItem->AdvAddr >> 16);
            
            if ( queueItem->AdvAddr == 0x00)
            {
                ServiceUartIFPrint("null address #####\n");
            }
            ZigBeeQueueNewReport(queueItem->rawData);
            uint8_t elementsCount = queueItem->NumOfRecords;
            queueItem->NumOfRecords = -1;
            //ServiceUartIFPrint("BLE report from: A%u: %d, %d //%d, %d //%d, %d //%d, %d //\n", queueItem->rawData[2], queueItem->rssi[0], queueItem->channel[0], queueItem->rssi[1], queueItem->channel[1], queueItem->rssi[2], queueItem->channel[2], queueItem->rssi[3], queueItem->channel[3]);
            //ServiceUartIFPrint("========== Whole BLE, elements %d\n", elementsCount);
            if (elementsCount != 4)
            {
                ServiceUartIFPrint("========== BLE part report -> elements %d\n", elementsCount);
            }
            
            
            queueItem->rssi[0] = -110;
            queueItem->rssi[1] = -110;
            queueItem->rssi[2] = -110;
            queueItem->rssi[3] = -110;
            
            queueItem->channel[0] = 0;
            queueItem->channel[1] = 0;
            queueItem->channel[2] = 0;
            queueItem->channel[3] = 0;
            //ServiceUartIFPrint("Delete slot %d, bottom %d\n", item, queueBottom);
            if(item == queueBottom)
            {
                queueBottom++;
                if (queueBottom >= QUEUE_SIZE)
                {
                    queueBottom = 0;
                }
            }
        }
    }
    else
    {
        static int lastItem = -1;
        if (lastItem != item)
        {
            lastItem = item;
            //ServiceUartIFPrint("no data: %d\n, bottom: %d", item, queueBottom);
        }
        
        if (item == queueBottom)        //Anchor0 has 3 messages in buffer slot0, Anchor1 has 4 messages in buffer slot1
        {                               //Anchor1 can send data so slot1 become free, Anchor0 waits for last report
          queueBottom++;                //once Anchor0 is freed, queueBottom jumps through slot1 (from Anchor1) to slot2
          if (queueBottom >= QUEUE_SIZE)
          {
              queueBottom = 0;
          }
        }
    }
}



void BleAddressFilterEnable()
{
    filterEnable = true;
}

void BleAddressFilterDisable()
{
    filterEnable = false;
}

void BleAddressFilterAdd(uint64_t address)
{
    advAddr[advAddrIndex] = address;
}

void BleResetTicks()
{
    tickReference = HAL_GetTick();
}

void PositioningModeSet(PositioningMode _positioingMode)
{
    positioingMode = _positioingMode;
}

PositioningMode PositioningModeGet()
{
    return positioingMode;
}
