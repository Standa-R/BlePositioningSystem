L 1 "..\Src\BLE.c"
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5050157
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 2 "..\Src\BLE.c" 2
N#include "string.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5050157
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 3 "..\Src\BLE.c" 2
N#include "BLE.h"
L 1 "..\Src\BLE.h" 1
N#include "stm32f0xx_hal.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal.h
N  * @author  MCD Application Team
N  * @brief   This file contains all the functions prototypes for the HAL 
N  *          module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_H
N#define __STM32F0xx_HAL_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_conf.h"
L 1 "../Inc/stm32f0xx_hal_conf.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_conf.h
N  * @brief   HAL configuration file.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2018 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_CONF_H
N#define __STM32F0xx_HAL_CONF_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/* ########################## Module Selection ############################## */
N/**
N  * @brief This is the list of modules to be used in the HAL driver 
N  */
N#define HAL_MODULE_ENABLED  
N/*#define HAL_ADC_MODULE_ENABLED   */
N/*#define HAL_CRYP_MODULE_ENABLED   */
N/*#define HAL_CAN_MODULE_ENABLED   */
N/*#define HAL_CEC_MODULE_ENABLED   */
N/*#define HAL_COMP_MODULE_ENABLED   */
N/*#define HAL_CRC_MODULE_ENABLED   */
N/*#define HAL_CRYP_MODULE_ENABLED   */
N/*#define HAL_TSC_MODULE_ENABLED   */
N/*#define HAL_DAC_MODULE_ENABLED   */
N/*#define HAL_I2S_MODULE_ENABLED   */
N/*#define HAL_IWDG_MODULE_ENABLED   */
N/*#define HAL_LCD_MODULE_ENABLED   */
N/*#define HAL_LPTIM_MODULE_ENABLED   */
N/*#define HAL_RNG_MODULE_ENABLED   */
N#define HAL_RTC_MODULE_ENABLED
N/*#define HAL_SPI_MODULE_ENABLED   */
N/*#define HAL_TIM_MODULE_ENABLED   */
N#define HAL_UART_MODULE_ENABLED
N/*#define HAL_USART_MODULE_ENABLED   */
N/*#define HAL_IRDA_MODULE_ENABLED   */
N/*#define HAL_SMARTCARD_MODULE_ENABLED   */
N/*#define HAL_SMBUS_MODULE_ENABLED   */
N/*#define HAL_WWDG_MODULE_ENABLED   */
N/*#define HAL_PCD_MODULE_ENABLED   */
N/*#define HAL_EXTI_MODULE_ENABLED   */
N#define HAL_CORTEX_MODULE_ENABLED
N#define HAL_DMA_MODULE_ENABLED
N#define HAL_FLASH_MODULE_ENABLED
N#define HAL_GPIO_MODULE_ENABLED
N#define HAL_PWR_MODULE_ENABLED
N#define HAL_RCC_MODULE_ENABLED
N#define HAL_I2C_MODULE_ENABLED
N
N/* ########################## HSE/HSI Values adaptation ##################### */
N/**
N  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
N  *        This value is used by the RCC HAL module to compute the system frequency
N  *        (when HSE is used as system clock source, directly or through the PLL).  
N  */
N#if !defined  (HSE_VALUE) 
X#if !0L 
N  #define HSE_VALUE    ((uint32_t)12000000) /*!< Value of the External oscillator in Hz */
N#endif /* HSE_VALUE */
N
N/**
N  * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
N  *        Timeout value 
N  */
N#if !defined  (HSE_STARTUP_TIMEOUT)
X#if !0L
N  #define HSE_STARTUP_TIMEOUT    ((uint32_t)100)   /*!< Time out for HSE start up, in ms */
N#endif /* HSE_STARTUP_TIMEOUT */
N
N/**
N  * @brief Internal High Speed oscillator (HSI) value.
N  *        This value is used by the RCC HAL module to compute the system frequency
N  *        (when HSI is used as system clock source, directly or through the PLL). 
N  */
N#if !defined  (HSI_VALUE)
X#if !0L
N  #define HSI_VALUE    ((uint32_t)8000000) /*!< Value of the Internal oscillator in Hz*/
N#endif /* HSI_VALUE */
N
N/**
N  * @brief In the following line adjust the Internal High Speed oscillator (HSI) Startup 
N  *        Timeout value 
N  */
N#if !defined  (HSI_STARTUP_TIMEOUT) 
X#if !0L 
N #define HSI_STARTUP_TIMEOUT   ((uint32_t)5000) /*!< Time out for HSI start up */
N#endif /* HSI_STARTUP_TIMEOUT */  
N
N/**
N  * @brief Internal High Speed oscillator for ADC (HSI14) value.
N  */
N#if !defined  (HSI14_VALUE) 
X#if !0L 
N#define HSI14_VALUE ((uint32_t)14000000) /*!< Value of the Internal High Speed oscillator for ADC in Hz.
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif /* HSI14_VALUE */
N
N/**
N  * @brief Internal High Speed oscillator for USB (HSI48) value.
N  */
N#if !defined  (HSI48_VALUE) 
X#if !0L 
N#define HSI48_VALUE ((uint32_t)48000000) /*!< Value of the Internal High Speed oscillator for USB in Hz.
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif /* HSI48_VALUE */
N
N/**
N  * @brief Internal Low Speed oscillator (LSI) value.
N  */
N#if !defined  (LSI_VALUE) 
X#if !0L 
N #define LSI_VALUE  ((uint32_t)40000)    
N#endif /* LSI_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N/**
N  * @brief External Low Speed oscillator (LSI) value.
N  */
N#if !defined  (LSE_VALUE)
X#if !0L
N #define LSE_VALUE  ((uint32_t)32768)    /*!< Value of the External Low Speed oscillator in Hz */
N#endif /* LSE_VALUE */     
N
N#if !defined  (LSE_STARTUP_TIMEOUT)
X#if !0L
N  #define LSE_STARTUP_TIMEOUT    ((uint32_t)5000)   /*!< Time out for LSE start up, in ms */
N#endif /* LSE_STARTUP_TIMEOUT */
N
N/* Tip: To avoid modifying this file each time you need to use different HSE,
N   ===  you can define the HSE value in your toolchain compiler preprocessor. */
N
N/* ########################### System Configuration ######################### */
N/**
N  * @brief This is the HAL system configuration section
N  */     
N#define  VDD_VALUE                    ((uint32_t)3300) /*!< Value of VDD in mv */           
N#define  TICK_INT_PRIORITY            ((uint32_t)0)    /*!< tick interrupt priority (lowest by default)  */            
N                                                                              /*  Warning: Must be set to higher priority for HAL_Delay()  */
N                                                                              /*  and HAL_GetTick() usage under interrupt context          */
N#define  USE_RTOS                     0     
N#define  PREFETCH_ENABLE              1              
N#define  INSTRUCTION_CACHE_ENABLE     0
N#define  DATA_CACHE_ENABLE            0
N/* ########################## Assert Selection ############################## */
N/**
N  * @brief Uncomment the line below to expanse the "assert_param" macro in the 
N  *        HAL drivers code
N  */
N/* #define USE_FULL_ASSERT   1U */
N
N/* ################## SPI peripheral configuration ########################## */
N
N/* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver
N* Activated: CRC code is present inside driver
N* Deactivated: CRC code cleaned from driver
N*/
N
N#define USE_SPI_CRC                     0U
N
N/* Includes ------------------------------------------------------------------*/
N/**
N  * @brief Include module's header file 
N  */
N
N#ifdef HAL_RCC_MODULE_ENABLED
N #include "stm32f0xx_hal_rcc.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_rcc.h
N  * @author  MCD Application Team
N  * @brief   Header file of RCC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_RCC_H
N#define __STM32F0xx_HAL_RCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_def.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_def.h
N  * @author  MCD Application Team
N  * @brief   This file contains HAL common defines, enumeration, macros and 
N  *          structures definitions. 
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_DEF
N#define __STM32F0xx_HAL_DEF
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx.h"
L 1 "../Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f0xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx.h
N  * @author  MCD Application Team
N  * @brief   CMSIS STM32F0xx Device Peripheral Access Layer Header File.           
N  *            
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The STM32F0xx device used in the target application
N  *              - To use or not the peripheral’s drivers in application code(i.e. 
N  *                code will be based on direct access to peripheral’s registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_HAL_DRIVER"
N  *  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f0xx
N  * @{
N  */
N    
N#ifndef __STM32F0xx_H
N#define __STM32F0xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N   
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N  
N/**
N  * @brief STM32 Family
N  */
N#if !defined  (STM32F0)
X#if !0L
N#define STM32F0
N#endif /* STM32F0 */
N
N/* Uncomment the line below according to the target STM32 device used in your
N   application 
N  */
N
N#if !defined (STM32F030x6) && !defined (STM32F030x8) &&                           \
N    !defined (STM32F031x6) && !defined (STM32F038xx) &&                           \
N    !defined (STM32F042x6) && !defined (STM32F048xx) && !defined (STM32F070x6) && \
N    !defined (STM32F051x8) && !defined (STM32F058xx) &&                           \
N    !defined (STM32F071xB) && !defined (STM32F072xB) && !defined (STM32F078xx) && !defined (STM32F070xB) && \
N    !defined (STM32F091xC) && !defined (STM32F098xx) && !defined (STM32F030xC)
X#if !0L && !0L &&                               !0L && !0L &&                               !0L && !0L && !0L &&     !0L && !0L &&                               !0L && !0L && !0L && !0L &&     !1L && !0L && !0L
S  /* #define STM32F030x6 */  /*!< STM32F030x4, STM32F030x6 Devices (STM32F030xx microcontrollers where the Flash memory ranges between 16 and 32 Kbytes)              */
S  /* #define STM32F030x8 */  /*!< STM32F030x8 Devices (STM32F030xx microcontrollers where the Flash memory is 64 Kbytes)                                              */
S  /* #define STM32F031x6 */  /*!< STM32F031x4, STM32F031x6 Devices (STM32F031xx microcontrollers where the Flash memory ranges between 16 and 32 Kbytes)              */
S  /* #define STM32F038xx */  /*!< STM32F038xx Devices (STM32F038xx microcontrollers where the Flash memory is 32 Kbytes)                                              */
S  /* #define STM32F042x6 */  /*!< STM32F042x4, STM32F042x6 Devices (STM32F042xx microcontrollers where the Flash memory ranges between 16 and 32 Kbytes)              */
S  /* #define STM32F048x6 */  /*!< STM32F048xx Devices (STM32F042xx microcontrollers where the Flash memory is 32 Kbytes)                                              */
S  /* #define STM32F051x8 */  /*!< STM32F051x4, STM32F051x6, STM32F051x8 Devices (STM32F051xx microcontrollers where the Flash memory ranges between 16 and 64 Kbytes) */
S  /* #define STM32F058xx */  /*!< STM32F058xx Devices (STM32F058xx microcontrollers where the Flash memory is 64 Kbytes)                                              */
S  /* #define STM32F070x6 */  /*!< STM32F070x6 Devices (STM32F070x6 microcontrollers where the Flash memory ranges between 16 and 32 Kbytes)                           */
S  /* #define STM32F070xB */  /*!< STM32F070xB Devices (STM32F070xB microcontrollers where the Flash memory ranges between 64 and 128 Kbytes)                          */
S  /* #define STM32F071xB */  /*!< STM32F071x8, STM32F071xB Devices (STM32F071xx microcontrollers where the Flash memory ranges between 64 and 128 Kbytes)             */
S  /* #define STM32F072xB */  /*!< STM32F072x8, STM32F072xB Devices (STM32F072xx microcontrollers where the Flash memory ranges between 64 and 128 Kbytes)             */
S  /* #define STM32F078xx */  /*!< STM32F078xx Devices (STM32F078xx microcontrollers where the Flash memory is 128 Kbytes)                                             */
S  /* #define STM32F030xC */  /*!< STM32F030xC Devices (STM32F030xC microcontrollers where the Flash memory is 256 Kbytes)                                             */  
S  /* #define STM32F091xC */  /*!< STM32F091xB, STM32F091xC Devices (STM32F091xx microcontrollers where the Flash memory ranges between 128 and 256 Kbytes)            */
S  /* #define STM32F098xx */  /*!< STM32F098xx Devices (STM32F098xx microcontrollers where the Flash memory is 256 Kbytes)                                             */
N#endif
N   
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N  */
N#if !defined  (USE_HAL_DRIVER)
X#if !1L
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_HAL_DRIVER */
N#endif /* USE_HAL_DRIVER */
N
N/**
N  * @brief CMSIS Device version number V2.3.3
N  */
N#define __STM32F0_DEVICE_VERSION_MAIN   (0x02) /*!< [31:24] main version */
N#define __STM32F0_DEVICE_VERSION_SUB1   (0x03) /*!< [23:16] sub1 version */
N#define __STM32F0_DEVICE_VERSION_SUB2   (0x03) /*!< [15:8]  sub2 version */
N#define __STM32F0_DEVICE_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __STM32F0_DEVICE_VERSION        ((__STM32F0_DEVICE_VERSION_MAIN << 24)\
N                                        |(__STM32F0_DEVICE_VERSION_SUB1 << 16)\
N                                        |(__STM32F0_DEVICE_VERSION_SUB2 << 8 )\
N                                        |(__STM32F0_DEVICE_VERSION_RC))
X#define __STM32F0_DEVICE_VERSION        ((__STM32F0_DEVICE_VERSION_MAIN << 24)                                        |(__STM32F0_DEVICE_VERSION_SUB1 << 16)                                        |(__STM32F0_DEVICE_VERSION_SUB2 << 8 )                                        |(__STM32F0_DEVICE_VERSION_RC))
N                                             
N/**
N  * @}
N  */
N
N/** @addtogroup Device_Included
N  * @{
N  */
N
N#if defined(STM32F030x6)
X#if 0L
S  #include "stm32f030x6.h"
S#elif defined(STM32F030x8)
X#elif 0L
S  #include "stm32f030x8.h"
S#elif defined(STM32F031x6)
X#elif 0L
S  #include "stm32f031x6.h"
S#elif defined(STM32F038xx)
X#elif 0L
S  #include "stm32f038xx.h"
S#elif defined(STM32F042x6)
X#elif 0L
S  #include "stm32f042x6.h"
S#elif defined(STM32F048xx)
X#elif 0L
S  #include "stm32f048xx.h"
S#elif defined(STM32F051x8)
X#elif 0L
S  #include "stm32f051x8.h"
S#elif defined(STM32F058xx)
X#elif 0L
S  #include "stm32f058xx.h"
S#elif defined(STM32F070x6)
X#elif 0L
S  #include "stm32f070x6.h"
S#elif defined(STM32F070xB)
X#elif 0L
S  #include "stm32f070xb.h"
S#elif defined(STM32F071xB)
X#elif 0L
S  #include "stm32f071xb.h"
S#elif defined(STM32F072xB)
X#elif 0L
S  #include "stm32f072xb.h"
S#elif defined(STM32F078xx)
X#elif 0L
S  #include "stm32f078xx.h"
N#elif defined(STM32F091xC)
X#elif 1L
N  #include "stm32f091xc.h"
L 1 "../Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f091xc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f091xc.h
N  * @author  MCD Application Team
N  * @brief   CMSIS Cortex-M0 Device Peripheral Access Layer Header File. 
N  *          This file contains all the peripheral register's definitions, bits 
N  *          definitions and memory mapping for STM32F0xx devices.            
N  *            
N  *          This file contains:
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripheral’s registers hardware
N  *  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N                                                           
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f091xc
N  * @{
N  */
N    
N#ifndef __STM32F091xC_H
N#define __STM32F091xC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N
N  /** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N/**
N * @brief Configuration of the Cortex-M0 Processor and Core Peripherals
N */
N#define __CM0_REV                 0 /*!< Core Revision r0p0                            */
N#define __MPU_PRESENT             0 /*!< STM32F0xx do not provide MPU                  */
N#define __NVIC_PRIO_BITS          2 /*!< STM32F0xx uses 2 Bits for the Priority Levels */
N#define __Vendor_SysTickConfig    0     /*!< Set to 1 if different SysTick Config is used */
N 
N/**
N  * @}
N  */
N   
N/** @addtogroup Peripheral_interrupt_number_definition
N  * @{
N  */
N
N/**
N * @brief STM32F0xx Interrupt Number Definition, according to the selected device 
N *        in @ref Library_configuration_section 
N */
N
N /*!< Interrupt Number Definition */
Ntypedef enum
N{
N/******  Cortex-M0 Processor Exceptions Numbers **************************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                        */
N  HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                                */
N  SVC_IRQn                    = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                                  */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                                  */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                              */
N
N/******  STM32F0 specific Interrupt Numbers ******************************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                               */
N  PVD_VDDIO2_IRQn             = 1,      /*!< PVD & VDDIO2 Interrupt through EXTI Lines 16 and 31             */
N  RTC_IRQn                    = 2,      /*!< RTC Interrupt through EXTI Lines 17, 19 and 20                  */
N  FLASH_IRQn                  = 3,      /*!< FLASH global Interrupt                                          */
N  RCC_CRS_IRQn                = 4,      /*!< RCC & CRS global Interrupt                                      */
N  EXTI0_1_IRQn                = 5,      /*!< EXTI Line 0 and 1 Interrupt                                     */
N  EXTI2_3_IRQn                = 6,      /*!< EXTI Line 2 and 3 Interrupt                                     */
N  EXTI4_15_IRQn               = 7,      /*!< EXTI Line 4 to 15 Interrupt                                     */
N  TSC_IRQn                    = 8,      /*!< Touch Sensing Controller Interrupts                             */
N  DMA1_Ch1_IRQn               = 9,      /*!< DMA1 Channel 1 Interrupt                                        */
N  DMA1_Ch2_3_DMA2_Ch1_2_IRQn  = 10,     /*!< DMA1 Channel 2 and 3 & DMA2 Channel 1 and 2 Interrupts          */
N  DMA1_Ch4_7_DMA2_Ch3_5_IRQn  = 11,     /*!< DMA1 Channel 4 to 7 & DMA2 Channel 3 to 5 Interrupt             */
N  ADC1_COMP_IRQn              = 12,     /*!< ADC1 and COMP interrupts (ADC interrupt combined with EXTI Lines 21 and 22 */
N  TIM1_BRK_UP_TRG_COM_IRQn    = 13,     /*!< TIM1 Break, Update, Trigger and Commutation Interrupt           */
N  TIM1_CC_IRQn                = 14,     /*!< TIM1 Capture Compare Interrupt                                  */
N  TIM2_IRQn                   = 15,     /*!< TIM2 global Interrupt                                           */
N  TIM3_IRQn                   = 16,     /*!< TIM3 global Interrupt                                           */
N  TIM6_DAC_IRQn               = 17,     /*!< TIM6 global and DAC channel underrun error Interrupt            */
N  TIM7_IRQn                   = 18,     /*!< TIM7 global Interrupt                                           */
N  TIM14_IRQn                  = 19,     /*!< TIM14 global Interrupt                                          */
N  TIM15_IRQn                  = 20,     /*!< TIM15 global Interrupt                                          */
N  TIM16_IRQn                  = 21,     /*!< TIM16 global Interrupt                                          */
N  TIM17_IRQn                  = 22,     /*!< TIM17 global Interrupt                                          */
N  I2C1_IRQn                   = 23,     /*!< I2C1 Event Interrupt & EXTI Line23 Interrupt (I2C1 wakeup)      */
N  I2C2_IRQn                   = 24,     /*!< I2C2 Event Interrupt                                            */
N  SPI1_IRQn                   = 25,     /*!< SPI1 global Interrupt                                           */
N  SPI2_IRQn                   = 26,     /*!< SPI2 global Interrupt                                           */
N  USART1_IRQn                 = 27,     /*!< USART1 global Interrupt & EXTI Line25 Interrupt (USART1 wakeup) */
N  USART2_IRQn                 = 28,     /*!< USART2 global Interrupt & EXTI Line26 Interrupt (USART2 wakeup) */
N  USART3_8_IRQn               = 29,     /*!< USART3 to USART8 global Interrupt                               */
N  CEC_CAN_IRQn                = 30      /*!< CEC and CAN global Interrupts & EXTI Line27 Interrupt           */
N} IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm0.h"            /* Cortex-M0 processor and core peripherals */
L 1 "../Drivers/CMSIS/Include/core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5050169 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5050157
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 45 "../Drivers/CMSIS/Include/core_cm0.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "../Drivers/CMSIS/Include/core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5050169 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "../Drivers/CMSIS/Include/cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5050169 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x00U) == 0x04U) || ((0x00U) == 0x07U)
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return(result);
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x00U) >= 0x04U)   
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "../Drivers/CMSIS/Include/core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 164 "../Drivers/CMSIS/Include/core_cm0.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "../Drivers/CMSIS/Include/core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5050169 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 165 "../Drivers/CMSIS/Include/core_cm0.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000U
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N        uint32_t RESERVED0;
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 132 "../Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f091xc.h" 2
N#include "system_stm32f0xx.h"    /* STM32F0xx System Header */
L 1 "../Drivers/CMSIS/Device/ST/STM32F0xx/Include/system_stm32f0xx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_stm32f0xx.h
N  * @author  MCD Application Team
N  * @brief   CMSIS Cortex-M0 Device System Source File for STM32F0xx devices.  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f0xx_system
N  * @{
N  */  
N  
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_STM32F0XX_H
N#define __SYSTEM_STM32F0XX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/** @addtogroup STM32F0xx_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup STM32F0xx_System_Exported_types
N  * @{
N  */
N  /* This variable is updated in three ways:
N      1) by calling CMSIS function SystemCoreClockUpdate()
N      3) by calling HAL API function HAL_RCC_GetHCLKFreq()
N      3) by calling HAL API function HAL_RCC_ClockConfig()
N         Note: If you use this function to configure the system clock; then there
N               is no need to call the 2 first functions listed above, since SystemCoreClock
N               variable is updated automatically.
N  */
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
Nextern const uint8_t AHBPrescTable[16];   /*!< AHB prescalers table values */
Nextern const uint8_t APBPrescTable[8];    /*!< APB prescalers table values */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F0xx_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F0xx_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F0xx_System_Exported_Functions
N  * @{
N  */
N  
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__SYSTEM_STM32F0XX_H */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 133 "../Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f091xc.h" 2
N#include <stdint.h>
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */
N
N/**
N  * @brief Analog to Digital Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ISR;          /*!< ADC interrupt and status register,             Address offset: 0x00 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IER;          /*!< ADC interrupt enable register,                 Address offset: 0x04 */
X  volatile uint32_t IER;           
N  __IO uint32_t CR;           /*!< ADC control register,                          Address offset: 0x08 */
X  volatile uint32_t CR;            
N  __IO uint32_t CFGR1;        /*!< ADC configuration register 1,                  Address offset: 0x0C */
X  volatile uint32_t CFGR1;         
N  __IO uint32_t CFGR2;        /*!< ADC configuration register 2,                  Address offset: 0x10 */
X  volatile uint32_t CFGR2;         
N  __IO uint32_t SMPR;         /*!< ADC sampling time register,                    Address offset: 0x14 */
X  volatile uint32_t SMPR;          
N       uint32_t RESERVED1;    /*!< Reserved,                                                      0x18 */
N       uint32_t RESERVED2;    /*!< Reserved,                                                      0x1C */
N  __IO uint32_t TR;           /*!< ADC analog watchdog 1 threshold register,      Address offset: 0x20 */
X  volatile uint32_t TR;            
N       uint32_t RESERVED3;    /*!< Reserved,                                                      0x24 */
N  __IO uint32_t CHSELR;       /*!< ADC group regular sequencer register,          Address offset: 0x28 */
X  volatile uint32_t CHSELR;        
N       uint32_t RESERVED4[5]; /*!< Reserved,                                                      0x2C */
N  __IO uint32_t DR;           /*!< ADC group regular data register,               Address offset: 0x40 */
X  volatile uint32_t DR;            
N} ADC_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CCR;          /*!< ADC common configuration register,             Address offset: ADC1 base address + 0x308 */
X  volatile uint32_t CCR;           
N} ADC_Common_TypeDef;
N
N/** 
N  * @brief Controller Area Network TxMailBox
N  */
Ntypedef struct
N{
N  __IO uint32_t TIR;  /*!< CAN TX mailbox identifier register */
X  volatile uint32_t TIR;   
N  __IO uint32_t TDTR; /*!< CAN mailbox data length control and time stamp register */
X  volatile uint32_t TDTR;  
N  __IO uint32_t TDLR; /*!< CAN mailbox data low register */
X  volatile uint32_t TDLR;  
N  __IO uint32_t TDHR; /*!< CAN mailbox data high register */
X  volatile uint32_t TDHR;  
N}CAN_TxMailBox_TypeDef;
N
N/**
N  * @brief Controller Area Network FIFOMailBox
N  */
Ntypedef struct
N{
N  __IO uint32_t RIR;  /*!< CAN receive FIFO mailbox identifier register */
X  volatile uint32_t RIR;   
N  __IO uint32_t RDTR; /*!< CAN receive FIFO mailbox data length control and time stamp register */
X  volatile uint32_t RDTR;  
N  __IO uint32_t RDLR; /*!< CAN receive FIFO mailbox data low register */
X  volatile uint32_t RDLR;  
N  __IO uint32_t RDHR; /*!< CAN receive FIFO mailbox data high register */
X  volatile uint32_t RDHR;  
N}CAN_FIFOMailBox_TypeDef;
N  
N/**
N  * @brief Controller Area Network FilterRegister
N  */
Ntypedef struct
N{
N  __IO uint32_t FR1; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR1;  
N  __IO uint32_t FR2; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR2;  
N}CAN_FilterRegister_TypeDef;
N
N/**
N  * @brief Controller Area Network
N  */
Ntypedef struct
N{
N  __IO uint32_t              MCR;                 /*!< CAN master control register,         Address offset: 0x00          */
X  volatile uint32_t              MCR;                  
N  __IO uint32_t              MSR;                 /*!< CAN master status register,          Address offset: 0x04          */
X  volatile uint32_t              MSR;                  
N  __IO uint32_t              TSR;                 /*!< CAN transmit status register,        Address offset: 0x08          */
X  volatile uint32_t              TSR;                  
N  __IO uint32_t              RF0R;                /*!< CAN receive FIFO 0 register,         Address offset: 0x0C          */
X  volatile uint32_t              RF0R;                 
N  __IO uint32_t              RF1R;                /*!< CAN receive FIFO 1 register,         Address offset: 0x10          */
X  volatile uint32_t              RF1R;                 
N  __IO uint32_t              IER;                 /*!< CAN interrupt enable register,       Address offset: 0x14          */
X  volatile uint32_t              IER;                  
N  __IO uint32_t              ESR;                 /*!< CAN error status register,           Address offset: 0x18          */
X  volatile uint32_t              ESR;                  
N  __IO uint32_t              BTR;                 /*!< CAN bit timing register,             Address offset: 0x1C          */
X  volatile uint32_t              BTR;                  
N  uint32_t                   RESERVED0[88];       /*!< Reserved, 0x020 - 0x17F                                            */
N  CAN_TxMailBox_TypeDef      sTxMailBox[3];       /*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC */
N  CAN_FIFOMailBox_TypeDef    sFIFOMailBox[2];     /*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC */
N  uint32_t                   RESERVED1[12];       /*!< Reserved, 0x1D0 - 0x1FF                                            */
N  __IO uint32_t              FMR;                 /*!< CAN filter master register,          Address offset: 0x200         */
X  volatile uint32_t              FMR;                  
N  __IO uint32_t              FM1R;                /*!< CAN filter mode register,            Address offset: 0x204         */
X  volatile uint32_t              FM1R;                 
N  uint32_t                   RESERVED2;           /*!< Reserved, 0x208                                                    */
N  __IO uint32_t              FS1R;                /*!< CAN filter scale register,           Address offset: 0x20C         */
X  volatile uint32_t              FS1R;                 
N  uint32_t                   RESERVED3;           /*!< Reserved, 0x210                                                    */
N  __IO uint32_t              FFA1R;               /*!< CAN filter FIFO assignment register, Address offset: 0x214         */
X  volatile uint32_t              FFA1R;                
N  uint32_t                   RESERVED4;           /*!< Reserved, 0x218                                                    */
N  __IO uint32_t              FA1R;                /*!< CAN filter activation register,      Address offset: 0x21C         */
X  volatile uint32_t              FA1R;                 
N  uint32_t                   RESERVED5[8];        /*!< Reserved, 0x220-0x23F                                              */
N  CAN_FilterRegister_TypeDef sFilterRegister[28]; /*!< CAN Filter Register,                 Address offset: 0x240-0x31C   */
N}CAN_TypeDef;
N
N/**
N  * @brief HDMI-CEC
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;           /*!< CEC control register,                                       Address offset:0x00 */
X  volatile uint32_t CR;            
N  __IO uint32_t CFGR;         /*!< CEC configuration register,                                 Address offset:0x04 */
X  volatile uint32_t CFGR;          
N  __IO uint32_t TXDR;         /*!< CEC Tx data register ,                                      Address offset:0x08 */
X  volatile uint32_t TXDR;          
N  __IO uint32_t RXDR;         /*!< CEC Rx Data Register,                                       Address offset:0x0C */
X  volatile uint32_t RXDR;          
N  __IO uint32_t ISR;          /*!< CEC Interrupt and Status Register,                          Address offset:0x10 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IER;          /*!< CEC interrupt enable register,                              Address offset:0x14 */
X  volatile uint32_t IER;           
N}CEC_TypeDef;
N
N/** 
N  * @brief Comparator 
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CSR;         /*!< COMP control and status register,                                                 Address offset: 0x00 */
X  volatile uint16_t CSR;          
N} COMP_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CSR;         /*!< COMP control and status register, used for bits common to several COMP instances, Address offset: 0x00 */
X  volatile uint32_t CSR;          
N} COMP_Common_TypeDef;
N
N/* Legacy defines */
Ntypedef struct
N{
N  __IO uint32_t CSR;         /*!< Kept for legacy purpose. Use structure 'COMP_Common_TypeDef'. */
X  volatile uint32_t CSR;          
N}COMP1_2_TypeDef;
N
N/** 
N  * @brief CRC calculation unit
N  */
N
Ntypedef struct
N{
N  __IO uint32_t DR;          /*!< CRC Data register,                           Address offset: 0x00 */
X  volatile uint32_t DR;           
N  __IO uint8_t  IDR;         /*!< CRC Independent data register,               Address offset: 0x04 */
X  volatile uint8_t  IDR;          
N  uint8_t       RESERVED0;   /*!< Reserved,                                                    0x05 */
N  uint16_t      RESERVED1;   /*!< Reserved,                                                    0x06 */
N  __IO uint32_t CR;          /*!< CRC Control register,                        Address offset: 0x08 */ 
X  volatile uint32_t CR;            
N  uint32_t      RESERVED2;   /*!< Reserved,                                                    0x0C */
N  __IO uint32_t INIT;        /*!< Initial CRC value register,                  Address offset: 0x10 */
X  volatile uint32_t INIT;         
N  __IO uint32_t POL;         /*!< CRC polynomial register,                     Address offset: 0x14 */
X  volatile uint32_t POL;          
N} CRC_TypeDef;
N
N/** 
N  * @brief Clock Recovery System
N  */
Ntypedef struct 
N{
N__IO uint32_t CR;     /*!< CRS ccontrol register,              Address offset: 0x00 */
Xvolatile uint32_t CR;      
N__IO uint32_t CFGR;   /*!< CRS configuration register,         Address offset: 0x04 */
Xvolatile uint32_t CFGR;    
N__IO uint32_t ISR;    /*!< CRS interrupt and status register,  Address offset: 0x08 */
Xvolatile uint32_t ISR;     
N__IO uint32_t ICR;    /*!< CRS interrupt flag clear register,  Address offset: 0x0C */
Xvolatile uint32_t ICR;     
N}CRS_TypeDef;
N
N/** 
N  * @brief Digital to Analog Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;           /*!< DAC control register,                                     Address offset: 0x00 */
X  volatile uint32_t CR;            
N  __IO uint32_t SWTRIGR;      /*!< DAC software trigger register,                            Address offset: 0x04 */
X  volatile uint32_t SWTRIGR;       
N  __IO uint32_t DHR12R1;      /*!< DAC channel1 12-bit right-aligned data holding register,  Address offset: 0x08 */
X  volatile uint32_t DHR12R1;       
N  __IO uint32_t DHR12L1;      /*!< DAC channel1 12-bit left aligned data holding register,   Address offset: 0x0C */
X  volatile uint32_t DHR12L1;       
N  __IO uint32_t DHR8R1;       /*!< DAC channel1 8-bit right aligned data holding register,   Address offset: 0x10 */
X  volatile uint32_t DHR8R1;        
N  __IO uint32_t DHR12R2;      /*!< DAC channel2 12-bit right aligned data holding register,  Address offset: 0x14 */
X  volatile uint32_t DHR12R2;       
N  __IO uint32_t DHR12L2;      /*!< DAC channel2 12-bit left aligned data holding register,   Address offset: 0x18 */
X  volatile uint32_t DHR12L2;       
N  __IO uint32_t DHR8R2;       /*!< DAC channel2 8-bit right-aligned data holding register,   Address offset: 0x1C */
X  volatile uint32_t DHR8R2;        
N  __IO uint32_t DHR12RD;      /*!< Dual DAC 12-bit right-aligned data holding register,      Address offset: 0x20 */
X  volatile uint32_t DHR12RD;       
N  __IO uint32_t DHR12LD;      /*!< DUAL DAC 12-bit left aligned data holding register,       Address offset: 0x24 */
X  volatile uint32_t DHR12LD;       
N  __IO uint32_t DHR8RD;       /*!< DUAL DAC 8-bit right aligned data holding register,       Address offset: 0x28 */
X  volatile uint32_t DHR8RD;        
N  __IO uint32_t DOR1;         /*!< DAC channel1 data output register,                        Address offset: 0x2C */
X  volatile uint32_t DOR1;          
N  __IO uint32_t DOR2;         /*!< DAC channel2 data output register,                        Address offset: 0x30 */
X  volatile uint32_t DOR2;          
N  __IO uint32_t SR;           /*!< DAC status register,                                      Address offset: 0x34 */
X  volatile uint32_t SR;            
N} DAC_TypeDef;
N
N/** 
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;       /*!< MCU device ID code,                          Address offset: 0x00 */
X  volatile uint32_t IDCODE;        
N  __IO uint32_t CR;           /*!< Debug MCU configuration register,            Address offset: 0x04 */
X  volatile uint32_t CR;            
N  __IO uint32_t APB1FZ;       /*!< Debug MCU APB1 freeze register,              Address offset: 0x08 */
X  volatile uint32_t APB1FZ;        
N  __IO uint32_t APB2FZ;       /*!< Debug MCU APB2 freeze register,              Address offset: 0x0C */
X  volatile uint32_t APB2FZ;        
N}DBGMCU_TypeDef;
N
N/** 
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CCR;          /*!< DMA channel x configuration register        */
X  volatile uint32_t CCR;           
N  __IO uint32_t CNDTR;        /*!< DMA channel x number of data register       */
X  volatile uint32_t CNDTR;         
N  __IO uint32_t CPAR;         /*!< DMA channel x peripheral address register   */
X  volatile uint32_t CPAR;          
N  __IO uint32_t CMAR;         /*!< DMA channel x memory address register       */
X  volatile uint32_t CMAR;          
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t ISR;          /*!< DMA interrupt status register,               Address offset: 0x00 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IFCR;         /*!< DMA interrupt flag clear register,           Address offset: 0x04 */
X  volatile uint32_t IFCR;          
N  uint32_t      RESERVED0[40];/*!< Reserved as declared by channel typedef                   0x08 - 0xA4          */
N  __IO uint32_t CSELR;        /*!< Channel selection register,                               Address offset: 0xA8 */
X  volatile uint32_t CSELR;         
N} DMA_TypeDef;
N
N/** 
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR;          /*!<EXTI Interrupt mask register,                 Address offset: 0x00 */
X  volatile uint32_t IMR;           
N  __IO uint32_t EMR;          /*!<EXTI Event mask register,                     Address offset: 0x04 */
X  volatile uint32_t EMR;           
N  __IO uint32_t RTSR;         /*!<EXTI Rising trigger selection register ,      Address offset: 0x08 */
X  volatile uint32_t RTSR;          
N  __IO uint32_t FTSR;         /*!<EXTI Falling trigger selection register,      Address offset: 0x0C */
X  volatile uint32_t FTSR;          
N  __IO uint32_t SWIER;        /*!<EXTI Software interrupt event register,       Address offset: 0x10 */
X  volatile uint32_t SWIER;         
N  __IO uint32_t PR;           /*!<EXTI Pending register,                        Address offset: 0x14 */
X  volatile uint32_t PR;            
N} EXTI_TypeDef;
N
N/** 
N  * @brief FLASH Registers
N  */
Ntypedef struct
N{
N  __IO uint32_t ACR;          /*!<FLASH access control register,                 Address offset: 0x00 */
X  volatile uint32_t ACR;           
N  __IO uint32_t KEYR;         /*!<FLASH key register,                            Address offset: 0x04 */
X  volatile uint32_t KEYR;          
N  __IO uint32_t OPTKEYR;      /*!<FLASH OPT key register,                        Address offset: 0x08 */
X  volatile uint32_t OPTKEYR;       
N  __IO uint32_t SR;           /*!<FLASH status register,                         Address offset: 0x0C */
X  volatile uint32_t SR;            
N  __IO uint32_t CR;           /*!<FLASH control register,                        Address offset: 0x10 */
X  volatile uint32_t CR;            
N  __IO uint32_t AR;           /*!<FLASH address register,                        Address offset: 0x14 */
X  volatile uint32_t AR;            
N  __IO uint32_t RESERVED;     /*!< Reserved,                                                     0x18 */
X  volatile uint32_t RESERVED;      
N  __IO uint32_t OBR;          /*!<FLASH option bytes register,                   Address offset: 0x1C */
X  volatile uint32_t OBR;           
N  __IO uint32_t WRPR;         /*!<FLASH option bytes register,                   Address offset: 0x20 */
X  volatile uint32_t WRPR;          
N} FLASH_TypeDef;
N
N/** 
N  * @brief Option Bytes Registers
N  */
Ntypedef struct
N{
N  __IO uint16_t RDP;          /*!< FLASH option byte Read protection,             Address offset: 0x00 */
X  volatile uint16_t RDP;           
N  __IO uint16_t USER;         /*!< FLASH option byte user options,                Address offset: 0x02 */
X  volatile uint16_t USER;          
N  __IO uint16_t DATA0;        /*!< User data byte 0 (stored in FLASH_OBR[23:16]), Address offset: 0x04 */
X  volatile uint16_t DATA0;         
N  __IO uint16_t DATA1;        /*!< User data byte 1 (stored in FLASH_OBR[31:24]), Address offset: 0x06 */
X  volatile uint16_t DATA1;         
N  __IO uint16_t WRP0;         /*!< FLASH option byte write protection 0,          Address offset: 0x08 */
X  volatile uint16_t WRP0;          
N  __IO uint16_t WRP1;         /*!< FLASH option byte write protection 1,          Address offset: 0x0A */
X  volatile uint16_t WRP1;          
N  __IO uint16_t WRP2;         /*!< FLASH option byte write protection 2,          Address offset: 0x0C */
X  volatile uint16_t WRP2;          
N  __IO uint16_t WRP3;         /*!< FLASH option byte write protection 3,          Address offset: 0x0E */
X  volatile uint16_t WRP3;          
N} OB_TypeDef;
N
N/** 
N  * @brief General Purpose I/O
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MODER;        /*!< GPIO port mode register,                     Address offset: 0x00      */
X  volatile uint32_t MODER;         
N  __IO uint32_t OTYPER;       /*!< GPIO port output type register,              Address offset: 0x04      */
X  volatile uint32_t OTYPER;        
N  __IO uint32_t OSPEEDR;      /*!< GPIO port output speed register,             Address offset: 0x08      */
X  volatile uint32_t OSPEEDR;       
N  __IO uint32_t PUPDR;        /*!< GPIO port pull-up/pull-down register,        Address offset: 0x0C      */
X  volatile uint32_t PUPDR;         
N  __IO uint32_t IDR;          /*!< GPIO port input data register,               Address offset: 0x10      */
X  volatile uint32_t IDR;           
N  __IO uint32_t ODR;          /*!< GPIO port output data register,              Address offset: 0x14      */
X  volatile uint32_t ODR;           
N  __IO uint32_t BSRR;         /*!< GPIO port bit set/reset register,      Address offset: 0x1A */
X  volatile uint32_t BSRR;          
N  __IO uint32_t LCKR;         /*!< GPIO port configuration lock register,       Address offset: 0x1C      */
X  volatile uint32_t LCKR;          
N  __IO uint32_t AFR[2];       /*!< GPIO alternate function low register,  Address offset: 0x20-0x24 */
X  volatile uint32_t AFR[2];        
N  __IO uint32_t BRR;          /*!< GPIO bit reset register,                     Address offset: 0x28      */
X  volatile uint32_t BRR;           
N} GPIO_TypeDef;
N
N/** 
N  * @brief SysTem Configuration
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CFGR1;       /*!< SYSCFG configuration register 1,                           Address offset: 0x00 */
X  volatile uint32_t CFGR1;        
N       uint32_t RESERVED;    /*!< Reserved,                                                                  0x04 */
N  __IO uint32_t EXTICR[4];   /*!< SYSCFG external interrupt configuration register,     Address offset: 0x14-0x08 */
X  volatile uint32_t EXTICR[4];    
N  __IO uint32_t CFGR2;       /*!< SYSCFG configuration register 2,                           Address offset: 0x18 */
X  volatile uint32_t CFGR2;        
N       uint32_t RESERVED1[25];    /*!< Reserved + COMP,                                                      0x1C */
N  __IO uint32_t IT_LINE_SR[32]; /*!< SYSCFG configuration IT_LINE register,                  Address offset: 0x80 */
X  volatile uint32_t IT_LINE_SR[32];  
N} SYSCFG_TypeDef;
N
N/** 
N  * @brief Inter-integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;          /*!< I2C Control register 1,                      Address offset: 0x00 */
X  volatile uint32_t CR1;           
N  __IO uint32_t CR2;          /*!< I2C Control register 2,                      Address offset: 0x04 */
X  volatile uint32_t CR2;           
N  __IO uint32_t OAR1;     /*!< I2C Own address 1 register,        Address offset: 0x08 */
X  volatile uint32_t OAR1;      
N  __IO uint32_t OAR2;     /*!< I2C Own address 2 register,        Address offset: 0x0C */
X  volatile uint32_t OAR2;      
N  __IO uint32_t TIMINGR;  /*!< I2C Timing register,               Address offset: 0x10 */
X  volatile uint32_t TIMINGR;   
N  __IO uint32_t TIMEOUTR; /*!< I2C Timeout register,              Address offset: 0x14 */
X  volatile uint32_t TIMEOUTR;  
N  __IO uint32_t ISR;      /*!< I2C Interrupt and status register, Address offset: 0x18 */
X  volatile uint32_t ISR;       
N  __IO uint32_t ICR;      /*!< I2C Interrupt clear register,      Address offset: 0x1C */
X  volatile uint32_t ICR;       
N  __IO uint32_t PECR;     /*!< I2C PEC register,                  Address offset: 0x20 */
X  volatile uint32_t PECR;      
N  __IO uint32_t RXDR;     /*!< I2C Receive data register,         Address offset: 0x24 */
X  volatile uint32_t RXDR;      
N  __IO uint32_t TXDR;     /*!< I2C Transmit data register,        Address offset: 0x28 */
X  volatile uint32_t TXDR;      
N} I2C_TypeDef;
N
N/** 
N  * @brief Independent WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
X  volatile uint32_t KR;    
N  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
X  volatile uint32_t PR;    
N  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
X  volatile uint32_t RLR;   
N  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
X  volatile uint32_t SR;    
N  __IO uint32_t WINR; /*!< IWDG Window register,    Address offset: 0x10 */
X  volatile uint32_t WINR;  
N} IWDG_TypeDef;
N
N/** 
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< PWR power control register,                          Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CSR;  /*!< PWR power control/status register,                   Address offset: 0x04 */
X  volatile uint32_t CSR;   
N} PWR_TypeDef;
N
N/** 
N  * @brief Reset and Clock Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;            /*!< RCC clock control register,                                   Address offset: 0x00 */
X  volatile uint32_t CR;             
N  __IO uint32_t CFGR;       /*!< RCC clock configuration register,                            Address offset: 0x04 */
X  volatile uint32_t CFGR;        
N  __IO uint32_t CIR;        /*!< RCC clock interrupt register,                                Address offset: 0x08 */
X  volatile uint32_t CIR;         
N  __IO uint32_t APB2RSTR;   /*!< RCC APB2 peripheral reset register,                          Address offset: 0x0C */
X  volatile uint32_t APB2RSTR;    
N  __IO uint32_t APB1RSTR;   /*!< RCC APB1 peripheral reset register,                          Address offset: 0x10 */
X  volatile uint32_t APB1RSTR;    
N  __IO uint32_t AHBENR;     /*!< RCC AHB peripheral clock register,                           Address offset: 0x14 */
X  volatile uint32_t AHBENR;      
N  __IO uint32_t APB2ENR;    /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x18 */
X  volatile uint32_t APB2ENR;     
N  __IO uint32_t APB1ENR;    /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x1C */
X  volatile uint32_t APB1ENR;     
N  __IO uint32_t BDCR;       /*!< RCC Backup domain control register,                          Address offset: 0x20 */
X  volatile uint32_t BDCR;        
N  __IO uint32_t CSR;        /*!< RCC clock control & status register,                         Address offset: 0x24 */
X  volatile uint32_t CSR;         
N  __IO uint32_t AHBRSTR;    /*!< RCC AHB peripheral reset register,                           Address offset: 0x28 */
X  volatile uint32_t AHBRSTR;     
N  __IO uint32_t CFGR2;      /*!< RCC clock configuration register 2,                          Address offset: 0x2C */
X  volatile uint32_t CFGR2;       
N  __IO uint32_t CFGR3;      /*!< RCC clock configuration register 3,                          Address offset: 0x30 */
X  volatile uint32_t CFGR3;       
N  __IO uint32_t CR2;        /*!< RCC clock control register 2,                                Address offset: 0x34 */
X  volatile uint32_t CR2;         
N} RCC_TypeDef;
N
N/** 
N  * @brief Real-Time Clock
N  */
Ntypedef struct
N{
N  __IO uint32_t TR;         /*!< RTC time register,                                         Address offset: 0x00 */
X  volatile uint32_t TR;          
N  __IO uint32_t DR;         /*!< RTC date register,                                         Address offset: 0x04 */
X  volatile uint32_t DR;          
N  __IO uint32_t CR;         /*!< RTC control register,                                      Address offset: 0x08 */                                                                                            
X  volatile uint32_t CR;                                                                                                      
N  __IO uint32_t ISR;        /*!< RTC initialization and status register,                    Address offset: 0x0C */
X  volatile uint32_t ISR;         
N  __IO uint32_t PRER;       /*!< RTC prescaler register,                                    Address offset: 0x10 */
X  volatile uint32_t PRER;        
N  __IO uint32_t WUTR;       /*!< RTC wakeup timer register,                                 Address offset: 0x14 */
X  volatile uint32_t WUTR;        
N       uint32_t RESERVED1;  /*!< Reserved,                                                  Address offset: 0x18 */
N  __IO uint32_t ALRMAR;     /*!< RTC alarm A register,                                      Address offset: 0x1C */
X  volatile uint32_t ALRMAR;      
N       uint32_t RESERVED2;  /*!< Reserved,                                                  Address offset: 0x20 */
N  __IO uint32_t WPR;        /*!< RTC write protection register,                             Address offset: 0x24 */
X  volatile uint32_t WPR;         
N  __IO uint32_t SSR;        /*!< RTC sub second register,                                   Address offset: 0x28 */
X  volatile uint32_t SSR;         
N  __IO uint32_t SHIFTR;     /*!< RTC shift control register,                                Address offset: 0x2C */
X  volatile uint32_t SHIFTR;      
N  __IO uint32_t TSTR;       /*!< RTC time stamp time register,                              Address offset: 0x30 */
X  volatile uint32_t TSTR;        
N  __IO uint32_t TSDR;       /*!< RTC time stamp date register,                              Address offset: 0x34 */
X  volatile uint32_t TSDR;        
N  __IO uint32_t TSSSR;      /*!< RTC time-stamp sub second register,                        Address offset: 0x38 */
X  volatile uint32_t TSSSR;       
N  __IO uint32_t CALR;       /*!< RTC calibration register,                                  Address offset: 0x3C */
X  volatile uint32_t CALR;        
N  __IO uint32_t TAFCR;      /*!< RTC tamper and alternate function configuration register,  Address offset: 0x40 */
X  volatile uint32_t TAFCR;       
N  __IO uint32_t ALRMASSR;   /*!< RTC alarm A sub second register,                           Address offset: 0x44 */
X  volatile uint32_t ALRMASSR;    
N       uint32_t RESERVED3;  /*!< Reserved,                                                  Address offset: 0x48 */
N       uint32_t RESERVED4;  /*!< Reserved,                                                  Address offset: 0x4C */
N  __IO uint32_t BKP0R;      /*!< RTC backup register 0,                                     Address offset: 0x50 */
X  volatile uint32_t BKP0R;       
N  __IO uint32_t BKP1R;      /*!< RTC backup register 1,                                     Address offset: 0x54 */
X  volatile uint32_t BKP1R;       
N  __IO uint32_t BKP2R;      /*!< RTC backup register 2,                                     Address offset: 0x58 */
X  volatile uint32_t BKP2R;       
N  __IO uint32_t BKP3R;      /*!< RTC backup register 3,                                     Address offset: 0x5C */
X  volatile uint32_t BKP3R;       
N  __IO uint32_t BKP4R;      /*!< RTC backup register 4,                                     Address offset: 0x60 */
X  volatile uint32_t BKP4R;       
N} RTC_TypeDef;
N
N/** 
N  * @brief Serial Peripheral Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;        /*!< SPI Control register 1 (not used in I2S mode),      Address offset: 0x00 */
X  volatile uint32_t CR1;         
N  __IO uint32_t CR2;        /*!< SPI Control register 2,                             Address offset: 0x04 */
X  volatile uint32_t CR2;         
N  __IO uint32_t SR;         /*!< SPI Status register,                                Address offset: 0x08 */
X  volatile uint32_t SR;          
N  __IO uint32_t DR;         /*!< SPI data register,                                  Address offset: 0x0C */
X  volatile uint32_t DR;          
N  __IO uint32_t CRCPR;      /*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 */
X  volatile uint32_t CRCPR;       
N  __IO uint32_t RXCRCR;     /*!< SPI Rx CRC register (not used in I2S mode),         Address offset: 0x14 */
X  volatile uint32_t RXCRCR;      
N  __IO uint32_t TXCRCR;     /*!< SPI Tx CRC register (not used in I2S mode),         Address offset: 0x18 */
X  volatile uint32_t TXCRCR;      
N  __IO uint32_t I2SCFGR;    /*!< SPI_I2S configuration register,                     Address offset: 0x1C */
X  volatile uint32_t I2SCFGR;     
N  __IO uint32_t I2SPR;      /*!< SPI_I2S prescaler register,                         Address offset: 0x20 */
X  volatile uint32_t I2SPR;       
N} SPI_TypeDef;
N
N/** 
N  * @brief TIM
N  */
Ntypedef struct
N{
N  __IO uint32_t CR1;          /*!< TIM control register 1,              Address offset: 0x00 */
X  volatile uint32_t CR1;           
N  __IO uint32_t CR2;          /*!< TIM control register 2,              Address offset: 0x04 */
X  volatile uint32_t CR2;           
N  __IO uint32_t SMCR;         /*!< TIM slave Mode Control register,     Address offset: 0x08 */
X  volatile uint32_t SMCR;          
N  __IO uint32_t DIER;         /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
X  volatile uint32_t DIER;          
N  __IO uint32_t SR;           /*!< TIM status register,                 Address offset: 0x10 */
X  volatile uint32_t SR;            
N  __IO uint32_t EGR;          /*!< TIM event generation register,       Address offset: 0x14 */
X  volatile uint32_t EGR;           
N  __IO uint32_t CCMR1;        /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
X  volatile uint32_t CCMR1;         
N  __IO uint32_t CCMR2;        /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
X  volatile uint32_t CCMR2;         
N  __IO uint32_t CCER;         /*!< TIM capture/compare enable register, Address offset: 0x20 */
X  volatile uint32_t CCER;          
N  __IO uint32_t CNT;          /*!< TIM counter register,                Address offset: 0x24 */
X  volatile uint32_t CNT;           
N  __IO uint32_t PSC;          /*!< TIM prescaler register,              Address offset: 0x28 */
X  volatile uint32_t PSC;           
N  __IO uint32_t ARR;          /*!< TIM auto-reload register,            Address offset: 0x2C */
X  volatile uint32_t ARR;           
N  __IO uint32_t RCR;             /*!< TIM  repetition counter register,            Address offset: 0x30 */
X  volatile uint32_t RCR;              
N  __IO uint32_t CCR1;         /*!< TIM capture/compare register 1,      Address offset: 0x34 */    
X  volatile uint32_t CCR1;              
N  __IO uint32_t CCR2;         /*!< TIM capture/compare register 2,      Address offset: 0x38 */    
X  volatile uint32_t CCR2;              
N  __IO uint32_t CCR3;         /*!< TIM capture/compare register 3,      Address offset: 0x3C */
X  volatile uint32_t CCR3;          
N  __IO uint32_t CCR4;         /*!< TIM capture/compare register 4,      Address offset: 0x40 */
X  volatile uint32_t CCR4;          
N  __IO uint32_t BDTR;            /*!< TIM break and dead-time register,            Address offset: 0x44 */
X  volatile uint32_t BDTR;             
N  __IO uint32_t DCR;          /*!< TIM DMA control register,            Address offset: 0x48 */
X  volatile uint32_t DCR;           
N  __IO uint32_t DMAR;            /*!< TIM DMA address for full transfer register,  Address offset: 0x4C */
X  volatile uint32_t DMAR;             
N  __IO uint32_t OR;           /*!< TIM option register,                 Address offset: 0x50 */
X  volatile uint32_t OR;            
N} TIM_TypeDef;
N
N/**
N  * @brief Touch Sensing Controller (TSC)
N  */
Ntypedef struct
N{
N  __IO uint32_t CR;        /*!< TSC control register,                                     Address offset: 0x00 */
X  volatile uint32_t CR;         
N  __IO uint32_t IER;       /*!< TSC interrupt enable register,                            Address offset: 0x04 */
X  volatile uint32_t IER;        
N  __IO uint32_t ICR;       /*!< TSC interrupt clear register,                             Address offset: 0x08 */
X  volatile uint32_t ICR;        
N  __IO uint32_t ISR;       /*!< TSC interrupt status register,                            Address offset: 0x0C */
X  volatile uint32_t ISR;        
N  __IO uint32_t IOHCR;     /*!< TSC I/O hysteresis control register,                      Address offset: 0x10 */
X  volatile uint32_t IOHCR;      
N       uint32_t RESERVED1; /*!< Reserved,                                                 Address offset: 0x14 */
N  __IO uint32_t IOASCR;    /*!< TSC I/O analog switch control register,                   Address offset: 0x18 */
X  volatile uint32_t IOASCR;     
N       uint32_t RESERVED2; /*!< Reserved,                                                 Address offset: 0x1C */
N  __IO uint32_t IOSCR;     /*!< TSC I/O sampling control register,                        Address offset: 0x20 */
X  volatile uint32_t IOSCR;      
N       uint32_t RESERVED3; /*!< Reserved,                                                 Address offset: 0x24 */
N  __IO uint32_t IOCCR;     /*!< TSC I/O channel control register,                         Address offset: 0x28 */
X  volatile uint32_t IOCCR;      
N       uint32_t RESERVED4; /*!< Reserved,                                                 Address offset: 0x2C */
N  __IO uint32_t IOGCSR;    /*!< TSC I/O group control status register,                    Address offset: 0x30 */
X  volatile uint32_t IOGCSR;     
N  __IO uint32_t IOGXCR[8]; /*!< TSC I/O group x counter register,                         Address offset: 0x34-50 */
X  volatile uint32_t IOGXCR[8];  
N}TSC_TypeDef;
N
N/** 
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N 
Ntypedef struct
N{
N  __IO uint32_t CR1;    /*!< USART Control register 1,                 Address offset: 0x00 */ 
X  volatile uint32_t CR1;      
N  __IO uint32_t CR2;    /*!< USART Control register 2,                 Address offset: 0x04 */ 
X  volatile uint32_t CR2;      
N  __IO uint32_t CR3;    /*!< USART Control register 3,                 Address offset: 0x08 */
X  volatile uint32_t CR3;     
N  __IO uint32_t BRR;    /*!< USART Baud rate register,                 Address offset: 0x0C */
X  volatile uint32_t BRR;     
N  __IO uint32_t GTPR;   /*!< USART Guard time and prescaler register,  Address offset: 0x10 */
X  volatile uint32_t GTPR;    
N  __IO uint32_t RTOR;   /*!< USART Receiver Time Out register,         Address offset: 0x14 */  
X  volatile uint32_t RTOR;      
N  __IO uint32_t RQR;    /*!< USART Request register,                   Address offset: 0x18 */
X  volatile uint32_t RQR;     
N  __IO uint32_t ISR;    /*!< USART Interrupt and status register,      Address offset: 0x1C */
X  volatile uint32_t ISR;     
N  __IO uint32_t ICR;    /*!< USART Interrupt flag Clear register,      Address offset: 0x20 */
X  volatile uint32_t ICR;     
N  __IO uint16_t RDR;    /*!< USART Receive Data register,              Address offset: 0x24 */
X  volatile uint16_t RDR;     
N  uint16_t  RESERVED1;  /*!< Reserved, 0x26                                                 */
N  __IO uint16_t TDR;    /*!< USART Transmit Data register,             Address offset: 0x28 */
X  volatile uint16_t TDR;     
N  uint16_t  RESERVED2;  /*!< Reserved, 0x2A                                                 */
N} USART_TypeDef;
N
N/** 
N  * @brief Window WATCHDOG
N  */
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
X  volatile uint32_t CFR;   
N  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
X  volatile uint32_t SR;    
N} WWDG_TypeDef;
N
N/** 
N  * @}
N  */
N  
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N
N#define FLASH_BASE            ((uint32_t)0x08000000U)              /*!< FLASH base address in the alias region */
N#define FLASH_BANK1_END       ((uint32_t)0x0803FFFFU) /*!< FLASH END address of bank1 */
N#define SRAM_BASE             ((uint32_t)0x20000000U)              /*!< SRAM base address in the alias region */
N#define PERIPH_BASE           ((uint32_t)0x40000000U)              /*!< Peripheral base address in the alias region */
N
N/*!< Peripheral memory map */
N#define APBPERIPH_BASE        PERIPH_BASE
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x00020000)
N#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x08000000)
N
N/*!< APB peripherals */
N#define TIM2_BASE             (APBPERIPH_BASE + 0x00000000)
N#define TIM3_BASE             (APBPERIPH_BASE + 0x00000400)
N#define TIM6_BASE             (APBPERIPH_BASE + 0x00001000)
N#define TIM7_BASE             (APBPERIPH_BASE + 0x00001400)
N#define TIM14_BASE            (APBPERIPH_BASE + 0x00002000)
N#define RTC_BASE              (APBPERIPH_BASE + 0x00002800)
N#define WWDG_BASE             (APBPERIPH_BASE + 0x00002C00)
N#define IWDG_BASE             (APBPERIPH_BASE + 0x00003000)
N#define SPI2_BASE             (APBPERIPH_BASE + 0x00003800)
N#define USART2_BASE           (APBPERIPH_BASE + 0x00004400)
N#define USART3_BASE           (APBPERIPH_BASE + 0x00004800)
N#define USART4_BASE           (APBPERIPH_BASE + 0x00004C00)
N#define USART5_BASE           (APBPERIPH_BASE + 0x00005000)
N#define I2C1_BASE             (APBPERIPH_BASE + 0x00005400)
N#define I2C2_BASE             (APBPERIPH_BASE + 0x00005800)
N#define CAN_BASE              (APBPERIPH_BASE + 0x00006400)
N#define CRS_BASE              (APBPERIPH_BASE + 0x00006C00)
N#define PWR_BASE              (APBPERIPH_BASE + 0x00007000)
N#define DAC_BASE              (APBPERIPH_BASE + 0x00007400)
N
N#define CEC_BASE              (APBPERIPH_BASE + 0x00007800)
N
N#define SYSCFG_BASE           (APBPERIPH_BASE + 0x00010000)
N#define COMP_BASE             (APBPERIPH_BASE + 0x0001001C)
N#define EXTI_BASE             (APBPERIPH_BASE + 0x00010400)
N#define USART6_BASE           (APBPERIPH_BASE + 0x00011400)
N#define USART7_BASE           (APBPERIPH_BASE + 0x00011800)
N#define USART8_BASE           (APBPERIPH_BASE + 0x00011C00)
N#define ADC1_BASE             (APBPERIPH_BASE + 0x00012400)
N#define ADC_BASE              (APBPERIPH_BASE + 0x00012708)
N#define TIM1_BASE             (APBPERIPH_BASE + 0x00012C00)
N#define SPI1_BASE             (APBPERIPH_BASE + 0x00013000)
N#define USART1_BASE           (APBPERIPH_BASE + 0x00013800)
N#define TIM15_BASE            (APBPERIPH_BASE + 0x00014000)
N#define TIM16_BASE            (APBPERIPH_BASE + 0x00014400)
N#define TIM17_BASE            (APBPERIPH_BASE + 0x00014800)
N#define DBGMCU_BASE           (APBPERIPH_BASE + 0x00015800)
N
N/*!< AHB peripherals */
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x00000000)
N#define DMA1_Channel1_BASE    (DMA1_BASE + 0x00000008)
N#define DMA1_Channel2_BASE    (DMA1_BASE + 0x0000001C)
N#define DMA1_Channel3_BASE    (DMA1_BASE + 0x00000030)
N#define DMA1_Channel4_BASE    (DMA1_BASE + 0x00000044)
N#define DMA1_Channel5_BASE    (DMA1_BASE + 0x00000058)
N#define DMA1_Channel6_BASE    (DMA1_BASE + 0x0000006C)
N#define DMA1_Channel7_BASE    (DMA1_BASE + 0x00000080)
N#define DMA2_BASE             (AHBPERIPH_BASE + 0x00000400)
N#define DMA2_Channel1_BASE    (DMA2_BASE + 0x00000008)
N#define DMA2_Channel2_BASE    (DMA2_BASE + 0x0000001C)
N#define DMA2_Channel3_BASE    (DMA2_BASE + 0x00000030)
N#define DMA2_Channel4_BASE    (DMA2_BASE + 0x00000044)
N#define DMA2_Channel5_BASE    (DMA2_BASE + 0x00000058)
N
N#define RCC_BASE              (AHBPERIPH_BASE + 0x00001000)
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x00002000) /*!< FLASH registers base address */
N#define OB_BASE               ((uint32_t)0x1FFFF800U)       /*!< FLASH Option Bytes base address */
N#define FLASHSIZE_BASE        ((uint32_t)0x1FFFF7CCU)       /*!< FLASH Size register base address */
N#define UID_BASE              ((uint32_t)0x1FFFF7ACU)       /*!< Unique device ID register base address */
N#define CRC_BASE              (AHBPERIPH_BASE + 0x00003000)
N#define TSC_BASE              (AHBPERIPH_BASE + 0x00004000)
N
N/*!< AHB2 peripherals */
N#define GPIOA_BASE            (AHB2PERIPH_BASE + 0x00000000)
N#define GPIOB_BASE            (AHB2PERIPH_BASE + 0x00000400)
N#define GPIOC_BASE            (AHB2PERIPH_BASE + 0x00000800)
N#define GPIOD_BASE            (AHB2PERIPH_BASE + 0x00000C00)
N#define GPIOE_BASE            (AHB2PERIPH_BASE + 0x00001000)
N#define GPIOF_BASE            (AHB2PERIPH_BASE + 0x00001400)
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_declaration
N  * @{
N  */  
N
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define USART3              ((USART_TypeDef *) USART3_BASE)
N#define USART4              ((USART_TypeDef *) USART4_BASE)
N#define USART5              ((USART_TypeDef *) USART5_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define CAN                 ((CAN_TypeDef *) CAN_BASE)
N#define CRS                 ((CRS_TypeDef *) CRS_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#define DAC1                ((DAC_TypeDef *) DAC_BASE)
N#define DAC                 ((DAC_TypeDef *) DAC_BASE) /* Kept for legacy purpose */
N#define CEC                 ((CEC_TypeDef *) CEC_BASE)
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define COMP1               ((COMP_TypeDef *) COMP_BASE)
N#define COMP2               ((COMP_TypeDef *) (COMP_BASE + 0x00000002))
N#define COMP12_COMMON       ((COMP_Common_TypeDef *) COMP_BASE)
N#define COMP                ((COMP1_2_TypeDef *) COMP_BASE) /* Kept for legacy purpose */
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define USART6              ((USART_TypeDef *) USART6_BASE)
N#define USART7              ((USART_TypeDef *) USART7_BASE)
N#define USART8              ((USART_TypeDef *) USART8_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC1_COMMON         ((ADC_Common_TypeDef *) ADC_BASE)
N#define ADC                 ((ADC_Common_TypeDef *) ADC_BASE) /* Kept for legacy purpose */
N#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define TIM15               ((TIM_TypeDef *) TIM15_BASE)
N#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
N#define TIM17               ((TIM_TypeDef *) TIM17_BASE)
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define OB                  ((OB_TypeDef *) OB_BASE) 
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define TSC                 ((TSC_TypeDef *) TSC_BASE)
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N
N  /** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N
N/******************************************************************************/
N/*                         Peripheral Registers Bits Definition               */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog to Digital Converter (ADC)                     */
N/*                                                                            */
N/******************************************************************************/
N
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32F0 serie)
N */
N#define ADC_CHANNEL_VBAT_SUPPORT                       /*!< ADC feature available only on specific devices: ADC internal channel Vbat */
N
N/********************  Bits definition for ADC_ISR register  ******************/
N#define ADC_ISR_ADRDY_Pos         (0U)                                         
N#define ADC_ISR_ADRDY_Msk         (0x1U << ADC_ISR_ADRDY_Pos)                  /*!< 0x00000001 */
N#define ADC_ISR_ADRDY             ADC_ISR_ADRDY_Msk                            /*!< ADC ready flag */
N#define ADC_ISR_EOSMP_Pos         (1U)                                         
N#define ADC_ISR_EOSMP_Msk         (0x1U << ADC_ISR_EOSMP_Pos)                  /*!< 0x00000002 */
N#define ADC_ISR_EOSMP             ADC_ISR_EOSMP_Msk                            /*!< ADC group regular end of sampling flag */
N#define ADC_ISR_EOC_Pos           (2U)                                         
N#define ADC_ISR_EOC_Msk           (0x1U << ADC_ISR_EOC_Pos)                    /*!< 0x00000004 */
N#define ADC_ISR_EOC               ADC_ISR_EOC_Msk                              /*!< ADC group regular end of unitary conversion flag */
N#define ADC_ISR_EOS_Pos           (3U)                                         
N#define ADC_ISR_EOS_Msk           (0x1U << ADC_ISR_EOS_Pos)                    /*!< 0x00000008 */
N#define ADC_ISR_EOS               ADC_ISR_EOS_Msk                              /*!< ADC group regular end of sequence conversions flag */
N#define ADC_ISR_OVR_Pos           (4U)                                         
N#define ADC_ISR_OVR_Msk           (0x1U << ADC_ISR_OVR_Pos)                    /*!< 0x00000010 */
N#define ADC_ISR_OVR               ADC_ISR_OVR_Msk                              /*!< ADC group regular overrun flag */
N#define ADC_ISR_AWD1_Pos          (7U)                                         
N#define ADC_ISR_AWD1_Msk          (0x1U << ADC_ISR_AWD1_Pos)                   /*!< 0x00000080 */
N#define ADC_ISR_AWD1              ADC_ISR_AWD1_Msk                             /*!< ADC analog watchdog 1 flag */
N
N/* Legacy defines */
N#define ADC_ISR_AWD             (ADC_ISR_AWD1)
N#define ADC_ISR_EOSEQ           (ADC_ISR_EOS)
N
N/********************  Bits definition for ADC_IER register  ******************/
N#define ADC_IER_ADRDYIE_Pos       (0U)                                         
N#define ADC_IER_ADRDYIE_Msk       (0x1U << ADC_IER_ADRDYIE_Pos)                /*!< 0x00000001 */
N#define ADC_IER_ADRDYIE           ADC_IER_ADRDYIE_Msk                          /*!< ADC ready interrupt */
N#define ADC_IER_EOSMPIE_Pos       (1U)                                         
N#define ADC_IER_EOSMPIE_Msk       (0x1U << ADC_IER_EOSMPIE_Pos)                /*!< 0x00000002 */
N#define ADC_IER_EOSMPIE           ADC_IER_EOSMPIE_Msk                          /*!< ADC group regular end of sampling interrupt */
N#define ADC_IER_EOCIE_Pos         (2U)                                         
N#define ADC_IER_EOCIE_Msk         (0x1U << ADC_IER_EOCIE_Pos)                  /*!< 0x00000004 */
N#define ADC_IER_EOCIE             ADC_IER_EOCIE_Msk                            /*!< ADC group regular end of unitary conversion interrupt */
N#define ADC_IER_EOSIE_Pos         (3U)                                         
N#define ADC_IER_EOSIE_Msk         (0x1U << ADC_IER_EOSIE_Pos)                  /*!< 0x00000008 */
N#define ADC_IER_EOSIE             ADC_IER_EOSIE_Msk                            /*!< ADC group regular end of sequence conversions interrupt */
N#define ADC_IER_OVRIE_Pos         (4U)                                         
N#define ADC_IER_OVRIE_Msk         (0x1U << ADC_IER_OVRIE_Pos)                  /*!< 0x00000010 */
N#define ADC_IER_OVRIE             ADC_IER_OVRIE_Msk                            /*!< ADC group regular overrun interrupt */
N#define ADC_IER_AWD1IE_Pos        (7U)                                         
N#define ADC_IER_AWD1IE_Msk        (0x1U << ADC_IER_AWD1IE_Pos)                 /*!< 0x00000080 */
N#define ADC_IER_AWD1IE            ADC_IER_AWD1IE_Msk                           /*!< ADC analog watchdog 1 interrupt */
N
N/* Legacy defines */
N#define ADC_IER_AWDIE           (ADC_IER_AWD1IE)
N#define ADC_IER_EOSEQIE         (ADC_IER_EOSIE)
N
N/********************  Bits definition for ADC_CR register  *******************/
N#define ADC_CR_ADEN_Pos           (0U)                                         
N#define ADC_CR_ADEN_Msk           (0x1U << ADC_CR_ADEN_Pos)                    /*!< 0x00000001 */
N#define ADC_CR_ADEN               ADC_CR_ADEN_Msk                              /*!< ADC enable */
N#define ADC_CR_ADDIS_Pos          (1U)                                         
N#define ADC_CR_ADDIS_Msk          (0x1U << ADC_CR_ADDIS_Pos)                   /*!< 0x00000002 */
N#define ADC_CR_ADDIS              ADC_CR_ADDIS_Msk                             /*!< ADC disable */
N#define ADC_CR_ADSTART_Pos        (2U)                                         
N#define ADC_CR_ADSTART_Msk        (0x1U << ADC_CR_ADSTART_Pos)                 /*!< 0x00000004 */
N#define ADC_CR_ADSTART            ADC_CR_ADSTART_Msk                           /*!< ADC group regular conversion start */
N#define ADC_CR_ADSTP_Pos          (4U)                                         
N#define ADC_CR_ADSTP_Msk          (0x1U << ADC_CR_ADSTP_Pos)                   /*!< 0x00000010 */
N#define ADC_CR_ADSTP              ADC_CR_ADSTP_Msk                             /*!< ADC group regular conversion stop */
N#define ADC_CR_ADCAL_Pos          (31U)                                        
N#define ADC_CR_ADCAL_Msk          (0x1U << ADC_CR_ADCAL_Pos)                   /*!< 0x80000000 */
N#define ADC_CR_ADCAL              ADC_CR_ADCAL_Msk                             /*!< ADC calibration */
N
N/*******************  Bits definition for ADC_CFGR1 register  *****************/
N#define ADC_CFGR1_DMAEN_Pos       (0U)                                         
N#define ADC_CFGR1_DMAEN_Msk       (0x1U << ADC_CFGR1_DMAEN_Pos)                /*!< 0x00000001 */
N#define ADC_CFGR1_DMAEN           ADC_CFGR1_DMAEN_Msk                          /*!< ADC DMA transfer enable */
N#define ADC_CFGR1_DMACFG_Pos      (1U)                                         
N#define ADC_CFGR1_DMACFG_Msk      (0x1U << ADC_CFGR1_DMACFG_Pos)               /*!< 0x00000002 */
N#define ADC_CFGR1_DMACFG          ADC_CFGR1_DMACFG_Msk                         /*!< ADC DMA transfer configuration */
N#define ADC_CFGR1_SCANDIR_Pos     (2U)                                         
N#define ADC_CFGR1_SCANDIR_Msk     (0x1U << ADC_CFGR1_SCANDIR_Pos)              /*!< 0x00000004 */
N#define ADC_CFGR1_SCANDIR         ADC_CFGR1_SCANDIR_Msk                        /*!< ADC group regular sequencer scan direction */
N
N#define ADC_CFGR1_RES_Pos         (3U)                                         
N#define ADC_CFGR1_RES_Msk         (0x3U << ADC_CFGR1_RES_Pos)                  /*!< 0x00000018 */
N#define ADC_CFGR1_RES             ADC_CFGR1_RES_Msk                            /*!< ADC data resolution */
N#define ADC_CFGR1_RES_0           (0x1U << ADC_CFGR1_RES_Pos)                  /*!< 0x00000008 */
N#define ADC_CFGR1_RES_1           (0x2U << ADC_CFGR1_RES_Pos)                  /*!< 0x00000010 */
N
N#define ADC_CFGR1_ALIGN_Pos       (5U)                                         
N#define ADC_CFGR1_ALIGN_Msk       (0x1U << ADC_CFGR1_ALIGN_Pos)                /*!< 0x00000020 */
N#define ADC_CFGR1_ALIGN           ADC_CFGR1_ALIGN_Msk                          /*!< ADC data alignement */
N
N#define ADC_CFGR1_EXTSEL_Pos      (6U)                                         
N#define ADC_CFGR1_EXTSEL_Msk      (0x7U << ADC_CFGR1_EXTSEL_Pos)               /*!< 0x000001C0 */
N#define ADC_CFGR1_EXTSEL          ADC_CFGR1_EXTSEL_Msk                         /*!< ADC group regular external trigger source */
N#define ADC_CFGR1_EXTSEL_0        (0x1U << ADC_CFGR1_EXTSEL_Pos)               /*!< 0x00000040 */
N#define ADC_CFGR1_EXTSEL_1        (0x2U << ADC_CFGR1_EXTSEL_Pos)               /*!< 0x00000080 */
N#define ADC_CFGR1_EXTSEL_2        (0x4U << ADC_CFGR1_EXTSEL_Pos)               /*!< 0x00000100 */
N
N#define ADC_CFGR1_EXTEN_Pos       (10U)                                        
N#define ADC_CFGR1_EXTEN_Msk       (0x3U << ADC_CFGR1_EXTEN_Pos)                /*!< 0x00000C00 */
N#define ADC_CFGR1_EXTEN           ADC_CFGR1_EXTEN_Msk                          /*!< ADC group regular external trigger polarity */
N#define ADC_CFGR1_EXTEN_0         (0x1U << ADC_CFGR1_EXTEN_Pos)                /*!< 0x00000400 */
N#define ADC_CFGR1_EXTEN_1         (0x2U << ADC_CFGR1_EXTEN_Pos)                /*!< 0x00000800 */
N
N#define ADC_CFGR1_OVRMOD_Pos      (12U)                                        
N#define ADC_CFGR1_OVRMOD_Msk      (0x1U << ADC_CFGR1_OVRMOD_Pos)               /*!< 0x00001000 */
N#define ADC_CFGR1_OVRMOD          ADC_CFGR1_OVRMOD_Msk                         /*!< ADC group regular overrun configuration */
N#define ADC_CFGR1_CONT_Pos        (13U)                                        
N#define ADC_CFGR1_CONT_Msk        (0x1U << ADC_CFGR1_CONT_Pos)                 /*!< 0x00002000 */
N#define ADC_CFGR1_CONT            ADC_CFGR1_CONT_Msk                           /*!< ADC group regular continuous conversion mode */
N#define ADC_CFGR1_WAIT_Pos        (14U)                                        
N#define ADC_CFGR1_WAIT_Msk        (0x1U << ADC_CFGR1_WAIT_Pos)                 /*!< 0x00004000 */
N#define ADC_CFGR1_WAIT            ADC_CFGR1_WAIT_Msk                           /*!< ADC low power auto wait */
N#define ADC_CFGR1_AUTOFF_Pos      (15U)                                        
N#define ADC_CFGR1_AUTOFF_Msk      (0x1U << ADC_CFGR1_AUTOFF_Pos)               /*!< 0x00008000 */
N#define ADC_CFGR1_AUTOFF          ADC_CFGR1_AUTOFF_Msk                         /*!< ADC low power auto power off */
N#define ADC_CFGR1_DISCEN_Pos      (16U)                                        
N#define ADC_CFGR1_DISCEN_Msk      (0x1U << ADC_CFGR1_DISCEN_Pos)               /*!< 0x00010000 */
N#define ADC_CFGR1_DISCEN          ADC_CFGR1_DISCEN_Msk                         /*!< ADC group regular sequencer discontinuous mode */
N
N#define ADC_CFGR1_AWD1SGL_Pos     (22U)                                        
N#define ADC_CFGR1_AWD1SGL_Msk     (0x1U << ADC_CFGR1_AWD1SGL_Pos)              /*!< 0x00400000 */
N#define ADC_CFGR1_AWD1SGL         ADC_CFGR1_AWD1SGL_Msk                        /*!< ADC analog watchdog 1 monitoring a single channel or all channels */
N#define ADC_CFGR1_AWD1EN_Pos      (23U)                                        
N#define ADC_CFGR1_AWD1EN_Msk      (0x1U << ADC_CFGR1_AWD1EN_Pos)               /*!< 0x00800000 */
N#define ADC_CFGR1_AWD1EN          ADC_CFGR1_AWD1EN_Msk                         /*!< ADC analog watchdog 1 enable on scope ADC group regular */
N
N#define ADC_CFGR1_AWD1CH_Pos      (26U)                                        
N#define ADC_CFGR1_AWD1CH_Msk      (0x1FU << ADC_CFGR1_AWD1CH_Pos)              /*!< 0x7C000000 */
N#define ADC_CFGR1_AWD1CH          ADC_CFGR1_AWD1CH_Msk                         /*!< ADC analog watchdog 1 monitored channel selection */
N#define ADC_CFGR1_AWD1CH_0        (0x01U << ADC_CFGR1_AWD1CH_Pos)              /*!< 0x04000000 */
N#define ADC_CFGR1_AWD1CH_1        (0x02U << ADC_CFGR1_AWD1CH_Pos)              /*!< 0x08000000 */
N#define ADC_CFGR1_AWD1CH_2        (0x04U << ADC_CFGR1_AWD1CH_Pos)              /*!< 0x10000000 */
N#define ADC_CFGR1_AWD1CH_3        (0x08U << ADC_CFGR1_AWD1CH_Pos)              /*!< 0x20000000 */
N#define ADC_CFGR1_AWD1CH_4        (0x10U << ADC_CFGR1_AWD1CH_Pos)              /*!< 0x40000000 */
N
N/* Legacy defines */
N#define ADC_CFGR1_AUTDLY        (ADC_CFGR1_WAIT)
N#define ADC_CFGR1_AWDSGL        (ADC_CFGR1_AWD1SGL)
N#define ADC_CFGR1_AWDEN         (ADC_CFGR1_AWD1EN)
N#define ADC_CFGR1_AWDCH         (ADC_CFGR1_AWD1CH)
N#define ADC_CFGR1_AWDCH_0       (ADC_CFGR1_AWD1CH_0)
N#define ADC_CFGR1_AWDCH_1       (ADC_CFGR1_AWD1CH_1)
N#define ADC_CFGR1_AWDCH_2       (ADC_CFGR1_AWD1CH_2)
N#define ADC_CFGR1_AWDCH_3       (ADC_CFGR1_AWD1CH_3)
N#define ADC_CFGR1_AWDCH_4       (ADC_CFGR1_AWD1CH_4)
N
N/*******************  Bits definition for ADC_CFGR2 register  *****************/
N#define ADC_CFGR2_CKMODE_Pos      (30U)                                        
N#define ADC_CFGR2_CKMODE_Msk      (0x3U << ADC_CFGR2_CKMODE_Pos)               /*!< 0xC0000000 */
N#define ADC_CFGR2_CKMODE          ADC_CFGR2_CKMODE_Msk                         /*!< ADC clock source and prescaler (prescaler only for clock source synchronous) */
N#define ADC_CFGR2_CKMODE_1        (0x2U << ADC_CFGR2_CKMODE_Pos)               /*!< 0x80000000 */
N#define ADC_CFGR2_CKMODE_0        (0x1U << ADC_CFGR2_CKMODE_Pos)               /*!< 0x40000000 */
N
N/* Legacy defines */
N#define  ADC_CFGR2_JITOFFDIV4   (ADC_CFGR2_CKMODE_1)   /*!< ADC clocked by PCLK div4 */
N#define  ADC_CFGR2_JITOFFDIV2   (ADC_CFGR2_CKMODE_0)   /*!< ADC clocked by PCLK div2 */
N
N/******************  Bit definition for ADC_SMPR register  ********************/
N#define ADC_SMPR_SMP_Pos          (0U)                                         
N#define ADC_SMPR_SMP_Msk          (0x7U << ADC_SMPR_SMP_Pos)                   /*!< 0x00000007 */
N#define ADC_SMPR_SMP              ADC_SMPR_SMP_Msk                             /*!< ADC group of channels sampling time 2 */
N#define ADC_SMPR_SMP_0            (0x1U << ADC_SMPR_SMP_Pos)                   /*!< 0x00000001 */
N#define ADC_SMPR_SMP_1            (0x2U << ADC_SMPR_SMP_Pos)                   /*!< 0x00000002 */
N#define ADC_SMPR_SMP_2            (0x4U << ADC_SMPR_SMP_Pos)                   /*!< 0x00000004 */
N
N/* Legacy defines */
N#define  ADC_SMPR1_SMPR         (ADC_SMPR_SMP)         /*!< SMP[2:0] bits (Sampling time selection) */
N#define  ADC_SMPR1_SMPR_0       (ADC_SMPR_SMP_0)       /*!< bit 0 */
N#define  ADC_SMPR1_SMPR_1       (ADC_SMPR_SMP_1)       /*!< bit 1 */
N#define  ADC_SMPR1_SMPR_2       (ADC_SMPR_SMP_2)       /*!< bit 2 */
N
N/*******************  Bit definition for ADC_TR register  ********************/
N#define ADC_TR1_LT1_Pos           (0U)                                         
N#define ADC_TR1_LT1_Msk           (0xFFFU << ADC_TR1_LT1_Pos)                  /*!< 0x00000FFF */
N#define ADC_TR1_LT1               ADC_TR1_LT1_Msk                              /*!< ADC analog watchdog 1 threshold low */
N#define ADC_TR1_LT1_0             (0x001U << ADC_TR1_LT1_Pos)                  /*!< 0x00000001 */
N#define ADC_TR1_LT1_1             (0x002U << ADC_TR1_LT1_Pos)                  /*!< 0x00000002 */
N#define ADC_TR1_LT1_2             (0x004U << ADC_TR1_LT1_Pos)                  /*!< 0x00000004 */
N#define ADC_TR1_LT1_3             (0x008U << ADC_TR1_LT1_Pos)                  /*!< 0x00000008 */
N#define ADC_TR1_LT1_4             (0x010U << ADC_TR1_LT1_Pos)                  /*!< 0x00000010 */
N#define ADC_TR1_LT1_5             (0x020U << ADC_TR1_LT1_Pos)                  /*!< 0x00000020 */
N#define ADC_TR1_LT1_6             (0x040U << ADC_TR1_LT1_Pos)                  /*!< 0x00000040 */
N#define ADC_TR1_LT1_7             (0x080U << ADC_TR1_LT1_Pos)                  /*!< 0x00000080 */
N#define ADC_TR1_LT1_8             (0x100U << ADC_TR1_LT1_Pos)                  /*!< 0x00000100 */
N#define ADC_TR1_LT1_9             (0x200U << ADC_TR1_LT1_Pos)                  /*!< 0x00000200 */
N#define ADC_TR1_LT1_10            (0x400U << ADC_TR1_LT1_Pos)                  /*!< 0x00000400 */
N#define ADC_TR1_LT1_11            (0x800U << ADC_TR1_LT1_Pos)                  /*!< 0x00000800 */
N
N#define ADC_TR1_HT1_Pos           (16U)                                        
N#define ADC_TR1_HT1_Msk           (0xFFFU << ADC_TR1_HT1_Pos)                  /*!< 0x0FFF0000 */
N#define ADC_TR1_HT1               ADC_TR1_HT1_Msk                              /*!< ADC Analog watchdog 1 threshold high */
N#define ADC_TR1_HT1_0             (0x001U << ADC_TR1_HT1_Pos)                  /*!< 0x00010000 */
N#define ADC_TR1_HT1_1             (0x002U << ADC_TR1_HT1_Pos)                  /*!< 0x00020000 */
N#define ADC_TR1_HT1_2             (0x004U << ADC_TR1_HT1_Pos)                  /*!< 0x00040000 */
N#define ADC_TR1_HT1_3             (0x008U << ADC_TR1_HT1_Pos)                  /*!< 0x00080000 */
N#define ADC_TR1_HT1_4             (0x010U << ADC_TR1_HT1_Pos)                  /*!< 0x00100000 */
N#define ADC_TR1_HT1_5             (0x020U << ADC_TR1_HT1_Pos)                  /*!< 0x00200000 */
N#define ADC_TR1_HT1_6             (0x040U << ADC_TR1_HT1_Pos)                  /*!< 0x00400000 */
N#define ADC_TR1_HT1_7             (0x080U << ADC_TR1_HT1_Pos)                  /*!< 0x00800000 */
N#define ADC_TR1_HT1_8             (0x100U << ADC_TR1_HT1_Pos)                  /*!< 0x01000000 */
N#define ADC_TR1_HT1_9             (0x200U << ADC_TR1_HT1_Pos)                  /*!< 0x02000000 */
N#define ADC_TR1_HT1_10            (0x400U << ADC_TR1_HT1_Pos)                  /*!< 0x04000000 */
N#define ADC_TR1_HT1_11            (0x800U << ADC_TR1_HT1_Pos)                  /*!< 0x08000000 */
N
N/* Legacy defines */
N#define  ADC_TR_HT              (ADC_TR1_HT1)
N#define  ADC_TR_LT              (ADC_TR1_LT1)
N#define  ADC_HTR_HT             (ADC_TR1_HT1)
N#define  ADC_LTR_LT             (ADC_TR1_LT1)
N
N/******************  Bit definition for ADC_CHSELR register  ******************/
N#define ADC_CHSELR_CHSEL_Pos      (0U)                                         
N#define ADC_CHSELR_CHSEL_Msk      (0x7FFFFU << ADC_CHSELR_CHSEL_Pos)           /*!< 0x0007FFFF */
N#define ADC_CHSELR_CHSEL          ADC_CHSELR_CHSEL_Msk                         /*!< ADC group regular sequencer channels, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL18_Pos    (18U)                                        
N#define ADC_CHSELR_CHSEL18_Msk    (0x1U << ADC_CHSELR_CHSEL18_Pos)             /*!< 0x00040000 */
N#define ADC_CHSELR_CHSEL18        ADC_CHSELR_CHSEL18_Msk                       /*!< ADC group regular sequencer channel 18, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL17_Pos    (17U)                                        
N#define ADC_CHSELR_CHSEL17_Msk    (0x1U << ADC_CHSELR_CHSEL17_Pos)             /*!< 0x00020000 */
N#define ADC_CHSELR_CHSEL17        ADC_CHSELR_CHSEL17_Msk                       /*!< ADC group regular sequencer channel 17, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL16_Pos    (16U)                                        
N#define ADC_CHSELR_CHSEL16_Msk    (0x1U << ADC_CHSELR_CHSEL16_Pos)             /*!< 0x00010000 */
N#define ADC_CHSELR_CHSEL16        ADC_CHSELR_CHSEL16_Msk                       /*!< ADC group regular sequencer channel 16, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL15_Pos    (15U)                                        
N#define ADC_CHSELR_CHSEL15_Msk    (0x1U << ADC_CHSELR_CHSEL15_Pos)             /*!< 0x00008000 */
N#define ADC_CHSELR_CHSEL15        ADC_CHSELR_CHSEL15_Msk                       /*!< ADC group regular sequencer channel 15, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL14_Pos    (14U)                                        
N#define ADC_CHSELR_CHSEL14_Msk    (0x1U << ADC_CHSELR_CHSEL14_Pos)             /*!< 0x00004000 */
N#define ADC_CHSELR_CHSEL14        ADC_CHSELR_CHSEL14_Msk                       /*!< ADC group regular sequencer channel 14, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL13_Pos    (13U)                                        
N#define ADC_CHSELR_CHSEL13_Msk    (0x1U << ADC_CHSELR_CHSEL13_Pos)             /*!< 0x00002000 */
N#define ADC_CHSELR_CHSEL13        ADC_CHSELR_CHSEL13_Msk                       /*!< ADC group regular sequencer channel 13, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL12_Pos    (12U)                                        
N#define ADC_CHSELR_CHSEL12_Msk    (0x1U << ADC_CHSELR_CHSEL12_Pos)             /*!< 0x00001000 */
N#define ADC_CHSELR_CHSEL12        ADC_CHSELR_CHSEL12_Msk                       /*!< ADC group regular sequencer channel 12, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL11_Pos    (11U)                                        
N#define ADC_CHSELR_CHSEL11_Msk    (0x1U << ADC_CHSELR_CHSEL11_Pos)             /*!< 0x00000800 */
N#define ADC_CHSELR_CHSEL11        ADC_CHSELR_CHSEL11_Msk                       /*!< ADC group regular sequencer channel 11, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL10_Pos    (10U)                                        
N#define ADC_CHSELR_CHSEL10_Msk    (0x1U << ADC_CHSELR_CHSEL10_Pos)             /*!< 0x00000400 */
N#define ADC_CHSELR_CHSEL10        ADC_CHSELR_CHSEL10_Msk                       /*!< ADC group regular sequencer channel 10, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL9_Pos     (9U)                                         
N#define ADC_CHSELR_CHSEL9_Msk     (0x1U << ADC_CHSELR_CHSEL9_Pos)              /*!< 0x00000200 */
N#define ADC_CHSELR_CHSEL9         ADC_CHSELR_CHSEL9_Msk                        /*!< ADC group regular sequencer channel 9, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL8_Pos     (8U)                                         
N#define ADC_CHSELR_CHSEL8_Msk     (0x1U << ADC_CHSELR_CHSEL8_Pos)              /*!< 0x00000100 */
N#define ADC_CHSELR_CHSEL8         ADC_CHSELR_CHSEL8_Msk                        /*!< ADC group regular sequencer channel 8, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL7_Pos     (7U)                                         
N#define ADC_CHSELR_CHSEL7_Msk     (0x1U << ADC_CHSELR_CHSEL7_Pos)              /*!< 0x00000080 */
N#define ADC_CHSELR_CHSEL7         ADC_CHSELR_CHSEL7_Msk                        /*!< ADC group regular sequencer channel 7, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL6_Pos     (6U)                                         
N#define ADC_CHSELR_CHSEL6_Msk     (0x1U << ADC_CHSELR_CHSEL6_Pos)              /*!< 0x00000040 */
N#define ADC_CHSELR_CHSEL6         ADC_CHSELR_CHSEL6_Msk                        /*!< ADC group regular sequencer channel 6, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL5_Pos     (5U)                                         
N#define ADC_CHSELR_CHSEL5_Msk     (0x1U << ADC_CHSELR_CHSEL5_Pos)              /*!< 0x00000020 */
N#define ADC_CHSELR_CHSEL5         ADC_CHSELR_CHSEL5_Msk                        /*!< ADC group regular sequencer channel 5, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL4_Pos     (4U)                                         
N#define ADC_CHSELR_CHSEL4_Msk     (0x1U << ADC_CHSELR_CHSEL4_Pos)              /*!< 0x00000010 */
N#define ADC_CHSELR_CHSEL4         ADC_CHSELR_CHSEL4_Msk                        /*!< ADC group regular sequencer channel 4, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL3_Pos     (3U)                                         
N#define ADC_CHSELR_CHSEL3_Msk     (0x1U << ADC_CHSELR_CHSEL3_Pos)              /*!< 0x00000008 */
N#define ADC_CHSELR_CHSEL3         ADC_CHSELR_CHSEL3_Msk                        /*!< ADC group regular sequencer channel 3, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL2_Pos     (2U)                                         
N#define ADC_CHSELR_CHSEL2_Msk     (0x1U << ADC_CHSELR_CHSEL2_Pos)              /*!< 0x00000004 */
N#define ADC_CHSELR_CHSEL2         ADC_CHSELR_CHSEL2_Msk                        /*!< ADC group regular sequencer channel 2, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL1_Pos     (1U)                                         
N#define ADC_CHSELR_CHSEL1_Msk     (0x1U << ADC_CHSELR_CHSEL1_Pos)              /*!< 0x00000002 */
N#define ADC_CHSELR_CHSEL1         ADC_CHSELR_CHSEL1_Msk                        /*!< ADC group regular sequencer channel 1, available when ADC_CFGR1_CHSELRMOD is reset */
N#define ADC_CHSELR_CHSEL0_Pos     (0U)                                         
N#define ADC_CHSELR_CHSEL0_Msk     (0x1U << ADC_CHSELR_CHSEL0_Pos)              /*!< 0x00000001 */
N#define ADC_CHSELR_CHSEL0         ADC_CHSELR_CHSEL0_Msk                        /*!< ADC group regular sequencer channel 0, available when ADC_CFGR1_CHSELRMOD is reset */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define ADC_DR_DATA_Pos           (0U)                                         
N#define ADC_DR_DATA_Msk           (0xFFFFU << ADC_DR_DATA_Pos)                 /*!< 0x0000FFFF */
N#define ADC_DR_DATA               ADC_DR_DATA_Msk                              /*!< ADC group regular conversion data */
N#define ADC_DR_DATA_0             (0x0001U << ADC_DR_DATA_Pos)                 /*!< 0x00000001 */
N#define ADC_DR_DATA_1             (0x0002U << ADC_DR_DATA_Pos)                 /*!< 0x00000002 */
N#define ADC_DR_DATA_2             (0x0004U << ADC_DR_DATA_Pos)                 /*!< 0x00000004 */
N#define ADC_DR_DATA_3             (0x0008U << ADC_DR_DATA_Pos)                 /*!< 0x00000008 */
N#define ADC_DR_DATA_4             (0x0010U << ADC_DR_DATA_Pos)                 /*!< 0x00000010 */
N#define ADC_DR_DATA_5             (0x0020U << ADC_DR_DATA_Pos)                 /*!< 0x00000020 */
N#define ADC_DR_DATA_6             (0x0040U << ADC_DR_DATA_Pos)                 /*!< 0x00000040 */
N#define ADC_DR_DATA_7             (0x0080U << ADC_DR_DATA_Pos)                 /*!< 0x00000080 */
N#define ADC_DR_DATA_8             (0x0100U << ADC_DR_DATA_Pos)                 /*!< 0x00000100 */
N#define ADC_DR_DATA_9             (0x0200U << ADC_DR_DATA_Pos)                 /*!< 0x00000200 */
N#define ADC_DR_DATA_10            (0x0400U << ADC_DR_DATA_Pos)                 /*!< 0x00000400 */
N#define ADC_DR_DATA_11            (0x0800U << ADC_DR_DATA_Pos)                 /*!< 0x00000800 */
N#define ADC_DR_DATA_12            (0x1000U << ADC_DR_DATA_Pos)                 /*!< 0x00001000 */
N#define ADC_DR_DATA_13            (0x2000U << ADC_DR_DATA_Pos)                 /*!< 0x00002000 */
N#define ADC_DR_DATA_14            (0x4000U << ADC_DR_DATA_Pos)                 /*!< 0x00004000 */
N#define ADC_DR_DATA_15            (0x8000U << ADC_DR_DATA_Pos)                 /*!< 0x00008000 */
N
N/*************************  ADC Common registers  *****************************/
N/*******************  Bit definition for ADC_CCR register  ********************/
N#define ADC_CCR_VREFEN_Pos        (22U)                                        
N#define ADC_CCR_VREFEN_Msk        (0x1U << ADC_CCR_VREFEN_Pos)                 /*!< 0x00400000 */
N#define ADC_CCR_VREFEN            ADC_CCR_VREFEN_Msk                           /*!< ADC internal path to VrefInt enable */
N#define ADC_CCR_TSEN_Pos          (23U)                                        
N#define ADC_CCR_TSEN_Msk          (0x1U << ADC_CCR_TSEN_Pos)                   /*!< 0x00800000 */
N#define ADC_CCR_TSEN              ADC_CCR_TSEN_Msk                             /*!< ADC internal path to temperature sensor enable */
N
N#define ADC_CCR_VBATEN_Pos        (24U)                                        
N#define ADC_CCR_VBATEN_Msk        (0x1U << ADC_CCR_VBATEN_Pos)                 /*!< 0x01000000 */
N#define ADC_CCR_VBATEN            ADC_CCR_VBATEN_Msk                           /*!< ADC internal path to battery voltage enable */
N
N/******************************************************************************/
N/*                                                                            */
N/*                   Controller Area Network (CAN )                           */
N/*                                                                            */
N/******************************************************************************/
N/*!<CAN control and status registers */
N/*******************  Bit definition for CAN_MCR register  ********************/
N#define CAN_MCR_INRQ_Pos       (0U)                                            
N#define CAN_MCR_INRQ_Msk       (0x1U << CAN_MCR_INRQ_Pos)                      /*!< 0x00000001 */
N#define CAN_MCR_INRQ           CAN_MCR_INRQ_Msk                                /*!<Initialization Request */
N#define CAN_MCR_SLEEP_Pos      (1U)                                            
N#define CAN_MCR_SLEEP_Msk      (0x1U << CAN_MCR_SLEEP_Pos)                     /*!< 0x00000002 */
N#define CAN_MCR_SLEEP          CAN_MCR_SLEEP_Msk                               /*!<Sleep Mode Request */
N#define CAN_MCR_TXFP_Pos       (2U)                                            
N#define CAN_MCR_TXFP_Msk       (0x1U << CAN_MCR_TXFP_Pos)                      /*!< 0x00000004 */
N#define CAN_MCR_TXFP           CAN_MCR_TXFP_Msk                                /*!<Transmit FIFO Priority */
N#define CAN_MCR_RFLM_Pos       (3U)                                            
N#define CAN_MCR_RFLM_Msk       (0x1U << CAN_MCR_RFLM_Pos)                      /*!< 0x00000008 */
N#define CAN_MCR_RFLM           CAN_MCR_RFLM_Msk                                /*!<Receive FIFO Locked Mode */
N#define CAN_MCR_NART_Pos       (4U)                                            
N#define CAN_MCR_NART_Msk       (0x1U << CAN_MCR_NART_Pos)                      /*!< 0x00000010 */
N#define CAN_MCR_NART           CAN_MCR_NART_Msk                                /*!<No Automatic Retransmission */
N#define CAN_MCR_AWUM_Pos       (5U)                                            
N#define CAN_MCR_AWUM_Msk       (0x1U << CAN_MCR_AWUM_Pos)                      /*!< 0x00000020 */
N#define CAN_MCR_AWUM           CAN_MCR_AWUM_Msk                                /*!<Automatic Wakeup Mode */
N#define CAN_MCR_ABOM_Pos       (6U)                                            
N#define CAN_MCR_ABOM_Msk       (0x1U << CAN_MCR_ABOM_Pos)                      /*!< 0x00000040 */
N#define CAN_MCR_ABOM           CAN_MCR_ABOM_Msk                                /*!<Automatic Bus-Off Management */
N#define CAN_MCR_TTCM_Pos       (7U)                                            
N#define CAN_MCR_TTCM_Msk       (0x1U << CAN_MCR_TTCM_Pos)                      /*!< 0x00000080 */
N#define CAN_MCR_TTCM           CAN_MCR_TTCM_Msk                                /*!<Time Triggered Communication Mode */
N#define CAN_MCR_RESET_Pos      (15U)                                           
N#define CAN_MCR_RESET_Msk      (0x1U << CAN_MCR_RESET_Pos)                     /*!< 0x00008000 */
N#define CAN_MCR_RESET          CAN_MCR_RESET_Msk                               /*!<bxCAN software master reset */
N
N/*******************  Bit definition for CAN_MSR register  ********************/
N#define CAN_MSR_INAK_Pos       (0U)                                            
N#define CAN_MSR_INAK_Msk       (0x1U << CAN_MSR_INAK_Pos)                      /*!< 0x00000001 */
N#define CAN_MSR_INAK           CAN_MSR_INAK_Msk                                /*!<Initialization Acknowledge */
N#define CAN_MSR_SLAK_Pos       (1U)                                            
N#define CAN_MSR_SLAK_Msk       (0x1U << CAN_MSR_SLAK_Pos)                      /*!< 0x00000002 */
N#define CAN_MSR_SLAK           CAN_MSR_SLAK_Msk                                /*!<Sleep Acknowledge */
N#define CAN_MSR_ERRI_Pos       (2U)                                            
N#define CAN_MSR_ERRI_Msk       (0x1U << CAN_MSR_ERRI_Pos)                      /*!< 0x00000004 */
N#define CAN_MSR_ERRI           CAN_MSR_ERRI_Msk                                /*!<Error Interrupt */
N#define CAN_MSR_WKUI_Pos       (3U)                                            
N#define CAN_MSR_WKUI_Msk       (0x1U << CAN_MSR_WKUI_Pos)                      /*!< 0x00000008 */
N#define CAN_MSR_WKUI           CAN_MSR_WKUI_Msk                                /*!<Wakeup Interrupt */
N#define CAN_MSR_SLAKI_Pos      (4U)                                            
N#define CAN_MSR_SLAKI_Msk      (0x1U << CAN_MSR_SLAKI_Pos)                     /*!< 0x00000010 */
N#define CAN_MSR_SLAKI          CAN_MSR_SLAKI_Msk                               /*!<Sleep Acknowledge Interrupt */
N#define CAN_MSR_TXM_Pos        (8U)                                            
N#define CAN_MSR_TXM_Msk        (0x1U << CAN_MSR_TXM_Pos)                       /*!< 0x00000100 */
N#define CAN_MSR_TXM            CAN_MSR_TXM_Msk                                 /*!<Transmit Mode */
N#define CAN_MSR_RXM_Pos        (9U)                                            
N#define CAN_MSR_RXM_Msk        (0x1U << CAN_MSR_RXM_Pos)                       /*!< 0x00000200 */
N#define CAN_MSR_RXM            CAN_MSR_RXM_Msk                                 /*!<Receive Mode */
N#define CAN_MSR_SAMP_Pos       (10U)                                           
N#define CAN_MSR_SAMP_Msk       (0x1U << CAN_MSR_SAMP_Pos)                      /*!< 0x00000400 */
N#define CAN_MSR_SAMP           CAN_MSR_SAMP_Msk                                /*!<Last Sample Point */
N#define CAN_MSR_RX_Pos         (11U)                                           
N#define CAN_MSR_RX_Msk         (0x1U << CAN_MSR_RX_Pos)                        /*!< 0x00000800 */
N#define CAN_MSR_RX             CAN_MSR_RX_Msk                                  /*!<CAN Rx Signal */
N
N/*******************  Bit definition for CAN_TSR register  ********************/
N#define CAN_TSR_RQCP0_Pos      (0U)                                            
N#define CAN_TSR_RQCP0_Msk      (0x1U << CAN_TSR_RQCP0_Pos)                     /*!< 0x00000001 */
N#define CAN_TSR_RQCP0          CAN_TSR_RQCP0_Msk                               /*!<Request Completed Mailbox0 */
N#define CAN_TSR_TXOK0_Pos      (1U)                                            
N#define CAN_TSR_TXOK0_Msk      (0x1U << CAN_TSR_TXOK0_Pos)                     /*!< 0x00000002 */
N#define CAN_TSR_TXOK0          CAN_TSR_TXOK0_Msk                               /*!<Transmission OK of Mailbox0 */
N#define CAN_TSR_ALST0_Pos      (2U)                                            
N#define CAN_TSR_ALST0_Msk      (0x1U << CAN_TSR_ALST0_Pos)                     /*!< 0x00000004 */
N#define CAN_TSR_ALST0          CAN_TSR_ALST0_Msk                               /*!<Arbitration Lost for Mailbox0 */
N#define CAN_TSR_TERR0_Pos      (3U)                                            
N#define CAN_TSR_TERR0_Msk      (0x1U << CAN_TSR_TERR0_Pos)                     /*!< 0x00000008 */
N#define CAN_TSR_TERR0          CAN_TSR_TERR0_Msk                               /*!<Transmission Error of Mailbox0 */
N#define CAN_TSR_ABRQ0_Pos      (7U)                                            
N#define CAN_TSR_ABRQ0_Msk      (0x1U << CAN_TSR_ABRQ0_Pos)                     /*!< 0x00000080 */
N#define CAN_TSR_ABRQ0          CAN_TSR_ABRQ0_Msk                               /*!<Abort Request for Mailbox0 */
N#define CAN_TSR_RQCP1_Pos      (8U)                                            
N#define CAN_TSR_RQCP1_Msk      (0x1U << CAN_TSR_RQCP1_Pos)                     /*!< 0x00000100 */
N#define CAN_TSR_RQCP1          CAN_TSR_RQCP1_Msk                               /*!<Request Completed Mailbox1 */
N#define CAN_TSR_TXOK1_Pos      (9U)                                            
N#define CAN_TSR_TXOK1_Msk      (0x1U << CAN_TSR_TXOK1_Pos)                     /*!< 0x00000200 */
N#define CAN_TSR_TXOK1          CAN_TSR_TXOK1_Msk                               /*!<Transmission OK of Mailbox1 */
N#define CAN_TSR_ALST1_Pos      (10U)                                           
N#define CAN_TSR_ALST1_Msk      (0x1U << CAN_TSR_ALST1_Pos)                     /*!< 0x00000400 */
N#define CAN_TSR_ALST1          CAN_TSR_ALST1_Msk                               /*!<Arbitration Lost for Mailbox1 */
N#define CAN_TSR_TERR1_Pos      (11U)                                           
N#define CAN_TSR_TERR1_Msk      (0x1U << CAN_TSR_TERR1_Pos)                     /*!< 0x00000800 */
N#define CAN_TSR_TERR1          CAN_TSR_TERR1_Msk                               /*!<Transmission Error of Mailbox1 */
N#define CAN_TSR_ABRQ1_Pos      (15U)                                           
N#define CAN_TSR_ABRQ1_Msk      (0x1U << CAN_TSR_ABRQ1_Pos)                     /*!< 0x00008000 */
N#define CAN_TSR_ABRQ1          CAN_TSR_ABRQ1_Msk                               /*!<Abort Request for Mailbox 1 */
N#define CAN_TSR_RQCP2_Pos      (16U)                                           
N#define CAN_TSR_RQCP2_Msk      (0x1U << CAN_TSR_RQCP2_Pos)                     /*!< 0x00010000 */
N#define CAN_TSR_RQCP2          CAN_TSR_RQCP2_Msk                               /*!<Request Completed Mailbox2 */
N#define CAN_TSR_TXOK2_Pos      (17U)                                           
N#define CAN_TSR_TXOK2_Msk      (0x1U << CAN_TSR_TXOK2_Pos)                     /*!< 0x00020000 */
N#define CAN_TSR_TXOK2          CAN_TSR_TXOK2_Msk                               /*!<Transmission OK of Mailbox 2 */
N#define CAN_TSR_ALST2_Pos      (18U)                                           
N#define CAN_TSR_ALST2_Msk      (0x1U << CAN_TSR_ALST2_Pos)                     /*!< 0x00040000 */
N#define CAN_TSR_ALST2          CAN_TSR_ALST2_Msk                               /*!<Arbitration Lost for mailbox 2 */
N#define CAN_TSR_TERR2_Pos      (19U)                                           
N#define CAN_TSR_TERR2_Msk      (0x1U << CAN_TSR_TERR2_Pos)                     /*!< 0x00080000 */
N#define CAN_TSR_TERR2          CAN_TSR_TERR2_Msk                               /*!<Transmission Error of Mailbox 2 */
N#define CAN_TSR_ABRQ2_Pos      (23U)                                           
N#define CAN_TSR_ABRQ2_Msk      (0x1U << CAN_TSR_ABRQ2_Pos)                     /*!< 0x00800000 */
N#define CAN_TSR_ABRQ2          CAN_TSR_ABRQ2_Msk                               /*!<Abort Request for Mailbox 2 */
N#define CAN_TSR_CODE_Pos       (24U)                                           
N#define CAN_TSR_CODE_Msk       (0x3U << CAN_TSR_CODE_Pos)                      /*!< 0x03000000 */
N#define CAN_TSR_CODE           CAN_TSR_CODE_Msk                                /*!<Mailbox Code */
N
N#define CAN_TSR_TME_Pos        (26U)                                           
N#define CAN_TSR_TME_Msk        (0x7U << CAN_TSR_TME_Pos)                       /*!< 0x1C000000 */
N#define CAN_TSR_TME            CAN_TSR_TME_Msk                                 /*!<TME[2:0] bits */
N#define CAN_TSR_TME0_Pos       (26U)                                           
N#define CAN_TSR_TME0_Msk       (0x1U << CAN_TSR_TME0_Pos)                      /*!< 0x04000000 */
N#define CAN_TSR_TME0           CAN_TSR_TME0_Msk                                /*!<Transmit Mailbox 0 Empty */
N#define CAN_TSR_TME1_Pos       (27U)                                           
N#define CAN_TSR_TME1_Msk       (0x1U << CAN_TSR_TME1_Pos)                      /*!< 0x08000000 */
N#define CAN_TSR_TME1           CAN_TSR_TME1_Msk                                /*!<Transmit Mailbox 1 Empty */
N#define CAN_TSR_TME2_Pos       (28U)                                           
N#define CAN_TSR_TME2_Msk       (0x1U << CAN_TSR_TME2_Pos)                      /*!< 0x10000000 */
N#define CAN_TSR_TME2           CAN_TSR_TME2_Msk                                /*!<Transmit Mailbox 2 Empty */
N
N#define CAN_TSR_LOW_Pos        (29U)                                           
N#define CAN_TSR_LOW_Msk        (0x7U << CAN_TSR_LOW_Pos)                       /*!< 0xE0000000 */
N#define CAN_TSR_LOW            CAN_TSR_LOW_Msk                                 /*!<LOW[2:0] bits */
N#define CAN_TSR_LOW0_Pos       (29U)                                           
N#define CAN_TSR_LOW0_Msk       (0x1U << CAN_TSR_LOW0_Pos)                      /*!< 0x20000000 */
N#define CAN_TSR_LOW0           CAN_TSR_LOW0_Msk                                /*!<Lowest Priority Flag for Mailbox 0 */
N#define CAN_TSR_LOW1_Pos       (30U)                                           
N#define CAN_TSR_LOW1_Msk       (0x1U << CAN_TSR_LOW1_Pos)                      /*!< 0x40000000 */
N#define CAN_TSR_LOW1           CAN_TSR_LOW1_Msk                                /*!<Lowest Priority Flag for Mailbox 1 */
N#define CAN_TSR_LOW2_Pos       (31U)                                           
N#define CAN_TSR_LOW2_Msk       (0x1U << CAN_TSR_LOW2_Pos)                      /*!< 0x80000000 */
N#define CAN_TSR_LOW2           CAN_TSR_LOW2_Msk                                /*!<Lowest Priority Flag for Mailbox 2 */
N
N/*******************  Bit definition for CAN_RF0R register  *******************/
N#define CAN_RF0R_FMP0_Pos      (0U)                                            
N#define CAN_RF0R_FMP0_Msk      (0x3U << CAN_RF0R_FMP0_Pos)                     /*!< 0x00000003 */
N#define CAN_RF0R_FMP0          CAN_RF0R_FMP0_Msk                               /*!<FIFO 0 Message Pending */
N#define CAN_RF0R_FULL0_Pos     (3U)                                            
N#define CAN_RF0R_FULL0_Msk     (0x1U << CAN_RF0R_FULL0_Pos)                    /*!< 0x00000008 */
N#define CAN_RF0R_FULL0         CAN_RF0R_FULL0_Msk                              /*!<FIFO 0 Full */
N#define CAN_RF0R_FOVR0_Pos     (4U)                                            
N#define CAN_RF0R_FOVR0_Msk     (0x1U << CAN_RF0R_FOVR0_Pos)                    /*!< 0x00000010 */
N#define CAN_RF0R_FOVR0         CAN_RF0R_FOVR0_Msk                              /*!<FIFO 0 Overrun */
N#define CAN_RF0R_RFOM0_Pos     (5U)                                            
N#define CAN_RF0R_RFOM0_Msk     (0x1U << CAN_RF0R_RFOM0_Pos)                    /*!< 0x00000020 */
N#define CAN_RF0R_RFOM0         CAN_RF0R_RFOM0_Msk                              /*!<Release FIFO 0 Output Mailbox */
N
N/*******************  Bit definition for CAN_RF1R register  *******************/
N#define CAN_RF1R_FMP1_Pos      (0U)                                            
N#define CAN_RF1R_FMP1_Msk      (0x3U << CAN_RF1R_FMP1_Pos)                     /*!< 0x00000003 */
N#define CAN_RF1R_FMP1          CAN_RF1R_FMP1_Msk                               /*!<FIFO 1 Message Pending */
N#define CAN_RF1R_FULL1_Pos     (3U)                                            
N#define CAN_RF1R_FULL1_Msk     (0x1U << CAN_RF1R_FULL1_Pos)                    /*!< 0x00000008 */
N#define CAN_RF1R_FULL1         CAN_RF1R_FULL1_Msk                              /*!<FIFO 1 Full */
N#define CAN_RF1R_FOVR1_Pos     (4U)                                            
N#define CAN_RF1R_FOVR1_Msk     (0x1U << CAN_RF1R_FOVR1_Pos)                    /*!< 0x00000010 */
N#define CAN_RF1R_FOVR1         CAN_RF1R_FOVR1_Msk                              /*!<FIFO 1 Overrun */
N#define CAN_RF1R_RFOM1_Pos     (5U)                                            
N#define CAN_RF1R_RFOM1_Msk     (0x1U << CAN_RF1R_RFOM1_Pos)                    /*!< 0x00000020 */
N#define CAN_RF1R_RFOM1         CAN_RF1R_RFOM1_Msk                              /*!<Release FIFO 1 Output Mailbox */
N
N/********************  Bit definition for CAN_IER register  *******************/
N#define CAN_IER_TMEIE_Pos      (0U)                                            
N#define CAN_IER_TMEIE_Msk      (0x1U << CAN_IER_TMEIE_Pos)                     /*!< 0x00000001 */
N#define CAN_IER_TMEIE          CAN_IER_TMEIE_Msk                               /*!<Transmit Mailbox Empty Interrupt Enable */
N#define CAN_IER_FMPIE0_Pos     (1U)                                            
N#define CAN_IER_FMPIE0_Msk     (0x1U << CAN_IER_FMPIE0_Pos)                    /*!< 0x00000002 */
N#define CAN_IER_FMPIE0         CAN_IER_FMPIE0_Msk                              /*!<FIFO Message Pending Interrupt Enable */
N#define CAN_IER_FFIE0_Pos      (2U)                                            
N#define CAN_IER_FFIE0_Msk      (0x1U << CAN_IER_FFIE0_Pos)                     /*!< 0x00000004 */
N#define CAN_IER_FFIE0          CAN_IER_FFIE0_Msk                               /*!<FIFO Full Interrupt Enable */
N#define CAN_IER_FOVIE0_Pos     (3U)                                            
N#define CAN_IER_FOVIE0_Msk     (0x1U << CAN_IER_FOVIE0_Pos)                    /*!< 0x00000008 */
N#define CAN_IER_FOVIE0         CAN_IER_FOVIE0_Msk                              /*!<FIFO Overrun Interrupt Enable */
N#define CAN_IER_FMPIE1_Pos     (4U)                                            
N#define CAN_IER_FMPIE1_Msk     (0x1U << CAN_IER_FMPIE1_Pos)                    /*!< 0x00000010 */
N#define CAN_IER_FMPIE1         CAN_IER_FMPIE1_Msk                              /*!<FIFO Message Pending Interrupt Enable */
N#define CAN_IER_FFIE1_Pos      (5U)                                            
N#define CAN_IER_FFIE1_Msk      (0x1U << CAN_IER_FFIE1_Pos)                     /*!< 0x00000020 */
N#define CAN_IER_FFIE1          CAN_IER_FFIE1_Msk                               /*!<FIFO Full Interrupt Enable */
N#define CAN_IER_FOVIE1_Pos     (6U)                                            
N#define CAN_IER_FOVIE1_Msk     (0x1U << CAN_IER_FOVIE1_Pos)                    /*!< 0x00000040 */
N#define CAN_IER_FOVIE1         CAN_IER_FOVIE1_Msk                              /*!<FIFO Overrun Interrupt Enable */
N#define CAN_IER_EWGIE_Pos      (8U)                                            
N#define CAN_IER_EWGIE_Msk      (0x1U << CAN_IER_EWGIE_Pos)                     /*!< 0x00000100 */
N#define CAN_IER_EWGIE          CAN_IER_EWGIE_Msk                               /*!<Error Warning Interrupt Enable */
N#define CAN_IER_EPVIE_Pos      (9U)                                            
N#define CAN_IER_EPVIE_Msk      (0x1U << CAN_IER_EPVIE_Pos)                     /*!< 0x00000200 */
N#define CAN_IER_EPVIE          CAN_IER_EPVIE_Msk                               /*!<Error Passive Interrupt Enable */
N#define CAN_IER_BOFIE_Pos      (10U)                                           
N#define CAN_IER_BOFIE_Msk      (0x1U << CAN_IER_BOFIE_Pos)                     /*!< 0x00000400 */
N#define CAN_IER_BOFIE          CAN_IER_BOFIE_Msk                               /*!<Bus-Off Interrupt Enable */
N#define CAN_IER_LECIE_Pos      (11U)                                           
N#define CAN_IER_LECIE_Msk      (0x1U << CAN_IER_LECIE_Pos)                     /*!< 0x00000800 */
N#define CAN_IER_LECIE          CAN_IER_LECIE_Msk                               /*!<Last Error Code Interrupt Enable */
N#define CAN_IER_ERRIE_Pos      (15U)                                           
N#define CAN_IER_ERRIE_Msk      (0x1U << CAN_IER_ERRIE_Pos)                     /*!< 0x00008000 */
N#define CAN_IER_ERRIE          CAN_IER_ERRIE_Msk                               /*!<Error Interrupt Enable */
N#define CAN_IER_WKUIE_Pos      (16U)                                           
N#define CAN_IER_WKUIE_Msk      (0x1U << CAN_IER_WKUIE_Pos)                     /*!< 0x00010000 */
N#define CAN_IER_WKUIE          CAN_IER_WKUIE_Msk                               /*!<Wakeup Interrupt Enable */
N#define CAN_IER_SLKIE_Pos      (17U)                                           
N#define CAN_IER_SLKIE_Msk      (0x1U << CAN_IER_SLKIE_Pos)                     /*!< 0x00020000 */
N#define CAN_IER_SLKIE          CAN_IER_SLKIE_Msk                               /*!<Sleep Interrupt Enable */
N
N/********************  Bit definition for CAN_ESR register  *******************/
N#define CAN_ESR_EWGF_Pos       (0U)                                            
N#define CAN_ESR_EWGF_Msk       (0x1U << CAN_ESR_EWGF_Pos)                      /*!< 0x00000001 */
N#define CAN_ESR_EWGF           CAN_ESR_EWGF_Msk                                /*!<Error Warning Flag */
N#define CAN_ESR_EPVF_Pos       (1U)                                            
N#define CAN_ESR_EPVF_Msk       (0x1U << CAN_ESR_EPVF_Pos)                      /*!< 0x00000002 */
N#define CAN_ESR_EPVF           CAN_ESR_EPVF_Msk                                /*!<Error Passive Flag */
N#define CAN_ESR_BOFF_Pos       (2U)                                            
N#define CAN_ESR_BOFF_Msk       (0x1U << CAN_ESR_BOFF_Pos)                      /*!< 0x00000004 */
N#define CAN_ESR_BOFF           CAN_ESR_BOFF_Msk                                /*!<Bus-Off Flag */
N
N#define CAN_ESR_LEC_Pos        (4U)                                            
N#define CAN_ESR_LEC_Msk        (0x7U << CAN_ESR_LEC_Pos)                       /*!< 0x00000070 */
N#define CAN_ESR_LEC            CAN_ESR_LEC_Msk                                 /*!<LEC[2:0] bits (Last Error Code) */
N#define CAN_ESR_LEC_0          (0x1U << CAN_ESR_LEC_Pos)                       /*!< 0x00000010 */
N#define CAN_ESR_LEC_1          (0x2U << CAN_ESR_LEC_Pos)                       /*!< 0x00000020 */
N#define CAN_ESR_LEC_2          (0x4U << CAN_ESR_LEC_Pos)                       /*!< 0x00000040 */
N
N#define CAN_ESR_TEC_Pos        (16U)                                           
N#define CAN_ESR_TEC_Msk        (0xFFU << CAN_ESR_TEC_Pos)                      /*!< 0x00FF0000 */
N#define CAN_ESR_TEC            CAN_ESR_TEC_Msk                                 /*!<Least significant byte of the 9-bit Transmit Error Counter */
N#define CAN_ESR_REC_Pos        (24U)                                           
N#define CAN_ESR_REC_Msk        (0xFFU << CAN_ESR_REC_Pos)                      /*!< 0xFF000000 */
N#define CAN_ESR_REC            CAN_ESR_REC_Msk                                 /*!<Receive Error Counter */
N
N/*******************  Bit definition for CAN_BTR register  ********************/
N#define CAN_BTR_BRP_Pos        (0U)                                            
N#define CAN_BTR_BRP_Msk        (0x3FFU << CAN_BTR_BRP_Pos)                     /*!< 0x000003FF */
N#define CAN_BTR_BRP            CAN_BTR_BRP_Msk                                 /*!<Baud Rate Prescaler */
N#define CAN_BTR_TS1_Pos        (16U)                                           
N#define CAN_BTR_TS1_Msk        (0xFU << CAN_BTR_TS1_Pos)                       /*!< 0x000F0000 */
N#define CAN_BTR_TS1            CAN_BTR_TS1_Msk                                 /*!<Time Segment 1 */
N#define CAN_BTR_TS1_0          (0x1U << CAN_BTR_TS1_Pos)                       /*!< 0x00010000 */
N#define CAN_BTR_TS1_1          (0x2U << CAN_BTR_TS1_Pos)                       /*!< 0x00020000 */
N#define CAN_BTR_TS1_2          (0x4U << CAN_BTR_TS1_Pos)                       /*!< 0x00040000 */
N#define CAN_BTR_TS1_3          (0x8U << CAN_BTR_TS1_Pos)                       /*!< 0x00080000 */
N#define CAN_BTR_TS2_Pos        (20U)                                           
N#define CAN_BTR_TS2_Msk        (0x7U << CAN_BTR_TS2_Pos)                       /*!< 0x00700000 */
N#define CAN_BTR_TS2            CAN_BTR_TS2_Msk                                 /*!<Time Segment 2 */
N#define CAN_BTR_TS2_0          (0x1U << CAN_BTR_TS2_Pos)                       /*!< 0x00100000 */
N#define CAN_BTR_TS2_1          (0x2U << CAN_BTR_TS2_Pos)                       /*!< 0x00200000 */
N#define CAN_BTR_TS2_2          (0x4U << CAN_BTR_TS2_Pos)                       /*!< 0x00400000 */
N#define CAN_BTR_SJW_Pos        (24U)                                           
N#define CAN_BTR_SJW_Msk        (0x3U << CAN_BTR_SJW_Pos)                       /*!< 0x03000000 */
N#define CAN_BTR_SJW            CAN_BTR_SJW_Msk                                 /*!<Resynchronization Jump Width */
N#define CAN_BTR_SJW_0          (0x1U << CAN_BTR_SJW_Pos)                       /*!< 0x01000000 */
N#define CAN_BTR_SJW_1          (0x2U << CAN_BTR_SJW_Pos)                       /*!< 0x02000000 */
N#define CAN_BTR_LBKM_Pos       (30U)                                           
N#define CAN_BTR_LBKM_Msk       (0x1U << CAN_BTR_LBKM_Pos)                      /*!< 0x40000000 */
N#define CAN_BTR_LBKM           CAN_BTR_LBKM_Msk                                /*!<Loop Back Mode (Debug) */
N#define CAN_BTR_SILM_Pos       (31U)                                           
N#define CAN_BTR_SILM_Msk       (0x1U << CAN_BTR_SILM_Pos)                      /*!< 0x80000000 */
N#define CAN_BTR_SILM           CAN_BTR_SILM_Msk                                /*!<Silent Mode */
N
N/*!<Mailbox registers */
N/******************  Bit definition for CAN_TI0R register  ********************/
N#define CAN_TI0R_TXRQ_Pos      (0U)                                            
N#define CAN_TI0R_TXRQ_Msk      (0x1U << CAN_TI0R_TXRQ_Pos)                     /*!< 0x00000001 */
N#define CAN_TI0R_TXRQ          CAN_TI0R_TXRQ_Msk                               /*!<Transmit Mailbox Request */
N#define CAN_TI0R_RTR_Pos       (1U)                                            
N#define CAN_TI0R_RTR_Msk       (0x1U << CAN_TI0R_RTR_Pos)                      /*!< 0x00000002 */
N#define CAN_TI0R_RTR           CAN_TI0R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_TI0R_IDE_Pos       (2U)                                            
N#define CAN_TI0R_IDE_Msk       (0x1U << CAN_TI0R_IDE_Pos)                      /*!< 0x00000004 */
N#define CAN_TI0R_IDE           CAN_TI0R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_TI0R_EXID_Pos      (3U)                                            
N#define CAN_TI0R_EXID_Msk      (0x3FFFFU << CAN_TI0R_EXID_Pos)                 /*!< 0x001FFFF8 */
N#define CAN_TI0R_EXID          CAN_TI0R_EXID_Msk                               /*!<Extended Identifier */
N#define CAN_TI0R_STID_Pos      (21U)                                           
N#define CAN_TI0R_STID_Msk      (0x7FFU << CAN_TI0R_STID_Pos)                   /*!< 0xFFE00000 */
N#define CAN_TI0R_STID          CAN_TI0R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/******************  Bit definition for CAN_TDT0R register  *******************/
N#define CAN_TDT0R_DLC_Pos      (0U)                                            
N#define CAN_TDT0R_DLC_Msk      (0xFU << CAN_TDT0R_DLC_Pos)                     /*!< 0x0000000F */
N#define CAN_TDT0R_DLC          CAN_TDT0R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_TDT0R_TGT_Pos      (8U)                                            
N#define CAN_TDT0R_TGT_Msk      (0x1U << CAN_TDT0R_TGT_Pos)                     /*!< 0x00000100 */
N#define CAN_TDT0R_TGT          CAN_TDT0R_TGT_Msk                               /*!<Transmit Global Time */
N#define CAN_TDT0R_TIME_Pos     (16U)                                           
N#define CAN_TDT0R_TIME_Msk     (0xFFFFU << CAN_TDT0R_TIME_Pos)                 /*!< 0xFFFF0000 */
N#define CAN_TDT0R_TIME         CAN_TDT0R_TIME_Msk                              /*!<Message Time Stamp */
N
N/******************  Bit definition for CAN_TDL0R register  *******************/
N#define CAN_TDL0R_DATA0_Pos    (0U)                                            
N#define CAN_TDL0R_DATA0_Msk    (0xFFU << CAN_TDL0R_DATA0_Pos)                  /*!< 0x000000FF */
N#define CAN_TDL0R_DATA0        CAN_TDL0R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_TDL0R_DATA1_Pos    (8U)                                            
N#define CAN_TDL0R_DATA1_Msk    (0xFFU << CAN_TDL0R_DATA1_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDL0R_DATA1        CAN_TDL0R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_TDL0R_DATA2_Pos    (16U)                                           
N#define CAN_TDL0R_DATA2_Msk    (0xFFU << CAN_TDL0R_DATA2_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDL0R_DATA2        CAN_TDL0R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_TDL0R_DATA3_Pos    (24U)                                           
N#define CAN_TDL0R_DATA3_Msk    (0xFFU << CAN_TDL0R_DATA3_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDL0R_DATA3        CAN_TDL0R_DATA3_Msk                             /*!<Data byte 3 */
N
N/******************  Bit definition for CAN_TDH0R register  *******************/
N#define CAN_TDH0R_DATA4_Pos    (0U)                                            
N#define CAN_TDH0R_DATA4_Msk    (0xFFU << CAN_TDH0R_DATA4_Pos)                  /*!< 0x000000FF */
N#define CAN_TDH0R_DATA4        CAN_TDH0R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_TDH0R_DATA5_Pos    (8U)                                            
N#define CAN_TDH0R_DATA5_Msk    (0xFFU << CAN_TDH0R_DATA5_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDH0R_DATA5        CAN_TDH0R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_TDH0R_DATA6_Pos    (16U)                                           
N#define CAN_TDH0R_DATA6_Msk    (0xFFU << CAN_TDH0R_DATA6_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDH0R_DATA6        CAN_TDH0R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_TDH0R_DATA7_Pos    (24U)                                           
N#define CAN_TDH0R_DATA7_Msk    (0xFFU << CAN_TDH0R_DATA7_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDH0R_DATA7        CAN_TDH0R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI1R register  *******************/
N#define CAN_TI1R_TXRQ_Pos      (0U)                                            
N#define CAN_TI1R_TXRQ_Msk      (0x1U << CAN_TI1R_TXRQ_Pos)                     /*!< 0x00000001 */
N#define CAN_TI1R_TXRQ          CAN_TI1R_TXRQ_Msk                               /*!<Transmit Mailbox Request */
N#define CAN_TI1R_RTR_Pos       (1U)                                            
N#define CAN_TI1R_RTR_Msk       (0x1U << CAN_TI1R_RTR_Pos)                      /*!< 0x00000002 */
N#define CAN_TI1R_RTR           CAN_TI1R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_TI1R_IDE_Pos       (2U)                                            
N#define CAN_TI1R_IDE_Msk       (0x1U << CAN_TI1R_IDE_Pos)                      /*!< 0x00000004 */
N#define CAN_TI1R_IDE           CAN_TI1R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_TI1R_EXID_Pos      (3U)                                            
N#define CAN_TI1R_EXID_Msk      (0x3FFFFU << CAN_TI1R_EXID_Pos)                 /*!< 0x001FFFF8 */
N#define CAN_TI1R_EXID          CAN_TI1R_EXID_Msk                               /*!<Extended Identifier */
N#define CAN_TI1R_STID_Pos      (21U)                                           
N#define CAN_TI1R_STID_Msk      (0x7FFU << CAN_TI1R_STID_Pos)                   /*!< 0xFFE00000 */
N#define CAN_TI1R_STID          CAN_TI1R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT1R register  ******************/
N#define CAN_TDT1R_DLC_Pos      (0U)                                            
N#define CAN_TDT1R_DLC_Msk      (0xFU << CAN_TDT1R_DLC_Pos)                     /*!< 0x0000000F */
N#define CAN_TDT1R_DLC          CAN_TDT1R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_TDT1R_TGT_Pos      (8U)                                            
N#define CAN_TDT1R_TGT_Msk      (0x1U << CAN_TDT1R_TGT_Pos)                     /*!< 0x00000100 */
N#define CAN_TDT1R_TGT          CAN_TDT1R_TGT_Msk                               /*!<Transmit Global Time */
N#define CAN_TDT1R_TIME_Pos     (16U)                                           
N#define CAN_TDT1R_TIME_Msk     (0xFFFFU << CAN_TDT1R_TIME_Pos)                 /*!< 0xFFFF0000 */
N#define CAN_TDT1R_TIME         CAN_TDT1R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL1R register  ******************/
N#define CAN_TDL1R_DATA0_Pos    (0U)                                            
N#define CAN_TDL1R_DATA0_Msk    (0xFFU << CAN_TDL1R_DATA0_Pos)                  /*!< 0x000000FF */
N#define CAN_TDL1R_DATA0        CAN_TDL1R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_TDL1R_DATA1_Pos    (8U)                                            
N#define CAN_TDL1R_DATA1_Msk    (0xFFU << CAN_TDL1R_DATA1_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDL1R_DATA1        CAN_TDL1R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_TDL1R_DATA2_Pos    (16U)                                           
N#define CAN_TDL1R_DATA2_Msk    (0xFFU << CAN_TDL1R_DATA2_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDL1R_DATA2        CAN_TDL1R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_TDL1R_DATA3_Pos    (24U)                                           
N#define CAN_TDL1R_DATA3_Msk    (0xFFU << CAN_TDL1R_DATA3_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDL1R_DATA3        CAN_TDL1R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH1R register  ******************/
N#define CAN_TDH1R_DATA4_Pos    (0U)                                            
N#define CAN_TDH1R_DATA4_Msk    (0xFFU << CAN_TDH1R_DATA4_Pos)                  /*!< 0x000000FF */
N#define CAN_TDH1R_DATA4        CAN_TDH1R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_TDH1R_DATA5_Pos    (8U)                                            
N#define CAN_TDH1R_DATA5_Msk    (0xFFU << CAN_TDH1R_DATA5_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDH1R_DATA5        CAN_TDH1R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_TDH1R_DATA6_Pos    (16U)                                           
N#define CAN_TDH1R_DATA6_Msk    (0xFFU << CAN_TDH1R_DATA6_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDH1R_DATA6        CAN_TDH1R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_TDH1R_DATA7_Pos    (24U)                                           
N#define CAN_TDH1R_DATA7_Msk    (0xFFU << CAN_TDH1R_DATA7_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDH1R_DATA7        CAN_TDH1R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI2R register  *******************/
N#define CAN_TI2R_TXRQ_Pos      (0U)                                            
N#define CAN_TI2R_TXRQ_Msk      (0x1U << CAN_TI2R_TXRQ_Pos)                     /*!< 0x00000001 */
N#define CAN_TI2R_TXRQ          CAN_TI2R_TXRQ_Msk                               /*!<Transmit Mailbox Request */
N#define CAN_TI2R_RTR_Pos       (1U)                                            
N#define CAN_TI2R_RTR_Msk       (0x1U << CAN_TI2R_RTR_Pos)                      /*!< 0x00000002 */
N#define CAN_TI2R_RTR           CAN_TI2R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_TI2R_IDE_Pos       (2U)                                            
N#define CAN_TI2R_IDE_Msk       (0x1U << CAN_TI2R_IDE_Pos)                      /*!< 0x00000004 */
N#define CAN_TI2R_IDE           CAN_TI2R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_TI2R_EXID_Pos      (3U)                                            
N#define CAN_TI2R_EXID_Msk      (0x3FFFFU << CAN_TI2R_EXID_Pos)                 /*!< 0x001FFFF8 */
N#define CAN_TI2R_EXID          CAN_TI2R_EXID_Msk                               /*!<Extended identifier */
N#define CAN_TI2R_STID_Pos      (21U)                                           
N#define CAN_TI2R_STID_Msk      (0x7FFU << CAN_TI2R_STID_Pos)                   /*!< 0xFFE00000 */
N#define CAN_TI2R_STID          CAN_TI2R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT2R register  ******************/
N#define CAN_TDT2R_DLC_Pos      (0U)                                            
N#define CAN_TDT2R_DLC_Msk      (0xFU << CAN_TDT2R_DLC_Pos)                     /*!< 0x0000000F */
N#define CAN_TDT2R_DLC          CAN_TDT2R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_TDT2R_TGT_Pos      (8U)                                            
N#define CAN_TDT2R_TGT_Msk      (0x1U << CAN_TDT2R_TGT_Pos)                     /*!< 0x00000100 */
N#define CAN_TDT2R_TGT          CAN_TDT2R_TGT_Msk                               /*!<Transmit Global Time */
N#define CAN_TDT2R_TIME_Pos     (16U)                                           
N#define CAN_TDT2R_TIME_Msk     (0xFFFFU << CAN_TDT2R_TIME_Pos)                 /*!< 0xFFFF0000 */
N#define CAN_TDT2R_TIME         CAN_TDT2R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL2R register  ******************/
N#define CAN_TDL2R_DATA0_Pos    (0U)                                            
N#define CAN_TDL2R_DATA0_Msk    (0xFFU << CAN_TDL2R_DATA0_Pos)                  /*!< 0x000000FF */
N#define CAN_TDL2R_DATA0        CAN_TDL2R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_TDL2R_DATA1_Pos    (8U)                                            
N#define CAN_TDL2R_DATA1_Msk    (0xFFU << CAN_TDL2R_DATA1_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDL2R_DATA1        CAN_TDL2R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_TDL2R_DATA2_Pos    (16U)                                           
N#define CAN_TDL2R_DATA2_Msk    (0xFFU << CAN_TDL2R_DATA2_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDL2R_DATA2        CAN_TDL2R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_TDL2R_DATA3_Pos    (24U)                                           
N#define CAN_TDL2R_DATA3_Msk    (0xFFU << CAN_TDL2R_DATA3_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDL2R_DATA3        CAN_TDL2R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH2R register  ******************/
N#define CAN_TDH2R_DATA4_Pos    (0U)                                            
N#define CAN_TDH2R_DATA4_Msk    (0xFFU << CAN_TDH2R_DATA4_Pos)                  /*!< 0x000000FF */
N#define CAN_TDH2R_DATA4        CAN_TDH2R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_TDH2R_DATA5_Pos    (8U)                                            
N#define CAN_TDH2R_DATA5_Msk    (0xFFU << CAN_TDH2R_DATA5_Pos)                  /*!< 0x0000FF00 */
N#define CAN_TDH2R_DATA5        CAN_TDH2R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_TDH2R_DATA6_Pos    (16U)                                           
N#define CAN_TDH2R_DATA6_Msk    (0xFFU << CAN_TDH2R_DATA6_Pos)                  /*!< 0x00FF0000 */
N#define CAN_TDH2R_DATA6        CAN_TDH2R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_TDH2R_DATA7_Pos    (24U)                                           
N#define CAN_TDH2R_DATA7_Msk    (0xFFU << CAN_TDH2R_DATA7_Pos)                  /*!< 0xFF000000 */
N#define CAN_TDH2R_DATA7        CAN_TDH2R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI0R register  *******************/
N#define CAN_RI0R_RTR_Pos       (1U)                                            
N#define CAN_RI0R_RTR_Msk       (0x1U << CAN_RI0R_RTR_Pos)                      /*!< 0x00000002 */
N#define CAN_RI0R_RTR           CAN_RI0R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_RI0R_IDE_Pos       (2U)                                            
N#define CAN_RI0R_IDE_Msk       (0x1U << CAN_RI0R_IDE_Pos)                      /*!< 0x00000004 */
N#define CAN_RI0R_IDE           CAN_RI0R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_RI0R_EXID_Pos      (3U)                                            
N#define CAN_RI0R_EXID_Msk      (0x3FFFFU << CAN_RI0R_EXID_Pos)                 /*!< 0x001FFFF8 */
N#define CAN_RI0R_EXID          CAN_RI0R_EXID_Msk                               /*!<Extended Identifier */
N#define CAN_RI0R_STID_Pos      (21U)                                           
N#define CAN_RI0R_STID_Msk      (0x7FFU << CAN_RI0R_STID_Pos)                   /*!< 0xFFE00000 */
N#define CAN_RI0R_STID          CAN_RI0R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT0R register  ******************/
N#define CAN_RDT0R_DLC_Pos      (0U)                                            
N#define CAN_RDT0R_DLC_Msk      (0xFU << CAN_RDT0R_DLC_Pos)                     /*!< 0x0000000F */
N#define CAN_RDT0R_DLC          CAN_RDT0R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_RDT0R_FMI_Pos      (8U)                                            
N#define CAN_RDT0R_FMI_Msk      (0xFFU << CAN_RDT0R_FMI_Pos)                    /*!< 0x0000FF00 */
N#define CAN_RDT0R_FMI          CAN_RDT0R_FMI_Msk                               /*!<Filter Match Index */
N#define CAN_RDT0R_TIME_Pos     (16U)                                           
N#define CAN_RDT0R_TIME_Msk     (0xFFFFU << CAN_RDT0R_TIME_Pos)                 /*!< 0xFFFF0000 */
N#define CAN_RDT0R_TIME         CAN_RDT0R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL0R register  ******************/
N#define CAN_RDL0R_DATA0_Pos    (0U)                                            
N#define CAN_RDL0R_DATA0_Msk    (0xFFU << CAN_RDL0R_DATA0_Pos)                  /*!< 0x000000FF */
N#define CAN_RDL0R_DATA0        CAN_RDL0R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_RDL0R_DATA1_Pos    (8U)                                            
N#define CAN_RDL0R_DATA1_Msk    (0xFFU << CAN_RDL0R_DATA1_Pos)                  /*!< 0x0000FF00 */
N#define CAN_RDL0R_DATA1        CAN_RDL0R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_RDL0R_DATA2_Pos    (16U)                                           
N#define CAN_RDL0R_DATA2_Msk    (0xFFU << CAN_RDL0R_DATA2_Pos)                  /*!< 0x00FF0000 */
N#define CAN_RDL0R_DATA2        CAN_RDL0R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_RDL0R_DATA3_Pos    (24U)                                           
N#define CAN_RDL0R_DATA3_Msk    (0xFFU << CAN_RDL0R_DATA3_Pos)                  /*!< 0xFF000000 */
N#define CAN_RDL0R_DATA3        CAN_RDL0R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH0R register  ******************/
N#define CAN_RDH0R_DATA4_Pos    (0U)                                            
N#define CAN_RDH0R_DATA4_Msk    (0xFFU << CAN_RDH0R_DATA4_Pos)                  /*!< 0x000000FF */
N#define CAN_RDH0R_DATA4        CAN_RDH0R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_RDH0R_DATA5_Pos    (8U)                                            
N#define CAN_RDH0R_DATA5_Msk    (0xFFU << CAN_RDH0R_DATA5_Pos)                  /*!< 0x0000FF00 */
N#define CAN_RDH0R_DATA5        CAN_RDH0R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_RDH0R_DATA6_Pos    (16U)                                           
N#define CAN_RDH0R_DATA6_Msk    (0xFFU << CAN_RDH0R_DATA6_Pos)                  /*!< 0x00FF0000 */
N#define CAN_RDH0R_DATA6        CAN_RDH0R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_RDH0R_DATA7_Pos    (24U)                                           
N#define CAN_RDH0R_DATA7_Msk    (0xFFU << CAN_RDH0R_DATA7_Pos)                  /*!< 0xFF000000 */
N#define CAN_RDH0R_DATA7        CAN_RDH0R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI1R register  *******************/
N#define CAN_RI1R_RTR_Pos       (1U)                                            
N#define CAN_RI1R_RTR_Msk       (0x1U << CAN_RI1R_RTR_Pos)                      /*!< 0x00000002 */
N#define CAN_RI1R_RTR           CAN_RI1R_RTR_Msk                                /*!<Remote Transmission Request */
N#define CAN_RI1R_IDE_Pos       (2U)                                            
N#define CAN_RI1R_IDE_Msk       (0x1U << CAN_RI1R_IDE_Pos)                      /*!< 0x00000004 */
N#define CAN_RI1R_IDE           CAN_RI1R_IDE_Msk                                /*!<Identifier Extension */
N#define CAN_RI1R_EXID_Pos      (3U)                                            
N#define CAN_RI1R_EXID_Msk      (0x3FFFFU << CAN_RI1R_EXID_Pos)                 /*!< 0x001FFFF8 */
N#define CAN_RI1R_EXID          CAN_RI1R_EXID_Msk                               /*!<Extended identifier */
N#define CAN_RI1R_STID_Pos      (21U)                                           
N#define CAN_RI1R_STID_Msk      (0x7FFU << CAN_RI1R_STID_Pos)                   /*!< 0xFFE00000 */
N#define CAN_RI1R_STID          CAN_RI1R_STID_Msk                               /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT1R register  ******************/
N#define CAN_RDT1R_DLC_Pos      (0U)                                            
N#define CAN_RDT1R_DLC_Msk      (0xFU << CAN_RDT1R_DLC_Pos)                     /*!< 0x0000000F */
N#define CAN_RDT1R_DLC          CAN_RDT1R_DLC_Msk                               /*!<Data Length Code */
N#define CAN_RDT1R_FMI_Pos      (8U)                                            
N#define CAN_RDT1R_FMI_Msk      (0xFFU << CAN_RDT1R_FMI_Pos)                    /*!< 0x0000FF00 */
N#define CAN_RDT1R_FMI          CAN_RDT1R_FMI_Msk                               /*!<Filter Match Index */
N#define CAN_RDT1R_TIME_Pos     (16U)                                           
N#define CAN_RDT1R_TIME_Msk     (0xFFFFU << CAN_RDT1R_TIME_Pos)                 /*!< 0xFFFF0000 */
N#define CAN_RDT1R_TIME         CAN_RDT1R_TIME_Msk                              /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL1R register  ******************/
N#define CAN_RDL1R_DATA0_Pos    (0U)                                            
N#define CAN_RDL1R_DATA0_Msk    (0xFFU << CAN_RDL1R_DATA0_Pos)                  /*!< 0x000000FF */
N#define CAN_RDL1R_DATA0        CAN_RDL1R_DATA0_Msk                             /*!<Data byte 0 */
N#define CAN_RDL1R_DATA1_Pos    (8U)                                            
N#define CAN_RDL1R_DATA1_Msk    (0xFFU << CAN_RDL1R_DATA1_Pos)                  /*!< 0x0000FF00 */
N#define CAN_RDL1R_DATA1        CAN_RDL1R_DATA1_Msk                             /*!<Data byte 1 */
N#define CAN_RDL1R_DATA2_Pos    (16U)                                           
N#define CAN_RDL1R_DATA2_Msk    (0xFFU << CAN_RDL1R_DATA2_Pos)                  /*!< 0x00FF0000 */
N#define CAN_RDL1R_DATA2        CAN_RDL1R_DATA2_Msk                             /*!<Data byte 2 */
N#define CAN_RDL1R_DATA3_Pos    (24U)                                           
N#define CAN_RDL1R_DATA3_Msk    (0xFFU << CAN_RDL1R_DATA3_Pos)                  /*!< 0xFF000000 */
N#define CAN_RDL1R_DATA3        CAN_RDL1R_DATA3_Msk                             /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH1R register  ******************/
N#define CAN_RDH1R_DATA4_Pos    (0U)                                            
N#define CAN_RDH1R_DATA4_Msk    (0xFFU << CAN_RDH1R_DATA4_Pos)                  /*!< 0x000000FF */
N#define CAN_RDH1R_DATA4        CAN_RDH1R_DATA4_Msk                             /*!<Data byte 4 */
N#define CAN_RDH1R_DATA5_Pos    (8U)                                            
N#define CAN_RDH1R_DATA5_Msk    (0xFFU << CAN_RDH1R_DATA5_Pos)                  /*!< 0x0000FF00 */
N#define CAN_RDH1R_DATA5        CAN_RDH1R_DATA5_Msk                             /*!<Data byte 5 */
N#define CAN_RDH1R_DATA6_Pos    (16U)                                           
N#define CAN_RDH1R_DATA6_Msk    (0xFFU << CAN_RDH1R_DATA6_Pos)                  /*!< 0x00FF0000 */
N#define CAN_RDH1R_DATA6        CAN_RDH1R_DATA6_Msk                             /*!<Data byte 6 */
N#define CAN_RDH1R_DATA7_Pos    (24U)                                           
N#define CAN_RDH1R_DATA7_Msk    (0xFFU << CAN_RDH1R_DATA7_Pos)                  /*!< 0xFF000000 */
N#define CAN_RDH1R_DATA7        CAN_RDH1R_DATA7_Msk                             /*!<Data byte 7 */
N
N/*!<CAN filter registers */
N/*******************  Bit definition for CAN_FMR register  ********************/
N#define CAN_FMR_FINIT_Pos      (0U)                                            
N#define CAN_FMR_FINIT_Msk      (0x1U << CAN_FMR_FINIT_Pos)                     /*!< 0x00000001 */
N#define CAN_FMR_FINIT          CAN_FMR_FINIT_Msk                               /*!<Filter Init Mode */
N#define CAN_FMR_CAN2SB_Pos     (8U)                                            
N#define CAN_FMR_CAN2SB_Msk     (0x3FU << CAN_FMR_CAN2SB_Pos)                   /*!< 0x00003F00 */
N#define CAN_FMR_CAN2SB         CAN_FMR_CAN2SB_Msk                              /*!<CAN2 start bank */
N
N/*******************  Bit definition for CAN_FM1R register  *******************/
N#define CAN_FM1R_FBM_Pos       (0U)                                            
N#define CAN_FM1R_FBM_Msk       (0xFFFFFFFU << CAN_FM1R_FBM_Pos)                /*!< 0x0FFFFFFF */
N#define CAN_FM1R_FBM           CAN_FM1R_FBM_Msk                                /*!<Filter Mode */
N#define CAN_FM1R_FBM0_Pos      (0U)                                            
N#define CAN_FM1R_FBM0_Msk      (0x1U << CAN_FM1R_FBM0_Pos)                     /*!< 0x00000001 */
N#define CAN_FM1R_FBM0          CAN_FM1R_FBM0_Msk                               /*!<Filter Init Mode bit 0 */
N#define CAN_FM1R_FBM1_Pos      (1U)                                            
N#define CAN_FM1R_FBM1_Msk      (0x1U << CAN_FM1R_FBM1_Pos)                     /*!< 0x00000002 */
N#define CAN_FM1R_FBM1          CAN_FM1R_FBM1_Msk                               /*!<Filter Init Mode bit 1 */
N#define CAN_FM1R_FBM2_Pos      (2U)                                            
N#define CAN_FM1R_FBM2_Msk      (0x1U << CAN_FM1R_FBM2_Pos)                     /*!< 0x00000004 */
N#define CAN_FM1R_FBM2          CAN_FM1R_FBM2_Msk                               /*!<Filter Init Mode bit 2 */
N#define CAN_FM1R_FBM3_Pos      (3U)                                            
N#define CAN_FM1R_FBM3_Msk      (0x1U << CAN_FM1R_FBM3_Pos)                     /*!< 0x00000008 */
N#define CAN_FM1R_FBM3          CAN_FM1R_FBM3_Msk                               /*!<Filter Init Mode bit 3 */
N#define CAN_FM1R_FBM4_Pos      (4U)                                            
N#define CAN_FM1R_FBM4_Msk      (0x1U << CAN_FM1R_FBM4_Pos)                     /*!< 0x00000010 */
N#define CAN_FM1R_FBM4          CAN_FM1R_FBM4_Msk                               /*!<Filter Init Mode bit 4 */
N#define CAN_FM1R_FBM5_Pos      (5U)                                            
N#define CAN_FM1R_FBM5_Msk      (0x1U << CAN_FM1R_FBM5_Pos)                     /*!< 0x00000020 */
N#define CAN_FM1R_FBM5          CAN_FM1R_FBM5_Msk                               /*!<Filter Init Mode bit 5 */
N#define CAN_FM1R_FBM6_Pos      (6U)                                            
N#define CAN_FM1R_FBM6_Msk      (0x1U << CAN_FM1R_FBM6_Pos)                     /*!< 0x00000040 */
N#define CAN_FM1R_FBM6          CAN_FM1R_FBM6_Msk                               /*!<Filter Init Mode bit 6 */
N#define CAN_FM1R_FBM7_Pos      (7U)                                            
N#define CAN_FM1R_FBM7_Msk      (0x1U << CAN_FM1R_FBM7_Pos)                     /*!< 0x00000080 */
N#define CAN_FM1R_FBM7          CAN_FM1R_FBM7_Msk                               /*!<Filter Init Mode bit 7 */
N#define CAN_FM1R_FBM8_Pos      (8U)                                            
N#define CAN_FM1R_FBM8_Msk      (0x1U << CAN_FM1R_FBM8_Pos)                     /*!< 0x00000100 */
N#define CAN_FM1R_FBM8          CAN_FM1R_FBM8_Msk                               /*!<Filter Init Mode bit 8 */
N#define CAN_FM1R_FBM9_Pos      (9U)                                            
N#define CAN_FM1R_FBM9_Msk      (0x1U << CAN_FM1R_FBM9_Pos)                     /*!< 0x00000200 */
N#define CAN_FM1R_FBM9          CAN_FM1R_FBM9_Msk                               /*!<Filter Init Mode bit 9 */
N#define CAN_FM1R_FBM10_Pos     (10U)                                           
N#define CAN_FM1R_FBM10_Msk     (0x1U << CAN_FM1R_FBM10_Pos)                    /*!< 0x00000400 */
N#define CAN_FM1R_FBM10         CAN_FM1R_FBM10_Msk                              /*!<Filter Init Mode bit 10 */
N#define CAN_FM1R_FBM11_Pos     (11U)                                           
N#define CAN_FM1R_FBM11_Msk     (0x1U << CAN_FM1R_FBM11_Pos)                    /*!< 0x00000800 */
N#define CAN_FM1R_FBM11         CAN_FM1R_FBM11_Msk                              /*!<Filter Init Mode bit 11 */
N#define CAN_FM1R_FBM12_Pos     (12U)                                           
N#define CAN_FM1R_FBM12_Msk     (0x1U << CAN_FM1R_FBM12_Pos)                    /*!< 0x00001000 */
N#define CAN_FM1R_FBM12         CAN_FM1R_FBM12_Msk                              /*!<Filter Init Mode bit 12 */
N#define CAN_FM1R_FBM13_Pos     (13U)                                           
N#define CAN_FM1R_FBM13_Msk     (0x1U << CAN_FM1R_FBM13_Pos)                    /*!< 0x00002000 */
N#define CAN_FM1R_FBM13         CAN_FM1R_FBM13_Msk                              /*!<Filter Init Mode bit 13 */
N#define CAN_FM1R_FBM14_Pos     (14U)                                           
N#define CAN_FM1R_FBM14_Msk     (0x1U << CAN_FM1R_FBM14_Pos)                    /*!< 0x00004000 */
N#define CAN_FM1R_FBM14         CAN_FM1R_FBM14_Msk                              /*!<Filter Init Mode bit 14 */
N#define CAN_FM1R_FBM15_Pos     (15U)                                           
N#define CAN_FM1R_FBM15_Msk     (0x1U << CAN_FM1R_FBM15_Pos)                    /*!< 0x00008000 */
N#define CAN_FM1R_FBM15         CAN_FM1R_FBM15_Msk                              /*!<Filter Init Mode bit 15 */
N#define CAN_FM1R_FBM16_Pos     (16U)                                           
N#define CAN_FM1R_FBM16_Msk     (0x1U << CAN_FM1R_FBM16_Pos)                    /*!< 0x00010000 */
N#define CAN_FM1R_FBM16         CAN_FM1R_FBM16_Msk                              /*!<Filter Init Mode bit 16 */
N#define CAN_FM1R_FBM17_Pos     (17U)                                           
N#define CAN_FM1R_FBM17_Msk     (0x1U << CAN_FM1R_FBM17_Pos)                    /*!< 0x00020000 */
N#define CAN_FM1R_FBM17         CAN_FM1R_FBM17_Msk                              /*!<Filter Init Mode bit 17 */
N#define CAN_FM1R_FBM18_Pos     (18U)                                           
N#define CAN_FM1R_FBM18_Msk     (0x1U << CAN_FM1R_FBM18_Pos)                    /*!< 0x00040000 */
N#define CAN_FM1R_FBM18         CAN_FM1R_FBM18_Msk                              /*!<Filter Init Mode bit 18 */
N#define CAN_FM1R_FBM19_Pos     (19U)                                           
N#define CAN_FM1R_FBM19_Msk     (0x1U << CAN_FM1R_FBM19_Pos)                    /*!< 0x00080000 */
N#define CAN_FM1R_FBM19         CAN_FM1R_FBM19_Msk                              /*!<Filter Init Mode bit 19 */
N#define CAN_FM1R_FBM20_Pos     (20U)                                           
N#define CAN_FM1R_FBM20_Msk     (0x1U << CAN_FM1R_FBM20_Pos)                    /*!< 0x00100000 */
N#define CAN_FM1R_FBM20         CAN_FM1R_FBM20_Msk                              /*!<Filter Init Mode bit 20 */
N#define CAN_FM1R_FBM21_Pos     (21U)                                           
N#define CAN_FM1R_FBM21_Msk     (0x1U << CAN_FM1R_FBM21_Pos)                    /*!< 0x00200000 */
N#define CAN_FM1R_FBM21         CAN_FM1R_FBM21_Msk                              /*!<Filter Init Mode bit 21 */
N#define CAN_FM1R_FBM22_Pos     (22U)                                           
N#define CAN_FM1R_FBM22_Msk     (0x1U << CAN_FM1R_FBM22_Pos)                    /*!< 0x00400000 */
N#define CAN_FM1R_FBM22         CAN_FM1R_FBM22_Msk                              /*!<Filter Init Mode bit 22 */
N#define CAN_FM1R_FBM23_Pos     (23U)                                           
N#define CAN_FM1R_FBM23_Msk     (0x1U << CAN_FM1R_FBM23_Pos)                    /*!< 0x00800000 */
N#define CAN_FM1R_FBM23         CAN_FM1R_FBM23_Msk                              /*!<Filter Init Mode bit 23 */
N#define CAN_FM1R_FBM24_Pos     (24U)                                           
N#define CAN_FM1R_FBM24_Msk     (0x1U << CAN_FM1R_FBM24_Pos)                    /*!< 0x01000000 */
N#define CAN_FM1R_FBM24         CAN_FM1R_FBM24_Msk                              /*!<Filter Init Mode bit 24 */
N#define CAN_FM1R_FBM25_Pos     (25U)                                           
N#define CAN_FM1R_FBM25_Msk     (0x1U << CAN_FM1R_FBM25_Pos)                    /*!< 0x02000000 */
N#define CAN_FM1R_FBM25         CAN_FM1R_FBM25_Msk                              /*!<Filter Init Mode bit 25 */
N#define CAN_FM1R_FBM26_Pos     (26U)                                           
N#define CAN_FM1R_FBM26_Msk     (0x1U << CAN_FM1R_FBM26_Pos)                    /*!< 0x04000000 */
N#define CAN_FM1R_FBM26         CAN_FM1R_FBM26_Msk                              /*!<Filter Init Mode bit 26 */
N#define CAN_FM1R_FBM27_Pos     (27U)                                           
N#define CAN_FM1R_FBM27_Msk     (0x1U << CAN_FM1R_FBM27_Pos)                    /*!< 0x08000000 */
N#define CAN_FM1R_FBM27         CAN_FM1R_FBM27_Msk                              /*!<Filter Init Mode bit 27 */
N
N/*******************  Bit definition for CAN_FS1R register  *******************/
N#define CAN_FS1R_FSC_Pos       (0U)                                            
N#define CAN_FS1R_FSC_Msk       (0xFFFFFFFU << CAN_FS1R_FSC_Pos)                /*!< 0x0FFFFFFF */
N#define CAN_FS1R_FSC           CAN_FS1R_FSC_Msk                                /*!<Filter Scale Configuration */
N#define CAN_FS1R_FSC0_Pos      (0U)                                            
N#define CAN_FS1R_FSC0_Msk      (0x1U << CAN_FS1R_FSC0_Pos)                     /*!< 0x00000001 */
N#define CAN_FS1R_FSC0          CAN_FS1R_FSC0_Msk                               /*!<Filter Scale Configuration bit 0 */
N#define CAN_FS1R_FSC1_Pos      (1U)                                            
N#define CAN_FS1R_FSC1_Msk      (0x1U << CAN_FS1R_FSC1_Pos)                     /*!< 0x00000002 */
N#define CAN_FS1R_FSC1          CAN_FS1R_FSC1_Msk                               /*!<Filter Scale Configuration bit 1 */
N#define CAN_FS1R_FSC2_Pos      (2U)                                            
N#define CAN_FS1R_FSC2_Msk      (0x1U << CAN_FS1R_FSC2_Pos)                     /*!< 0x00000004 */
N#define CAN_FS1R_FSC2          CAN_FS1R_FSC2_Msk                               /*!<Filter Scale Configuration bit 2 */
N#define CAN_FS1R_FSC3_Pos      (3U)                                            
N#define CAN_FS1R_FSC3_Msk      (0x1U << CAN_FS1R_FSC3_Pos)                     /*!< 0x00000008 */
N#define CAN_FS1R_FSC3          CAN_FS1R_FSC3_Msk                               /*!<Filter Scale Configuration bit 3 */
N#define CAN_FS1R_FSC4_Pos      (4U)                                            
N#define CAN_FS1R_FSC4_Msk      (0x1U << CAN_FS1R_FSC4_Pos)                     /*!< 0x00000010 */
N#define CAN_FS1R_FSC4          CAN_FS1R_FSC4_Msk                               /*!<Filter Scale Configuration bit 4 */
N#define CAN_FS1R_FSC5_Pos      (5U)                                            
N#define CAN_FS1R_FSC5_Msk      (0x1U << CAN_FS1R_FSC5_Pos)                     /*!< 0x00000020 */
N#define CAN_FS1R_FSC5          CAN_FS1R_FSC5_Msk                               /*!<Filter Scale Configuration bit 5 */
N#define CAN_FS1R_FSC6_Pos      (6U)                                            
N#define CAN_FS1R_FSC6_Msk      (0x1U << CAN_FS1R_FSC6_Pos)                     /*!< 0x00000040 */
N#define CAN_FS1R_FSC6          CAN_FS1R_FSC6_Msk                               /*!<Filter Scale Configuration bit 6 */
N#define CAN_FS1R_FSC7_Pos      (7U)                                            
N#define CAN_FS1R_FSC7_Msk      (0x1U << CAN_FS1R_FSC7_Pos)                     /*!< 0x00000080 */
N#define CAN_FS1R_FSC7          CAN_FS1R_FSC7_Msk                               /*!<Filter Scale Configuration bit 7 */
N#define CAN_FS1R_FSC8_Pos      (8U)                                            
N#define CAN_FS1R_FSC8_Msk      (0x1U << CAN_FS1R_FSC8_Pos)                     /*!< 0x00000100 */
N#define CAN_FS1R_FSC8          CAN_FS1R_FSC8_Msk                               /*!<Filter Scale Configuration bit 8 */
N#define CAN_FS1R_FSC9_Pos      (9U)                                            
N#define CAN_FS1R_FSC9_Msk      (0x1U << CAN_FS1R_FSC9_Pos)                     /*!< 0x00000200 */
N#define CAN_FS1R_FSC9          CAN_FS1R_FSC9_Msk                               /*!<Filter Scale Configuration bit 9 */
N#define CAN_FS1R_FSC10_Pos     (10U)                                           
N#define CAN_FS1R_FSC10_Msk     (0x1U << CAN_FS1R_FSC10_Pos)                    /*!< 0x00000400 */
N#define CAN_FS1R_FSC10         CAN_FS1R_FSC10_Msk                              /*!<Filter Scale Configuration bit 10 */
N#define CAN_FS1R_FSC11_Pos     (11U)                                           
N#define CAN_FS1R_FSC11_Msk     (0x1U << CAN_FS1R_FSC11_Pos)                    /*!< 0x00000800 */
N#define CAN_FS1R_FSC11         CAN_FS1R_FSC11_Msk                              /*!<Filter Scale Configuration bit 11 */
N#define CAN_FS1R_FSC12_Pos     (12U)                                           
N#define CAN_FS1R_FSC12_Msk     (0x1U << CAN_FS1R_FSC12_Pos)                    /*!< 0x00001000 */
N#define CAN_FS1R_FSC12         CAN_FS1R_FSC12_Msk                              /*!<Filter Scale Configuration bit 12 */
N#define CAN_FS1R_FSC13_Pos     (13U)                                           
N#define CAN_FS1R_FSC13_Msk     (0x1U << CAN_FS1R_FSC13_Pos)                    /*!< 0x00002000 */
N#define CAN_FS1R_FSC13         CAN_FS1R_FSC13_Msk                              /*!<Filter Scale Configuration bit 13 */
N#define CAN_FS1R_FSC14_Pos     (14U)                                           
N#define CAN_FS1R_FSC14_Msk     (0x1U << CAN_FS1R_FSC14_Pos)                    /*!< 0x00004000 */
N#define CAN_FS1R_FSC14         CAN_FS1R_FSC14_Msk                              /*!<Filter Scale Configuration bit 14 */
N#define CAN_FS1R_FSC15_Pos     (15U)                                           
N#define CAN_FS1R_FSC15_Msk     (0x1U << CAN_FS1R_FSC15_Pos)                    /*!< 0x00008000 */
N#define CAN_FS1R_FSC15         CAN_FS1R_FSC15_Msk                              /*!<Filter Scale Configuration bit 15 */
N#define CAN_FS1R_FSC16_Pos     (16U)                                           
N#define CAN_FS1R_FSC16_Msk     (0x1U << CAN_FS1R_FSC16_Pos)                    /*!< 0x00010000 */
N#define CAN_FS1R_FSC16         CAN_FS1R_FSC16_Msk                              /*!<Filter Scale Configuration bit 16 */
N#define CAN_FS1R_FSC17_Pos     (17U)                                           
N#define CAN_FS1R_FSC17_Msk     (0x1U << CAN_FS1R_FSC17_Pos)                    /*!< 0x00020000 */
N#define CAN_FS1R_FSC17         CAN_FS1R_FSC17_Msk                              /*!<Filter Scale Configuration bit 17 */
N#define CAN_FS1R_FSC18_Pos     (18U)                                           
N#define CAN_FS1R_FSC18_Msk     (0x1U << CAN_FS1R_FSC18_Pos)                    /*!< 0x00040000 */
N#define CAN_FS1R_FSC18         CAN_FS1R_FSC18_Msk                              /*!<Filter Scale Configuration bit 18 */
N#define CAN_FS1R_FSC19_Pos     (19U)                                           
N#define CAN_FS1R_FSC19_Msk     (0x1U << CAN_FS1R_FSC19_Pos)                    /*!< 0x00080000 */
N#define CAN_FS1R_FSC19         CAN_FS1R_FSC19_Msk                              /*!<Filter Scale Configuration bit 19 */
N#define CAN_FS1R_FSC20_Pos     (20U)                                           
N#define CAN_FS1R_FSC20_Msk     (0x1U << CAN_FS1R_FSC20_Pos)                    /*!< 0x00100000 */
N#define CAN_FS1R_FSC20         CAN_FS1R_FSC20_Msk                              /*!<Filter Scale Configuration bit 20 */
N#define CAN_FS1R_FSC21_Pos     (21U)                                           
N#define CAN_FS1R_FSC21_Msk     (0x1U << CAN_FS1R_FSC21_Pos)                    /*!< 0x00200000 */
N#define CAN_FS1R_FSC21         CAN_FS1R_FSC21_Msk                              /*!<Filter Scale Configuration bit 21 */
N#define CAN_FS1R_FSC22_Pos     (22U)                                           
N#define CAN_FS1R_FSC22_Msk     (0x1U << CAN_FS1R_FSC22_Pos)                    /*!< 0x00400000 */
N#define CAN_FS1R_FSC22         CAN_FS1R_FSC22_Msk                              /*!<Filter Scale Configuration bit 22 */
N#define CAN_FS1R_FSC23_Pos     (23U)                                           
N#define CAN_FS1R_FSC23_Msk     (0x1U << CAN_FS1R_FSC23_Pos)                    /*!< 0x00800000 */
N#define CAN_FS1R_FSC23         CAN_FS1R_FSC23_Msk                              /*!<Filter Scale Configuration bit 23 */
N#define CAN_FS1R_FSC24_Pos     (24U)                                           
N#define CAN_FS1R_FSC24_Msk     (0x1U << CAN_FS1R_FSC24_Pos)                    /*!< 0x01000000 */
N#define CAN_FS1R_FSC24         CAN_FS1R_FSC24_Msk                              /*!<Filter Scale Configuration bit 24 */
N#define CAN_FS1R_FSC25_Pos     (25U)                                           
N#define CAN_FS1R_FSC25_Msk     (0x1U << CAN_FS1R_FSC25_Pos)                    /*!< 0x02000000 */
N#define CAN_FS1R_FSC25         CAN_FS1R_FSC25_Msk                              /*!<Filter Scale Configuration bit 25 */
N#define CAN_FS1R_FSC26_Pos     (26U)                                           
N#define CAN_FS1R_FSC26_Msk     (0x1U << CAN_FS1R_FSC26_Pos)                    /*!< 0x04000000 */
N#define CAN_FS1R_FSC26         CAN_FS1R_FSC26_Msk                              /*!<Filter Scale Configuration bit 26 */
N#define CAN_FS1R_FSC27_Pos     (27U)                                           
N#define CAN_FS1R_FSC27_Msk     (0x1U << CAN_FS1R_FSC27_Pos)                    /*!< 0x08000000 */
N#define CAN_FS1R_FSC27         CAN_FS1R_FSC27_Msk                              /*!<Filter Scale Configuration bit 27 */
N
N/******************  Bit definition for CAN_FFA1R register  *******************/
N#define CAN_FFA1R_FFA_Pos      (0U)                                            
N#define CAN_FFA1R_FFA_Msk      (0xFFFFFFFU << CAN_FFA1R_FFA_Pos)               /*!< 0x0FFFFFFF */
N#define CAN_FFA1R_FFA          CAN_FFA1R_FFA_Msk                               /*!<Filter FIFO Assignment */
N#define CAN_FFA1R_FFA0_Pos     (0U)                                            
N#define CAN_FFA1R_FFA0_Msk     (0x1U << CAN_FFA1R_FFA0_Pos)                    /*!< 0x00000001 */
N#define CAN_FFA1R_FFA0         CAN_FFA1R_FFA0_Msk                              /*!<Filter FIFO Assignment bit 0 */
N#define CAN_FFA1R_FFA1_Pos     (1U)                                            
N#define CAN_FFA1R_FFA1_Msk     (0x1U << CAN_FFA1R_FFA1_Pos)                    /*!< 0x00000002 */
N#define CAN_FFA1R_FFA1         CAN_FFA1R_FFA1_Msk                              /*!<Filter FIFO Assignment bit 1 */
N#define CAN_FFA1R_FFA2_Pos     (2U)                                            
N#define CAN_FFA1R_FFA2_Msk     (0x1U << CAN_FFA1R_FFA2_Pos)                    /*!< 0x00000004 */
N#define CAN_FFA1R_FFA2         CAN_FFA1R_FFA2_Msk                              /*!<Filter FIFO Assignment bit 2 */
N#define CAN_FFA1R_FFA3_Pos     (3U)                                            
N#define CAN_FFA1R_FFA3_Msk     (0x1U << CAN_FFA1R_FFA3_Pos)                    /*!< 0x00000008 */
N#define CAN_FFA1R_FFA3         CAN_FFA1R_FFA3_Msk                              /*!<Filter FIFO Assignment bit 3 */
N#define CAN_FFA1R_FFA4_Pos     (4U)                                            
N#define CAN_FFA1R_FFA4_Msk     (0x1U << CAN_FFA1R_FFA4_Pos)                    /*!< 0x00000010 */
N#define CAN_FFA1R_FFA4         CAN_FFA1R_FFA4_Msk                              /*!<Filter FIFO Assignment bit 4 */
N#define CAN_FFA1R_FFA5_Pos     (5U)                                            
N#define CAN_FFA1R_FFA5_Msk     (0x1U << CAN_FFA1R_FFA5_Pos)                    /*!< 0x00000020 */
N#define CAN_FFA1R_FFA5         CAN_FFA1R_FFA5_Msk                              /*!<Filter FIFO Assignment bit 5 */
N#define CAN_FFA1R_FFA6_Pos     (6U)                                            
N#define CAN_FFA1R_FFA6_Msk     (0x1U << CAN_FFA1R_FFA6_Pos)                    /*!< 0x00000040 */
N#define CAN_FFA1R_FFA6         CAN_FFA1R_FFA6_Msk                              /*!<Filter FIFO Assignment bit 6 */
N#define CAN_FFA1R_FFA7_Pos     (7U)                                            
N#define CAN_FFA1R_FFA7_Msk     (0x1U << CAN_FFA1R_FFA7_Pos)                    /*!< 0x00000080 */
N#define CAN_FFA1R_FFA7         CAN_FFA1R_FFA7_Msk                              /*!<Filter FIFO Assignment bit 7 */
N#define CAN_FFA1R_FFA8_Pos     (8U)                                            
N#define CAN_FFA1R_FFA8_Msk     (0x1U << CAN_FFA1R_FFA8_Pos)                    /*!< 0x00000100 */
N#define CAN_FFA1R_FFA8         CAN_FFA1R_FFA8_Msk                              /*!<Filter FIFO Assignment bit 8 */
N#define CAN_FFA1R_FFA9_Pos     (9U)                                            
N#define CAN_FFA1R_FFA9_Msk     (0x1U << CAN_FFA1R_FFA9_Pos)                    /*!< 0x00000200 */
N#define CAN_FFA1R_FFA9         CAN_FFA1R_FFA9_Msk                              /*!<Filter FIFO Assignment bit 9 */
N#define CAN_FFA1R_FFA10_Pos    (10U)                                           
N#define CAN_FFA1R_FFA10_Msk    (0x1U << CAN_FFA1R_FFA10_Pos)                   /*!< 0x00000400 */
N#define CAN_FFA1R_FFA10        CAN_FFA1R_FFA10_Msk                             /*!<Filter FIFO Assignment bit 10 */
N#define CAN_FFA1R_FFA11_Pos    (11U)                                           
N#define CAN_FFA1R_FFA11_Msk    (0x1U << CAN_FFA1R_FFA11_Pos)                   /*!< 0x00000800 */
N#define CAN_FFA1R_FFA11        CAN_FFA1R_FFA11_Msk                             /*!<Filter FIFO Assignment bit 11 */
N#define CAN_FFA1R_FFA12_Pos    (12U)                                           
N#define CAN_FFA1R_FFA12_Msk    (0x1U << CAN_FFA1R_FFA12_Pos)                   /*!< 0x00001000 */
N#define CAN_FFA1R_FFA12        CAN_FFA1R_FFA12_Msk                             /*!<Filter FIFO Assignment bit 12 */
N#define CAN_FFA1R_FFA13_Pos    (13U)                                           
N#define CAN_FFA1R_FFA13_Msk    (0x1U << CAN_FFA1R_FFA13_Pos)                   /*!< 0x00002000 */
N#define CAN_FFA1R_FFA13        CAN_FFA1R_FFA13_Msk                             /*!<Filter FIFO Assignment bit 13 */
N#define CAN_FFA1R_FFA14_Pos    (14U)                                           
N#define CAN_FFA1R_FFA14_Msk    (0x1U << CAN_FFA1R_FFA14_Pos)                   /*!< 0x00004000 */
N#define CAN_FFA1R_FFA14        CAN_FFA1R_FFA14_Msk                             /*!<Filter FIFO Assignment bit 14 */
N#define CAN_FFA1R_FFA15_Pos    (15U)                                           
N#define CAN_FFA1R_FFA15_Msk    (0x1U << CAN_FFA1R_FFA15_Pos)                   /*!< 0x00008000 */
N#define CAN_FFA1R_FFA15        CAN_FFA1R_FFA15_Msk                             /*!<Filter FIFO Assignment bit 15 */
N#define CAN_FFA1R_FFA16_Pos    (16U)                                           
N#define CAN_FFA1R_FFA16_Msk    (0x1U << CAN_FFA1R_FFA16_Pos)                   /*!< 0x00010000 */
N#define CAN_FFA1R_FFA16        CAN_FFA1R_FFA16_Msk                             /*!<Filter FIFO Assignment bit 16 */
N#define CAN_FFA1R_FFA17_Pos    (17U)                                           
N#define CAN_FFA1R_FFA17_Msk    (0x1U << CAN_FFA1R_FFA17_Pos)                   /*!< 0x00020000 */
N#define CAN_FFA1R_FFA17        CAN_FFA1R_FFA17_Msk                             /*!<Filter FIFO Assignment bit 17 */
N#define CAN_FFA1R_FFA18_Pos    (18U)                                           
N#define CAN_FFA1R_FFA18_Msk    (0x1U << CAN_FFA1R_FFA18_Pos)                   /*!< 0x00040000 */
N#define CAN_FFA1R_FFA18        CAN_FFA1R_FFA18_Msk                             /*!<Filter FIFO Assignment bit 18 */
N#define CAN_FFA1R_FFA19_Pos    (19U)                                           
N#define CAN_FFA1R_FFA19_Msk    (0x1U << CAN_FFA1R_FFA19_Pos)                   /*!< 0x00080000 */
N#define CAN_FFA1R_FFA19        CAN_FFA1R_FFA19_Msk                             /*!<Filter FIFO Assignment bit 19 */
N#define CAN_FFA1R_FFA20_Pos    (20U)                                           
N#define CAN_FFA1R_FFA20_Msk    (0x1U << CAN_FFA1R_FFA20_Pos)                   /*!< 0x00100000 */
N#define CAN_FFA1R_FFA20        CAN_FFA1R_FFA20_Msk                             /*!<Filter FIFO Assignment bit 20 */
N#define CAN_FFA1R_FFA21_Pos    (21U)                                           
N#define CAN_FFA1R_FFA21_Msk    (0x1U << CAN_FFA1R_FFA21_Pos)                   /*!< 0x00200000 */
N#define CAN_FFA1R_FFA21        CAN_FFA1R_FFA21_Msk                             /*!<Filter FIFO Assignment bit 21 */
N#define CAN_FFA1R_FFA22_Pos    (22U)                                           
N#define CAN_FFA1R_FFA22_Msk    (0x1U << CAN_FFA1R_FFA22_Pos)                   /*!< 0x00400000 */
N#define CAN_FFA1R_FFA22        CAN_FFA1R_FFA22_Msk                             /*!<Filter FIFO Assignment bit 22 */
N#define CAN_FFA1R_FFA23_Pos    (23U)                                           
N#define CAN_FFA1R_FFA23_Msk    (0x1U << CAN_FFA1R_FFA23_Pos)                   /*!< 0x00800000 */
N#define CAN_FFA1R_FFA23        CAN_FFA1R_FFA23_Msk                             /*!<Filter FIFO Assignment bit 23 */
N#define CAN_FFA1R_FFA24_Pos    (24U)                                           
N#define CAN_FFA1R_FFA24_Msk    (0x1U << CAN_FFA1R_FFA24_Pos)                   /*!< 0x01000000 */
N#define CAN_FFA1R_FFA24        CAN_FFA1R_FFA24_Msk                             /*!<Filter FIFO Assignment bit 24 */
N#define CAN_FFA1R_FFA25_Pos    (25U)                                           
N#define CAN_FFA1R_FFA25_Msk    (0x1U << CAN_FFA1R_FFA25_Pos)                   /*!< 0x02000000 */
N#define CAN_FFA1R_FFA25        CAN_FFA1R_FFA25_Msk                             /*!<Filter FIFO Assignment bit 25 */
N#define CAN_FFA1R_FFA26_Pos    (26U)                                           
N#define CAN_FFA1R_FFA26_Msk    (0x1U << CAN_FFA1R_FFA26_Pos)                   /*!< 0x04000000 */
N#define CAN_FFA1R_FFA26        CAN_FFA1R_FFA26_Msk                             /*!<Filter FIFO Assignment bit 26 */
N#define CAN_FFA1R_FFA27_Pos    (27U)                                           
N#define CAN_FFA1R_FFA27_Msk    (0x1U << CAN_FFA1R_FFA27_Pos)                   /*!< 0x08000000 */
N#define CAN_FFA1R_FFA27        CAN_FFA1R_FFA27_Msk                             /*!<Filter FIFO Assignment bit 27 */
N
N/*******************  Bit definition for CAN_FA1R register  *******************/
N#define CAN_FA1R_FACT_Pos      (0U)                                            
N#define CAN_FA1R_FACT_Msk      (0xFFFFFFFU << CAN_FA1R_FACT_Pos)               /*!< 0x0FFFFFFF */
N#define CAN_FA1R_FACT          CAN_FA1R_FACT_Msk                               /*!<Filter Active */
N#define CAN_FA1R_FACT0_Pos     (0U)                                            
N#define CAN_FA1R_FACT0_Msk     (0x1U << CAN_FA1R_FACT0_Pos)                    /*!< 0x00000001 */
N#define CAN_FA1R_FACT0         CAN_FA1R_FACT0_Msk                              /*!<Filter Active bit 0 */
N#define CAN_FA1R_FACT1_Pos     (1U)                                            
N#define CAN_FA1R_FACT1_Msk     (0x1U << CAN_FA1R_FACT1_Pos)                    /*!< 0x00000002 */
N#define CAN_FA1R_FACT1         CAN_FA1R_FACT1_Msk                              /*!<Filter Active bit 1 */
N#define CAN_FA1R_FACT2_Pos     (2U)                                            
N#define CAN_FA1R_FACT2_Msk     (0x1U << CAN_FA1R_FACT2_Pos)                    /*!< 0x00000004 */
N#define CAN_FA1R_FACT2         CAN_FA1R_FACT2_Msk                              /*!<Filter Active bit 2 */
N#define CAN_FA1R_FACT3_Pos     (3U)                                            
N#define CAN_FA1R_FACT3_Msk     (0x1U << CAN_FA1R_FACT3_Pos)                    /*!< 0x00000008 */
N#define CAN_FA1R_FACT3         CAN_FA1R_FACT3_Msk                              /*!<Filter Active bit 3 */
N#define CAN_FA1R_FACT4_Pos     (4U)                                            
N#define CAN_FA1R_FACT4_Msk     (0x1U << CAN_FA1R_FACT4_Pos)                    /*!< 0x00000010 */
N#define CAN_FA1R_FACT4         CAN_FA1R_FACT4_Msk                              /*!<Filter Active bit 4 */
N#define CAN_FA1R_FACT5_Pos     (5U)                                            
N#define CAN_FA1R_FACT5_Msk     (0x1U << CAN_FA1R_FACT5_Pos)                    /*!< 0x00000020 */
N#define CAN_FA1R_FACT5         CAN_FA1R_FACT5_Msk                              /*!<Filter Active bit 5 */
N#define CAN_FA1R_FACT6_Pos     (6U)                                            
N#define CAN_FA1R_FACT6_Msk     (0x1U << CAN_FA1R_FACT6_Pos)                    /*!< 0x00000040 */
N#define CAN_FA1R_FACT6         CAN_FA1R_FACT6_Msk                              /*!<Filter Active bit 6 */
N#define CAN_FA1R_FACT7_Pos     (7U)                                            
N#define CAN_FA1R_FACT7_Msk     (0x1U << CAN_FA1R_FACT7_Pos)                    /*!< 0x00000080 */
N#define CAN_FA1R_FACT7         CAN_FA1R_FACT7_Msk                              /*!<Filter Active bit 7 */
N#define CAN_FA1R_FACT8_Pos     (8U)                                            
N#define CAN_FA1R_FACT8_Msk     (0x1U << CAN_FA1R_FACT8_Pos)                    /*!< 0x00000100 */
N#define CAN_FA1R_FACT8         CAN_FA1R_FACT8_Msk                              /*!<Filter Active bit 8 */
N#define CAN_FA1R_FACT9_Pos     (9U)                                            
N#define CAN_FA1R_FACT9_Msk     (0x1U << CAN_FA1R_FACT9_Pos)                    /*!< 0x00000200 */
N#define CAN_FA1R_FACT9         CAN_FA1R_FACT9_Msk                              /*!<Filter Active bit 9 */
N#define CAN_FA1R_FACT10_Pos    (10U)                                           
N#define CAN_FA1R_FACT10_Msk    (0x1U << CAN_FA1R_FACT10_Pos)                   /*!< 0x00000400 */
N#define CAN_FA1R_FACT10        CAN_FA1R_FACT10_Msk                             /*!<Filter Active bit 10 */
N#define CAN_FA1R_FACT11_Pos    (11U)                                           
N#define CAN_FA1R_FACT11_Msk    (0x1U << CAN_FA1R_FACT11_Pos)                   /*!< 0x00000800 */
N#define CAN_FA1R_FACT11        CAN_FA1R_FACT11_Msk                             /*!<Filter Active bit 11 */
N#define CAN_FA1R_FACT12_Pos    (12U)                                           
N#define CAN_FA1R_FACT12_Msk    (0x1U << CAN_FA1R_FACT12_Pos)                   /*!< 0x00001000 */
N#define CAN_FA1R_FACT12        CAN_FA1R_FACT12_Msk                             /*!<Filter Active bit 12 */
N#define CAN_FA1R_FACT13_Pos    (13U)                                           
N#define CAN_FA1R_FACT13_Msk    (0x1U << CAN_FA1R_FACT13_Pos)                   /*!< 0x00002000 */
N#define CAN_FA1R_FACT13        CAN_FA1R_FACT13_Msk                             /*!<Filter Active bit 13 */
N#define CAN_FA1R_FACT14_Pos    (14U)                                           
N#define CAN_FA1R_FACT14_Msk    (0x1U << CAN_FA1R_FACT14_Pos)                   /*!< 0x00004000 */
N#define CAN_FA1R_FACT14        CAN_FA1R_FACT14_Msk                             /*!<Filter Active bit 14 */
N#define CAN_FA1R_FACT15_Pos    (15U)                                           
N#define CAN_FA1R_FACT15_Msk    (0x1U << CAN_FA1R_FACT15_Pos)                   /*!< 0x00008000 */
N#define CAN_FA1R_FACT15        CAN_FA1R_FACT15_Msk                             /*!<Filter Active bit 15 */
N#define CAN_FA1R_FACT16_Pos    (16U)                                           
N#define CAN_FA1R_FACT16_Msk    (0x1U << CAN_FA1R_FACT16_Pos)                   /*!< 0x00010000 */
N#define CAN_FA1R_FACT16        CAN_FA1R_FACT16_Msk                             /*!<Filter Active bit 16 */
N#define CAN_FA1R_FACT17_Pos    (17U)                                           
N#define CAN_FA1R_FACT17_Msk    (0x1U << CAN_FA1R_FACT17_Pos)                   /*!< 0x00020000 */
N#define CAN_FA1R_FACT17        CAN_FA1R_FACT17_Msk                             /*!<Filter Active bit 17 */
N#define CAN_FA1R_FACT18_Pos    (18U)                                           
N#define CAN_FA1R_FACT18_Msk    (0x1U << CAN_FA1R_FACT18_Pos)                   /*!< 0x00040000 */
N#define CAN_FA1R_FACT18        CAN_FA1R_FACT18_Msk                             /*!<Filter Active bit 18 */
N#define CAN_FA1R_FACT19_Pos    (19U)                                           
N#define CAN_FA1R_FACT19_Msk    (0x1U << CAN_FA1R_FACT19_Pos)                   /*!< 0x00080000 */
N#define CAN_FA1R_FACT19        CAN_FA1R_FACT19_Msk                             /*!<Filter Active bit 19 */
N#define CAN_FA1R_FACT20_Pos    (20U)                                           
N#define CAN_FA1R_FACT20_Msk    (0x1U << CAN_FA1R_FACT20_Pos)                   /*!< 0x00100000 */
N#define CAN_FA1R_FACT20        CAN_FA1R_FACT20_Msk                             /*!<Filter Active bit 20 */
N#define CAN_FA1R_FACT21_Pos    (21U)                                           
N#define CAN_FA1R_FACT21_Msk    (0x1U << CAN_FA1R_FACT21_Pos)                   /*!< 0x00200000 */
N#define CAN_FA1R_FACT21        CAN_FA1R_FACT21_Msk                             /*!<Filter Active bit 21 */
N#define CAN_FA1R_FACT22_Pos    (22U)                                           
N#define CAN_FA1R_FACT22_Msk    (0x1U << CAN_FA1R_FACT22_Pos)                   /*!< 0x00400000 */
N#define CAN_FA1R_FACT22        CAN_FA1R_FACT22_Msk                             /*!<Filter Active bit 22 */
N#define CAN_FA1R_FACT23_Pos    (23U)                                           
N#define CAN_FA1R_FACT23_Msk    (0x1U << CAN_FA1R_FACT23_Pos)                   /*!< 0x00800000 */
N#define CAN_FA1R_FACT23        CAN_FA1R_FACT23_Msk                             /*!<Filter Active bit 23 */
N#define CAN_FA1R_FACT24_Pos    (24U)                                           
N#define CAN_FA1R_FACT24_Msk    (0x1U << CAN_FA1R_FACT24_Pos)                   /*!< 0x01000000 */
N#define CAN_FA1R_FACT24        CAN_FA1R_FACT24_Msk                             /*!<Filter Active bit 24 */
N#define CAN_FA1R_FACT25_Pos    (25U)                                           
N#define CAN_FA1R_FACT25_Msk    (0x1U << CAN_FA1R_FACT25_Pos)                   /*!< 0x02000000 */
N#define CAN_FA1R_FACT25        CAN_FA1R_FACT25_Msk                             /*!<Filter Active bit 25 */
N#define CAN_FA1R_FACT26_Pos    (26U)                                           
N#define CAN_FA1R_FACT26_Msk    (0x1U << CAN_FA1R_FACT26_Pos)                   /*!< 0x04000000 */
N#define CAN_FA1R_FACT26        CAN_FA1R_FACT26_Msk                             /*!<Filter Active bit 26 */
N#define CAN_FA1R_FACT27_Pos    (27U)                                           
N#define CAN_FA1R_FACT27_Msk    (0x1U << CAN_FA1R_FACT27_Pos)                   /*!< 0x08000000 */
N#define CAN_FA1R_FACT27        CAN_FA1R_FACT27_Msk                             /*!<Filter Active bit 27 */
N
N/*******************  Bit definition for CAN_F0R1 register  *******************/
N#define CAN_F0R1_FB0_Pos       (0U)                                            
N#define CAN_F0R1_FB0_Msk       (0x1U << CAN_F0R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F0R1_FB0           CAN_F0R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F0R1_FB1_Pos       (1U)                                            
N#define CAN_F0R1_FB1_Msk       (0x1U << CAN_F0R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F0R1_FB1           CAN_F0R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F0R1_FB2_Pos       (2U)                                            
N#define CAN_F0R1_FB2_Msk       (0x1U << CAN_F0R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F0R1_FB2           CAN_F0R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F0R1_FB3_Pos       (3U)                                            
N#define CAN_F0R1_FB3_Msk       (0x1U << CAN_F0R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F0R1_FB3           CAN_F0R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F0R1_FB4_Pos       (4U)                                            
N#define CAN_F0R1_FB4_Msk       (0x1U << CAN_F0R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F0R1_FB4           CAN_F0R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F0R1_FB5_Pos       (5U)                                            
N#define CAN_F0R1_FB5_Msk       (0x1U << CAN_F0R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F0R1_FB5           CAN_F0R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F0R1_FB6_Pos       (6U)                                            
N#define CAN_F0R1_FB6_Msk       (0x1U << CAN_F0R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F0R1_FB6           CAN_F0R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F0R1_FB7_Pos       (7U)                                            
N#define CAN_F0R1_FB7_Msk       (0x1U << CAN_F0R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F0R1_FB7           CAN_F0R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F0R1_FB8_Pos       (8U)                                            
N#define CAN_F0R1_FB8_Msk       (0x1U << CAN_F0R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F0R1_FB8           CAN_F0R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F0R1_FB9_Pos       (9U)                                            
N#define CAN_F0R1_FB9_Msk       (0x1U << CAN_F0R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F0R1_FB9           CAN_F0R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F0R1_FB10_Pos      (10U)                                           
N#define CAN_F0R1_FB10_Msk      (0x1U << CAN_F0R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F0R1_FB10          CAN_F0R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F0R1_FB11_Pos      (11U)                                           
N#define CAN_F0R1_FB11_Msk      (0x1U << CAN_F0R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F0R1_FB11          CAN_F0R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F0R1_FB12_Pos      (12U)                                           
N#define CAN_F0R1_FB12_Msk      (0x1U << CAN_F0R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F0R1_FB12          CAN_F0R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F0R1_FB13_Pos      (13U)                                           
N#define CAN_F0R1_FB13_Msk      (0x1U << CAN_F0R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F0R1_FB13          CAN_F0R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F0R1_FB14_Pos      (14U)                                           
N#define CAN_F0R1_FB14_Msk      (0x1U << CAN_F0R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F0R1_FB14          CAN_F0R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F0R1_FB15_Pos      (15U)                                           
N#define CAN_F0R1_FB15_Msk      (0x1U << CAN_F0R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F0R1_FB15          CAN_F0R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F0R1_FB16_Pos      (16U)                                           
N#define CAN_F0R1_FB16_Msk      (0x1U << CAN_F0R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F0R1_FB16          CAN_F0R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F0R1_FB17_Pos      (17U)                                           
N#define CAN_F0R1_FB17_Msk      (0x1U << CAN_F0R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F0R1_FB17          CAN_F0R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F0R1_FB18_Pos      (18U)                                           
N#define CAN_F0R1_FB18_Msk      (0x1U << CAN_F0R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F0R1_FB18          CAN_F0R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F0R1_FB19_Pos      (19U)                                           
N#define CAN_F0R1_FB19_Msk      (0x1U << CAN_F0R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F0R1_FB19          CAN_F0R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F0R1_FB20_Pos      (20U)                                           
N#define CAN_F0R1_FB20_Msk      (0x1U << CAN_F0R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F0R1_FB20          CAN_F0R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F0R1_FB21_Pos      (21U)                                           
N#define CAN_F0R1_FB21_Msk      (0x1U << CAN_F0R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F0R1_FB21          CAN_F0R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F0R1_FB22_Pos      (22U)                                           
N#define CAN_F0R1_FB22_Msk      (0x1U << CAN_F0R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F0R1_FB22          CAN_F0R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F0R1_FB23_Pos      (23U)                                           
N#define CAN_F0R1_FB23_Msk      (0x1U << CAN_F0R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F0R1_FB23          CAN_F0R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F0R1_FB24_Pos      (24U)                                           
N#define CAN_F0R1_FB24_Msk      (0x1U << CAN_F0R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F0R1_FB24          CAN_F0R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F0R1_FB25_Pos      (25U)                                           
N#define CAN_F0R1_FB25_Msk      (0x1U << CAN_F0R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F0R1_FB25          CAN_F0R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F0R1_FB26_Pos      (26U)                                           
N#define CAN_F0R1_FB26_Msk      (0x1U << CAN_F0R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F0R1_FB26          CAN_F0R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F0R1_FB27_Pos      (27U)                                           
N#define CAN_F0R1_FB27_Msk      (0x1U << CAN_F0R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F0R1_FB27          CAN_F0R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F0R1_FB28_Pos      (28U)                                           
N#define CAN_F0R1_FB28_Msk      (0x1U << CAN_F0R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F0R1_FB28          CAN_F0R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F0R1_FB29_Pos      (29U)                                           
N#define CAN_F0R1_FB29_Msk      (0x1U << CAN_F0R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F0R1_FB29          CAN_F0R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F0R1_FB30_Pos      (30U)                                           
N#define CAN_F0R1_FB30_Msk      (0x1U << CAN_F0R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F0R1_FB30          CAN_F0R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F0R1_FB31_Pos      (31U)                                           
N#define CAN_F0R1_FB31_Msk      (0x1U << CAN_F0R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F0R1_FB31          CAN_F0R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R1 register  *******************/
N#define CAN_F1R1_FB0_Pos       (0U)                                            
N#define CAN_F1R1_FB0_Msk       (0x1U << CAN_F1R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F1R1_FB0           CAN_F1R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F1R1_FB1_Pos       (1U)                                            
N#define CAN_F1R1_FB1_Msk       (0x1U << CAN_F1R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F1R1_FB1           CAN_F1R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F1R1_FB2_Pos       (2U)                                            
N#define CAN_F1R1_FB2_Msk       (0x1U << CAN_F1R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F1R1_FB2           CAN_F1R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F1R1_FB3_Pos       (3U)                                            
N#define CAN_F1R1_FB3_Msk       (0x1U << CAN_F1R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F1R1_FB3           CAN_F1R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F1R1_FB4_Pos       (4U)                                            
N#define CAN_F1R1_FB4_Msk       (0x1U << CAN_F1R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F1R1_FB4           CAN_F1R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F1R1_FB5_Pos       (5U)                                            
N#define CAN_F1R1_FB5_Msk       (0x1U << CAN_F1R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F1R1_FB5           CAN_F1R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F1R1_FB6_Pos       (6U)                                            
N#define CAN_F1R1_FB6_Msk       (0x1U << CAN_F1R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F1R1_FB6           CAN_F1R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F1R1_FB7_Pos       (7U)                                            
N#define CAN_F1R1_FB7_Msk       (0x1U << CAN_F1R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F1R1_FB7           CAN_F1R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F1R1_FB8_Pos       (8U)                                            
N#define CAN_F1R1_FB8_Msk       (0x1U << CAN_F1R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F1R1_FB8           CAN_F1R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F1R1_FB9_Pos       (9U)                                            
N#define CAN_F1R1_FB9_Msk       (0x1U << CAN_F1R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F1R1_FB9           CAN_F1R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F1R1_FB10_Pos      (10U)                                           
N#define CAN_F1R1_FB10_Msk      (0x1U << CAN_F1R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F1R1_FB10          CAN_F1R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F1R1_FB11_Pos      (11U)                                           
N#define CAN_F1R1_FB11_Msk      (0x1U << CAN_F1R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F1R1_FB11          CAN_F1R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F1R1_FB12_Pos      (12U)                                           
N#define CAN_F1R1_FB12_Msk      (0x1U << CAN_F1R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F1R1_FB12          CAN_F1R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F1R1_FB13_Pos      (13U)                                           
N#define CAN_F1R1_FB13_Msk      (0x1U << CAN_F1R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F1R1_FB13          CAN_F1R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F1R1_FB14_Pos      (14U)                                           
N#define CAN_F1R1_FB14_Msk      (0x1U << CAN_F1R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F1R1_FB14          CAN_F1R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F1R1_FB15_Pos      (15U)                                           
N#define CAN_F1R1_FB15_Msk      (0x1U << CAN_F1R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F1R1_FB15          CAN_F1R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F1R1_FB16_Pos      (16U)                                           
N#define CAN_F1R1_FB16_Msk      (0x1U << CAN_F1R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F1R1_FB16          CAN_F1R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F1R1_FB17_Pos      (17U)                                           
N#define CAN_F1R1_FB17_Msk      (0x1U << CAN_F1R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F1R1_FB17          CAN_F1R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F1R1_FB18_Pos      (18U)                                           
N#define CAN_F1R1_FB18_Msk      (0x1U << CAN_F1R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F1R1_FB18          CAN_F1R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F1R1_FB19_Pos      (19U)                                           
N#define CAN_F1R1_FB19_Msk      (0x1U << CAN_F1R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F1R1_FB19          CAN_F1R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F1R1_FB20_Pos      (20U)                                           
N#define CAN_F1R1_FB20_Msk      (0x1U << CAN_F1R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F1R1_FB20          CAN_F1R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F1R1_FB21_Pos      (21U)                                           
N#define CAN_F1R1_FB21_Msk      (0x1U << CAN_F1R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F1R1_FB21          CAN_F1R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F1R1_FB22_Pos      (22U)                                           
N#define CAN_F1R1_FB22_Msk      (0x1U << CAN_F1R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F1R1_FB22          CAN_F1R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F1R1_FB23_Pos      (23U)                                           
N#define CAN_F1R1_FB23_Msk      (0x1U << CAN_F1R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F1R1_FB23          CAN_F1R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F1R1_FB24_Pos      (24U)                                           
N#define CAN_F1R1_FB24_Msk      (0x1U << CAN_F1R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F1R1_FB24          CAN_F1R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F1R1_FB25_Pos      (25U)                                           
N#define CAN_F1R1_FB25_Msk      (0x1U << CAN_F1R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F1R1_FB25          CAN_F1R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F1R1_FB26_Pos      (26U)                                           
N#define CAN_F1R1_FB26_Msk      (0x1U << CAN_F1R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F1R1_FB26          CAN_F1R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F1R1_FB27_Pos      (27U)                                           
N#define CAN_F1R1_FB27_Msk      (0x1U << CAN_F1R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F1R1_FB27          CAN_F1R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F1R1_FB28_Pos      (28U)                                           
N#define CAN_F1R1_FB28_Msk      (0x1U << CAN_F1R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F1R1_FB28          CAN_F1R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F1R1_FB29_Pos      (29U)                                           
N#define CAN_F1R1_FB29_Msk      (0x1U << CAN_F1R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F1R1_FB29          CAN_F1R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F1R1_FB30_Pos      (30U)                                           
N#define CAN_F1R1_FB30_Msk      (0x1U << CAN_F1R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F1R1_FB30          CAN_F1R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F1R1_FB31_Pos      (31U)                                           
N#define CAN_F1R1_FB31_Msk      (0x1U << CAN_F1R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F1R1_FB31          CAN_F1R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R1 register  *******************/
N#define CAN_F2R1_FB0_Pos       (0U)                                            
N#define CAN_F2R1_FB0_Msk       (0x1U << CAN_F2R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F2R1_FB0           CAN_F2R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F2R1_FB1_Pos       (1U)                                            
N#define CAN_F2R1_FB1_Msk       (0x1U << CAN_F2R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F2R1_FB1           CAN_F2R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F2R1_FB2_Pos       (2U)                                            
N#define CAN_F2R1_FB2_Msk       (0x1U << CAN_F2R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F2R1_FB2           CAN_F2R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F2R1_FB3_Pos       (3U)                                            
N#define CAN_F2R1_FB3_Msk       (0x1U << CAN_F2R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F2R1_FB3           CAN_F2R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F2R1_FB4_Pos       (4U)                                            
N#define CAN_F2R1_FB4_Msk       (0x1U << CAN_F2R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F2R1_FB4           CAN_F2R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F2R1_FB5_Pos       (5U)                                            
N#define CAN_F2R1_FB5_Msk       (0x1U << CAN_F2R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F2R1_FB5           CAN_F2R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F2R1_FB6_Pos       (6U)                                            
N#define CAN_F2R1_FB6_Msk       (0x1U << CAN_F2R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F2R1_FB6           CAN_F2R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F2R1_FB7_Pos       (7U)                                            
N#define CAN_F2R1_FB7_Msk       (0x1U << CAN_F2R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F2R1_FB7           CAN_F2R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F2R1_FB8_Pos       (8U)                                            
N#define CAN_F2R1_FB8_Msk       (0x1U << CAN_F2R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F2R1_FB8           CAN_F2R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F2R1_FB9_Pos       (9U)                                            
N#define CAN_F2R1_FB9_Msk       (0x1U << CAN_F2R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F2R1_FB9           CAN_F2R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F2R1_FB10_Pos      (10U)                                           
N#define CAN_F2R1_FB10_Msk      (0x1U << CAN_F2R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F2R1_FB10          CAN_F2R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F2R1_FB11_Pos      (11U)                                           
N#define CAN_F2R1_FB11_Msk      (0x1U << CAN_F2R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F2R1_FB11          CAN_F2R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F2R1_FB12_Pos      (12U)                                           
N#define CAN_F2R1_FB12_Msk      (0x1U << CAN_F2R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F2R1_FB12          CAN_F2R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F2R1_FB13_Pos      (13U)                                           
N#define CAN_F2R1_FB13_Msk      (0x1U << CAN_F2R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F2R1_FB13          CAN_F2R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F2R1_FB14_Pos      (14U)                                           
N#define CAN_F2R1_FB14_Msk      (0x1U << CAN_F2R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F2R1_FB14          CAN_F2R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F2R1_FB15_Pos      (15U)                                           
N#define CAN_F2R1_FB15_Msk      (0x1U << CAN_F2R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F2R1_FB15          CAN_F2R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F2R1_FB16_Pos      (16U)                                           
N#define CAN_F2R1_FB16_Msk      (0x1U << CAN_F2R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F2R1_FB16          CAN_F2R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F2R1_FB17_Pos      (17U)                                           
N#define CAN_F2R1_FB17_Msk      (0x1U << CAN_F2R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F2R1_FB17          CAN_F2R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F2R1_FB18_Pos      (18U)                                           
N#define CAN_F2R1_FB18_Msk      (0x1U << CAN_F2R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F2R1_FB18          CAN_F2R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F2R1_FB19_Pos      (19U)                                           
N#define CAN_F2R1_FB19_Msk      (0x1U << CAN_F2R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F2R1_FB19          CAN_F2R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F2R1_FB20_Pos      (20U)                                           
N#define CAN_F2R1_FB20_Msk      (0x1U << CAN_F2R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F2R1_FB20          CAN_F2R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F2R1_FB21_Pos      (21U)                                           
N#define CAN_F2R1_FB21_Msk      (0x1U << CAN_F2R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F2R1_FB21          CAN_F2R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F2R1_FB22_Pos      (22U)                                           
N#define CAN_F2R1_FB22_Msk      (0x1U << CAN_F2R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F2R1_FB22          CAN_F2R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F2R1_FB23_Pos      (23U)                                           
N#define CAN_F2R1_FB23_Msk      (0x1U << CAN_F2R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F2R1_FB23          CAN_F2R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F2R1_FB24_Pos      (24U)                                           
N#define CAN_F2R1_FB24_Msk      (0x1U << CAN_F2R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F2R1_FB24          CAN_F2R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F2R1_FB25_Pos      (25U)                                           
N#define CAN_F2R1_FB25_Msk      (0x1U << CAN_F2R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F2R1_FB25          CAN_F2R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F2R1_FB26_Pos      (26U)                                           
N#define CAN_F2R1_FB26_Msk      (0x1U << CAN_F2R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F2R1_FB26          CAN_F2R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F2R1_FB27_Pos      (27U)                                           
N#define CAN_F2R1_FB27_Msk      (0x1U << CAN_F2R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F2R1_FB27          CAN_F2R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F2R1_FB28_Pos      (28U)                                           
N#define CAN_F2R1_FB28_Msk      (0x1U << CAN_F2R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F2R1_FB28          CAN_F2R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F2R1_FB29_Pos      (29U)                                           
N#define CAN_F2R1_FB29_Msk      (0x1U << CAN_F2R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F2R1_FB29          CAN_F2R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F2R1_FB30_Pos      (30U)                                           
N#define CAN_F2R1_FB30_Msk      (0x1U << CAN_F2R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F2R1_FB30          CAN_F2R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F2R1_FB31_Pos      (31U)                                           
N#define CAN_F2R1_FB31_Msk      (0x1U << CAN_F2R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F2R1_FB31          CAN_F2R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R1 register  *******************/
N#define CAN_F3R1_FB0_Pos       (0U)                                            
N#define CAN_F3R1_FB0_Msk       (0x1U << CAN_F3R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F3R1_FB0           CAN_F3R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F3R1_FB1_Pos       (1U)                                            
N#define CAN_F3R1_FB1_Msk       (0x1U << CAN_F3R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F3R1_FB1           CAN_F3R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F3R1_FB2_Pos       (2U)                                            
N#define CAN_F3R1_FB2_Msk       (0x1U << CAN_F3R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F3R1_FB2           CAN_F3R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F3R1_FB3_Pos       (3U)                                            
N#define CAN_F3R1_FB3_Msk       (0x1U << CAN_F3R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F3R1_FB3           CAN_F3R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F3R1_FB4_Pos       (4U)                                            
N#define CAN_F3R1_FB4_Msk       (0x1U << CAN_F3R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F3R1_FB4           CAN_F3R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F3R1_FB5_Pos       (5U)                                            
N#define CAN_F3R1_FB5_Msk       (0x1U << CAN_F3R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F3R1_FB5           CAN_F3R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F3R1_FB6_Pos       (6U)                                            
N#define CAN_F3R1_FB6_Msk       (0x1U << CAN_F3R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F3R1_FB6           CAN_F3R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F3R1_FB7_Pos       (7U)                                            
N#define CAN_F3R1_FB7_Msk       (0x1U << CAN_F3R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F3R1_FB7           CAN_F3R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F3R1_FB8_Pos       (8U)                                            
N#define CAN_F3R1_FB8_Msk       (0x1U << CAN_F3R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F3R1_FB8           CAN_F3R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F3R1_FB9_Pos       (9U)                                            
N#define CAN_F3R1_FB9_Msk       (0x1U << CAN_F3R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F3R1_FB9           CAN_F3R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F3R1_FB10_Pos      (10U)                                           
N#define CAN_F3R1_FB10_Msk      (0x1U << CAN_F3R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F3R1_FB10          CAN_F3R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F3R1_FB11_Pos      (11U)                                           
N#define CAN_F3R1_FB11_Msk      (0x1U << CAN_F3R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F3R1_FB11          CAN_F3R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F3R1_FB12_Pos      (12U)                                           
N#define CAN_F3R1_FB12_Msk      (0x1U << CAN_F3R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F3R1_FB12          CAN_F3R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F3R1_FB13_Pos      (13U)                                           
N#define CAN_F3R1_FB13_Msk      (0x1U << CAN_F3R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F3R1_FB13          CAN_F3R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F3R1_FB14_Pos      (14U)                                           
N#define CAN_F3R1_FB14_Msk      (0x1U << CAN_F3R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F3R1_FB14          CAN_F3R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F3R1_FB15_Pos      (15U)                                           
N#define CAN_F3R1_FB15_Msk      (0x1U << CAN_F3R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F3R1_FB15          CAN_F3R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F3R1_FB16_Pos      (16U)                                           
N#define CAN_F3R1_FB16_Msk      (0x1U << CAN_F3R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F3R1_FB16          CAN_F3R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F3R1_FB17_Pos      (17U)                                           
N#define CAN_F3R1_FB17_Msk      (0x1U << CAN_F3R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F3R1_FB17          CAN_F3R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F3R1_FB18_Pos      (18U)                                           
N#define CAN_F3R1_FB18_Msk      (0x1U << CAN_F3R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F3R1_FB18          CAN_F3R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F3R1_FB19_Pos      (19U)                                           
N#define CAN_F3R1_FB19_Msk      (0x1U << CAN_F3R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F3R1_FB19          CAN_F3R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F3R1_FB20_Pos      (20U)                                           
N#define CAN_F3R1_FB20_Msk      (0x1U << CAN_F3R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F3R1_FB20          CAN_F3R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F3R1_FB21_Pos      (21U)                                           
N#define CAN_F3R1_FB21_Msk      (0x1U << CAN_F3R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F3R1_FB21          CAN_F3R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F3R1_FB22_Pos      (22U)                                           
N#define CAN_F3R1_FB22_Msk      (0x1U << CAN_F3R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F3R1_FB22          CAN_F3R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F3R1_FB23_Pos      (23U)                                           
N#define CAN_F3R1_FB23_Msk      (0x1U << CAN_F3R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F3R1_FB23          CAN_F3R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F3R1_FB24_Pos      (24U)                                           
N#define CAN_F3R1_FB24_Msk      (0x1U << CAN_F3R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F3R1_FB24          CAN_F3R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F3R1_FB25_Pos      (25U)                                           
N#define CAN_F3R1_FB25_Msk      (0x1U << CAN_F3R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F3R1_FB25          CAN_F3R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F3R1_FB26_Pos      (26U)                                           
N#define CAN_F3R1_FB26_Msk      (0x1U << CAN_F3R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F3R1_FB26          CAN_F3R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F3R1_FB27_Pos      (27U)                                           
N#define CAN_F3R1_FB27_Msk      (0x1U << CAN_F3R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F3R1_FB27          CAN_F3R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F3R1_FB28_Pos      (28U)                                           
N#define CAN_F3R1_FB28_Msk      (0x1U << CAN_F3R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F3R1_FB28          CAN_F3R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F3R1_FB29_Pos      (29U)                                           
N#define CAN_F3R1_FB29_Msk      (0x1U << CAN_F3R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F3R1_FB29          CAN_F3R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F3R1_FB30_Pos      (30U)                                           
N#define CAN_F3R1_FB30_Msk      (0x1U << CAN_F3R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F3R1_FB30          CAN_F3R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F3R1_FB31_Pos      (31U)                                           
N#define CAN_F3R1_FB31_Msk      (0x1U << CAN_F3R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F3R1_FB31          CAN_F3R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R1 register  *******************/
N#define CAN_F4R1_FB0_Pos       (0U)                                            
N#define CAN_F4R1_FB0_Msk       (0x1U << CAN_F4R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F4R1_FB0           CAN_F4R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F4R1_FB1_Pos       (1U)                                            
N#define CAN_F4R1_FB1_Msk       (0x1U << CAN_F4R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F4R1_FB1           CAN_F4R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F4R1_FB2_Pos       (2U)                                            
N#define CAN_F4R1_FB2_Msk       (0x1U << CAN_F4R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F4R1_FB2           CAN_F4R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F4R1_FB3_Pos       (3U)                                            
N#define CAN_F4R1_FB3_Msk       (0x1U << CAN_F4R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F4R1_FB3           CAN_F4R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F4R1_FB4_Pos       (4U)                                            
N#define CAN_F4R1_FB4_Msk       (0x1U << CAN_F4R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F4R1_FB4           CAN_F4R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F4R1_FB5_Pos       (5U)                                            
N#define CAN_F4R1_FB5_Msk       (0x1U << CAN_F4R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F4R1_FB5           CAN_F4R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F4R1_FB6_Pos       (6U)                                            
N#define CAN_F4R1_FB6_Msk       (0x1U << CAN_F4R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F4R1_FB6           CAN_F4R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F4R1_FB7_Pos       (7U)                                            
N#define CAN_F4R1_FB7_Msk       (0x1U << CAN_F4R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F4R1_FB7           CAN_F4R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F4R1_FB8_Pos       (8U)                                            
N#define CAN_F4R1_FB8_Msk       (0x1U << CAN_F4R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F4R1_FB8           CAN_F4R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F4R1_FB9_Pos       (9U)                                            
N#define CAN_F4R1_FB9_Msk       (0x1U << CAN_F4R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F4R1_FB9           CAN_F4R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F4R1_FB10_Pos      (10U)                                           
N#define CAN_F4R1_FB10_Msk      (0x1U << CAN_F4R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F4R1_FB10          CAN_F4R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F4R1_FB11_Pos      (11U)                                           
N#define CAN_F4R1_FB11_Msk      (0x1U << CAN_F4R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F4R1_FB11          CAN_F4R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F4R1_FB12_Pos      (12U)                                           
N#define CAN_F4R1_FB12_Msk      (0x1U << CAN_F4R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F4R1_FB12          CAN_F4R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F4R1_FB13_Pos      (13U)                                           
N#define CAN_F4R1_FB13_Msk      (0x1U << CAN_F4R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F4R1_FB13          CAN_F4R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F4R1_FB14_Pos      (14U)                                           
N#define CAN_F4R1_FB14_Msk      (0x1U << CAN_F4R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F4R1_FB14          CAN_F4R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F4R1_FB15_Pos      (15U)                                           
N#define CAN_F4R1_FB15_Msk      (0x1U << CAN_F4R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F4R1_FB15          CAN_F4R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F4R1_FB16_Pos      (16U)                                           
N#define CAN_F4R1_FB16_Msk      (0x1U << CAN_F4R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F4R1_FB16          CAN_F4R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F4R1_FB17_Pos      (17U)                                           
N#define CAN_F4R1_FB17_Msk      (0x1U << CAN_F4R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F4R1_FB17          CAN_F4R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F4R1_FB18_Pos      (18U)                                           
N#define CAN_F4R1_FB18_Msk      (0x1U << CAN_F4R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F4R1_FB18          CAN_F4R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F4R1_FB19_Pos      (19U)                                           
N#define CAN_F4R1_FB19_Msk      (0x1U << CAN_F4R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F4R1_FB19          CAN_F4R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F4R1_FB20_Pos      (20U)                                           
N#define CAN_F4R1_FB20_Msk      (0x1U << CAN_F4R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F4R1_FB20          CAN_F4R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F4R1_FB21_Pos      (21U)                                           
N#define CAN_F4R1_FB21_Msk      (0x1U << CAN_F4R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F4R1_FB21          CAN_F4R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F4R1_FB22_Pos      (22U)                                           
N#define CAN_F4R1_FB22_Msk      (0x1U << CAN_F4R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F4R1_FB22          CAN_F4R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F4R1_FB23_Pos      (23U)                                           
N#define CAN_F4R1_FB23_Msk      (0x1U << CAN_F4R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F4R1_FB23          CAN_F4R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F4R1_FB24_Pos      (24U)                                           
N#define CAN_F4R1_FB24_Msk      (0x1U << CAN_F4R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F4R1_FB24          CAN_F4R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F4R1_FB25_Pos      (25U)                                           
N#define CAN_F4R1_FB25_Msk      (0x1U << CAN_F4R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F4R1_FB25          CAN_F4R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F4R1_FB26_Pos      (26U)                                           
N#define CAN_F4R1_FB26_Msk      (0x1U << CAN_F4R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F4R1_FB26          CAN_F4R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F4R1_FB27_Pos      (27U)                                           
N#define CAN_F4R1_FB27_Msk      (0x1U << CAN_F4R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F4R1_FB27          CAN_F4R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F4R1_FB28_Pos      (28U)                                           
N#define CAN_F4R1_FB28_Msk      (0x1U << CAN_F4R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F4R1_FB28          CAN_F4R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F4R1_FB29_Pos      (29U)                                           
N#define CAN_F4R1_FB29_Msk      (0x1U << CAN_F4R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F4R1_FB29          CAN_F4R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F4R1_FB30_Pos      (30U)                                           
N#define CAN_F4R1_FB30_Msk      (0x1U << CAN_F4R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F4R1_FB30          CAN_F4R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F4R1_FB31_Pos      (31U)                                           
N#define CAN_F4R1_FB31_Msk      (0x1U << CAN_F4R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F4R1_FB31          CAN_F4R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R1 register  *******************/
N#define CAN_F5R1_FB0_Pos       (0U)                                            
N#define CAN_F5R1_FB0_Msk       (0x1U << CAN_F5R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F5R1_FB0           CAN_F5R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F5R1_FB1_Pos       (1U)                                            
N#define CAN_F5R1_FB1_Msk       (0x1U << CAN_F5R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F5R1_FB1           CAN_F5R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F5R1_FB2_Pos       (2U)                                            
N#define CAN_F5R1_FB2_Msk       (0x1U << CAN_F5R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F5R1_FB2           CAN_F5R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F5R1_FB3_Pos       (3U)                                            
N#define CAN_F5R1_FB3_Msk       (0x1U << CAN_F5R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F5R1_FB3           CAN_F5R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F5R1_FB4_Pos       (4U)                                            
N#define CAN_F5R1_FB4_Msk       (0x1U << CAN_F5R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F5R1_FB4           CAN_F5R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F5R1_FB5_Pos       (5U)                                            
N#define CAN_F5R1_FB5_Msk       (0x1U << CAN_F5R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F5R1_FB5           CAN_F5R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F5R1_FB6_Pos       (6U)                                            
N#define CAN_F5R1_FB6_Msk       (0x1U << CAN_F5R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F5R1_FB6           CAN_F5R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F5R1_FB7_Pos       (7U)                                            
N#define CAN_F5R1_FB7_Msk       (0x1U << CAN_F5R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F5R1_FB7           CAN_F5R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F5R1_FB8_Pos       (8U)                                            
N#define CAN_F5R1_FB8_Msk       (0x1U << CAN_F5R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F5R1_FB8           CAN_F5R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F5R1_FB9_Pos       (9U)                                            
N#define CAN_F5R1_FB9_Msk       (0x1U << CAN_F5R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F5R1_FB9           CAN_F5R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F5R1_FB10_Pos      (10U)                                           
N#define CAN_F5R1_FB10_Msk      (0x1U << CAN_F5R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F5R1_FB10          CAN_F5R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F5R1_FB11_Pos      (11U)                                           
N#define CAN_F5R1_FB11_Msk      (0x1U << CAN_F5R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F5R1_FB11          CAN_F5R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F5R1_FB12_Pos      (12U)                                           
N#define CAN_F5R1_FB12_Msk      (0x1U << CAN_F5R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F5R1_FB12          CAN_F5R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F5R1_FB13_Pos      (13U)                                           
N#define CAN_F5R1_FB13_Msk      (0x1U << CAN_F5R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F5R1_FB13          CAN_F5R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F5R1_FB14_Pos      (14U)                                           
N#define CAN_F5R1_FB14_Msk      (0x1U << CAN_F5R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F5R1_FB14          CAN_F5R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F5R1_FB15_Pos      (15U)                                           
N#define CAN_F5R1_FB15_Msk      (0x1U << CAN_F5R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F5R1_FB15          CAN_F5R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F5R1_FB16_Pos      (16U)                                           
N#define CAN_F5R1_FB16_Msk      (0x1U << CAN_F5R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F5R1_FB16          CAN_F5R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F5R1_FB17_Pos      (17U)                                           
N#define CAN_F5R1_FB17_Msk      (0x1U << CAN_F5R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F5R1_FB17          CAN_F5R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F5R1_FB18_Pos      (18U)                                           
N#define CAN_F5R1_FB18_Msk      (0x1U << CAN_F5R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F5R1_FB18          CAN_F5R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F5R1_FB19_Pos      (19U)                                           
N#define CAN_F5R1_FB19_Msk      (0x1U << CAN_F5R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F5R1_FB19          CAN_F5R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F5R1_FB20_Pos      (20U)                                           
N#define CAN_F5R1_FB20_Msk      (0x1U << CAN_F5R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F5R1_FB20          CAN_F5R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F5R1_FB21_Pos      (21U)                                           
N#define CAN_F5R1_FB21_Msk      (0x1U << CAN_F5R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F5R1_FB21          CAN_F5R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F5R1_FB22_Pos      (22U)                                           
N#define CAN_F5R1_FB22_Msk      (0x1U << CAN_F5R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F5R1_FB22          CAN_F5R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F5R1_FB23_Pos      (23U)                                           
N#define CAN_F5R1_FB23_Msk      (0x1U << CAN_F5R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F5R1_FB23          CAN_F5R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F5R1_FB24_Pos      (24U)                                           
N#define CAN_F5R1_FB24_Msk      (0x1U << CAN_F5R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F5R1_FB24          CAN_F5R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F5R1_FB25_Pos      (25U)                                           
N#define CAN_F5R1_FB25_Msk      (0x1U << CAN_F5R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F5R1_FB25          CAN_F5R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F5R1_FB26_Pos      (26U)                                           
N#define CAN_F5R1_FB26_Msk      (0x1U << CAN_F5R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F5R1_FB26          CAN_F5R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F5R1_FB27_Pos      (27U)                                           
N#define CAN_F5R1_FB27_Msk      (0x1U << CAN_F5R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F5R1_FB27          CAN_F5R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F5R1_FB28_Pos      (28U)                                           
N#define CAN_F5R1_FB28_Msk      (0x1U << CAN_F5R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F5R1_FB28          CAN_F5R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F5R1_FB29_Pos      (29U)                                           
N#define CAN_F5R1_FB29_Msk      (0x1U << CAN_F5R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F5R1_FB29          CAN_F5R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F5R1_FB30_Pos      (30U)                                           
N#define CAN_F5R1_FB30_Msk      (0x1U << CAN_F5R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F5R1_FB30          CAN_F5R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F5R1_FB31_Pos      (31U)                                           
N#define CAN_F5R1_FB31_Msk      (0x1U << CAN_F5R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F5R1_FB31          CAN_F5R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R1 register  *******************/
N#define CAN_F6R1_FB0_Pos       (0U)                                            
N#define CAN_F6R1_FB0_Msk       (0x1U << CAN_F6R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F6R1_FB0           CAN_F6R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F6R1_FB1_Pos       (1U)                                            
N#define CAN_F6R1_FB1_Msk       (0x1U << CAN_F6R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F6R1_FB1           CAN_F6R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F6R1_FB2_Pos       (2U)                                            
N#define CAN_F6R1_FB2_Msk       (0x1U << CAN_F6R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F6R1_FB2           CAN_F6R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F6R1_FB3_Pos       (3U)                                            
N#define CAN_F6R1_FB3_Msk       (0x1U << CAN_F6R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F6R1_FB3           CAN_F6R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F6R1_FB4_Pos       (4U)                                            
N#define CAN_F6R1_FB4_Msk       (0x1U << CAN_F6R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F6R1_FB4           CAN_F6R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F6R1_FB5_Pos       (5U)                                            
N#define CAN_F6R1_FB5_Msk       (0x1U << CAN_F6R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F6R1_FB5           CAN_F6R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F6R1_FB6_Pos       (6U)                                            
N#define CAN_F6R1_FB6_Msk       (0x1U << CAN_F6R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F6R1_FB6           CAN_F6R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F6R1_FB7_Pos       (7U)                                            
N#define CAN_F6R1_FB7_Msk       (0x1U << CAN_F6R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F6R1_FB7           CAN_F6R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F6R1_FB8_Pos       (8U)                                            
N#define CAN_F6R1_FB8_Msk       (0x1U << CAN_F6R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F6R1_FB8           CAN_F6R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F6R1_FB9_Pos       (9U)                                            
N#define CAN_F6R1_FB9_Msk       (0x1U << CAN_F6R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F6R1_FB9           CAN_F6R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F6R1_FB10_Pos      (10U)                                           
N#define CAN_F6R1_FB10_Msk      (0x1U << CAN_F6R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F6R1_FB10          CAN_F6R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F6R1_FB11_Pos      (11U)                                           
N#define CAN_F6R1_FB11_Msk      (0x1U << CAN_F6R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F6R1_FB11          CAN_F6R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F6R1_FB12_Pos      (12U)                                           
N#define CAN_F6R1_FB12_Msk      (0x1U << CAN_F6R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F6R1_FB12          CAN_F6R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F6R1_FB13_Pos      (13U)                                           
N#define CAN_F6R1_FB13_Msk      (0x1U << CAN_F6R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F6R1_FB13          CAN_F6R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F6R1_FB14_Pos      (14U)                                           
N#define CAN_F6R1_FB14_Msk      (0x1U << CAN_F6R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F6R1_FB14          CAN_F6R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F6R1_FB15_Pos      (15U)                                           
N#define CAN_F6R1_FB15_Msk      (0x1U << CAN_F6R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F6R1_FB15          CAN_F6R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F6R1_FB16_Pos      (16U)                                           
N#define CAN_F6R1_FB16_Msk      (0x1U << CAN_F6R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F6R1_FB16          CAN_F6R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F6R1_FB17_Pos      (17U)                                           
N#define CAN_F6R1_FB17_Msk      (0x1U << CAN_F6R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F6R1_FB17          CAN_F6R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F6R1_FB18_Pos      (18U)                                           
N#define CAN_F6R1_FB18_Msk      (0x1U << CAN_F6R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F6R1_FB18          CAN_F6R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F6R1_FB19_Pos      (19U)                                           
N#define CAN_F6R1_FB19_Msk      (0x1U << CAN_F6R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F6R1_FB19          CAN_F6R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F6R1_FB20_Pos      (20U)                                           
N#define CAN_F6R1_FB20_Msk      (0x1U << CAN_F6R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F6R1_FB20          CAN_F6R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F6R1_FB21_Pos      (21U)                                           
N#define CAN_F6R1_FB21_Msk      (0x1U << CAN_F6R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F6R1_FB21          CAN_F6R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F6R1_FB22_Pos      (22U)                                           
N#define CAN_F6R1_FB22_Msk      (0x1U << CAN_F6R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F6R1_FB22          CAN_F6R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F6R1_FB23_Pos      (23U)                                           
N#define CAN_F6R1_FB23_Msk      (0x1U << CAN_F6R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F6R1_FB23          CAN_F6R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F6R1_FB24_Pos      (24U)                                           
N#define CAN_F6R1_FB24_Msk      (0x1U << CAN_F6R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F6R1_FB24          CAN_F6R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F6R1_FB25_Pos      (25U)                                           
N#define CAN_F6R1_FB25_Msk      (0x1U << CAN_F6R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F6R1_FB25          CAN_F6R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F6R1_FB26_Pos      (26U)                                           
N#define CAN_F6R1_FB26_Msk      (0x1U << CAN_F6R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F6R1_FB26          CAN_F6R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F6R1_FB27_Pos      (27U)                                           
N#define CAN_F6R1_FB27_Msk      (0x1U << CAN_F6R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F6R1_FB27          CAN_F6R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F6R1_FB28_Pos      (28U)                                           
N#define CAN_F6R1_FB28_Msk      (0x1U << CAN_F6R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F6R1_FB28          CAN_F6R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F6R1_FB29_Pos      (29U)                                           
N#define CAN_F6R1_FB29_Msk      (0x1U << CAN_F6R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F6R1_FB29          CAN_F6R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F6R1_FB30_Pos      (30U)                                           
N#define CAN_F6R1_FB30_Msk      (0x1U << CAN_F6R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F6R1_FB30          CAN_F6R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F6R1_FB31_Pos      (31U)                                           
N#define CAN_F6R1_FB31_Msk      (0x1U << CAN_F6R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F6R1_FB31          CAN_F6R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R1 register  *******************/
N#define CAN_F7R1_FB0_Pos       (0U)                                            
N#define CAN_F7R1_FB0_Msk       (0x1U << CAN_F7R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F7R1_FB0           CAN_F7R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F7R1_FB1_Pos       (1U)                                            
N#define CAN_F7R1_FB1_Msk       (0x1U << CAN_F7R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F7R1_FB1           CAN_F7R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F7R1_FB2_Pos       (2U)                                            
N#define CAN_F7R1_FB2_Msk       (0x1U << CAN_F7R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F7R1_FB2           CAN_F7R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F7R1_FB3_Pos       (3U)                                            
N#define CAN_F7R1_FB3_Msk       (0x1U << CAN_F7R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F7R1_FB3           CAN_F7R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F7R1_FB4_Pos       (4U)                                            
N#define CAN_F7R1_FB4_Msk       (0x1U << CAN_F7R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F7R1_FB4           CAN_F7R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F7R1_FB5_Pos       (5U)                                            
N#define CAN_F7R1_FB5_Msk       (0x1U << CAN_F7R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F7R1_FB5           CAN_F7R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F7R1_FB6_Pos       (6U)                                            
N#define CAN_F7R1_FB6_Msk       (0x1U << CAN_F7R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F7R1_FB6           CAN_F7R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F7R1_FB7_Pos       (7U)                                            
N#define CAN_F7R1_FB7_Msk       (0x1U << CAN_F7R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F7R1_FB7           CAN_F7R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F7R1_FB8_Pos       (8U)                                            
N#define CAN_F7R1_FB8_Msk       (0x1U << CAN_F7R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F7R1_FB8           CAN_F7R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F7R1_FB9_Pos       (9U)                                            
N#define CAN_F7R1_FB9_Msk       (0x1U << CAN_F7R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F7R1_FB9           CAN_F7R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F7R1_FB10_Pos      (10U)                                           
N#define CAN_F7R1_FB10_Msk      (0x1U << CAN_F7R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F7R1_FB10          CAN_F7R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F7R1_FB11_Pos      (11U)                                           
N#define CAN_F7R1_FB11_Msk      (0x1U << CAN_F7R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F7R1_FB11          CAN_F7R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F7R1_FB12_Pos      (12U)                                           
N#define CAN_F7R1_FB12_Msk      (0x1U << CAN_F7R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F7R1_FB12          CAN_F7R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F7R1_FB13_Pos      (13U)                                           
N#define CAN_F7R1_FB13_Msk      (0x1U << CAN_F7R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F7R1_FB13          CAN_F7R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F7R1_FB14_Pos      (14U)                                           
N#define CAN_F7R1_FB14_Msk      (0x1U << CAN_F7R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F7R1_FB14          CAN_F7R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F7R1_FB15_Pos      (15U)                                           
N#define CAN_F7R1_FB15_Msk      (0x1U << CAN_F7R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F7R1_FB15          CAN_F7R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F7R1_FB16_Pos      (16U)                                           
N#define CAN_F7R1_FB16_Msk      (0x1U << CAN_F7R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F7R1_FB16          CAN_F7R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F7R1_FB17_Pos      (17U)                                           
N#define CAN_F7R1_FB17_Msk      (0x1U << CAN_F7R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F7R1_FB17          CAN_F7R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F7R1_FB18_Pos      (18U)                                           
N#define CAN_F7R1_FB18_Msk      (0x1U << CAN_F7R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F7R1_FB18          CAN_F7R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F7R1_FB19_Pos      (19U)                                           
N#define CAN_F7R1_FB19_Msk      (0x1U << CAN_F7R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F7R1_FB19          CAN_F7R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F7R1_FB20_Pos      (20U)                                           
N#define CAN_F7R1_FB20_Msk      (0x1U << CAN_F7R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F7R1_FB20          CAN_F7R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F7R1_FB21_Pos      (21U)                                           
N#define CAN_F7R1_FB21_Msk      (0x1U << CAN_F7R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F7R1_FB21          CAN_F7R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F7R1_FB22_Pos      (22U)                                           
N#define CAN_F7R1_FB22_Msk      (0x1U << CAN_F7R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F7R1_FB22          CAN_F7R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F7R1_FB23_Pos      (23U)                                           
N#define CAN_F7R1_FB23_Msk      (0x1U << CAN_F7R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F7R1_FB23          CAN_F7R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F7R1_FB24_Pos      (24U)                                           
N#define CAN_F7R1_FB24_Msk      (0x1U << CAN_F7R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F7R1_FB24          CAN_F7R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F7R1_FB25_Pos      (25U)                                           
N#define CAN_F7R1_FB25_Msk      (0x1U << CAN_F7R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F7R1_FB25          CAN_F7R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F7R1_FB26_Pos      (26U)                                           
N#define CAN_F7R1_FB26_Msk      (0x1U << CAN_F7R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F7R1_FB26          CAN_F7R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F7R1_FB27_Pos      (27U)                                           
N#define CAN_F7R1_FB27_Msk      (0x1U << CAN_F7R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F7R1_FB27          CAN_F7R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F7R1_FB28_Pos      (28U)                                           
N#define CAN_F7R1_FB28_Msk      (0x1U << CAN_F7R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F7R1_FB28          CAN_F7R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F7R1_FB29_Pos      (29U)                                           
N#define CAN_F7R1_FB29_Msk      (0x1U << CAN_F7R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F7R1_FB29          CAN_F7R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F7R1_FB30_Pos      (30U)                                           
N#define CAN_F7R1_FB30_Msk      (0x1U << CAN_F7R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F7R1_FB30          CAN_F7R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F7R1_FB31_Pos      (31U)                                           
N#define CAN_F7R1_FB31_Msk      (0x1U << CAN_F7R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F7R1_FB31          CAN_F7R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R1 register  *******************/
N#define CAN_F8R1_FB0_Pos       (0U)                                            
N#define CAN_F8R1_FB0_Msk       (0x1U << CAN_F8R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F8R1_FB0           CAN_F8R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F8R1_FB1_Pos       (1U)                                            
N#define CAN_F8R1_FB1_Msk       (0x1U << CAN_F8R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F8R1_FB1           CAN_F8R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F8R1_FB2_Pos       (2U)                                            
N#define CAN_F8R1_FB2_Msk       (0x1U << CAN_F8R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F8R1_FB2           CAN_F8R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F8R1_FB3_Pos       (3U)                                            
N#define CAN_F8R1_FB3_Msk       (0x1U << CAN_F8R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F8R1_FB3           CAN_F8R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F8R1_FB4_Pos       (4U)                                            
N#define CAN_F8R1_FB4_Msk       (0x1U << CAN_F8R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F8R1_FB4           CAN_F8R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F8R1_FB5_Pos       (5U)                                            
N#define CAN_F8R1_FB5_Msk       (0x1U << CAN_F8R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F8R1_FB5           CAN_F8R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F8R1_FB6_Pos       (6U)                                            
N#define CAN_F8R1_FB6_Msk       (0x1U << CAN_F8R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F8R1_FB6           CAN_F8R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F8R1_FB7_Pos       (7U)                                            
N#define CAN_F8R1_FB7_Msk       (0x1U << CAN_F8R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F8R1_FB7           CAN_F8R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F8R1_FB8_Pos       (8U)                                            
N#define CAN_F8R1_FB8_Msk       (0x1U << CAN_F8R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F8R1_FB8           CAN_F8R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F8R1_FB9_Pos       (9U)                                            
N#define CAN_F8R1_FB9_Msk       (0x1U << CAN_F8R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F8R1_FB9           CAN_F8R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F8R1_FB10_Pos      (10U)                                           
N#define CAN_F8R1_FB10_Msk      (0x1U << CAN_F8R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F8R1_FB10          CAN_F8R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F8R1_FB11_Pos      (11U)                                           
N#define CAN_F8R1_FB11_Msk      (0x1U << CAN_F8R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F8R1_FB11          CAN_F8R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F8R1_FB12_Pos      (12U)                                           
N#define CAN_F8R1_FB12_Msk      (0x1U << CAN_F8R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F8R1_FB12          CAN_F8R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F8R1_FB13_Pos      (13U)                                           
N#define CAN_F8R1_FB13_Msk      (0x1U << CAN_F8R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F8R1_FB13          CAN_F8R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F8R1_FB14_Pos      (14U)                                           
N#define CAN_F8R1_FB14_Msk      (0x1U << CAN_F8R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F8R1_FB14          CAN_F8R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F8R1_FB15_Pos      (15U)                                           
N#define CAN_F8R1_FB15_Msk      (0x1U << CAN_F8R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F8R1_FB15          CAN_F8R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F8R1_FB16_Pos      (16U)                                           
N#define CAN_F8R1_FB16_Msk      (0x1U << CAN_F8R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F8R1_FB16          CAN_F8R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F8R1_FB17_Pos      (17U)                                           
N#define CAN_F8R1_FB17_Msk      (0x1U << CAN_F8R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F8R1_FB17          CAN_F8R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F8R1_FB18_Pos      (18U)                                           
N#define CAN_F8R1_FB18_Msk      (0x1U << CAN_F8R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F8R1_FB18          CAN_F8R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F8R1_FB19_Pos      (19U)                                           
N#define CAN_F8R1_FB19_Msk      (0x1U << CAN_F8R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F8R1_FB19          CAN_F8R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F8R1_FB20_Pos      (20U)                                           
N#define CAN_F8R1_FB20_Msk      (0x1U << CAN_F8R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F8R1_FB20          CAN_F8R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F8R1_FB21_Pos      (21U)                                           
N#define CAN_F8R1_FB21_Msk      (0x1U << CAN_F8R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F8R1_FB21          CAN_F8R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F8R1_FB22_Pos      (22U)                                           
N#define CAN_F8R1_FB22_Msk      (0x1U << CAN_F8R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F8R1_FB22          CAN_F8R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F8R1_FB23_Pos      (23U)                                           
N#define CAN_F8R1_FB23_Msk      (0x1U << CAN_F8R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F8R1_FB23          CAN_F8R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F8R1_FB24_Pos      (24U)                                           
N#define CAN_F8R1_FB24_Msk      (0x1U << CAN_F8R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F8R1_FB24          CAN_F8R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F8R1_FB25_Pos      (25U)                                           
N#define CAN_F8R1_FB25_Msk      (0x1U << CAN_F8R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F8R1_FB25          CAN_F8R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F8R1_FB26_Pos      (26U)                                           
N#define CAN_F8R1_FB26_Msk      (0x1U << CAN_F8R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F8R1_FB26          CAN_F8R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F8R1_FB27_Pos      (27U)                                           
N#define CAN_F8R1_FB27_Msk      (0x1U << CAN_F8R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F8R1_FB27          CAN_F8R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F8R1_FB28_Pos      (28U)                                           
N#define CAN_F8R1_FB28_Msk      (0x1U << CAN_F8R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F8R1_FB28          CAN_F8R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F8R1_FB29_Pos      (29U)                                           
N#define CAN_F8R1_FB29_Msk      (0x1U << CAN_F8R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F8R1_FB29          CAN_F8R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F8R1_FB30_Pos      (30U)                                           
N#define CAN_F8R1_FB30_Msk      (0x1U << CAN_F8R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F8R1_FB30          CAN_F8R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F8R1_FB31_Pos      (31U)                                           
N#define CAN_F8R1_FB31_Msk      (0x1U << CAN_F8R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F8R1_FB31          CAN_F8R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R1 register  *******************/
N#define CAN_F9R1_FB0_Pos       (0U)                                            
N#define CAN_F9R1_FB0_Msk       (0x1U << CAN_F9R1_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F9R1_FB0           CAN_F9R1_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F9R1_FB1_Pos       (1U)                                            
N#define CAN_F9R1_FB1_Msk       (0x1U << CAN_F9R1_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F9R1_FB1           CAN_F9R1_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F9R1_FB2_Pos       (2U)                                            
N#define CAN_F9R1_FB2_Msk       (0x1U << CAN_F9R1_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F9R1_FB2           CAN_F9R1_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F9R1_FB3_Pos       (3U)                                            
N#define CAN_F9R1_FB3_Msk       (0x1U << CAN_F9R1_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F9R1_FB3           CAN_F9R1_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F9R1_FB4_Pos       (4U)                                            
N#define CAN_F9R1_FB4_Msk       (0x1U << CAN_F9R1_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F9R1_FB4           CAN_F9R1_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F9R1_FB5_Pos       (5U)                                            
N#define CAN_F9R1_FB5_Msk       (0x1U << CAN_F9R1_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F9R1_FB5           CAN_F9R1_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F9R1_FB6_Pos       (6U)                                            
N#define CAN_F9R1_FB6_Msk       (0x1U << CAN_F9R1_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F9R1_FB6           CAN_F9R1_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F9R1_FB7_Pos       (7U)                                            
N#define CAN_F9R1_FB7_Msk       (0x1U << CAN_F9R1_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F9R1_FB7           CAN_F9R1_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F9R1_FB8_Pos       (8U)                                            
N#define CAN_F9R1_FB8_Msk       (0x1U << CAN_F9R1_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F9R1_FB8           CAN_F9R1_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F9R1_FB9_Pos       (9U)                                            
N#define CAN_F9R1_FB9_Msk       (0x1U << CAN_F9R1_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F9R1_FB9           CAN_F9R1_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F9R1_FB10_Pos      (10U)                                           
N#define CAN_F9R1_FB10_Msk      (0x1U << CAN_F9R1_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F9R1_FB10          CAN_F9R1_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F9R1_FB11_Pos      (11U)                                           
N#define CAN_F9R1_FB11_Msk      (0x1U << CAN_F9R1_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F9R1_FB11          CAN_F9R1_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F9R1_FB12_Pos      (12U)                                           
N#define CAN_F9R1_FB12_Msk      (0x1U << CAN_F9R1_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F9R1_FB12          CAN_F9R1_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F9R1_FB13_Pos      (13U)                                           
N#define CAN_F9R1_FB13_Msk      (0x1U << CAN_F9R1_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F9R1_FB13          CAN_F9R1_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F9R1_FB14_Pos      (14U)                                           
N#define CAN_F9R1_FB14_Msk      (0x1U << CAN_F9R1_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F9R1_FB14          CAN_F9R1_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F9R1_FB15_Pos      (15U)                                           
N#define CAN_F9R1_FB15_Msk      (0x1U << CAN_F9R1_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F9R1_FB15          CAN_F9R1_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F9R1_FB16_Pos      (16U)                                           
N#define CAN_F9R1_FB16_Msk      (0x1U << CAN_F9R1_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F9R1_FB16          CAN_F9R1_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F9R1_FB17_Pos      (17U)                                           
N#define CAN_F9R1_FB17_Msk      (0x1U << CAN_F9R1_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F9R1_FB17          CAN_F9R1_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F9R1_FB18_Pos      (18U)                                           
N#define CAN_F9R1_FB18_Msk      (0x1U << CAN_F9R1_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F9R1_FB18          CAN_F9R1_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F9R1_FB19_Pos      (19U)                                           
N#define CAN_F9R1_FB19_Msk      (0x1U << CAN_F9R1_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F9R1_FB19          CAN_F9R1_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F9R1_FB20_Pos      (20U)                                           
N#define CAN_F9R1_FB20_Msk      (0x1U << CAN_F9R1_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F9R1_FB20          CAN_F9R1_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F9R1_FB21_Pos      (21U)                                           
N#define CAN_F9R1_FB21_Msk      (0x1U << CAN_F9R1_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F9R1_FB21          CAN_F9R1_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F9R1_FB22_Pos      (22U)                                           
N#define CAN_F9R1_FB22_Msk      (0x1U << CAN_F9R1_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F9R1_FB22          CAN_F9R1_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F9R1_FB23_Pos      (23U)                                           
N#define CAN_F9R1_FB23_Msk      (0x1U << CAN_F9R1_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F9R1_FB23          CAN_F9R1_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F9R1_FB24_Pos      (24U)                                           
N#define CAN_F9R1_FB24_Msk      (0x1U << CAN_F9R1_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F9R1_FB24          CAN_F9R1_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F9R1_FB25_Pos      (25U)                                           
N#define CAN_F9R1_FB25_Msk      (0x1U << CAN_F9R1_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F9R1_FB25          CAN_F9R1_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F9R1_FB26_Pos      (26U)                                           
N#define CAN_F9R1_FB26_Msk      (0x1U << CAN_F9R1_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F9R1_FB26          CAN_F9R1_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F9R1_FB27_Pos      (27U)                                           
N#define CAN_F9R1_FB27_Msk      (0x1U << CAN_F9R1_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F9R1_FB27          CAN_F9R1_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F9R1_FB28_Pos      (28U)                                           
N#define CAN_F9R1_FB28_Msk      (0x1U << CAN_F9R1_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F9R1_FB28          CAN_F9R1_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F9R1_FB29_Pos      (29U)                                           
N#define CAN_F9R1_FB29_Msk      (0x1U << CAN_F9R1_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F9R1_FB29          CAN_F9R1_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F9R1_FB30_Pos      (30U)                                           
N#define CAN_F9R1_FB30_Msk      (0x1U << CAN_F9R1_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F9R1_FB30          CAN_F9R1_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F9R1_FB31_Pos      (31U)                                           
N#define CAN_F9R1_FB31_Msk      (0x1U << CAN_F9R1_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F9R1_FB31          CAN_F9R1_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R1 register  ******************/
N#define CAN_F10R1_FB0_Pos      (0U)                                            
N#define CAN_F10R1_FB0_Msk      (0x1U << CAN_F10R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F10R1_FB0          CAN_F10R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F10R1_FB1_Pos      (1U)                                            
N#define CAN_F10R1_FB1_Msk      (0x1U << CAN_F10R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F10R1_FB1          CAN_F10R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F10R1_FB2_Pos      (2U)                                            
N#define CAN_F10R1_FB2_Msk      (0x1U << CAN_F10R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F10R1_FB2          CAN_F10R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F10R1_FB3_Pos      (3U)                                            
N#define CAN_F10R1_FB3_Msk      (0x1U << CAN_F10R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F10R1_FB3          CAN_F10R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F10R1_FB4_Pos      (4U)                                            
N#define CAN_F10R1_FB4_Msk      (0x1U << CAN_F10R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F10R1_FB4          CAN_F10R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F10R1_FB5_Pos      (5U)                                            
N#define CAN_F10R1_FB5_Msk      (0x1U << CAN_F10R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F10R1_FB5          CAN_F10R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F10R1_FB6_Pos      (6U)                                            
N#define CAN_F10R1_FB6_Msk      (0x1U << CAN_F10R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F10R1_FB6          CAN_F10R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F10R1_FB7_Pos      (7U)                                            
N#define CAN_F10R1_FB7_Msk      (0x1U << CAN_F10R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F10R1_FB7          CAN_F10R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F10R1_FB8_Pos      (8U)                                            
N#define CAN_F10R1_FB8_Msk      (0x1U << CAN_F10R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F10R1_FB8          CAN_F10R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F10R1_FB9_Pos      (9U)                                            
N#define CAN_F10R1_FB9_Msk      (0x1U << CAN_F10R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F10R1_FB9          CAN_F10R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F10R1_FB10_Pos     (10U)                                           
N#define CAN_F10R1_FB10_Msk     (0x1U << CAN_F10R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F10R1_FB10         CAN_F10R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F10R1_FB11_Pos     (11U)                                           
N#define CAN_F10R1_FB11_Msk     (0x1U << CAN_F10R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F10R1_FB11         CAN_F10R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F10R1_FB12_Pos     (12U)                                           
N#define CAN_F10R1_FB12_Msk     (0x1U << CAN_F10R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F10R1_FB12         CAN_F10R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F10R1_FB13_Pos     (13U)                                           
N#define CAN_F10R1_FB13_Msk     (0x1U << CAN_F10R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F10R1_FB13         CAN_F10R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F10R1_FB14_Pos     (14U)                                           
N#define CAN_F10R1_FB14_Msk     (0x1U << CAN_F10R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F10R1_FB14         CAN_F10R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F10R1_FB15_Pos     (15U)                                           
N#define CAN_F10R1_FB15_Msk     (0x1U << CAN_F10R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F10R1_FB15         CAN_F10R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F10R1_FB16_Pos     (16U)                                           
N#define CAN_F10R1_FB16_Msk     (0x1U << CAN_F10R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F10R1_FB16         CAN_F10R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F10R1_FB17_Pos     (17U)                                           
N#define CAN_F10R1_FB17_Msk     (0x1U << CAN_F10R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F10R1_FB17         CAN_F10R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F10R1_FB18_Pos     (18U)                                           
N#define CAN_F10R1_FB18_Msk     (0x1U << CAN_F10R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F10R1_FB18         CAN_F10R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F10R1_FB19_Pos     (19U)                                           
N#define CAN_F10R1_FB19_Msk     (0x1U << CAN_F10R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F10R1_FB19         CAN_F10R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F10R1_FB20_Pos     (20U)                                           
N#define CAN_F10R1_FB20_Msk     (0x1U << CAN_F10R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F10R1_FB20         CAN_F10R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F10R1_FB21_Pos     (21U)                                           
N#define CAN_F10R1_FB21_Msk     (0x1U << CAN_F10R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F10R1_FB21         CAN_F10R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F10R1_FB22_Pos     (22U)                                           
N#define CAN_F10R1_FB22_Msk     (0x1U << CAN_F10R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F10R1_FB22         CAN_F10R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F10R1_FB23_Pos     (23U)                                           
N#define CAN_F10R1_FB23_Msk     (0x1U << CAN_F10R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F10R1_FB23         CAN_F10R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F10R1_FB24_Pos     (24U)                                           
N#define CAN_F10R1_FB24_Msk     (0x1U << CAN_F10R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F10R1_FB24         CAN_F10R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F10R1_FB25_Pos     (25U)                                           
N#define CAN_F10R1_FB25_Msk     (0x1U << CAN_F10R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F10R1_FB25         CAN_F10R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F10R1_FB26_Pos     (26U)                                           
N#define CAN_F10R1_FB26_Msk     (0x1U << CAN_F10R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F10R1_FB26         CAN_F10R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F10R1_FB27_Pos     (27U)                                           
N#define CAN_F10R1_FB27_Msk     (0x1U << CAN_F10R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F10R1_FB27         CAN_F10R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F10R1_FB28_Pos     (28U)                                           
N#define CAN_F10R1_FB28_Msk     (0x1U << CAN_F10R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F10R1_FB28         CAN_F10R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F10R1_FB29_Pos     (29U)                                           
N#define CAN_F10R1_FB29_Msk     (0x1U << CAN_F10R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F10R1_FB29         CAN_F10R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F10R1_FB30_Pos     (30U)                                           
N#define CAN_F10R1_FB30_Msk     (0x1U << CAN_F10R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F10R1_FB30         CAN_F10R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F10R1_FB31_Pos     (31U)                                           
N#define CAN_F10R1_FB31_Msk     (0x1U << CAN_F10R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F10R1_FB31         CAN_F10R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R1 register  ******************/
N#define CAN_F11R1_FB0_Pos      (0U)                                            
N#define CAN_F11R1_FB0_Msk      (0x1U << CAN_F11R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F11R1_FB0          CAN_F11R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F11R1_FB1_Pos      (1U)                                            
N#define CAN_F11R1_FB1_Msk      (0x1U << CAN_F11R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F11R1_FB1          CAN_F11R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F11R1_FB2_Pos      (2U)                                            
N#define CAN_F11R1_FB2_Msk      (0x1U << CAN_F11R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F11R1_FB2          CAN_F11R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F11R1_FB3_Pos      (3U)                                            
N#define CAN_F11R1_FB3_Msk      (0x1U << CAN_F11R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F11R1_FB3          CAN_F11R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F11R1_FB4_Pos      (4U)                                            
N#define CAN_F11R1_FB4_Msk      (0x1U << CAN_F11R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F11R1_FB4          CAN_F11R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F11R1_FB5_Pos      (5U)                                            
N#define CAN_F11R1_FB5_Msk      (0x1U << CAN_F11R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F11R1_FB5          CAN_F11R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F11R1_FB6_Pos      (6U)                                            
N#define CAN_F11R1_FB6_Msk      (0x1U << CAN_F11R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F11R1_FB6          CAN_F11R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F11R1_FB7_Pos      (7U)                                            
N#define CAN_F11R1_FB7_Msk      (0x1U << CAN_F11R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F11R1_FB7          CAN_F11R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F11R1_FB8_Pos      (8U)                                            
N#define CAN_F11R1_FB8_Msk      (0x1U << CAN_F11R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F11R1_FB8          CAN_F11R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F11R1_FB9_Pos      (9U)                                            
N#define CAN_F11R1_FB9_Msk      (0x1U << CAN_F11R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F11R1_FB9          CAN_F11R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F11R1_FB10_Pos     (10U)                                           
N#define CAN_F11R1_FB10_Msk     (0x1U << CAN_F11R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F11R1_FB10         CAN_F11R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F11R1_FB11_Pos     (11U)                                           
N#define CAN_F11R1_FB11_Msk     (0x1U << CAN_F11R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F11R1_FB11         CAN_F11R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F11R1_FB12_Pos     (12U)                                           
N#define CAN_F11R1_FB12_Msk     (0x1U << CAN_F11R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F11R1_FB12         CAN_F11R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F11R1_FB13_Pos     (13U)                                           
N#define CAN_F11R1_FB13_Msk     (0x1U << CAN_F11R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F11R1_FB13         CAN_F11R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F11R1_FB14_Pos     (14U)                                           
N#define CAN_F11R1_FB14_Msk     (0x1U << CAN_F11R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F11R1_FB14         CAN_F11R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F11R1_FB15_Pos     (15U)                                           
N#define CAN_F11R1_FB15_Msk     (0x1U << CAN_F11R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F11R1_FB15         CAN_F11R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F11R1_FB16_Pos     (16U)                                           
N#define CAN_F11R1_FB16_Msk     (0x1U << CAN_F11R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F11R1_FB16         CAN_F11R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F11R1_FB17_Pos     (17U)                                           
N#define CAN_F11R1_FB17_Msk     (0x1U << CAN_F11R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F11R1_FB17         CAN_F11R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F11R1_FB18_Pos     (18U)                                           
N#define CAN_F11R1_FB18_Msk     (0x1U << CAN_F11R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F11R1_FB18         CAN_F11R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F11R1_FB19_Pos     (19U)                                           
N#define CAN_F11R1_FB19_Msk     (0x1U << CAN_F11R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F11R1_FB19         CAN_F11R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F11R1_FB20_Pos     (20U)                                           
N#define CAN_F11R1_FB20_Msk     (0x1U << CAN_F11R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F11R1_FB20         CAN_F11R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F11R1_FB21_Pos     (21U)                                           
N#define CAN_F11R1_FB21_Msk     (0x1U << CAN_F11R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F11R1_FB21         CAN_F11R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F11R1_FB22_Pos     (22U)                                           
N#define CAN_F11R1_FB22_Msk     (0x1U << CAN_F11R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F11R1_FB22         CAN_F11R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F11R1_FB23_Pos     (23U)                                           
N#define CAN_F11R1_FB23_Msk     (0x1U << CAN_F11R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F11R1_FB23         CAN_F11R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F11R1_FB24_Pos     (24U)                                           
N#define CAN_F11R1_FB24_Msk     (0x1U << CAN_F11R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F11R1_FB24         CAN_F11R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F11R1_FB25_Pos     (25U)                                           
N#define CAN_F11R1_FB25_Msk     (0x1U << CAN_F11R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F11R1_FB25         CAN_F11R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F11R1_FB26_Pos     (26U)                                           
N#define CAN_F11R1_FB26_Msk     (0x1U << CAN_F11R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F11R1_FB26         CAN_F11R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F11R1_FB27_Pos     (27U)                                           
N#define CAN_F11R1_FB27_Msk     (0x1U << CAN_F11R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F11R1_FB27         CAN_F11R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F11R1_FB28_Pos     (28U)                                           
N#define CAN_F11R1_FB28_Msk     (0x1U << CAN_F11R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F11R1_FB28         CAN_F11R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F11R1_FB29_Pos     (29U)                                           
N#define CAN_F11R1_FB29_Msk     (0x1U << CAN_F11R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F11R1_FB29         CAN_F11R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F11R1_FB30_Pos     (30U)                                           
N#define CAN_F11R1_FB30_Msk     (0x1U << CAN_F11R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F11R1_FB30         CAN_F11R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F11R1_FB31_Pos     (31U)                                           
N#define CAN_F11R1_FB31_Msk     (0x1U << CAN_F11R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F11R1_FB31         CAN_F11R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R1 register  ******************/
N#define CAN_F12R1_FB0_Pos      (0U)                                            
N#define CAN_F12R1_FB0_Msk      (0x1U << CAN_F12R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F12R1_FB0          CAN_F12R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F12R1_FB1_Pos      (1U)                                            
N#define CAN_F12R1_FB1_Msk      (0x1U << CAN_F12R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F12R1_FB1          CAN_F12R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F12R1_FB2_Pos      (2U)                                            
N#define CAN_F12R1_FB2_Msk      (0x1U << CAN_F12R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F12R1_FB2          CAN_F12R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F12R1_FB3_Pos      (3U)                                            
N#define CAN_F12R1_FB3_Msk      (0x1U << CAN_F12R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F12R1_FB3          CAN_F12R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F12R1_FB4_Pos      (4U)                                            
N#define CAN_F12R1_FB4_Msk      (0x1U << CAN_F12R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F12R1_FB4          CAN_F12R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F12R1_FB5_Pos      (5U)                                            
N#define CAN_F12R1_FB5_Msk      (0x1U << CAN_F12R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F12R1_FB5          CAN_F12R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F12R1_FB6_Pos      (6U)                                            
N#define CAN_F12R1_FB6_Msk      (0x1U << CAN_F12R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F12R1_FB6          CAN_F12R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F12R1_FB7_Pos      (7U)                                            
N#define CAN_F12R1_FB7_Msk      (0x1U << CAN_F12R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F12R1_FB7          CAN_F12R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F12R1_FB8_Pos      (8U)                                            
N#define CAN_F12R1_FB8_Msk      (0x1U << CAN_F12R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F12R1_FB8          CAN_F12R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F12R1_FB9_Pos      (9U)                                            
N#define CAN_F12R1_FB9_Msk      (0x1U << CAN_F12R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F12R1_FB9          CAN_F12R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F12R1_FB10_Pos     (10U)                                           
N#define CAN_F12R1_FB10_Msk     (0x1U << CAN_F12R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F12R1_FB10         CAN_F12R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F12R1_FB11_Pos     (11U)                                           
N#define CAN_F12R1_FB11_Msk     (0x1U << CAN_F12R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F12R1_FB11         CAN_F12R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F12R1_FB12_Pos     (12U)                                           
N#define CAN_F12R1_FB12_Msk     (0x1U << CAN_F12R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F12R1_FB12         CAN_F12R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F12R1_FB13_Pos     (13U)                                           
N#define CAN_F12R1_FB13_Msk     (0x1U << CAN_F12R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F12R1_FB13         CAN_F12R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F12R1_FB14_Pos     (14U)                                           
N#define CAN_F12R1_FB14_Msk     (0x1U << CAN_F12R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F12R1_FB14         CAN_F12R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F12R1_FB15_Pos     (15U)                                           
N#define CAN_F12R1_FB15_Msk     (0x1U << CAN_F12R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F12R1_FB15         CAN_F12R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F12R1_FB16_Pos     (16U)                                           
N#define CAN_F12R1_FB16_Msk     (0x1U << CAN_F12R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F12R1_FB16         CAN_F12R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F12R1_FB17_Pos     (17U)                                           
N#define CAN_F12R1_FB17_Msk     (0x1U << CAN_F12R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F12R1_FB17         CAN_F12R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F12R1_FB18_Pos     (18U)                                           
N#define CAN_F12R1_FB18_Msk     (0x1U << CAN_F12R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F12R1_FB18         CAN_F12R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F12R1_FB19_Pos     (19U)                                           
N#define CAN_F12R1_FB19_Msk     (0x1U << CAN_F12R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F12R1_FB19         CAN_F12R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F12R1_FB20_Pos     (20U)                                           
N#define CAN_F12R1_FB20_Msk     (0x1U << CAN_F12R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F12R1_FB20         CAN_F12R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F12R1_FB21_Pos     (21U)                                           
N#define CAN_F12R1_FB21_Msk     (0x1U << CAN_F12R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F12R1_FB21         CAN_F12R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F12R1_FB22_Pos     (22U)                                           
N#define CAN_F12R1_FB22_Msk     (0x1U << CAN_F12R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F12R1_FB22         CAN_F12R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F12R1_FB23_Pos     (23U)                                           
N#define CAN_F12R1_FB23_Msk     (0x1U << CAN_F12R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F12R1_FB23         CAN_F12R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F12R1_FB24_Pos     (24U)                                           
N#define CAN_F12R1_FB24_Msk     (0x1U << CAN_F12R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F12R1_FB24         CAN_F12R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F12R1_FB25_Pos     (25U)                                           
N#define CAN_F12R1_FB25_Msk     (0x1U << CAN_F12R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F12R1_FB25         CAN_F12R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F12R1_FB26_Pos     (26U)                                           
N#define CAN_F12R1_FB26_Msk     (0x1U << CAN_F12R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F12R1_FB26         CAN_F12R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F12R1_FB27_Pos     (27U)                                           
N#define CAN_F12R1_FB27_Msk     (0x1U << CAN_F12R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F12R1_FB27         CAN_F12R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F12R1_FB28_Pos     (28U)                                           
N#define CAN_F12R1_FB28_Msk     (0x1U << CAN_F12R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F12R1_FB28         CAN_F12R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F12R1_FB29_Pos     (29U)                                           
N#define CAN_F12R1_FB29_Msk     (0x1U << CAN_F12R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F12R1_FB29         CAN_F12R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F12R1_FB30_Pos     (30U)                                           
N#define CAN_F12R1_FB30_Msk     (0x1U << CAN_F12R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F12R1_FB30         CAN_F12R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F12R1_FB31_Pos     (31U)                                           
N#define CAN_F12R1_FB31_Msk     (0x1U << CAN_F12R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F12R1_FB31         CAN_F12R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R1 register  ******************/
N#define CAN_F13R1_FB0_Pos      (0U)                                            
N#define CAN_F13R1_FB0_Msk      (0x1U << CAN_F13R1_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F13R1_FB0          CAN_F13R1_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F13R1_FB1_Pos      (1U)                                            
N#define CAN_F13R1_FB1_Msk      (0x1U << CAN_F13R1_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F13R1_FB1          CAN_F13R1_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F13R1_FB2_Pos      (2U)                                            
N#define CAN_F13R1_FB2_Msk      (0x1U << CAN_F13R1_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F13R1_FB2          CAN_F13R1_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F13R1_FB3_Pos      (3U)                                            
N#define CAN_F13R1_FB3_Msk      (0x1U << CAN_F13R1_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F13R1_FB3          CAN_F13R1_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F13R1_FB4_Pos      (4U)                                            
N#define CAN_F13R1_FB4_Msk      (0x1U << CAN_F13R1_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F13R1_FB4          CAN_F13R1_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F13R1_FB5_Pos      (5U)                                            
N#define CAN_F13R1_FB5_Msk      (0x1U << CAN_F13R1_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F13R1_FB5          CAN_F13R1_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F13R1_FB6_Pos      (6U)                                            
N#define CAN_F13R1_FB6_Msk      (0x1U << CAN_F13R1_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F13R1_FB6          CAN_F13R1_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F13R1_FB7_Pos      (7U)                                            
N#define CAN_F13R1_FB7_Msk      (0x1U << CAN_F13R1_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F13R1_FB7          CAN_F13R1_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F13R1_FB8_Pos      (8U)                                            
N#define CAN_F13R1_FB8_Msk      (0x1U << CAN_F13R1_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F13R1_FB8          CAN_F13R1_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F13R1_FB9_Pos      (9U)                                            
N#define CAN_F13R1_FB9_Msk      (0x1U << CAN_F13R1_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F13R1_FB9          CAN_F13R1_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F13R1_FB10_Pos     (10U)                                           
N#define CAN_F13R1_FB10_Msk     (0x1U << CAN_F13R1_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F13R1_FB10         CAN_F13R1_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F13R1_FB11_Pos     (11U)                                           
N#define CAN_F13R1_FB11_Msk     (0x1U << CAN_F13R1_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F13R1_FB11         CAN_F13R1_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F13R1_FB12_Pos     (12U)                                           
N#define CAN_F13R1_FB12_Msk     (0x1U << CAN_F13R1_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F13R1_FB12         CAN_F13R1_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F13R1_FB13_Pos     (13U)                                           
N#define CAN_F13R1_FB13_Msk     (0x1U << CAN_F13R1_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F13R1_FB13         CAN_F13R1_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F13R1_FB14_Pos     (14U)                                           
N#define CAN_F13R1_FB14_Msk     (0x1U << CAN_F13R1_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F13R1_FB14         CAN_F13R1_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F13R1_FB15_Pos     (15U)                                           
N#define CAN_F13R1_FB15_Msk     (0x1U << CAN_F13R1_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F13R1_FB15         CAN_F13R1_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F13R1_FB16_Pos     (16U)                                           
N#define CAN_F13R1_FB16_Msk     (0x1U << CAN_F13R1_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F13R1_FB16         CAN_F13R1_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F13R1_FB17_Pos     (17U)                                           
N#define CAN_F13R1_FB17_Msk     (0x1U << CAN_F13R1_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F13R1_FB17         CAN_F13R1_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F13R1_FB18_Pos     (18U)                                           
N#define CAN_F13R1_FB18_Msk     (0x1U << CAN_F13R1_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F13R1_FB18         CAN_F13R1_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F13R1_FB19_Pos     (19U)                                           
N#define CAN_F13R1_FB19_Msk     (0x1U << CAN_F13R1_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F13R1_FB19         CAN_F13R1_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F13R1_FB20_Pos     (20U)                                           
N#define CAN_F13R1_FB20_Msk     (0x1U << CAN_F13R1_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F13R1_FB20         CAN_F13R1_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F13R1_FB21_Pos     (21U)                                           
N#define CAN_F13R1_FB21_Msk     (0x1U << CAN_F13R1_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F13R1_FB21         CAN_F13R1_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F13R1_FB22_Pos     (22U)                                           
N#define CAN_F13R1_FB22_Msk     (0x1U << CAN_F13R1_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F13R1_FB22         CAN_F13R1_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F13R1_FB23_Pos     (23U)                                           
N#define CAN_F13R1_FB23_Msk     (0x1U << CAN_F13R1_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F13R1_FB23         CAN_F13R1_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F13R1_FB24_Pos     (24U)                                           
N#define CAN_F13R1_FB24_Msk     (0x1U << CAN_F13R1_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F13R1_FB24         CAN_F13R1_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F13R1_FB25_Pos     (25U)                                           
N#define CAN_F13R1_FB25_Msk     (0x1U << CAN_F13R1_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F13R1_FB25         CAN_F13R1_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F13R1_FB26_Pos     (26U)                                           
N#define CAN_F13R1_FB26_Msk     (0x1U << CAN_F13R1_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F13R1_FB26         CAN_F13R1_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F13R1_FB27_Pos     (27U)                                           
N#define CAN_F13R1_FB27_Msk     (0x1U << CAN_F13R1_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F13R1_FB27         CAN_F13R1_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F13R1_FB28_Pos     (28U)                                           
N#define CAN_F13R1_FB28_Msk     (0x1U << CAN_F13R1_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F13R1_FB28         CAN_F13R1_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F13R1_FB29_Pos     (29U)                                           
N#define CAN_F13R1_FB29_Msk     (0x1U << CAN_F13R1_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F13R1_FB29         CAN_F13R1_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F13R1_FB30_Pos     (30U)                                           
N#define CAN_F13R1_FB30_Msk     (0x1U << CAN_F13R1_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F13R1_FB30         CAN_F13R1_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F13R1_FB31_Pos     (31U)                                           
N#define CAN_F13R1_FB31_Msk     (0x1U << CAN_F13R1_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F13R1_FB31         CAN_F13R1_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F0R2 register  *******************/
N#define CAN_F0R2_FB0_Pos       (0U)                                            
N#define CAN_F0R2_FB0_Msk       (0x1U << CAN_F0R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F0R2_FB0           CAN_F0R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F0R2_FB1_Pos       (1U)                                            
N#define CAN_F0R2_FB1_Msk       (0x1U << CAN_F0R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F0R2_FB1           CAN_F0R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F0R2_FB2_Pos       (2U)                                            
N#define CAN_F0R2_FB2_Msk       (0x1U << CAN_F0R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F0R2_FB2           CAN_F0R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F0R2_FB3_Pos       (3U)                                            
N#define CAN_F0R2_FB3_Msk       (0x1U << CAN_F0R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F0R2_FB3           CAN_F0R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F0R2_FB4_Pos       (4U)                                            
N#define CAN_F0R2_FB4_Msk       (0x1U << CAN_F0R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F0R2_FB4           CAN_F0R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F0R2_FB5_Pos       (5U)                                            
N#define CAN_F0R2_FB5_Msk       (0x1U << CAN_F0R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F0R2_FB5           CAN_F0R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F0R2_FB6_Pos       (6U)                                            
N#define CAN_F0R2_FB6_Msk       (0x1U << CAN_F0R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F0R2_FB6           CAN_F0R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F0R2_FB7_Pos       (7U)                                            
N#define CAN_F0R2_FB7_Msk       (0x1U << CAN_F0R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F0R2_FB7           CAN_F0R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F0R2_FB8_Pos       (8U)                                            
N#define CAN_F0R2_FB8_Msk       (0x1U << CAN_F0R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F0R2_FB8           CAN_F0R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F0R2_FB9_Pos       (9U)                                            
N#define CAN_F0R2_FB9_Msk       (0x1U << CAN_F0R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F0R2_FB9           CAN_F0R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F0R2_FB10_Pos      (10U)                                           
N#define CAN_F0R2_FB10_Msk      (0x1U << CAN_F0R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F0R2_FB10          CAN_F0R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F0R2_FB11_Pos      (11U)                                           
N#define CAN_F0R2_FB11_Msk      (0x1U << CAN_F0R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F0R2_FB11          CAN_F0R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F0R2_FB12_Pos      (12U)                                           
N#define CAN_F0R2_FB12_Msk      (0x1U << CAN_F0R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F0R2_FB12          CAN_F0R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F0R2_FB13_Pos      (13U)                                           
N#define CAN_F0R2_FB13_Msk      (0x1U << CAN_F0R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F0R2_FB13          CAN_F0R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F0R2_FB14_Pos      (14U)                                           
N#define CAN_F0R2_FB14_Msk      (0x1U << CAN_F0R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F0R2_FB14          CAN_F0R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F0R2_FB15_Pos      (15U)                                           
N#define CAN_F0R2_FB15_Msk      (0x1U << CAN_F0R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F0R2_FB15          CAN_F0R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F0R2_FB16_Pos      (16U)                                           
N#define CAN_F0R2_FB16_Msk      (0x1U << CAN_F0R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F0R2_FB16          CAN_F0R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F0R2_FB17_Pos      (17U)                                           
N#define CAN_F0R2_FB17_Msk      (0x1U << CAN_F0R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F0R2_FB17          CAN_F0R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F0R2_FB18_Pos      (18U)                                           
N#define CAN_F0R2_FB18_Msk      (0x1U << CAN_F0R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F0R2_FB18          CAN_F0R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F0R2_FB19_Pos      (19U)                                           
N#define CAN_F0R2_FB19_Msk      (0x1U << CAN_F0R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F0R2_FB19          CAN_F0R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F0R2_FB20_Pos      (20U)                                           
N#define CAN_F0R2_FB20_Msk      (0x1U << CAN_F0R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F0R2_FB20          CAN_F0R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F0R2_FB21_Pos      (21U)                                           
N#define CAN_F0R2_FB21_Msk      (0x1U << CAN_F0R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F0R2_FB21          CAN_F0R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F0R2_FB22_Pos      (22U)                                           
N#define CAN_F0R2_FB22_Msk      (0x1U << CAN_F0R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F0R2_FB22          CAN_F0R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F0R2_FB23_Pos      (23U)                                           
N#define CAN_F0R2_FB23_Msk      (0x1U << CAN_F0R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F0R2_FB23          CAN_F0R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F0R2_FB24_Pos      (24U)                                           
N#define CAN_F0R2_FB24_Msk      (0x1U << CAN_F0R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F0R2_FB24          CAN_F0R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F0R2_FB25_Pos      (25U)                                           
N#define CAN_F0R2_FB25_Msk      (0x1U << CAN_F0R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F0R2_FB25          CAN_F0R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F0R2_FB26_Pos      (26U)                                           
N#define CAN_F0R2_FB26_Msk      (0x1U << CAN_F0R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F0R2_FB26          CAN_F0R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F0R2_FB27_Pos      (27U)                                           
N#define CAN_F0R2_FB27_Msk      (0x1U << CAN_F0R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F0R2_FB27          CAN_F0R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F0R2_FB28_Pos      (28U)                                           
N#define CAN_F0R2_FB28_Msk      (0x1U << CAN_F0R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F0R2_FB28          CAN_F0R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F0R2_FB29_Pos      (29U)                                           
N#define CAN_F0R2_FB29_Msk      (0x1U << CAN_F0R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F0R2_FB29          CAN_F0R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F0R2_FB30_Pos      (30U)                                           
N#define CAN_F0R2_FB30_Msk      (0x1U << CAN_F0R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F0R2_FB30          CAN_F0R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F0R2_FB31_Pos      (31U)                                           
N#define CAN_F0R2_FB31_Msk      (0x1U << CAN_F0R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F0R2_FB31          CAN_F0R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R2 register  *******************/
N#define CAN_F1R2_FB0_Pos       (0U)                                            
N#define CAN_F1R2_FB0_Msk       (0x1U << CAN_F1R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F1R2_FB0           CAN_F1R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F1R2_FB1_Pos       (1U)                                            
N#define CAN_F1R2_FB1_Msk       (0x1U << CAN_F1R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F1R2_FB1           CAN_F1R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F1R2_FB2_Pos       (2U)                                            
N#define CAN_F1R2_FB2_Msk       (0x1U << CAN_F1R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F1R2_FB2           CAN_F1R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F1R2_FB3_Pos       (3U)                                            
N#define CAN_F1R2_FB3_Msk       (0x1U << CAN_F1R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F1R2_FB3           CAN_F1R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F1R2_FB4_Pos       (4U)                                            
N#define CAN_F1R2_FB4_Msk       (0x1U << CAN_F1R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F1R2_FB4           CAN_F1R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F1R2_FB5_Pos       (5U)                                            
N#define CAN_F1R2_FB5_Msk       (0x1U << CAN_F1R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F1R2_FB5           CAN_F1R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F1R2_FB6_Pos       (6U)                                            
N#define CAN_F1R2_FB6_Msk       (0x1U << CAN_F1R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F1R2_FB6           CAN_F1R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F1R2_FB7_Pos       (7U)                                            
N#define CAN_F1R2_FB7_Msk       (0x1U << CAN_F1R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F1R2_FB7           CAN_F1R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F1R2_FB8_Pos       (8U)                                            
N#define CAN_F1R2_FB8_Msk       (0x1U << CAN_F1R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F1R2_FB8           CAN_F1R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F1R2_FB9_Pos       (9U)                                            
N#define CAN_F1R2_FB9_Msk       (0x1U << CAN_F1R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F1R2_FB9           CAN_F1R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F1R2_FB10_Pos      (10U)                                           
N#define CAN_F1R2_FB10_Msk      (0x1U << CAN_F1R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F1R2_FB10          CAN_F1R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F1R2_FB11_Pos      (11U)                                           
N#define CAN_F1R2_FB11_Msk      (0x1U << CAN_F1R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F1R2_FB11          CAN_F1R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F1R2_FB12_Pos      (12U)                                           
N#define CAN_F1R2_FB12_Msk      (0x1U << CAN_F1R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F1R2_FB12          CAN_F1R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F1R2_FB13_Pos      (13U)                                           
N#define CAN_F1R2_FB13_Msk      (0x1U << CAN_F1R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F1R2_FB13          CAN_F1R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F1R2_FB14_Pos      (14U)                                           
N#define CAN_F1R2_FB14_Msk      (0x1U << CAN_F1R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F1R2_FB14          CAN_F1R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F1R2_FB15_Pos      (15U)                                           
N#define CAN_F1R2_FB15_Msk      (0x1U << CAN_F1R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F1R2_FB15          CAN_F1R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F1R2_FB16_Pos      (16U)                                           
N#define CAN_F1R2_FB16_Msk      (0x1U << CAN_F1R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F1R2_FB16          CAN_F1R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F1R2_FB17_Pos      (17U)                                           
N#define CAN_F1R2_FB17_Msk      (0x1U << CAN_F1R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F1R2_FB17          CAN_F1R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F1R2_FB18_Pos      (18U)                                           
N#define CAN_F1R2_FB18_Msk      (0x1U << CAN_F1R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F1R2_FB18          CAN_F1R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F1R2_FB19_Pos      (19U)                                           
N#define CAN_F1R2_FB19_Msk      (0x1U << CAN_F1R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F1R2_FB19          CAN_F1R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F1R2_FB20_Pos      (20U)                                           
N#define CAN_F1R2_FB20_Msk      (0x1U << CAN_F1R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F1R2_FB20          CAN_F1R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F1R2_FB21_Pos      (21U)                                           
N#define CAN_F1R2_FB21_Msk      (0x1U << CAN_F1R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F1R2_FB21          CAN_F1R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F1R2_FB22_Pos      (22U)                                           
N#define CAN_F1R2_FB22_Msk      (0x1U << CAN_F1R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F1R2_FB22          CAN_F1R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F1R2_FB23_Pos      (23U)                                           
N#define CAN_F1R2_FB23_Msk      (0x1U << CAN_F1R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F1R2_FB23          CAN_F1R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F1R2_FB24_Pos      (24U)                                           
N#define CAN_F1R2_FB24_Msk      (0x1U << CAN_F1R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F1R2_FB24          CAN_F1R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F1R2_FB25_Pos      (25U)                                           
N#define CAN_F1R2_FB25_Msk      (0x1U << CAN_F1R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F1R2_FB25          CAN_F1R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F1R2_FB26_Pos      (26U)                                           
N#define CAN_F1R2_FB26_Msk      (0x1U << CAN_F1R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F1R2_FB26          CAN_F1R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F1R2_FB27_Pos      (27U)                                           
N#define CAN_F1R2_FB27_Msk      (0x1U << CAN_F1R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F1R2_FB27          CAN_F1R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F1R2_FB28_Pos      (28U)                                           
N#define CAN_F1R2_FB28_Msk      (0x1U << CAN_F1R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F1R2_FB28          CAN_F1R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F1R2_FB29_Pos      (29U)                                           
N#define CAN_F1R2_FB29_Msk      (0x1U << CAN_F1R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F1R2_FB29          CAN_F1R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F1R2_FB30_Pos      (30U)                                           
N#define CAN_F1R2_FB30_Msk      (0x1U << CAN_F1R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F1R2_FB30          CAN_F1R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F1R2_FB31_Pos      (31U)                                           
N#define CAN_F1R2_FB31_Msk      (0x1U << CAN_F1R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F1R2_FB31          CAN_F1R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R2 register  *******************/
N#define CAN_F2R2_FB0_Pos       (0U)                                            
N#define CAN_F2R2_FB0_Msk       (0x1U << CAN_F2R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F2R2_FB0           CAN_F2R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F2R2_FB1_Pos       (1U)                                            
N#define CAN_F2R2_FB1_Msk       (0x1U << CAN_F2R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F2R2_FB1           CAN_F2R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F2R2_FB2_Pos       (2U)                                            
N#define CAN_F2R2_FB2_Msk       (0x1U << CAN_F2R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F2R2_FB2           CAN_F2R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F2R2_FB3_Pos       (3U)                                            
N#define CAN_F2R2_FB3_Msk       (0x1U << CAN_F2R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F2R2_FB3           CAN_F2R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F2R2_FB4_Pos       (4U)                                            
N#define CAN_F2R2_FB4_Msk       (0x1U << CAN_F2R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F2R2_FB4           CAN_F2R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F2R2_FB5_Pos       (5U)                                            
N#define CAN_F2R2_FB5_Msk       (0x1U << CAN_F2R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F2R2_FB5           CAN_F2R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F2R2_FB6_Pos       (6U)                                            
N#define CAN_F2R2_FB6_Msk       (0x1U << CAN_F2R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F2R2_FB6           CAN_F2R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F2R2_FB7_Pos       (7U)                                            
N#define CAN_F2R2_FB7_Msk       (0x1U << CAN_F2R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F2R2_FB7           CAN_F2R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F2R2_FB8_Pos       (8U)                                            
N#define CAN_F2R2_FB8_Msk       (0x1U << CAN_F2R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F2R2_FB8           CAN_F2R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F2R2_FB9_Pos       (9U)                                            
N#define CAN_F2R2_FB9_Msk       (0x1U << CAN_F2R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F2R2_FB9           CAN_F2R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F2R2_FB10_Pos      (10U)                                           
N#define CAN_F2R2_FB10_Msk      (0x1U << CAN_F2R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F2R2_FB10          CAN_F2R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F2R2_FB11_Pos      (11U)                                           
N#define CAN_F2R2_FB11_Msk      (0x1U << CAN_F2R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F2R2_FB11          CAN_F2R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F2R2_FB12_Pos      (12U)                                           
N#define CAN_F2R2_FB12_Msk      (0x1U << CAN_F2R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F2R2_FB12          CAN_F2R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F2R2_FB13_Pos      (13U)                                           
N#define CAN_F2R2_FB13_Msk      (0x1U << CAN_F2R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F2R2_FB13          CAN_F2R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F2R2_FB14_Pos      (14U)                                           
N#define CAN_F2R2_FB14_Msk      (0x1U << CAN_F2R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F2R2_FB14          CAN_F2R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F2R2_FB15_Pos      (15U)                                           
N#define CAN_F2R2_FB15_Msk      (0x1U << CAN_F2R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F2R2_FB15          CAN_F2R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F2R2_FB16_Pos      (16U)                                           
N#define CAN_F2R2_FB16_Msk      (0x1U << CAN_F2R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F2R2_FB16          CAN_F2R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F2R2_FB17_Pos      (17U)                                           
N#define CAN_F2R2_FB17_Msk      (0x1U << CAN_F2R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F2R2_FB17          CAN_F2R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F2R2_FB18_Pos      (18U)                                           
N#define CAN_F2R2_FB18_Msk      (0x1U << CAN_F2R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F2R2_FB18          CAN_F2R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F2R2_FB19_Pos      (19U)                                           
N#define CAN_F2R2_FB19_Msk      (0x1U << CAN_F2R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F2R2_FB19          CAN_F2R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F2R2_FB20_Pos      (20U)                                           
N#define CAN_F2R2_FB20_Msk      (0x1U << CAN_F2R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F2R2_FB20          CAN_F2R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F2R2_FB21_Pos      (21U)                                           
N#define CAN_F2R2_FB21_Msk      (0x1U << CAN_F2R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F2R2_FB21          CAN_F2R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F2R2_FB22_Pos      (22U)                                           
N#define CAN_F2R2_FB22_Msk      (0x1U << CAN_F2R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F2R2_FB22          CAN_F2R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F2R2_FB23_Pos      (23U)                                           
N#define CAN_F2R2_FB23_Msk      (0x1U << CAN_F2R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F2R2_FB23          CAN_F2R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F2R2_FB24_Pos      (24U)                                           
N#define CAN_F2R2_FB24_Msk      (0x1U << CAN_F2R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F2R2_FB24          CAN_F2R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F2R2_FB25_Pos      (25U)                                           
N#define CAN_F2R2_FB25_Msk      (0x1U << CAN_F2R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F2R2_FB25          CAN_F2R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F2R2_FB26_Pos      (26U)                                           
N#define CAN_F2R2_FB26_Msk      (0x1U << CAN_F2R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F2R2_FB26          CAN_F2R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F2R2_FB27_Pos      (27U)                                           
N#define CAN_F2R2_FB27_Msk      (0x1U << CAN_F2R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F2R2_FB27          CAN_F2R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F2R2_FB28_Pos      (28U)                                           
N#define CAN_F2R2_FB28_Msk      (0x1U << CAN_F2R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F2R2_FB28          CAN_F2R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F2R2_FB29_Pos      (29U)                                           
N#define CAN_F2R2_FB29_Msk      (0x1U << CAN_F2R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F2R2_FB29          CAN_F2R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F2R2_FB30_Pos      (30U)                                           
N#define CAN_F2R2_FB30_Msk      (0x1U << CAN_F2R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F2R2_FB30          CAN_F2R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F2R2_FB31_Pos      (31U)                                           
N#define CAN_F2R2_FB31_Msk      (0x1U << CAN_F2R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F2R2_FB31          CAN_F2R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R2 register  *******************/
N#define CAN_F3R2_FB0_Pos       (0U)                                            
N#define CAN_F3R2_FB0_Msk       (0x1U << CAN_F3R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F3R2_FB0           CAN_F3R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F3R2_FB1_Pos       (1U)                                            
N#define CAN_F3R2_FB1_Msk       (0x1U << CAN_F3R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F3R2_FB1           CAN_F3R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F3R2_FB2_Pos       (2U)                                            
N#define CAN_F3R2_FB2_Msk       (0x1U << CAN_F3R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F3R2_FB2           CAN_F3R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F3R2_FB3_Pos       (3U)                                            
N#define CAN_F3R2_FB3_Msk       (0x1U << CAN_F3R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F3R2_FB3           CAN_F3R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F3R2_FB4_Pos       (4U)                                            
N#define CAN_F3R2_FB4_Msk       (0x1U << CAN_F3R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F3R2_FB4           CAN_F3R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F3R2_FB5_Pos       (5U)                                            
N#define CAN_F3R2_FB5_Msk       (0x1U << CAN_F3R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F3R2_FB5           CAN_F3R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F3R2_FB6_Pos       (6U)                                            
N#define CAN_F3R2_FB6_Msk       (0x1U << CAN_F3R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F3R2_FB6           CAN_F3R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F3R2_FB7_Pos       (7U)                                            
N#define CAN_F3R2_FB7_Msk       (0x1U << CAN_F3R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F3R2_FB7           CAN_F3R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F3R2_FB8_Pos       (8U)                                            
N#define CAN_F3R2_FB8_Msk       (0x1U << CAN_F3R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F3R2_FB8           CAN_F3R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F3R2_FB9_Pos       (9U)                                            
N#define CAN_F3R2_FB9_Msk       (0x1U << CAN_F3R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F3R2_FB9           CAN_F3R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F3R2_FB10_Pos      (10U)                                           
N#define CAN_F3R2_FB10_Msk      (0x1U << CAN_F3R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F3R2_FB10          CAN_F3R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F3R2_FB11_Pos      (11U)                                           
N#define CAN_F3R2_FB11_Msk      (0x1U << CAN_F3R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F3R2_FB11          CAN_F3R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F3R2_FB12_Pos      (12U)                                           
N#define CAN_F3R2_FB12_Msk      (0x1U << CAN_F3R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F3R2_FB12          CAN_F3R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F3R2_FB13_Pos      (13U)                                           
N#define CAN_F3R2_FB13_Msk      (0x1U << CAN_F3R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F3R2_FB13          CAN_F3R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F3R2_FB14_Pos      (14U)                                           
N#define CAN_F3R2_FB14_Msk      (0x1U << CAN_F3R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F3R2_FB14          CAN_F3R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F3R2_FB15_Pos      (15U)                                           
N#define CAN_F3R2_FB15_Msk      (0x1U << CAN_F3R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F3R2_FB15          CAN_F3R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F3R2_FB16_Pos      (16U)                                           
N#define CAN_F3R2_FB16_Msk      (0x1U << CAN_F3R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F3R2_FB16          CAN_F3R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F3R2_FB17_Pos      (17U)                                           
N#define CAN_F3R2_FB17_Msk      (0x1U << CAN_F3R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F3R2_FB17          CAN_F3R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F3R2_FB18_Pos      (18U)                                           
N#define CAN_F3R2_FB18_Msk      (0x1U << CAN_F3R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F3R2_FB18          CAN_F3R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F3R2_FB19_Pos      (19U)                                           
N#define CAN_F3R2_FB19_Msk      (0x1U << CAN_F3R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F3R2_FB19          CAN_F3R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F3R2_FB20_Pos      (20U)                                           
N#define CAN_F3R2_FB20_Msk      (0x1U << CAN_F3R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F3R2_FB20          CAN_F3R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F3R2_FB21_Pos      (21U)                                           
N#define CAN_F3R2_FB21_Msk      (0x1U << CAN_F3R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F3R2_FB21          CAN_F3R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F3R2_FB22_Pos      (22U)                                           
N#define CAN_F3R2_FB22_Msk      (0x1U << CAN_F3R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F3R2_FB22          CAN_F3R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F3R2_FB23_Pos      (23U)                                           
N#define CAN_F3R2_FB23_Msk      (0x1U << CAN_F3R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F3R2_FB23          CAN_F3R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F3R2_FB24_Pos      (24U)                                           
N#define CAN_F3R2_FB24_Msk      (0x1U << CAN_F3R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F3R2_FB24          CAN_F3R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F3R2_FB25_Pos      (25U)                                           
N#define CAN_F3R2_FB25_Msk      (0x1U << CAN_F3R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F3R2_FB25          CAN_F3R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F3R2_FB26_Pos      (26U)                                           
N#define CAN_F3R2_FB26_Msk      (0x1U << CAN_F3R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F3R2_FB26          CAN_F3R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F3R2_FB27_Pos      (27U)                                           
N#define CAN_F3R2_FB27_Msk      (0x1U << CAN_F3R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F3R2_FB27          CAN_F3R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F3R2_FB28_Pos      (28U)                                           
N#define CAN_F3R2_FB28_Msk      (0x1U << CAN_F3R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F3R2_FB28          CAN_F3R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F3R2_FB29_Pos      (29U)                                           
N#define CAN_F3R2_FB29_Msk      (0x1U << CAN_F3R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F3R2_FB29          CAN_F3R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F3R2_FB30_Pos      (30U)                                           
N#define CAN_F3R2_FB30_Msk      (0x1U << CAN_F3R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F3R2_FB30          CAN_F3R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F3R2_FB31_Pos      (31U)                                           
N#define CAN_F3R2_FB31_Msk      (0x1U << CAN_F3R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F3R2_FB31          CAN_F3R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R2 register  *******************/
N#define CAN_F4R2_FB0_Pos       (0U)                                            
N#define CAN_F4R2_FB0_Msk       (0x1U << CAN_F4R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F4R2_FB0           CAN_F4R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F4R2_FB1_Pos       (1U)                                            
N#define CAN_F4R2_FB1_Msk       (0x1U << CAN_F4R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F4R2_FB1           CAN_F4R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F4R2_FB2_Pos       (2U)                                            
N#define CAN_F4R2_FB2_Msk       (0x1U << CAN_F4R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F4R2_FB2           CAN_F4R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F4R2_FB3_Pos       (3U)                                            
N#define CAN_F4R2_FB3_Msk       (0x1U << CAN_F4R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F4R2_FB3           CAN_F4R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F4R2_FB4_Pos       (4U)                                            
N#define CAN_F4R2_FB4_Msk       (0x1U << CAN_F4R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F4R2_FB4           CAN_F4R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F4R2_FB5_Pos       (5U)                                            
N#define CAN_F4R2_FB5_Msk       (0x1U << CAN_F4R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F4R2_FB5           CAN_F4R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F4R2_FB6_Pos       (6U)                                            
N#define CAN_F4R2_FB6_Msk       (0x1U << CAN_F4R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F4R2_FB6           CAN_F4R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F4R2_FB7_Pos       (7U)                                            
N#define CAN_F4R2_FB7_Msk       (0x1U << CAN_F4R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F4R2_FB7           CAN_F4R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F4R2_FB8_Pos       (8U)                                            
N#define CAN_F4R2_FB8_Msk       (0x1U << CAN_F4R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F4R2_FB8           CAN_F4R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F4R2_FB9_Pos       (9U)                                            
N#define CAN_F4R2_FB9_Msk       (0x1U << CAN_F4R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F4R2_FB9           CAN_F4R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F4R2_FB10_Pos      (10U)                                           
N#define CAN_F4R2_FB10_Msk      (0x1U << CAN_F4R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F4R2_FB10          CAN_F4R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F4R2_FB11_Pos      (11U)                                           
N#define CAN_F4R2_FB11_Msk      (0x1U << CAN_F4R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F4R2_FB11          CAN_F4R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F4R2_FB12_Pos      (12U)                                           
N#define CAN_F4R2_FB12_Msk      (0x1U << CAN_F4R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F4R2_FB12          CAN_F4R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F4R2_FB13_Pos      (13U)                                           
N#define CAN_F4R2_FB13_Msk      (0x1U << CAN_F4R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F4R2_FB13          CAN_F4R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F4R2_FB14_Pos      (14U)                                           
N#define CAN_F4R2_FB14_Msk      (0x1U << CAN_F4R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F4R2_FB14          CAN_F4R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F4R2_FB15_Pos      (15U)                                           
N#define CAN_F4R2_FB15_Msk      (0x1U << CAN_F4R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F4R2_FB15          CAN_F4R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F4R2_FB16_Pos      (16U)                                           
N#define CAN_F4R2_FB16_Msk      (0x1U << CAN_F4R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F4R2_FB16          CAN_F4R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F4R2_FB17_Pos      (17U)                                           
N#define CAN_F4R2_FB17_Msk      (0x1U << CAN_F4R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F4R2_FB17          CAN_F4R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F4R2_FB18_Pos      (18U)                                           
N#define CAN_F4R2_FB18_Msk      (0x1U << CAN_F4R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F4R2_FB18          CAN_F4R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F4R2_FB19_Pos      (19U)                                           
N#define CAN_F4R2_FB19_Msk      (0x1U << CAN_F4R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F4R2_FB19          CAN_F4R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F4R2_FB20_Pos      (20U)                                           
N#define CAN_F4R2_FB20_Msk      (0x1U << CAN_F4R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F4R2_FB20          CAN_F4R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F4R2_FB21_Pos      (21U)                                           
N#define CAN_F4R2_FB21_Msk      (0x1U << CAN_F4R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F4R2_FB21          CAN_F4R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F4R2_FB22_Pos      (22U)                                           
N#define CAN_F4R2_FB22_Msk      (0x1U << CAN_F4R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F4R2_FB22          CAN_F4R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F4R2_FB23_Pos      (23U)                                           
N#define CAN_F4R2_FB23_Msk      (0x1U << CAN_F4R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F4R2_FB23          CAN_F4R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F4R2_FB24_Pos      (24U)                                           
N#define CAN_F4R2_FB24_Msk      (0x1U << CAN_F4R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F4R2_FB24          CAN_F4R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F4R2_FB25_Pos      (25U)                                           
N#define CAN_F4R2_FB25_Msk      (0x1U << CAN_F4R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F4R2_FB25          CAN_F4R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F4R2_FB26_Pos      (26U)                                           
N#define CAN_F4R2_FB26_Msk      (0x1U << CAN_F4R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F4R2_FB26          CAN_F4R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F4R2_FB27_Pos      (27U)                                           
N#define CAN_F4R2_FB27_Msk      (0x1U << CAN_F4R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F4R2_FB27          CAN_F4R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F4R2_FB28_Pos      (28U)                                           
N#define CAN_F4R2_FB28_Msk      (0x1U << CAN_F4R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F4R2_FB28          CAN_F4R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F4R2_FB29_Pos      (29U)                                           
N#define CAN_F4R2_FB29_Msk      (0x1U << CAN_F4R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F4R2_FB29          CAN_F4R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F4R2_FB30_Pos      (30U)                                           
N#define CAN_F4R2_FB30_Msk      (0x1U << CAN_F4R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F4R2_FB30          CAN_F4R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F4R2_FB31_Pos      (31U)                                           
N#define CAN_F4R2_FB31_Msk      (0x1U << CAN_F4R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F4R2_FB31          CAN_F4R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R2 register  *******************/
N#define CAN_F5R2_FB0_Pos       (0U)                                            
N#define CAN_F5R2_FB0_Msk       (0x1U << CAN_F5R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F5R2_FB0           CAN_F5R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F5R2_FB1_Pos       (1U)                                            
N#define CAN_F5R2_FB1_Msk       (0x1U << CAN_F5R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F5R2_FB1           CAN_F5R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F5R2_FB2_Pos       (2U)                                            
N#define CAN_F5R2_FB2_Msk       (0x1U << CAN_F5R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F5R2_FB2           CAN_F5R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F5R2_FB3_Pos       (3U)                                            
N#define CAN_F5R2_FB3_Msk       (0x1U << CAN_F5R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F5R2_FB3           CAN_F5R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F5R2_FB4_Pos       (4U)                                            
N#define CAN_F5R2_FB4_Msk       (0x1U << CAN_F5R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F5R2_FB4           CAN_F5R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F5R2_FB5_Pos       (5U)                                            
N#define CAN_F5R2_FB5_Msk       (0x1U << CAN_F5R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F5R2_FB5           CAN_F5R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F5R2_FB6_Pos       (6U)                                            
N#define CAN_F5R2_FB6_Msk       (0x1U << CAN_F5R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F5R2_FB6           CAN_F5R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F5R2_FB7_Pos       (7U)                                            
N#define CAN_F5R2_FB7_Msk       (0x1U << CAN_F5R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F5R2_FB7           CAN_F5R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F5R2_FB8_Pos       (8U)                                            
N#define CAN_F5R2_FB8_Msk       (0x1U << CAN_F5R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F5R2_FB8           CAN_F5R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F5R2_FB9_Pos       (9U)                                            
N#define CAN_F5R2_FB9_Msk       (0x1U << CAN_F5R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F5R2_FB9           CAN_F5R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F5R2_FB10_Pos      (10U)                                           
N#define CAN_F5R2_FB10_Msk      (0x1U << CAN_F5R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F5R2_FB10          CAN_F5R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F5R2_FB11_Pos      (11U)                                           
N#define CAN_F5R2_FB11_Msk      (0x1U << CAN_F5R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F5R2_FB11          CAN_F5R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F5R2_FB12_Pos      (12U)                                           
N#define CAN_F5R2_FB12_Msk      (0x1U << CAN_F5R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F5R2_FB12          CAN_F5R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F5R2_FB13_Pos      (13U)                                           
N#define CAN_F5R2_FB13_Msk      (0x1U << CAN_F5R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F5R2_FB13          CAN_F5R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F5R2_FB14_Pos      (14U)                                           
N#define CAN_F5R2_FB14_Msk      (0x1U << CAN_F5R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F5R2_FB14          CAN_F5R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F5R2_FB15_Pos      (15U)                                           
N#define CAN_F5R2_FB15_Msk      (0x1U << CAN_F5R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F5R2_FB15          CAN_F5R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F5R2_FB16_Pos      (16U)                                           
N#define CAN_F5R2_FB16_Msk      (0x1U << CAN_F5R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F5R2_FB16          CAN_F5R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F5R2_FB17_Pos      (17U)                                           
N#define CAN_F5R2_FB17_Msk      (0x1U << CAN_F5R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F5R2_FB17          CAN_F5R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F5R2_FB18_Pos      (18U)                                           
N#define CAN_F5R2_FB18_Msk      (0x1U << CAN_F5R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F5R2_FB18          CAN_F5R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F5R2_FB19_Pos      (19U)                                           
N#define CAN_F5R2_FB19_Msk      (0x1U << CAN_F5R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F5R2_FB19          CAN_F5R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F5R2_FB20_Pos      (20U)                                           
N#define CAN_F5R2_FB20_Msk      (0x1U << CAN_F5R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F5R2_FB20          CAN_F5R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F5R2_FB21_Pos      (21U)                                           
N#define CAN_F5R2_FB21_Msk      (0x1U << CAN_F5R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F5R2_FB21          CAN_F5R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F5R2_FB22_Pos      (22U)                                           
N#define CAN_F5R2_FB22_Msk      (0x1U << CAN_F5R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F5R2_FB22          CAN_F5R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F5R2_FB23_Pos      (23U)                                           
N#define CAN_F5R2_FB23_Msk      (0x1U << CAN_F5R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F5R2_FB23          CAN_F5R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F5R2_FB24_Pos      (24U)                                           
N#define CAN_F5R2_FB24_Msk      (0x1U << CAN_F5R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F5R2_FB24          CAN_F5R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F5R2_FB25_Pos      (25U)                                           
N#define CAN_F5R2_FB25_Msk      (0x1U << CAN_F5R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F5R2_FB25          CAN_F5R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F5R2_FB26_Pos      (26U)                                           
N#define CAN_F5R2_FB26_Msk      (0x1U << CAN_F5R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F5R2_FB26          CAN_F5R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F5R2_FB27_Pos      (27U)                                           
N#define CAN_F5R2_FB27_Msk      (0x1U << CAN_F5R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F5R2_FB27          CAN_F5R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F5R2_FB28_Pos      (28U)                                           
N#define CAN_F5R2_FB28_Msk      (0x1U << CAN_F5R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F5R2_FB28          CAN_F5R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F5R2_FB29_Pos      (29U)                                           
N#define CAN_F5R2_FB29_Msk      (0x1U << CAN_F5R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F5R2_FB29          CAN_F5R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F5R2_FB30_Pos      (30U)                                           
N#define CAN_F5R2_FB30_Msk      (0x1U << CAN_F5R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F5R2_FB30          CAN_F5R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F5R2_FB31_Pos      (31U)                                           
N#define CAN_F5R2_FB31_Msk      (0x1U << CAN_F5R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F5R2_FB31          CAN_F5R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R2 register  *******************/
N#define CAN_F6R2_FB0_Pos       (0U)                                            
N#define CAN_F6R2_FB0_Msk       (0x1U << CAN_F6R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F6R2_FB0           CAN_F6R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F6R2_FB1_Pos       (1U)                                            
N#define CAN_F6R2_FB1_Msk       (0x1U << CAN_F6R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F6R2_FB1           CAN_F6R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F6R2_FB2_Pos       (2U)                                            
N#define CAN_F6R2_FB2_Msk       (0x1U << CAN_F6R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F6R2_FB2           CAN_F6R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F6R2_FB3_Pos       (3U)                                            
N#define CAN_F6R2_FB3_Msk       (0x1U << CAN_F6R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F6R2_FB3           CAN_F6R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F6R2_FB4_Pos       (4U)                                            
N#define CAN_F6R2_FB4_Msk       (0x1U << CAN_F6R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F6R2_FB4           CAN_F6R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F6R2_FB5_Pos       (5U)                                            
N#define CAN_F6R2_FB5_Msk       (0x1U << CAN_F6R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F6R2_FB5           CAN_F6R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F6R2_FB6_Pos       (6U)                                            
N#define CAN_F6R2_FB6_Msk       (0x1U << CAN_F6R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F6R2_FB6           CAN_F6R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F6R2_FB7_Pos       (7U)                                            
N#define CAN_F6R2_FB7_Msk       (0x1U << CAN_F6R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F6R2_FB7           CAN_F6R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F6R2_FB8_Pos       (8U)                                            
N#define CAN_F6R2_FB8_Msk       (0x1U << CAN_F6R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F6R2_FB8           CAN_F6R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F6R2_FB9_Pos       (9U)                                            
N#define CAN_F6R2_FB9_Msk       (0x1U << CAN_F6R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F6R2_FB9           CAN_F6R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F6R2_FB10_Pos      (10U)                                           
N#define CAN_F6R2_FB10_Msk      (0x1U << CAN_F6R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F6R2_FB10          CAN_F6R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F6R2_FB11_Pos      (11U)                                           
N#define CAN_F6R2_FB11_Msk      (0x1U << CAN_F6R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F6R2_FB11          CAN_F6R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F6R2_FB12_Pos      (12U)                                           
N#define CAN_F6R2_FB12_Msk      (0x1U << CAN_F6R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F6R2_FB12          CAN_F6R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F6R2_FB13_Pos      (13U)                                           
N#define CAN_F6R2_FB13_Msk      (0x1U << CAN_F6R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F6R2_FB13          CAN_F6R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F6R2_FB14_Pos      (14U)                                           
N#define CAN_F6R2_FB14_Msk      (0x1U << CAN_F6R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F6R2_FB14          CAN_F6R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F6R2_FB15_Pos      (15U)                                           
N#define CAN_F6R2_FB15_Msk      (0x1U << CAN_F6R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F6R2_FB15          CAN_F6R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F6R2_FB16_Pos      (16U)                                           
N#define CAN_F6R2_FB16_Msk      (0x1U << CAN_F6R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F6R2_FB16          CAN_F6R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F6R2_FB17_Pos      (17U)                                           
N#define CAN_F6R2_FB17_Msk      (0x1U << CAN_F6R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F6R2_FB17          CAN_F6R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F6R2_FB18_Pos      (18U)                                           
N#define CAN_F6R2_FB18_Msk      (0x1U << CAN_F6R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F6R2_FB18          CAN_F6R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F6R2_FB19_Pos      (19U)                                           
N#define CAN_F6R2_FB19_Msk      (0x1U << CAN_F6R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F6R2_FB19          CAN_F6R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F6R2_FB20_Pos      (20U)                                           
N#define CAN_F6R2_FB20_Msk      (0x1U << CAN_F6R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F6R2_FB20          CAN_F6R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F6R2_FB21_Pos      (21U)                                           
N#define CAN_F6R2_FB21_Msk      (0x1U << CAN_F6R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F6R2_FB21          CAN_F6R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F6R2_FB22_Pos      (22U)                                           
N#define CAN_F6R2_FB22_Msk      (0x1U << CAN_F6R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F6R2_FB22          CAN_F6R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F6R2_FB23_Pos      (23U)                                           
N#define CAN_F6R2_FB23_Msk      (0x1U << CAN_F6R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F6R2_FB23          CAN_F6R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F6R2_FB24_Pos      (24U)                                           
N#define CAN_F6R2_FB24_Msk      (0x1U << CAN_F6R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F6R2_FB24          CAN_F6R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F6R2_FB25_Pos      (25U)                                           
N#define CAN_F6R2_FB25_Msk      (0x1U << CAN_F6R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F6R2_FB25          CAN_F6R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F6R2_FB26_Pos      (26U)                                           
N#define CAN_F6R2_FB26_Msk      (0x1U << CAN_F6R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F6R2_FB26          CAN_F6R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F6R2_FB27_Pos      (27U)                                           
N#define CAN_F6R2_FB27_Msk      (0x1U << CAN_F6R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F6R2_FB27          CAN_F6R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F6R2_FB28_Pos      (28U)                                           
N#define CAN_F6R2_FB28_Msk      (0x1U << CAN_F6R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F6R2_FB28          CAN_F6R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F6R2_FB29_Pos      (29U)                                           
N#define CAN_F6R2_FB29_Msk      (0x1U << CAN_F6R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F6R2_FB29          CAN_F6R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F6R2_FB30_Pos      (30U)                                           
N#define CAN_F6R2_FB30_Msk      (0x1U << CAN_F6R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F6R2_FB30          CAN_F6R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F6R2_FB31_Pos      (31U)                                           
N#define CAN_F6R2_FB31_Msk      (0x1U << CAN_F6R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F6R2_FB31          CAN_F6R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R2 register  *******************/
N#define CAN_F7R2_FB0_Pos       (0U)                                            
N#define CAN_F7R2_FB0_Msk       (0x1U << CAN_F7R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F7R2_FB0           CAN_F7R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F7R2_FB1_Pos       (1U)                                            
N#define CAN_F7R2_FB1_Msk       (0x1U << CAN_F7R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F7R2_FB1           CAN_F7R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F7R2_FB2_Pos       (2U)                                            
N#define CAN_F7R2_FB2_Msk       (0x1U << CAN_F7R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F7R2_FB2           CAN_F7R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F7R2_FB3_Pos       (3U)                                            
N#define CAN_F7R2_FB3_Msk       (0x1U << CAN_F7R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F7R2_FB3           CAN_F7R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F7R2_FB4_Pos       (4U)                                            
N#define CAN_F7R2_FB4_Msk       (0x1U << CAN_F7R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F7R2_FB4           CAN_F7R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F7R2_FB5_Pos       (5U)                                            
N#define CAN_F7R2_FB5_Msk       (0x1U << CAN_F7R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F7R2_FB5           CAN_F7R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F7R2_FB6_Pos       (6U)                                            
N#define CAN_F7R2_FB6_Msk       (0x1U << CAN_F7R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F7R2_FB6           CAN_F7R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F7R2_FB7_Pos       (7U)                                            
N#define CAN_F7R2_FB7_Msk       (0x1U << CAN_F7R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F7R2_FB7           CAN_F7R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F7R2_FB8_Pos       (8U)                                            
N#define CAN_F7R2_FB8_Msk       (0x1U << CAN_F7R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F7R2_FB8           CAN_F7R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F7R2_FB9_Pos       (9U)                                            
N#define CAN_F7R2_FB9_Msk       (0x1U << CAN_F7R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F7R2_FB9           CAN_F7R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F7R2_FB10_Pos      (10U)                                           
N#define CAN_F7R2_FB10_Msk      (0x1U << CAN_F7R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F7R2_FB10          CAN_F7R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F7R2_FB11_Pos      (11U)                                           
N#define CAN_F7R2_FB11_Msk      (0x1U << CAN_F7R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F7R2_FB11          CAN_F7R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F7R2_FB12_Pos      (12U)                                           
N#define CAN_F7R2_FB12_Msk      (0x1U << CAN_F7R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F7R2_FB12          CAN_F7R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F7R2_FB13_Pos      (13U)                                           
N#define CAN_F7R2_FB13_Msk      (0x1U << CAN_F7R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F7R2_FB13          CAN_F7R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F7R2_FB14_Pos      (14U)                                           
N#define CAN_F7R2_FB14_Msk      (0x1U << CAN_F7R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F7R2_FB14          CAN_F7R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F7R2_FB15_Pos      (15U)                                           
N#define CAN_F7R2_FB15_Msk      (0x1U << CAN_F7R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F7R2_FB15          CAN_F7R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F7R2_FB16_Pos      (16U)                                           
N#define CAN_F7R2_FB16_Msk      (0x1U << CAN_F7R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F7R2_FB16          CAN_F7R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F7R2_FB17_Pos      (17U)                                           
N#define CAN_F7R2_FB17_Msk      (0x1U << CAN_F7R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F7R2_FB17          CAN_F7R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F7R2_FB18_Pos      (18U)                                           
N#define CAN_F7R2_FB18_Msk      (0x1U << CAN_F7R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F7R2_FB18          CAN_F7R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F7R2_FB19_Pos      (19U)                                           
N#define CAN_F7R2_FB19_Msk      (0x1U << CAN_F7R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F7R2_FB19          CAN_F7R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F7R2_FB20_Pos      (20U)                                           
N#define CAN_F7R2_FB20_Msk      (0x1U << CAN_F7R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F7R2_FB20          CAN_F7R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F7R2_FB21_Pos      (21U)                                           
N#define CAN_F7R2_FB21_Msk      (0x1U << CAN_F7R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F7R2_FB21          CAN_F7R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F7R2_FB22_Pos      (22U)                                           
N#define CAN_F7R2_FB22_Msk      (0x1U << CAN_F7R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F7R2_FB22          CAN_F7R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F7R2_FB23_Pos      (23U)                                           
N#define CAN_F7R2_FB23_Msk      (0x1U << CAN_F7R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F7R2_FB23          CAN_F7R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F7R2_FB24_Pos      (24U)                                           
N#define CAN_F7R2_FB24_Msk      (0x1U << CAN_F7R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F7R2_FB24          CAN_F7R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F7R2_FB25_Pos      (25U)                                           
N#define CAN_F7R2_FB25_Msk      (0x1U << CAN_F7R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F7R2_FB25          CAN_F7R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F7R2_FB26_Pos      (26U)                                           
N#define CAN_F7R2_FB26_Msk      (0x1U << CAN_F7R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F7R2_FB26          CAN_F7R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F7R2_FB27_Pos      (27U)                                           
N#define CAN_F7R2_FB27_Msk      (0x1U << CAN_F7R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F7R2_FB27          CAN_F7R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F7R2_FB28_Pos      (28U)                                           
N#define CAN_F7R2_FB28_Msk      (0x1U << CAN_F7R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F7R2_FB28          CAN_F7R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F7R2_FB29_Pos      (29U)                                           
N#define CAN_F7R2_FB29_Msk      (0x1U << CAN_F7R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F7R2_FB29          CAN_F7R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F7R2_FB30_Pos      (30U)                                           
N#define CAN_F7R2_FB30_Msk      (0x1U << CAN_F7R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F7R2_FB30          CAN_F7R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F7R2_FB31_Pos      (31U)                                           
N#define CAN_F7R2_FB31_Msk      (0x1U << CAN_F7R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F7R2_FB31          CAN_F7R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R2 register  *******************/
N#define CAN_F8R2_FB0_Pos       (0U)                                            
N#define CAN_F8R2_FB0_Msk       (0x1U << CAN_F8R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F8R2_FB0           CAN_F8R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F8R2_FB1_Pos       (1U)                                            
N#define CAN_F8R2_FB1_Msk       (0x1U << CAN_F8R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F8R2_FB1           CAN_F8R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F8R2_FB2_Pos       (2U)                                            
N#define CAN_F8R2_FB2_Msk       (0x1U << CAN_F8R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F8R2_FB2           CAN_F8R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F8R2_FB3_Pos       (3U)                                            
N#define CAN_F8R2_FB3_Msk       (0x1U << CAN_F8R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F8R2_FB3           CAN_F8R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F8R2_FB4_Pos       (4U)                                            
N#define CAN_F8R2_FB4_Msk       (0x1U << CAN_F8R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F8R2_FB4           CAN_F8R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F8R2_FB5_Pos       (5U)                                            
N#define CAN_F8R2_FB5_Msk       (0x1U << CAN_F8R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F8R2_FB5           CAN_F8R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F8R2_FB6_Pos       (6U)                                            
N#define CAN_F8R2_FB6_Msk       (0x1U << CAN_F8R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F8R2_FB6           CAN_F8R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F8R2_FB7_Pos       (7U)                                            
N#define CAN_F8R2_FB7_Msk       (0x1U << CAN_F8R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F8R2_FB7           CAN_F8R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F8R2_FB8_Pos       (8U)                                            
N#define CAN_F8R2_FB8_Msk       (0x1U << CAN_F8R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F8R2_FB8           CAN_F8R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F8R2_FB9_Pos       (9U)                                            
N#define CAN_F8R2_FB9_Msk       (0x1U << CAN_F8R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F8R2_FB9           CAN_F8R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F8R2_FB10_Pos      (10U)                                           
N#define CAN_F8R2_FB10_Msk      (0x1U << CAN_F8R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F8R2_FB10          CAN_F8R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F8R2_FB11_Pos      (11U)                                           
N#define CAN_F8R2_FB11_Msk      (0x1U << CAN_F8R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F8R2_FB11          CAN_F8R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F8R2_FB12_Pos      (12U)                                           
N#define CAN_F8R2_FB12_Msk      (0x1U << CAN_F8R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F8R2_FB12          CAN_F8R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F8R2_FB13_Pos      (13U)                                           
N#define CAN_F8R2_FB13_Msk      (0x1U << CAN_F8R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F8R2_FB13          CAN_F8R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F8R2_FB14_Pos      (14U)                                           
N#define CAN_F8R2_FB14_Msk      (0x1U << CAN_F8R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F8R2_FB14          CAN_F8R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F8R2_FB15_Pos      (15U)                                           
N#define CAN_F8R2_FB15_Msk      (0x1U << CAN_F8R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F8R2_FB15          CAN_F8R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F8R2_FB16_Pos      (16U)                                           
N#define CAN_F8R2_FB16_Msk      (0x1U << CAN_F8R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F8R2_FB16          CAN_F8R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F8R2_FB17_Pos      (17U)                                           
N#define CAN_F8R2_FB17_Msk      (0x1U << CAN_F8R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F8R2_FB17          CAN_F8R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F8R2_FB18_Pos      (18U)                                           
N#define CAN_F8R2_FB18_Msk      (0x1U << CAN_F8R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F8R2_FB18          CAN_F8R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F8R2_FB19_Pos      (19U)                                           
N#define CAN_F8R2_FB19_Msk      (0x1U << CAN_F8R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F8R2_FB19          CAN_F8R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F8R2_FB20_Pos      (20U)                                           
N#define CAN_F8R2_FB20_Msk      (0x1U << CAN_F8R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F8R2_FB20          CAN_F8R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F8R2_FB21_Pos      (21U)                                           
N#define CAN_F8R2_FB21_Msk      (0x1U << CAN_F8R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F8R2_FB21          CAN_F8R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F8R2_FB22_Pos      (22U)                                           
N#define CAN_F8R2_FB22_Msk      (0x1U << CAN_F8R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F8R2_FB22          CAN_F8R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F8R2_FB23_Pos      (23U)                                           
N#define CAN_F8R2_FB23_Msk      (0x1U << CAN_F8R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F8R2_FB23          CAN_F8R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F8R2_FB24_Pos      (24U)                                           
N#define CAN_F8R2_FB24_Msk      (0x1U << CAN_F8R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F8R2_FB24          CAN_F8R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F8R2_FB25_Pos      (25U)                                           
N#define CAN_F8R2_FB25_Msk      (0x1U << CAN_F8R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F8R2_FB25          CAN_F8R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F8R2_FB26_Pos      (26U)                                           
N#define CAN_F8R2_FB26_Msk      (0x1U << CAN_F8R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F8R2_FB26          CAN_F8R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F8R2_FB27_Pos      (27U)                                           
N#define CAN_F8R2_FB27_Msk      (0x1U << CAN_F8R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F8R2_FB27          CAN_F8R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F8R2_FB28_Pos      (28U)                                           
N#define CAN_F8R2_FB28_Msk      (0x1U << CAN_F8R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F8R2_FB28          CAN_F8R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F8R2_FB29_Pos      (29U)                                           
N#define CAN_F8R2_FB29_Msk      (0x1U << CAN_F8R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F8R2_FB29          CAN_F8R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F8R2_FB30_Pos      (30U)                                           
N#define CAN_F8R2_FB30_Msk      (0x1U << CAN_F8R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F8R2_FB30          CAN_F8R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F8R2_FB31_Pos      (31U)                                           
N#define CAN_F8R2_FB31_Msk      (0x1U << CAN_F8R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F8R2_FB31          CAN_F8R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R2 register  *******************/
N#define CAN_F9R2_FB0_Pos       (0U)                                            
N#define CAN_F9R2_FB0_Msk       (0x1U << CAN_F9R2_FB0_Pos)                      /*!< 0x00000001 */
N#define CAN_F9R2_FB0           CAN_F9R2_FB0_Msk                                /*!<Filter bit 0 */
N#define CAN_F9R2_FB1_Pos       (1U)                                            
N#define CAN_F9R2_FB1_Msk       (0x1U << CAN_F9R2_FB1_Pos)                      /*!< 0x00000002 */
N#define CAN_F9R2_FB1           CAN_F9R2_FB1_Msk                                /*!<Filter bit 1 */
N#define CAN_F9R2_FB2_Pos       (2U)                                            
N#define CAN_F9R2_FB2_Msk       (0x1U << CAN_F9R2_FB2_Pos)                      /*!< 0x00000004 */
N#define CAN_F9R2_FB2           CAN_F9R2_FB2_Msk                                /*!<Filter bit 2 */
N#define CAN_F9R2_FB3_Pos       (3U)                                            
N#define CAN_F9R2_FB3_Msk       (0x1U << CAN_F9R2_FB3_Pos)                      /*!< 0x00000008 */
N#define CAN_F9R2_FB3           CAN_F9R2_FB3_Msk                                /*!<Filter bit 3 */
N#define CAN_F9R2_FB4_Pos       (4U)                                            
N#define CAN_F9R2_FB4_Msk       (0x1U << CAN_F9R2_FB4_Pos)                      /*!< 0x00000010 */
N#define CAN_F9R2_FB4           CAN_F9R2_FB4_Msk                                /*!<Filter bit 4 */
N#define CAN_F9R2_FB5_Pos       (5U)                                            
N#define CAN_F9R2_FB5_Msk       (0x1U << CAN_F9R2_FB5_Pos)                      /*!< 0x00000020 */
N#define CAN_F9R2_FB5           CAN_F9R2_FB5_Msk                                /*!<Filter bit 5 */
N#define CAN_F9R2_FB6_Pos       (6U)                                            
N#define CAN_F9R2_FB6_Msk       (0x1U << CAN_F9R2_FB6_Pos)                      /*!< 0x00000040 */
N#define CAN_F9R2_FB6           CAN_F9R2_FB6_Msk                                /*!<Filter bit 6 */
N#define CAN_F9R2_FB7_Pos       (7U)                                            
N#define CAN_F9R2_FB7_Msk       (0x1U << CAN_F9R2_FB7_Pos)                      /*!< 0x00000080 */
N#define CAN_F9R2_FB7           CAN_F9R2_FB7_Msk                                /*!<Filter bit 7 */
N#define CAN_F9R2_FB8_Pos       (8U)                                            
N#define CAN_F9R2_FB8_Msk       (0x1U << CAN_F9R2_FB8_Pos)                      /*!< 0x00000100 */
N#define CAN_F9R2_FB8           CAN_F9R2_FB8_Msk                                /*!<Filter bit 8 */
N#define CAN_F9R2_FB9_Pos       (9U)                                            
N#define CAN_F9R2_FB9_Msk       (0x1U << CAN_F9R2_FB9_Pos)                      /*!< 0x00000200 */
N#define CAN_F9R2_FB9           CAN_F9R2_FB9_Msk                                /*!<Filter bit 9 */
N#define CAN_F9R2_FB10_Pos      (10U)                                           
N#define CAN_F9R2_FB10_Msk      (0x1U << CAN_F9R2_FB10_Pos)                     /*!< 0x00000400 */
N#define CAN_F9R2_FB10          CAN_F9R2_FB10_Msk                               /*!<Filter bit 10 */
N#define CAN_F9R2_FB11_Pos      (11U)                                           
N#define CAN_F9R2_FB11_Msk      (0x1U << CAN_F9R2_FB11_Pos)                     /*!< 0x00000800 */
N#define CAN_F9R2_FB11          CAN_F9R2_FB11_Msk                               /*!<Filter bit 11 */
N#define CAN_F9R2_FB12_Pos      (12U)                                           
N#define CAN_F9R2_FB12_Msk      (0x1U << CAN_F9R2_FB12_Pos)                     /*!< 0x00001000 */
N#define CAN_F9R2_FB12          CAN_F9R2_FB12_Msk                               /*!<Filter bit 12 */
N#define CAN_F9R2_FB13_Pos      (13U)                                           
N#define CAN_F9R2_FB13_Msk      (0x1U << CAN_F9R2_FB13_Pos)                     /*!< 0x00002000 */
N#define CAN_F9R2_FB13          CAN_F9R2_FB13_Msk                               /*!<Filter bit 13 */
N#define CAN_F9R2_FB14_Pos      (14U)                                           
N#define CAN_F9R2_FB14_Msk      (0x1U << CAN_F9R2_FB14_Pos)                     /*!< 0x00004000 */
N#define CAN_F9R2_FB14          CAN_F9R2_FB14_Msk                               /*!<Filter bit 14 */
N#define CAN_F9R2_FB15_Pos      (15U)                                           
N#define CAN_F9R2_FB15_Msk      (0x1U << CAN_F9R2_FB15_Pos)                     /*!< 0x00008000 */
N#define CAN_F9R2_FB15          CAN_F9R2_FB15_Msk                               /*!<Filter bit 15 */
N#define CAN_F9R2_FB16_Pos      (16U)                                           
N#define CAN_F9R2_FB16_Msk      (0x1U << CAN_F9R2_FB16_Pos)                     /*!< 0x00010000 */
N#define CAN_F9R2_FB16          CAN_F9R2_FB16_Msk                               /*!<Filter bit 16 */
N#define CAN_F9R2_FB17_Pos      (17U)                                           
N#define CAN_F9R2_FB17_Msk      (0x1U << CAN_F9R2_FB17_Pos)                     /*!< 0x00020000 */
N#define CAN_F9R2_FB17          CAN_F9R2_FB17_Msk                               /*!<Filter bit 17 */
N#define CAN_F9R2_FB18_Pos      (18U)                                           
N#define CAN_F9R2_FB18_Msk      (0x1U << CAN_F9R2_FB18_Pos)                     /*!< 0x00040000 */
N#define CAN_F9R2_FB18          CAN_F9R2_FB18_Msk                               /*!<Filter bit 18 */
N#define CAN_F9R2_FB19_Pos      (19U)                                           
N#define CAN_F9R2_FB19_Msk      (0x1U << CAN_F9R2_FB19_Pos)                     /*!< 0x00080000 */
N#define CAN_F9R2_FB19          CAN_F9R2_FB19_Msk                               /*!<Filter bit 19 */
N#define CAN_F9R2_FB20_Pos      (20U)                                           
N#define CAN_F9R2_FB20_Msk      (0x1U << CAN_F9R2_FB20_Pos)                     /*!< 0x00100000 */
N#define CAN_F9R2_FB20          CAN_F9R2_FB20_Msk                               /*!<Filter bit 20 */
N#define CAN_F9R2_FB21_Pos      (21U)                                           
N#define CAN_F9R2_FB21_Msk      (0x1U << CAN_F9R2_FB21_Pos)                     /*!< 0x00200000 */
N#define CAN_F9R2_FB21          CAN_F9R2_FB21_Msk                               /*!<Filter bit 21 */
N#define CAN_F9R2_FB22_Pos      (22U)                                           
N#define CAN_F9R2_FB22_Msk      (0x1U << CAN_F9R2_FB22_Pos)                     /*!< 0x00400000 */
N#define CAN_F9R2_FB22          CAN_F9R2_FB22_Msk                               /*!<Filter bit 22 */
N#define CAN_F9R2_FB23_Pos      (23U)                                           
N#define CAN_F9R2_FB23_Msk      (0x1U << CAN_F9R2_FB23_Pos)                     /*!< 0x00800000 */
N#define CAN_F9R2_FB23          CAN_F9R2_FB23_Msk                               /*!<Filter bit 23 */
N#define CAN_F9R2_FB24_Pos      (24U)                                           
N#define CAN_F9R2_FB24_Msk      (0x1U << CAN_F9R2_FB24_Pos)                     /*!< 0x01000000 */
N#define CAN_F9R2_FB24          CAN_F9R2_FB24_Msk                               /*!<Filter bit 24 */
N#define CAN_F9R2_FB25_Pos      (25U)                                           
N#define CAN_F9R2_FB25_Msk      (0x1U << CAN_F9R2_FB25_Pos)                     /*!< 0x02000000 */
N#define CAN_F9R2_FB25          CAN_F9R2_FB25_Msk                               /*!<Filter bit 25 */
N#define CAN_F9R2_FB26_Pos      (26U)                                           
N#define CAN_F9R2_FB26_Msk      (0x1U << CAN_F9R2_FB26_Pos)                     /*!< 0x04000000 */
N#define CAN_F9R2_FB26          CAN_F9R2_FB26_Msk                               /*!<Filter bit 26 */
N#define CAN_F9R2_FB27_Pos      (27U)                                           
N#define CAN_F9R2_FB27_Msk      (0x1U << CAN_F9R2_FB27_Pos)                     /*!< 0x08000000 */
N#define CAN_F9R2_FB27          CAN_F9R2_FB27_Msk                               /*!<Filter bit 27 */
N#define CAN_F9R2_FB28_Pos      (28U)                                           
N#define CAN_F9R2_FB28_Msk      (0x1U << CAN_F9R2_FB28_Pos)                     /*!< 0x10000000 */
N#define CAN_F9R2_FB28          CAN_F9R2_FB28_Msk                               /*!<Filter bit 28 */
N#define CAN_F9R2_FB29_Pos      (29U)                                           
N#define CAN_F9R2_FB29_Msk      (0x1U << CAN_F9R2_FB29_Pos)                     /*!< 0x20000000 */
N#define CAN_F9R2_FB29          CAN_F9R2_FB29_Msk                               /*!<Filter bit 29 */
N#define CAN_F9R2_FB30_Pos      (30U)                                           
N#define CAN_F9R2_FB30_Msk      (0x1U << CAN_F9R2_FB30_Pos)                     /*!< 0x40000000 */
N#define CAN_F9R2_FB30          CAN_F9R2_FB30_Msk                               /*!<Filter bit 30 */
N#define CAN_F9R2_FB31_Pos      (31U)                                           
N#define CAN_F9R2_FB31_Msk      (0x1U << CAN_F9R2_FB31_Pos)                     /*!< 0x80000000 */
N#define CAN_F9R2_FB31          CAN_F9R2_FB31_Msk                               /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R2 register  ******************/
N#define CAN_F10R2_FB0_Pos      (0U)                                            
N#define CAN_F10R2_FB0_Msk      (0x1U << CAN_F10R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F10R2_FB0          CAN_F10R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F10R2_FB1_Pos      (1U)                                            
N#define CAN_F10R2_FB1_Msk      (0x1U << CAN_F10R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F10R2_FB1          CAN_F10R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F10R2_FB2_Pos      (2U)                                            
N#define CAN_F10R2_FB2_Msk      (0x1U << CAN_F10R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F10R2_FB2          CAN_F10R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F10R2_FB3_Pos      (3U)                                            
N#define CAN_F10R2_FB3_Msk      (0x1U << CAN_F10R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F10R2_FB3          CAN_F10R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F10R2_FB4_Pos      (4U)                                            
N#define CAN_F10R2_FB4_Msk      (0x1U << CAN_F10R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F10R2_FB4          CAN_F10R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F10R2_FB5_Pos      (5U)                                            
N#define CAN_F10R2_FB5_Msk      (0x1U << CAN_F10R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F10R2_FB5          CAN_F10R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F10R2_FB6_Pos      (6U)                                            
N#define CAN_F10R2_FB6_Msk      (0x1U << CAN_F10R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F10R2_FB6          CAN_F10R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F10R2_FB7_Pos      (7U)                                            
N#define CAN_F10R2_FB7_Msk      (0x1U << CAN_F10R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F10R2_FB7          CAN_F10R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F10R2_FB8_Pos      (8U)                                            
N#define CAN_F10R2_FB8_Msk      (0x1U << CAN_F10R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F10R2_FB8          CAN_F10R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F10R2_FB9_Pos      (9U)                                            
N#define CAN_F10R2_FB9_Msk      (0x1U << CAN_F10R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F10R2_FB9          CAN_F10R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F10R2_FB10_Pos     (10U)                                           
N#define CAN_F10R2_FB10_Msk     (0x1U << CAN_F10R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F10R2_FB10         CAN_F10R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F10R2_FB11_Pos     (11U)                                           
N#define CAN_F10R2_FB11_Msk     (0x1U << CAN_F10R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F10R2_FB11         CAN_F10R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F10R2_FB12_Pos     (12U)                                           
N#define CAN_F10R2_FB12_Msk     (0x1U << CAN_F10R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F10R2_FB12         CAN_F10R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F10R2_FB13_Pos     (13U)                                           
N#define CAN_F10R2_FB13_Msk     (0x1U << CAN_F10R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F10R2_FB13         CAN_F10R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F10R2_FB14_Pos     (14U)                                           
N#define CAN_F10R2_FB14_Msk     (0x1U << CAN_F10R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F10R2_FB14         CAN_F10R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F10R2_FB15_Pos     (15U)                                           
N#define CAN_F10R2_FB15_Msk     (0x1U << CAN_F10R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F10R2_FB15         CAN_F10R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F10R2_FB16_Pos     (16U)                                           
N#define CAN_F10R2_FB16_Msk     (0x1U << CAN_F10R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F10R2_FB16         CAN_F10R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F10R2_FB17_Pos     (17U)                                           
N#define CAN_F10R2_FB17_Msk     (0x1U << CAN_F10R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F10R2_FB17         CAN_F10R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F10R2_FB18_Pos     (18U)                                           
N#define CAN_F10R2_FB18_Msk     (0x1U << CAN_F10R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F10R2_FB18         CAN_F10R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F10R2_FB19_Pos     (19U)                                           
N#define CAN_F10R2_FB19_Msk     (0x1U << CAN_F10R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F10R2_FB19         CAN_F10R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F10R2_FB20_Pos     (20U)                                           
N#define CAN_F10R2_FB20_Msk     (0x1U << CAN_F10R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F10R2_FB20         CAN_F10R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F10R2_FB21_Pos     (21U)                                           
N#define CAN_F10R2_FB21_Msk     (0x1U << CAN_F10R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F10R2_FB21         CAN_F10R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F10R2_FB22_Pos     (22U)                                           
N#define CAN_F10R2_FB22_Msk     (0x1U << CAN_F10R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F10R2_FB22         CAN_F10R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F10R2_FB23_Pos     (23U)                                           
N#define CAN_F10R2_FB23_Msk     (0x1U << CAN_F10R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F10R2_FB23         CAN_F10R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F10R2_FB24_Pos     (24U)                                           
N#define CAN_F10R2_FB24_Msk     (0x1U << CAN_F10R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F10R2_FB24         CAN_F10R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F10R2_FB25_Pos     (25U)                                           
N#define CAN_F10R2_FB25_Msk     (0x1U << CAN_F10R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F10R2_FB25         CAN_F10R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F10R2_FB26_Pos     (26U)                                           
N#define CAN_F10R2_FB26_Msk     (0x1U << CAN_F10R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F10R2_FB26         CAN_F10R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F10R2_FB27_Pos     (27U)                                           
N#define CAN_F10R2_FB27_Msk     (0x1U << CAN_F10R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F10R2_FB27         CAN_F10R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F10R2_FB28_Pos     (28U)                                           
N#define CAN_F10R2_FB28_Msk     (0x1U << CAN_F10R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F10R2_FB28         CAN_F10R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F10R2_FB29_Pos     (29U)                                           
N#define CAN_F10R2_FB29_Msk     (0x1U << CAN_F10R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F10R2_FB29         CAN_F10R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F10R2_FB30_Pos     (30U)                                           
N#define CAN_F10R2_FB30_Msk     (0x1U << CAN_F10R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F10R2_FB30         CAN_F10R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F10R2_FB31_Pos     (31U)                                           
N#define CAN_F10R2_FB31_Msk     (0x1U << CAN_F10R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F10R2_FB31         CAN_F10R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R2 register  ******************/
N#define CAN_F11R2_FB0_Pos      (0U)                                            
N#define CAN_F11R2_FB0_Msk      (0x1U << CAN_F11R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F11R2_FB0          CAN_F11R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F11R2_FB1_Pos      (1U)                                            
N#define CAN_F11R2_FB1_Msk      (0x1U << CAN_F11R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F11R2_FB1          CAN_F11R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F11R2_FB2_Pos      (2U)                                            
N#define CAN_F11R2_FB2_Msk      (0x1U << CAN_F11R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F11R2_FB2          CAN_F11R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F11R2_FB3_Pos      (3U)                                            
N#define CAN_F11R2_FB3_Msk      (0x1U << CAN_F11R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F11R2_FB3          CAN_F11R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F11R2_FB4_Pos      (4U)                                            
N#define CAN_F11R2_FB4_Msk      (0x1U << CAN_F11R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F11R2_FB4          CAN_F11R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F11R2_FB5_Pos      (5U)                                            
N#define CAN_F11R2_FB5_Msk      (0x1U << CAN_F11R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F11R2_FB5          CAN_F11R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F11R2_FB6_Pos      (6U)                                            
N#define CAN_F11R2_FB6_Msk      (0x1U << CAN_F11R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F11R2_FB6          CAN_F11R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F11R2_FB7_Pos      (7U)                                            
N#define CAN_F11R2_FB7_Msk      (0x1U << CAN_F11R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F11R2_FB7          CAN_F11R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F11R2_FB8_Pos      (8U)                                            
N#define CAN_F11R2_FB8_Msk      (0x1U << CAN_F11R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F11R2_FB8          CAN_F11R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F11R2_FB9_Pos      (9U)                                            
N#define CAN_F11R2_FB9_Msk      (0x1U << CAN_F11R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F11R2_FB9          CAN_F11R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F11R2_FB10_Pos     (10U)                                           
N#define CAN_F11R2_FB10_Msk     (0x1U << CAN_F11R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F11R2_FB10         CAN_F11R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F11R2_FB11_Pos     (11U)                                           
N#define CAN_F11R2_FB11_Msk     (0x1U << CAN_F11R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F11R2_FB11         CAN_F11R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F11R2_FB12_Pos     (12U)                                           
N#define CAN_F11R2_FB12_Msk     (0x1U << CAN_F11R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F11R2_FB12         CAN_F11R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F11R2_FB13_Pos     (13U)                                           
N#define CAN_F11R2_FB13_Msk     (0x1U << CAN_F11R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F11R2_FB13         CAN_F11R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F11R2_FB14_Pos     (14U)                                           
N#define CAN_F11R2_FB14_Msk     (0x1U << CAN_F11R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F11R2_FB14         CAN_F11R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F11R2_FB15_Pos     (15U)                                           
N#define CAN_F11R2_FB15_Msk     (0x1U << CAN_F11R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F11R2_FB15         CAN_F11R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F11R2_FB16_Pos     (16U)                                           
N#define CAN_F11R2_FB16_Msk     (0x1U << CAN_F11R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F11R2_FB16         CAN_F11R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F11R2_FB17_Pos     (17U)                                           
N#define CAN_F11R2_FB17_Msk     (0x1U << CAN_F11R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F11R2_FB17         CAN_F11R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F11R2_FB18_Pos     (18U)                                           
N#define CAN_F11R2_FB18_Msk     (0x1U << CAN_F11R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F11R2_FB18         CAN_F11R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F11R2_FB19_Pos     (19U)                                           
N#define CAN_F11R2_FB19_Msk     (0x1U << CAN_F11R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F11R2_FB19         CAN_F11R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F11R2_FB20_Pos     (20U)                                           
N#define CAN_F11R2_FB20_Msk     (0x1U << CAN_F11R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F11R2_FB20         CAN_F11R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F11R2_FB21_Pos     (21U)                                           
N#define CAN_F11R2_FB21_Msk     (0x1U << CAN_F11R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F11R2_FB21         CAN_F11R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F11R2_FB22_Pos     (22U)                                           
N#define CAN_F11R2_FB22_Msk     (0x1U << CAN_F11R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F11R2_FB22         CAN_F11R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F11R2_FB23_Pos     (23U)                                           
N#define CAN_F11R2_FB23_Msk     (0x1U << CAN_F11R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F11R2_FB23         CAN_F11R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F11R2_FB24_Pos     (24U)                                           
N#define CAN_F11R2_FB24_Msk     (0x1U << CAN_F11R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F11R2_FB24         CAN_F11R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F11R2_FB25_Pos     (25U)                                           
N#define CAN_F11R2_FB25_Msk     (0x1U << CAN_F11R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F11R2_FB25         CAN_F11R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F11R2_FB26_Pos     (26U)                                           
N#define CAN_F11R2_FB26_Msk     (0x1U << CAN_F11R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F11R2_FB26         CAN_F11R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F11R2_FB27_Pos     (27U)                                           
N#define CAN_F11R2_FB27_Msk     (0x1U << CAN_F11R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F11R2_FB27         CAN_F11R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F11R2_FB28_Pos     (28U)                                           
N#define CAN_F11R2_FB28_Msk     (0x1U << CAN_F11R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F11R2_FB28         CAN_F11R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F11R2_FB29_Pos     (29U)                                           
N#define CAN_F11R2_FB29_Msk     (0x1U << CAN_F11R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F11R2_FB29         CAN_F11R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F11R2_FB30_Pos     (30U)                                           
N#define CAN_F11R2_FB30_Msk     (0x1U << CAN_F11R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F11R2_FB30         CAN_F11R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F11R2_FB31_Pos     (31U)                                           
N#define CAN_F11R2_FB31_Msk     (0x1U << CAN_F11R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F11R2_FB31         CAN_F11R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R2 register  ******************/
N#define CAN_F12R2_FB0_Pos      (0U)                                            
N#define CAN_F12R2_FB0_Msk      (0x1U << CAN_F12R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F12R2_FB0          CAN_F12R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F12R2_FB1_Pos      (1U)                                            
N#define CAN_F12R2_FB1_Msk      (0x1U << CAN_F12R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F12R2_FB1          CAN_F12R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F12R2_FB2_Pos      (2U)                                            
N#define CAN_F12R2_FB2_Msk      (0x1U << CAN_F12R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F12R2_FB2          CAN_F12R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F12R2_FB3_Pos      (3U)                                            
N#define CAN_F12R2_FB3_Msk      (0x1U << CAN_F12R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F12R2_FB3          CAN_F12R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F12R2_FB4_Pos      (4U)                                            
N#define CAN_F12R2_FB4_Msk      (0x1U << CAN_F12R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F12R2_FB4          CAN_F12R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F12R2_FB5_Pos      (5U)                                            
N#define CAN_F12R2_FB5_Msk      (0x1U << CAN_F12R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F12R2_FB5          CAN_F12R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F12R2_FB6_Pos      (6U)                                            
N#define CAN_F12R2_FB6_Msk      (0x1U << CAN_F12R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F12R2_FB6          CAN_F12R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F12R2_FB7_Pos      (7U)                                            
N#define CAN_F12R2_FB7_Msk      (0x1U << CAN_F12R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F12R2_FB7          CAN_F12R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F12R2_FB8_Pos      (8U)                                            
N#define CAN_F12R2_FB8_Msk      (0x1U << CAN_F12R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F12R2_FB8          CAN_F12R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F12R2_FB9_Pos      (9U)                                            
N#define CAN_F12R2_FB9_Msk      (0x1U << CAN_F12R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F12R2_FB9          CAN_F12R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F12R2_FB10_Pos     (10U)                                           
N#define CAN_F12R2_FB10_Msk     (0x1U << CAN_F12R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F12R2_FB10         CAN_F12R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F12R2_FB11_Pos     (11U)                                           
N#define CAN_F12R2_FB11_Msk     (0x1U << CAN_F12R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F12R2_FB11         CAN_F12R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F12R2_FB12_Pos     (12U)                                           
N#define CAN_F12R2_FB12_Msk     (0x1U << CAN_F12R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F12R2_FB12         CAN_F12R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F12R2_FB13_Pos     (13U)                                           
N#define CAN_F12R2_FB13_Msk     (0x1U << CAN_F12R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F12R2_FB13         CAN_F12R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F12R2_FB14_Pos     (14U)                                           
N#define CAN_F12R2_FB14_Msk     (0x1U << CAN_F12R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F12R2_FB14         CAN_F12R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F12R2_FB15_Pos     (15U)                                           
N#define CAN_F12R2_FB15_Msk     (0x1U << CAN_F12R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F12R2_FB15         CAN_F12R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F12R2_FB16_Pos     (16U)                                           
N#define CAN_F12R2_FB16_Msk     (0x1U << CAN_F12R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F12R2_FB16         CAN_F12R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F12R2_FB17_Pos     (17U)                                           
N#define CAN_F12R2_FB17_Msk     (0x1U << CAN_F12R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F12R2_FB17         CAN_F12R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F12R2_FB18_Pos     (18U)                                           
N#define CAN_F12R2_FB18_Msk     (0x1U << CAN_F12R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F12R2_FB18         CAN_F12R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F12R2_FB19_Pos     (19U)                                           
N#define CAN_F12R2_FB19_Msk     (0x1U << CAN_F12R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F12R2_FB19         CAN_F12R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F12R2_FB20_Pos     (20U)                                           
N#define CAN_F12R2_FB20_Msk     (0x1U << CAN_F12R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F12R2_FB20         CAN_F12R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F12R2_FB21_Pos     (21U)                                           
N#define CAN_F12R2_FB21_Msk     (0x1U << CAN_F12R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F12R2_FB21         CAN_F12R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F12R2_FB22_Pos     (22U)                                           
N#define CAN_F12R2_FB22_Msk     (0x1U << CAN_F12R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F12R2_FB22         CAN_F12R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F12R2_FB23_Pos     (23U)                                           
N#define CAN_F12R2_FB23_Msk     (0x1U << CAN_F12R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F12R2_FB23         CAN_F12R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F12R2_FB24_Pos     (24U)                                           
N#define CAN_F12R2_FB24_Msk     (0x1U << CAN_F12R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F12R2_FB24         CAN_F12R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F12R2_FB25_Pos     (25U)                                           
N#define CAN_F12R2_FB25_Msk     (0x1U << CAN_F12R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F12R2_FB25         CAN_F12R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F12R2_FB26_Pos     (26U)                                           
N#define CAN_F12R2_FB26_Msk     (0x1U << CAN_F12R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F12R2_FB26         CAN_F12R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F12R2_FB27_Pos     (27U)                                           
N#define CAN_F12R2_FB27_Msk     (0x1U << CAN_F12R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F12R2_FB27         CAN_F12R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F12R2_FB28_Pos     (28U)                                           
N#define CAN_F12R2_FB28_Msk     (0x1U << CAN_F12R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F12R2_FB28         CAN_F12R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F12R2_FB29_Pos     (29U)                                           
N#define CAN_F12R2_FB29_Msk     (0x1U << CAN_F12R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F12R2_FB29         CAN_F12R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F12R2_FB30_Pos     (30U)                                           
N#define CAN_F12R2_FB30_Msk     (0x1U << CAN_F12R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F12R2_FB30         CAN_F12R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F12R2_FB31_Pos     (31U)                                           
N#define CAN_F12R2_FB31_Msk     (0x1U << CAN_F12R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F12R2_FB31         CAN_F12R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R2 register  ******************/
N#define CAN_F13R2_FB0_Pos      (0U)                                            
N#define CAN_F13R2_FB0_Msk      (0x1U << CAN_F13R2_FB0_Pos)                     /*!< 0x00000001 */
N#define CAN_F13R2_FB0          CAN_F13R2_FB0_Msk                               /*!<Filter bit 0 */
N#define CAN_F13R2_FB1_Pos      (1U)                                            
N#define CAN_F13R2_FB1_Msk      (0x1U << CAN_F13R2_FB1_Pos)                     /*!< 0x00000002 */
N#define CAN_F13R2_FB1          CAN_F13R2_FB1_Msk                               /*!<Filter bit 1 */
N#define CAN_F13R2_FB2_Pos      (2U)                                            
N#define CAN_F13R2_FB2_Msk      (0x1U << CAN_F13R2_FB2_Pos)                     /*!< 0x00000004 */
N#define CAN_F13R2_FB2          CAN_F13R2_FB2_Msk                               /*!<Filter bit 2 */
N#define CAN_F13R2_FB3_Pos      (3U)                                            
N#define CAN_F13R2_FB3_Msk      (0x1U << CAN_F13R2_FB3_Pos)                     /*!< 0x00000008 */
N#define CAN_F13R2_FB3          CAN_F13R2_FB3_Msk                               /*!<Filter bit 3 */
N#define CAN_F13R2_FB4_Pos      (4U)                                            
N#define CAN_F13R2_FB4_Msk      (0x1U << CAN_F13R2_FB4_Pos)                     /*!< 0x00000010 */
N#define CAN_F13R2_FB4          CAN_F13R2_FB4_Msk                               /*!<Filter bit 4 */
N#define CAN_F13R2_FB5_Pos      (5U)                                            
N#define CAN_F13R2_FB5_Msk      (0x1U << CAN_F13R2_FB5_Pos)                     /*!< 0x00000020 */
N#define CAN_F13R2_FB5          CAN_F13R2_FB5_Msk                               /*!<Filter bit 5 */
N#define CAN_F13R2_FB6_Pos      (6U)                                            
N#define CAN_F13R2_FB6_Msk      (0x1U << CAN_F13R2_FB6_Pos)                     /*!< 0x00000040 */
N#define CAN_F13R2_FB6          CAN_F13R2_FB6_Msk                               /*!<Filter bit 6 */
N#define CAN_F13R2_FB7_Pos      (7U)                                            
N#define CAN_F13R2_FB7_Msk      (0x1U << CAN_F13R2_FB7_Pos)                     /*!< 0x00000080 */
N#define CAN_F13R2_FB7          CAN_F13R2_FB7_Msk                               /*!<Filter bit 7 */
N#define CAN_F13R2_FB8_Pos      (8U)                                            
N#define CAN_F13R2_FB8_Msk      (0x1U << CAN_F13R2_FB8_Pos)                     /*!< 0x00000100 */
N#define CAN_F13R2_FB8          CAN_F13R2_FB8_Msk                               /*!<Filter bit 8 */
N#define CAN_F13R2_FB9_Pos      (9U)                                            
N#define CAN_F13R2_FB9_Msk      (0x1U << CAN_F13R2_FB9_Pos)                     /*!< 0x00000200 */
N#define CAN_F13R2_FB9          CAN_F13R2_FB9_Msk                               /*!<Filter bit 9 */
N#define CAN_F13R2_FB10_Pos     (10U)                                           
N#define CAN_F13R2_FB10_Msk     (0x1U << CAN_F13R2_FB10_Pos)                    /*!< 0x00000400 */
N#define CAN_F13R2_FB10         CAN_F13R2_FB10_Msk                              /*!<Filter bit 10 */
N#define CAN_F13R2_FB11_Pos     (11U)                                           
N#define CAN_F13R2_FB11_Msk     (0x1U << CAN_F13R2_FB11_Pos)                    /*!< 0x00000800 */
N#define CAN_F13R2_FB11         CAN_F13R2_FB11_Msk                              /*!<Filter bit 11 */
N#define CAN_F13R2_FB12_Pos     (12U)                                           
N#define CAN_F13R2_FB12_Msk     (0x1U << CAN_F13R2_FB12_Pos)                    /*!< 0x00001000 */
N#define CAN_F13R2_FB12         CAN_F13R2_FB12_Msk                              /*!<Filter bit 12 */
N#define CAN_F13R2_FB13_Pos     (13U)                                           
N#define CAN_F13R2_FB13_Msk     (0x1U << CAN_F13R2_FB13_Pos)                    /*!< 0x00002000 */
N#define CAN_F13R2_FB13         CAN_F13R2_FB13_Msk                              /*!<Filter bit 13 */
N#define CAN_F13R2_FB14_Pos     (14U)                                           
N#define CAN_F13R2_FB14_Msk     (0x1U << CAN_F13R2_FB14_Pos)                    /*!< 0x00004000 */
N#define CAN_F13R2_FB14         CAN_F13R2_FB14_Msk                              /*!<Filter bit 14 */
N#define CAN_F13R2_FB15_Pos     (15U)                                           
N#define CAN_F13R2_FB15_Msk     (0x1U << CAN_F13R2_FB15_Pos)                    /*!< 0x00008000 */
N#define CAN_F13R2_FB15         CAN_F13R2_FB15_Msk                              /*!<Filter bit 15 */
N#define CAN_F13R2_FB16_Pos     (16U)                                           
N#define CAN_F13R2_FB16_Msk     (0x1U << CAN_F13R2_FB16_Pos)                    /*!< 0x00010000 */
N#define CAN_F13R2_FB16         CAN_F13R2_FB16_Msk                              /*!<Filter bit 16 */
N#define CAN_F13R2_FB17_Pos     (17U)                                           
N#define CAN_F13R2_FB17_Msk     (0x1U << CAN_F13R2_FB17_Pos)                    /*!< 0x00020000 */
N#define CAN_F13R2_FB17         CAN_F13R2_FB17_Msk                              /*!<Filter bit 17 */
N#define CAN_F13R2_FB18_Pos     (18U)                                           
N#define CAN_F13R2_FB18_Msk     (0x1U << CAN_F13R2_FB18_Pos)                    /*!< 0x00040000 */
N#define CAN_F13R2_FB18         CAN_F13R2_FB18_Msk                              /*!<Filter bit 18 */
N#define CAN_F13R2_FB19_Pos     (19U)                                           
N#define CAN_F13R2_FB19_Msk     (0x1U << CAN_F13R2_FB19_Pos)                    /*!< 0x00080000 */
N#define CAN_F13R2_FB19         CAN_F13R2_FB19_Msk                              /*!<Filter bit 19 */
N#define CAN_F13R2_FB20_Pos     (20U)                                           
N#define CAN_F13R2_FB20_Msk     (0x1U << CAN_F13R2_FB20_Pos)                    /*!< 0x00100000 */
N#define CAN_F13R2_FB20         CAN_F13R2_FB20_Msk                              /*!<Filter bit 20 */
N#define CAN_F13R2_FB21_Pos     (21U)                                           
N#define CAN_F13R2_FB21_Msk     (0x1U << CAN_F13R2_FB21_Pos)                    /*!< 0x00200000 */
N#define CAN_F13R2_FB21         CAN_F13R2_FB21_Msk                              /*!<Filter bit 21 */
N#define CAN_F13R2_FB22_Pos     (22U)                                           
N#define CAN_F13R2_FB22_Msk     (0x1U << CAN_F13R2_FB22_Pos)                    /*!< 0x00400000 */
N#define CAN_F13R2_FB22         CAN_F13R2_FB22_Msk                              /*!<Filter bit 22 */
N#define CAN_F13R2_FB23_Pos     (23U)                                           
N#define CAN_F13R2_FB23_Msk     (0x1U << CAN_F13R2_FB23_Pos)                    /*!< 0x00800000 */
N#define CAN_F13R2_FB23         CAN_F13R2_FB23_Msk                              /*!<Filter bit 23 */
N#define CAN_F13R2_FB24_Pos     (24U)                                           
N#define CAN_F13R2_FB24_Msk     (0x1U << CAN_F13R2_FB24_Pos)                    /*!< 0x01000000 */
N#define CAN_F13R2_FB24         CAN_F13R2_FB24_Msk                              /*!<Filter bit 24 */
N#define CAN_F13R2_FB25_Pos     (25U)                                           
N#define CAN_F13R2_FB25_Msk     (0x1U << CAN_F13R2_FB25_Pos)                    /*!< 0x02000000 */
N#define CAN_F13R2_FB25         CAN_F13R2_FB25_Msk                              /*!<Filter bit 25 */
N#define CAN_F13R2_FB26_Pos     (26U)                                           
N#define CAN_F13R2_FB26_Msk     (0x1U << CAN_F13R2_FB26_Pos)                    /*!< 0x04000000 */
N#define CAN_F13R2_FB26         CAN_F13R2_FB26_Msk                              /*!<Filter bit 26 */
N#define CAN_F13R2_FB27_Pos     (27U)                                           
N#define CAN_F13R2_FB27_Msk     (0x1U << CAN_F13R2_FB27_Pos)                    /*!< 0x08000000 */
N#define CAN_F13R2_FB27         CAN_F13R2_FB27_Msk                              /*!<Filter bit 27 */
N#define CAN_F13R2_FB28_Pos     (28U)                                           
N#define CAN_F13R2_FB28_Msk     (0x1U << CAN_F13R2_FB28_Pos)                    /*!< 0x10000000 */
N#define CAN_F13R2_FB28         CAN_F13R2_FB28_Msk                              /*!<Filter bit 28 */
N#define CAN_F13R2_FB29_Pos     (29U)                                           
N#define CAN_F13R2_FB29_Msk     (0x1U << CAN_F13R2_FB29_Pos)                    /*!< 0x20000000 */
N#define CAN_F13R2_FB29         CAN_F13R2_FB29_Msk                              /*!<Filter bit 29 */
N#define CAN_F13R2_FB30_Pos     (30U)                                           
N#define CAN_F13R2_FB30_Msk     (0x1U << CAN_F13R2_FB30_Pos)                    /*!< 0x40000000 */
N#define CAN_F13R2_FB30         CAN_F13R2_FB30_Msk                              /*!<Filter bit 30 */
N#define CAN_F13R2_FB31_Pos     (31U)                                           
N#define CAN_F13R2_FB31_Msk     (0x1U << CAN_F13R2_FB31_Pos)                    /*!< 0x80000000 */
N#define CAN_F13R2_FB31         CAN_F13R2_FB31_Msk                              /*!<Filter bit 31 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 HDMI-CEC (CEC)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for CEC_CR register  *********************/
N#define CEC_CR_CECEN_Pos         (0U)                                          
N#define CEC_CR_CECEN_Msk         (0x1U << CEC_CR_CECEN_Pos)                    /*!< 0x00000001 */
N#define CEC_CR_CECEN             CEC_CR_CECEN_Msk                              /*!< CEC Enable                         */
N#define CEC_CR_TXSOM_Pos         (1U)                                          
N#define CEC_CR_TXSOM_Msk         (0x1U << CEC_CR_TXSOM_Pos)                    /*!< 0x00000002 */
N#define CEC_CR_TXSOM             CEC_CR_TXSOM_Msk                              /*!< CEC Tx Start Of Message            */
N#define CEC_CR_TXEOM_Pos         (2U)                                          
N#define CEC_CR_TXEOM_Msk         (0x1U << CEC_CR_TXEOM_Pos)                    /*!< 0x00000004 */
N#define CEC_CR_TXEOM             CEC_CR_TXEOM_Msk                              /*!< CEC Tx End Of Message              */
N
N/*******************  Bit definition for CEC_CFGR register  *******************/
N#define CEC_CFGR_SFT_Pos         (0U)                                          
N#define CEC_CFGR_SFT_Msk         (0x7U << CEC_CFGR_SFT_Pos)                    /*!< 0x00000007 */
N#define CEC_CFGR_SFT             CEC_CFGR_SFT_Msk                              /*!< CEC Signal Free Time               */
N#define CEC_CFGR_RXTOL_Pos       (3U)                                          
N#define CEC_CFGR_RXTOL_Msk       (0x1U << CEC_CFGR_RXTOL_Pos)                  /*!< 0x00000008 */
N#define CEC_CFGR_RXTOL           CEC_CFGR_RXTOL_Msk                            /*!< CEC Tolerance                      */
N#define CEC_CFGR_BRESTP_Pos      (4U)                                          
N#define CEC_CFGR_BRESTP_Msk      (0x1U << CEC_CFGR_BRESTP_Pos)                 /*!< 0x00000010 */
N#define CEC_CFGR_BRESTP          CEC_CFGR_BRESTP_Msk                           /*!< CEC Rx Stop                        */
N#define CEC_CFGR_BREGEN_Pos      (5U)                                          
N#define CEC_CFGR_BREGEN_Msk      (0x1U << CEC_CFGR_BREGEN_Pos)                 /*!< 0x00000020 */
N#define CEC_CFGR_BREGEN          CEC_CFGR_BREGEN_Msk                           /*!< CEC Bit Rising Error generation    */
N#define CEC_CFGR_LBPEGEN_Pos     (6U)                                          
N#define CEC_CFGR_LBPEGEN_Msk     (0x1U << CEC_CFGR_LBPEGEN_Pos)                /*!< 0x00000040 */
N#define CEC_CFGR_LBPEGEN         CEC_CFGR_LBPEGEN_Msk                          /*!< CEC Long Bit Period Error gener.   */
N#define CEC_CFGR_BRDNOGEN_Pos    (7U)                                          
N#define CEC_CFGR_BRDNOGEN_Msk    (0x1U << CEC_CFGR_BRDNOGEN_Pos)               /*!< 0x00000080 */
N#define CEC_CFGR_BRDNOGEN        CEC_CFGR_BRDNOGEN_Msk                         /*!< CEC Broadcast No Error generation  */
N#define CEC_CFGR_SFTOPT_Pos      (8U)                                          
N#define CEC_CFGR_SFTOPT_Msk      (0x1U << CEC_CFGR_SFTOPT_Pos)                 /*!< 0x00000100 */
N#define CEC_CFGR_SFTOPT          CEC_CFGR_SFTOPT_Msk                           /*!< CEC Signal Free Time optional      */
N#define CEC_CFGR_OAR_Pos         (16U)                                         
N#define CEC_CFGR_OAR_Msk         (0x7FFFU << CEC_CFGR_OAR_Pos)                 /*!< 0x7FFF0000 */
N#define CEC_CFGR_OAR             CEC_CFGR_OAR_Msk                              /*!< CEC Own Address                    */
N#define CEC_CFGR_LSTN_Pos        (31U)                                         
N#define CEC_CFGR_LSTN_Msk        (0x1U << CEC_CFGR_LSTN_Pos)                   /*!< 0x80000000 */
N#define CEC_CFGR_LSTN            CEC_CFGR_LSTN_Msk                             /*!< CEC Listen mode                    */
N
N/*******************  Bit definition for CEC_TXDR register  *******************/
N#define CEC_TXDR_TXD_Pos         (0U)                                          
N#define CEC_TXDR_TXD_Msk         (0xFFU << CEC_TXDR_TXD_Pos)                   /*!< 0x000000FF */
N#define CEC_TXDR_TXD             CEC_TXDR_TXD_Msk                              /*!< CEC Tx Data                        */
N
N/*******************  Bit definition for CEC_RXDR register  *******************/
N#define CEC_TXDR_RXD_Pos         (0U)                                          
N#define CEC_TXDR_RXD_Msk         (0xFFU << CEC_TXDR_RXD_Pos)                   /*!< 0x000000FF */
N#define CEC_TXDR_RXD             CEC_TXDR_RXD_Msk                              /*!< CEC Rx Data                        */
N
N/*******************  Bit definition for CEC_ISR register  ********************/
N#define CEC_ISR_RXBR_Pos         (0U)                                          
N#define CEC_ISR_RXBR_Msk         (0x1U << CEC_ISR_RXBR_Pos)                    /*!< 0x00000001 */
N#define CEC_ISR_RXBR             CEC_ISR_RXBR_Msk                              /*!< CEC Rx-Byte Received                   */
N#define CEC_ISR_RXEND_Pos        (1U)                                          
N#define CEC_ISR_RXEND_Msk        (0x1U << CEC_ISR_RXEND_Pos)                   /*!< 0x00000002 */
N#define CEC_ISR_RXEND            CEC_ISR_RXEND_Msk                             /*!< CEC End Of Reception                   */
N#define CEC_ISR_RXOVR_Pos        (2U)                                          
N#define CEC_ISR_RXOVR_Msk        (0x1U << CEC_ISR_RXOVR_Pos)                   /*!< 0x00000004 */
N#define CEC_ISR_RXOVR            CEC_ISR_RXOVR_Msk                             /*!< CEC Rx-Overrun                         */
N#define CEC_ISR_BRE_Pos          (3U)                                          
N#define CEC_ISR_BRE_Msk          (0x1U << CEC_ISR_BRE_Pos)                     /*!< 0x00000008 */
N#define CEC_ISR_BRE              CEC_ISR_BRE_Msk                               /*!< CEC Rx Bit Rising Error                */
N#define CEC_ISR_SBPE_Pos         (4U)                                          
N#define CEC_ISR_SBPE_Msk         (0x1U << CEC_ISR_SBPE_Pos)                    /*!< 0x00000010 */
N#define CEC_ISR_SBPE             CEC_ISR_SBPE_Msk                              /*!< CEC Rx Short Bit period Error          */
N#define CEC_ISR_LBPE_Pos         (5U)                                          
N#define CEC_ISR_LBPE_Msk         (0x1U << CEC_ISR_LBPE_Pos)                    /*!< 0x00000020 */
N#define CEC_ISR_LBPE             CEC_ISR_LBPE_Msk                              /*!< CEC Rx Long Bit period Error           */
N#define CEC_ISR_RXACKE_Pos       (6U)                                          
N#define CEC_ISR_RXACKE_Msk       (0x1U << CEC_ISR_RXACKE_Pos)                  /*!< 0x00000040 */
N#define CEC_ISR_RXACKE           CEC_ISR_RXACKE_Msk                            /*!< CEC Rx Missing Acknowledge             */
N#define CEC_ISR_ARBLST_Pos       (7U)                                          
N#define CEC_ISR_ARBLST_Msk       (0x1U << CEC_ISR_ARBLST_Pos)                  /*!< 0x00000080 */
N#define CEC_ISR_ARBLST           CEC_ISR_ARBLST_Msk                            /*!< CEC Arbitration Lost                   */
N#define CEC_ISR_TXBR_Pos         (8U)                                          
N#define CEC_ISR_TXBR_Msk         (0x1U << CEC_ISR_TXBR_Pos)                    /*!< 0x00000100 */
N#define CEC_ISR_TXBR             CEC_ISR_TXBR_Msk                              /*!< CEC Tx Byte Request                    */
N#define CEC_ISR_TXEND_Pos        (9U)                                          
N#define CEC_ISR_TXEND_Msk        (0x1U << CEC_ISR_TXEND_Pos)                   /*!< 0x00000200 */
N#define CEC_ISR_TXEND            CEC_ISR_TXEND_Msk                             /*!< CEC End of Transmission                */
N#define CEC_ISR_TXUDR_Pos        (10U)                                         
N#define CEC_ISR_TXUDR_Msk        (0x1U << CEC_ISR_TXUDR_Pos)                   /*!< 0x00000400 */
N#define CEC_ISR_TXUDR            CEC_ISR_TXUDR_Msk                             /*!< CEC Tx-Buffer Underrun                 */
N#define CEC_ISR_TXERR_Pos        (11U)                                         
N#define CEC_ISR_TXERR_Msk        (0x1U << CEC_ISR_TXERR_Pos)                   /*!< 0x00000800 */
N#define CEC_ISR_TXERR            CEC_ISR_TXERR_Msk                             /*!< CEC Tx-Error                           */
N#define CEC_ISR_TXACKE_Pos       (12U)                                         
N#define CEC_ISR_TXACKE_Msk       (0x1U << CEC_ISR_TXACKE_Pos)                  /*!< 0x00001000 */
N#define CEC_ISR_TXACKE           CEC_ISR_TXACKE_Msk                            /*!< CEC Tx Missing Acknowledge             */
N
N/*******************  Bit definition for CEC_IER register  ********************/
N#define CEC_IER_RXBRIE_Pos       (0U)                                          
N#define CEC_IER_RXBRIE_Msk       (0x1U << CEC_IER_RXBRIE_Pos)                  /*!< 0x00000001 */
N#define CEC_IER_RXBRIE           CEC_IER_RXBRIE_Msk                            /*!< CEC Rx-Byte Received IT Enable         */
N#define CEC_IER_RXENDIE_Pos      (1U)                                          
N#define CEC_IER_RXENDIE_Msk      (0x1U << CEC_IER_RXENDIE_Pos)                 /*!< 0x00000002 */
N#define CEC_IER_RXENDIE          CEC_IER_RXENDIE_Msk                           /*!< CEC End Of Reception IT Enable         */
N#define CEC_IER_RXOVRIE_Pos      (2U)                                          
N#define CEC_IER_RXOVRIE_Msk      (0x1U << CEC_IER_RXOVRIE_Pos)                 /*!< 0x00000004 */
N#define CEC_IER_RXOVRIE          CEC_IER_RXOVRIE_Msk                           /*!< CEC Rx-Overrun IT Enable               */
N#define CEC_IER_BREIE_Pos        (3U)                                          
N#define CEC_IER_BREIE_Msk        (0x1U << CEC_IER_BREIE_Pos)                   /*!< 0x00000008 */
N#define CEC_IER_BREIE            CEC_IER_BREIE_Msk                             /*!< CEC Rx Bit Rising Error IT Enable      */
N#define CEC_IER_SBPEIE_Pos       (4U)                                          
N#define CEC_IER_SBPEIE_Msk       (0x1U << CEC_IER_SBPEIE_Pos)                  /*!< 0x00000010 */
N#define CEC_IER_SBPEIE           CEC_IER_SBPEIE_Msk                            /*!< CEC Rx Short Bit period Error IT Enable*/
N#define CEC_IER_LBPEIE_Pos       (5U)                                          
N#define CEC_IER_LBPEIE_Msk       (0x1U << CEC_IER_LBPEIE_Pos)                  /*!< 0x00000020 */
N#define CEC_IER_LBPEIE           CEC_IER_LBPEIE_Msk                            /*!< CEC Rx Long Bit period Error IT Enable */
N#define CEC_IER_RXACKEIE_Pos     (6U)                                          
N#define CEC_IER_RXACKEIE_Msk     (0x1U << CEC_IER_RXACKEIE_Pos)                /*!< 0x00000040 */
N#define CEC_IER_RXACKEIE         CEC_IER_RXACKEIE_Msk                          /*!< CEC Rx Missing Acknowledge IT Enable   */
N#define CEC_IER_ARBLSTIE_Pos     (7U)                                          
N#define CEC_IER_ARBLSTIE_Msk     (0x1U << CEC_IER_ARBLSTIE_Pos)                /*!< 0x00000080 */
N#define CEC_IER_ARBLSTIE         CEC_IER_ARBLSTIE_Msk                          /*!< CEC Arbitration Lost IT Enable         */
N#define CEC_IER_TXBRIE_Pos       (8U)                                          
N#define CEC_IER_TXBRIE_Msk       (0x1U << CEC_IER_TXBRIE_Pos)                  /*!< 0x00000100 */
N#define CEC_IER_TXBRIE           CEC_IER_TXBRIE_Msk                            /*!< CEC Tx Byte Request  IT Enable         */
N#define CEC_IER_TXENDIE_Pos      (9U)                                          
N#define CEC_IER_TXENDIE_Msk      (0x1U << CEC_IER_TXENDIE_Pos)                 /*!< 0x00000200 */
N#define CEC_IER_TXENDIE          CEC_IER_TXENDIE_Msk                           /*!< CEC End of Transmission IT Enable      */
N#define CEC_IER_TXUDRIE_Pos      (10U)                                         
N#define CEC_IER_TXUDRIE_Msk      (0x1U << CEC_IER_TXUDRIE_Pos)                 /*!< 0x00000400 */
N#define CEC_IER_TXUDRIE          CEC_IER_TXUDRIE_Msk                           /*!< CEC Tx-Buffer Underrun IT Enable       */
N#define CEC_IER_TXERRIE_Pos      (11U)                                         
N#define CEC_IER_TXERRIE_Msk      (0x1U << CEC_IER_TXERRIE_Pos)                 /*!< 0x00000800 */
N#define CEC_IER_TXERRIE          CEC_IER_TXERRIE_Msk                           /*!< CEC Tx-Error IT Enable                 */
N#define CEC_IER_TXACKEIE_Pos     (12U)                                         
N#define CEC_IER_TXACKEIE_Msk     (0x1U << CEC_IER_TXACKEIE_Pos)                /*!< 0x00001000 */
N#define CEC_IER_TXACKEIE         CEC_IER_TXACKEIE_Msk                          /*!< CEC Tx Missing Acknowledge IT Enable   */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog Comparators (COMP)                             */
N/*                                                                            */
N/******************************************************************************/
N/***********************  Bit definition for COMP_CSR register  ***************/
N/* COMP1 bits definition */
N#define COMP_CSR_COMP1EN_Pos          (0U)                                     
N#define COMP_CSR_COMP1EN_Msk          (0x1U << COMP_CSR_COMP1EN_Pos)           /*!< 0x00000001 */
N#define COMP_CSR_COMP1EN              COMP_CSR_COMP1EN_Msk                     /*!< COMP1 enable */
N#define COMP_CSR_COMP1SW1_Pos         (1U)                                     
N#define COMP_CSR_COMP1SW1_Msk         (0x1U << COMP_CSR_COMP1SW1_Pos)          /*!< 0x00000002 */
N#define COMP_CSR_COMP1SW1             COMP_CSR_COMP1SW1_Msk                    /*!< COMP1 SW1 switch control */
N#define COMP_CSR_COMP1MODE_Pos        (2U)                                     
N#define COMP_CSR_COMP1MODE_Msk        (0x3U << COMP_CSR_COMP1MODE_Pos)         /*!< 0x0000000C */
N#define COMP_CSR_COMP1MODE            COMP_CSR_COMP1MODE_Msk                   /*!< COMP1 power mode */
N#define COMP_CSR_COMP1MODE_0          (0x1U << COMP_CSR_COMP1MODE_Pos)         /*!< 0x00000004 */
N#define COMP_CSR_COMP1MODE_1          (0x2U << COMP_CSR_COMP1MODE_Pos)         /*!< 0x00000008 */
N#define COMP_CSR_COMP1INSEL_Pos       (4U)                                     
N#define COMP_CSR_COMP1INSEL_Msk       (0x7U << COMP_CSR_COMP1INSEL_Pos)        /*!< 0x00000070 */
N#define COMP_CSR_COMP1INSEL           COMP_CSR_COMP1INSEL_Msk                  /*!< COMP1 inverting input select */
N#define COMP_CSR_COMP1INSEL_0         (0x1U << COMP_CSR_COMP1INSEL_Pos)        /*!< 0x00000010 */
N#define COMP_CSR_COMP1INSEL_1         (0x2U << COMP_CSR_COMP1INSEL_Pos)        /*!< 0x00000020 */
N#define COMP_CSR_COMP1INSEL_2         (0x4U << COMP_CSR_COMP1INSEL_Pos)        /*!< 0x00000040 */
N#define COMP_CSR_COMP1OUTSEL_Pos      (8U)                                     
N#define COMP_CSR_COMP1OUTSEL_Msk      (0x7U << COMP_CSR_COMP1OUTSEL_Pos)       /*!< 0x00000700 */
N#define COMP_CSR_COMP1OUTSEL          COMP_CSR_COMP1OUTSEL_Msk                 /*!< COMP1 output select */
N#define COMP_CSR_COMP1OUTSEL_0        (0x1U << COMP_CSR_COMP1OUTSEL_Pos)       /*!< 0x00000100 */
N#define COMP_CSR_COMP1OUTSEL_1        (0x2U << COMP_CSR_COMP1OUTSEL_Pos)       /*!< 0x00000200 */
N#define COMP_CSR_COMP1OUTSEL_2        (0x4U << COMP_CSR_COMP1OUTSEL_Pos)       /*!< 0x00000400 */
N#define COMP_CSR_COMP1POL_Pos         (11U)                                    
N#define COMP_CSR_COMP1POL_Msk         (0x1U << COMP_CSR_COMP1POL_Pos)          /*!< 0x00000800 */
N#define COMP_CSR_COMP1POL             COMP_CSR_COMP1POL_Msk                    /*!< COMP1 output polarity */
N#define COMP_CSR_COMP1HYST_Pos        (12U)                                    
N#define COMP_CSR_COMP1HYST_Msk        (0x3U << COMP_CSR_COMP1HYST_Pos)         /*!< 0x00003000 */
N#define COMP_CSR_COMP1HYST            COMP_CSR_COMP1HYST_Msk                   /*!< COMP1 hysteresis */
N#define COMP_CSR_COMP1HYST_0          (0x1U << COMP_CSR_COMP1HYST_Pos)         /*!< 0x00001000 */
N#define COMP_CSR_COMP1HYST_1          (0x2U << COMP_CSR_COMP1HYST_Pos)         /*!< 0x00002000 */
N#define COMP_CSR_COMP1OUT_Pos         (14U)                                    
N#define COMP_CSR_COMP1OUT_Msk         (0x1U << COMP_CSR_COMP1OUT_Pos)          /*!< 0x00004000 */
N#define COMP_CSR_COMP1OUT             COMP_CSR_COMP1OUT_Msk                    /*!< COMP1 output level */
N#define COMP_CSR_COMP1LOCK_Pos        (15U)                                    
N#define COMP_CSR_COMP1LOCK_Msk        (0x1U << COMP_CSR_COMP1LOCK_Pos)         /*!< 0x00008000 */
N#define COMP_CSR_COMP1LOCK            COMP_CSR_COMP1LOCK_Msk                   /*!< COMP1 lock */
N/* COMP2 bits definition */
N#define COMP_CSR_COMP2EN_Pos          (16U)                                    
N#define COMP_CSR_COMP2EN_Msk          (0x1U << COMP_CSR_COMP2EN_Pos)           /*!< 0x00010000 */
N#define COMP_CSR_COMP2EN              COMP_CSR_COMP2EN_Msk                     /*!< COMP2 enable */
N#define COMP_CSR_COMP2MODE_Pos        (18U)                                    
N#define COMP_CSR_COMP2MODE_Msk        (0x3U << COMP_CSR_COMP2MODE_Pos)         /*!< 0x000C0000 */
N#define COMP_CSR_COMP2MODE            COMP_CSR_COMP2MODE_Msk                   /*!< COMP2 power mode */
N#define COMP_CSR_COMP2MODE_0          (0x1U << COMP_CSR_COMP2MODE_Pos)         /*!< 0x00040000 */
N#define COMP_CSR_COMP2MODE_1          (0x2U << COMP_CSR_COMP2MODE_Pos)         /*!< 0x00080000 */
N#define COMP_CSR_COMP2INSEL_Pos       (20U)                                    
N#define COMP_CSR_COMP2INSEL_Msk       (0x7U << COMP_CSR_COMP2INSEL_Pos)        /*!< 0x00700000 */
N#define COMP_CSR_COMP2INSEL           COMP_CSR_COMP2INSEL_Msk                  /*!< COMP2 inverting input select */
N#define COMP_CSR_COMP2INSEL_0         (0x1U << COMP_CSR_COMP2INSEL_Pos)        /*!< 0x00100000 */
N#define COMP_CSR_COMP2INSEL_1         (0x2U << COMP_CSR_COMP2INSEL_Pos)        /*!< 0x00200000 */
N#define COMP_CSR_COMP2INSEL_2         (0x4U << COMP_CSR_COMP2INSEL_Pos)        /*!< 0x00400000 */
N#define COMP_CSR_WNDWEN_Pos           (23U)                                    
N#define COMP_CSR_WNDWEN_Msk           (0x1U << COMP_CSR_WNDWEN_Pos)            /*!< 0x00800000 */
N#define COMP_CSR_WNDWEN               COMP_CSR_WNDWEN_Msk                      /*!< COMPx window mode. Bit intended to be used with COMP common instance (COMP_Common_TypeDef) */
N#define COMP_CSR_COMP2OUTSEL_Pos      (24U)                                    
N#define COMP_CSR_COMP2OUTSEL_Msk      (0x7U << COMP_CSR_COMP2OUTSEL_Pos)       /*!< 0x07000000 */
N#define COMP_CSR_COMP2OUTSEL          COMP_CSR_COMP2OUTSEL_Msk                 /*!< COMP2 output select */
N#define COMP_CSR_COMP2OUTSEL_0        (0x1U << COMP_CSR_COMP2OUTSEL_Pos)       /*!< 0x01000000 */
N#define COMP_CSR_COMP2OUTSEL_1        (0x2U << COMP_CSR_COMP2OUTSEL_Pos)       /*!< 0x02000000 */
N#define COMP_CSR_COMP2OUTSEL_2        (0x4U << COMP_CSR_COMP2OUTSEL_Pos)       /*!< 0x04000000 */
N#define COMP_CSR_COMP2POL_Pos         (27U)                                    
N#define COMP_CSR_COMP2POL_Msk         (0x1U << COMP_CSR_COMP2POL_Pos)          /*!< 0x08000000 */
N#define COMP_CSR_COMP2POL             COMP_CSR_COMP2POL_Msk                    /*!< COMP2 output polarity */
N#define COMP_CSR_COMP2HYST_Pos        (28U)                                    
N#define COMP_CSR_COMP2HYST_Msk        (0x3U << COMP_CSR_COMP2HYST_Pos)         /*!< 0x30000000 */
N#define COMP_CSR_COMP2HYST            COMP_CSR_COMP2HYST_Msk                   /*!< COMP2 hysteresis */
N#define COMP_CSR_COMP2HYST_0          (0x1U << COMP_CSR_COMP2HYST_Pos)         /*!< 0x10000000 */
N#define COMP_CSR_COMP2HYST_1          (0x2U << COMP_CSR_COMP2HYST_Pos)         /*!< 0x20000000 */
N#define COMP_CSR_COMP2OUT_Pos         (30U)                                    
N#define COMP_CSR_COMP2OUT_Msk         (0x1U << COMP_CSR_COMP2OUT_Pos)          /*!< 0x40000000 */
N#define COMP_CSR_COMP2OUT             COMP_CSR_COMP2OUT_Msk                    /*!< COMP2 output level */
N#define COMP_CSR_COMP2LOCK_Pos        (31U)                                    
N#define COMP_CSR_COMP2LOCK_Msk        (0x1U << COMP_CSR_COMP2LOCK_Pos)         /*!< 0x80000000 */
N#define COMP_CSR_COMP2LOCK            COMP_CSR_COMP2LOCK_Msk                   /*!< COMP2 lock */
N/* COMPx bits definition */
N#define COMP_CSR_COMPxEN_Pos          (0U)                                     
N#define COMP_CSR_COMPxEN_Msk          (0x1U << COMP_CSR_COMPxEN_Pos)           /*!< 0x00000001 */
N#define COMP_CSR_COMPxEN              COMP_CSR_COMPxEN_Msk                     /*!< COMPx enable */
N#define COMP_CSR_COMPxMODE_Pos        (2U)                                     
N#define COMP_CSR_COMPxMODE_Msk        (0x3U << COMP_CSR_COMPxMODE_Pos)         /*!< 0x0000000C */
N#define COMP_CSR_COMPxMODE            COMP_CSR_COMPxMODE_Msk                   /*!< COMPx power mode */
N#define COMP_CSR_COMPxMODE_0          (0x1U << COMP_CSR_COMPxMODE_Pos)         /*!< 0x00000004 */
N#define COMP_CSR_COMPxMODE_1          (0x2U << COMP_CSR_COMPxMODE_Pos)         /*!< 0x00000008 */
N#define COMP_CSR_COMPxINSEL_Pos       (4U)                                     
N#define COMP_CSR_COMPxINSEL_Msk       (0x7U << COMP_CSR_COMPxINSEL_Pos)        /*!< 0x00000070 */
N#define COMP_CSR_COMPxINSEL           COMP_CSR_COMPxINSEL_Msk                  /*!< COMPx inverting input select */
N#define COMP_CSR_COMPxINSEL_0         (0x1U << COMP_CSR_COMPxINSEL_Pos)        /*!< 0x00000010 */
N#define COMP_CSR_COMPxINSEL_1         (0x2U << COMP_CSR_COMPxINSEL_Pos)        /*!< 0x00000020 */
N#define COMP_CSR_COMPxINSEL_2         (0x4U << COMP_CSR_COMPxINSEL_Pos)        /*!< 0x00000040 */
N#define COMP_CSR_COMPxOUTSEL_Pos      (8U)                                     
N#define COMP_CSR_COMPxOUTSEL_Msk      (0x7U << COMP_CSR_COMPxOUTSEL_Pos)       /*!< 0x00000700 */
N#define COMP_CSR_COMPxOUTSEL          COMP_CSR_COMPxOUTSEL_Msk                 /*!< COMPx output select */
N#define COMP_CSR_COMPxOUTSEL_0        (0x1U << COMP_CSR_COMPxOUTSEL_Pos)       /*!< 0x00000100 */
N#define COMP_CSR_COMPxOUTSEL_1        (0x2U << COMP_CSR_COMPxOUTSEL_Pos)       /*!< 0x00000200 */
N#define COMP_CSR_COMPxOUTSEL_2        (0x4U << COMP_CSR_COMPxOUTSEL_Pos)       /*!< 0x00000400 */
N#define COMP_CSR_COMPxPOL_Pos         (11U)                                    
N#define COMP_CSR_COMPxPOL_Msk         (0x1U << COMP_CSR_COMPxPOL_Pos)          /*!< 0x00000800 */
N#define COMP_CSR_COMPxPOL             COMP_CSR_COMPxPOL_Msk                    /*!< COMPx output polarity */
N#define COMP_CSR_COMPxHYST_Pos        (12U)                                    
N#define COMP_CSR_COMPxHYST_Msk        (0x3U << COMP_CSR_COMPxHYST_Pos)         /*!< 0x00003000 */
N#define COMP_CSR_COMPxHYST            COMP_CSR_COMPxHYST_Msk                   /*!< COMPx hysteresis */
N#define COMP_CSR_COMPxHYST_0          (0x1U << COMP_CSR_COMPxHYST_Pos)         /*!< 0x00001000 */
N#define COMP_CSR_COMPxHYST_1          (0x2U << COMP_CSR_COMPxHYST_Pos)         /*!< 0x00002000 */
N#define COMP_CSR_COMPxOUT_Pos         (14U)                                    
N#define COMP_CSR_COMPxOUT_Msk         (0x1U << COMP_CSR_COMPxOUT_Pos)          /*!< 0x00004000 */
N#define COMP_CSR_COMPxOUT             COMP_CSR_COMPxOUT_Msk                    /*!< COMPx output level */
N#define COMP_CSR_COMPxLOCK_Pos        (15U)                                    
N#define COMP_CSR_COMPxLOCK_Msk        (0x1U << COMP_CSR_COMPxLOCK_Pos)         /*!< 0x00008000 */
N#define COMP_CSR_COMPxLOCK            COMP_CSR_COMPxLOCK_Msk                   /*!< COMPx lock */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       CRC calculation unit (CRC)                           */
N/*                                                                            */
N/******************************************************************************/
N
N/*
N* @brief Specific device feature definitions (not present on all devices in the STM32F0 serie)
N*/
N
N/* Support of Programmable Polynomial size and value feature */
N#define CRC_PROG_POLYNOMIAL_SUPPORT
N
N/*******************  Bit definition for CRC_DR register  *********************/
N#define CRC_DR_DR_Pos            (0U)                                          
N#define CRC_DR_DR_Msk            (0xFFFFFFFFU << CRC_DR_DR_Pos)                /*!< 0xFFFFFFFF */
N#define CRC_DR_DR                CRC_DR_DR_Msk                                 /*!< Data register bits */
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define CRC_IDR_IDR              ((uint8_t)0xFFU)                              /*!< General-purpose 8-bit data register bits */
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define CRC_CR_RESET_Pos         (0U)                                          
N#define CRC_CR_RESET_Msk         (0x1U << CRC_CR_RESET_Pos)                    /*!< 0x00000001 */
N#define CRC_CR_RESET             CRC_CR_RESET_Msk                              /*!< RESET the CRC computation unit bit */
N#define CRC_CR_POLYSIZE_Pos      (3U)                                          
N#define CRC_CR_POLYSIZE_Msk      (0x3U << CRC_CR_POLYSIZE_Pos)                 /*!< 0x00000018 */
N#define CRC_CR_POLYSIZE          CRC_CR_POLYSIZE_Msk                           /*!< Polynomial size bits */
N#define CRC_CR_POLYSIZE_0        (0x1U << CRC_CR_POLYSIZE_Pos)                 /*!< 0x00000008 */
N#define CRC_CR_POLYSIZE_1        (0x2U << CRC_CR_POLYSIZE_Pos)                 /*!< 0x00000010 */
N#define CRC_CR_REV_IN_Pos        (5U)                                          
N#define CRC_CR_REV_IN_Msk        (0x3U << CRC_CR_REV_IN_Pos)                   /*!< 0x00000060 */
N#define CRC_CR_REV_IN            CRC_CR_REV_IN_Msk                             /*!< REV_IN Reverse Input Data bits */
N#define CRC_CR_REV_IN_0          (0x1U << CRC_CR_REV_IN_Pos)                   /*!< 0x00000020 */
N#define CRC_CR_REV_IN_1          (0x2U << CRC_CR_REV_IN_Pos)                   /*!< 0x00000040 */
N#define CRC_CR_REV_OUT_Pos       (7U)                                          
N#define CRC_CR_REV_OUT_Msk       (0x1U << CRC_CR_REV_OUT_Pos)                  /*!< 0x00000080 */
N#define CRC_CR_REV_OUT           CRC_CR_REV_OUT_Msk                            /*!< REV_OUT Reverse Output Data bits */
N
N/*******************  Bit definition for CRC_INIT register  *******************/
N#define CRC_INIT_INIT_Pos        (0U)                                          
N#define CRC_INIT_INIT_Msk        (0xFFFFFFFFU << CRC_INIT_INIT_Pos)            /*!< 0xFFFFFFFF */
N#define CRC_INIT_INIT            CRC_INIT_INIT_Msk                             /*!< Initial CRC value bits */
N
N/*******************  Bit definition for CRC_POL register  ********************/
N#define CRC_POL_POL_Pos          (0U)                                          
N#define CRC_POL_POL_Msk          (0xFFFFFFFFU << CRC_POL_POL_Pos)              /*!< 0xFFFFFFFF */
N#define CRC_POL_POL              CRC_POL_POL_Msk                               /*!< Coefficients of the polynomial  */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          CRS Clock Recovery System                         */
N/******************************************************************************/
N
N/*******************  Bit definition for CRS_CR register  *********************/
N#define CRS_CR_SYNCOKIE_Pos       (0U)                                         
N#define CRS_CR_SYNCOKIE_Msk       (0x1U << CRS_CR_SYNCOKIE_Pos)                /*!< 0x00000001 */
N#define CRS_CR_SYNCOKIE           CRS_CR_SYNCOKIE_Msk                          /* SYNC event OK interrupt enable        */
N#define CRS_CR_SYNCWARNIE_Pos     (1U)                                         
N#define CRS_CR_SYNCWARNIE_Msk     (0x1U << CRS_CR_SYNCWARNIE_Pos)              /*!< 0x00000002 */
N#define CRS_CR_SYNCWARNIE         CRS_CR_SYNCWARNIE_Msk                        /* SYNC warning interrupt enable         */
N#define CRS_CR_ERRIE_Pos          (2U)                                         
N#define CRS_CR_ERRIE_Msk          (0x1U << CRS_CR_ERRIE_Pos)                   /*!< 0x00000004 */
N#define CRS_CR_ERRIE              CRS_CR_ERRIE_Msk                             /* SYNC error interrupt enable           */
N#define CRS_CR_ESYNCIE_Pos        (3U)                                         
N#define CRS_CR_ESYNCIE_Msk        (0x1U << CRS_CR_ESYNCIE_Pos)                 /*!< 0x00000008 */
N#define CRS_CR_ESYNCIE            CRS_CR_ESYNCIE_Msk                           /* Expected SYNC(ESYNCF) interrupt Enable*/
N#define CRS_CR_CEN_Pos            (5U)                                         
N#define CRS_CR_CEN_Msk            (0x1U << CRS_CR_CEN_Pos)                     /*!< 0x00000020 */
N#define CRS_CR_CEN                CRS_CR_CEN_Msk                               /* Frequency error counter enable        */
N#define CRS_CR_AUTOTRIMEN_Pos     (6U)                                         
N#define CRS_CR_AUTOTRIMEN_Msk     (0x1U << CRS_CR_AUTOTRIMEN_Pos)              /*!< 0x00000040 */
N#define CRS_CR_AUTOTRIMEN         CRS_CR_AUTOTRIMEN_Msk                        /* Automatic trimming enable             */
N#define CRS_CR_SWSYNC_Pos         (7U)                                         
N#define CRS_CR_SWSYNC_Msk         (0x1U << CRS_CR_SWSYNC_Pos)                  /*!< 0x00000080 */
N#define CRS_CR_SWSYNC             CRS_CR_SWSYNC_Msk                            /* A Software SYNC event is generated    */
N#define CRS_CR_TRIM_Pos           (8U)                                         
N#define CRS_CR_TRIM_Msk           (0x3FU << CRS_CR_TRIM_Pos)                   /*!< 0x00003F00 */
N#define CRS_CR_TRIM               CRS_CR_TRIM_Msk                              /* HSI48 oscillator smooth trimming      */
N
N/*******************  Bit definition for CRS_CFGR register  *********************/
N#define CRS_CFGR_RELOAD_Pos       (0U)                                         
N#define CRS_CFGR_RELOAD_Msk       (0xFFFFU << CRS_CFGR_RELOAD_Pos)             /*!< 0x0000FFFF */
N#define CRS_CFGR_RELOAD           CRS_CFGR_RELOAD_Msk                          /* Counter reload value               */
N#define CRS_CFGR_FELIM_Pos        (16U)                                        
N#define CRS_CFGR_FELIM_Msk        (0xFFU << CRS_CFGR_FELIM_Pos)                /*!< 0x00FF0000 */
N#define CRS_CFGR_FELIM            CRS_CFGR_FELIM_Msk                           /* Frequency error limit              */
N
N#define CRS_CFGR_SYNCDIV_Pos      (24U)                                        
N#define CRS_CFGR_SYNCDIV_Msk      (0x7U << CRS_CFGR_SYNCDIV_Pos)               /*!< 0x07000000 */
N#define CRS_CFGR_SYNCDIV          CRS_CFGR_SYNCDIV_Msk                         /* SYNC divider                       */
N#define CRS_CFGR_SYNCDIV_0        (0x1U << CRS_CFGR_SYNCDIV_Pos)               /*!< 0x01000000 */
N#define CRS_CFGR_SYNCDIV_1        (0x2U << CRS_CFGR_SYNCDIV_Pos)               /*!< 0x02000000 */
N#define CRS_CFGR_SYNCDIV_2        (0x4U << CRS_CFGR_SYNCDIV_Pos)               /*!< 0x04000000 */
N
N#define CRS_CFGR_SYNCSRC_Pos      (28U)                                        
N#define CRS_CFGR_SYNCSRC_Msk      (0x3U << CRS_CFGR_SYNCSRC_Pos)               /*!< 0x30000000 */
N#define CRS_CFGR_SYNCSRC          CRS_CFGR_SYNCSRC_Msk                         /* SYNC signal source selection       */
N#define CRS_CFGR_SYNCSRC_0        (0x1U << CRS_CFGR_SYNCSRC_Pos)               /*!< 0x10000000 */
N#define CRS_CFGR_SYNCSRC_1        (0x2U << CRS_CFGR_SYNCSRC_Pos)               /*!< 0x20000000 */
N
N#define CRS_CFGR_SYNCPOL_Pos      (31U)                                        
N#define CRS_CFGR_SYNCPOL_Msk      (0x1U << CRS_CFGR_SYNCPOL_Pos)               /*!< 0x80000000 */
N#define CRS_CFGR_SYNCPOL          CRS_CFGR_SYNCPOL_Msk                         /* SYNC polarity selection            */
N  
N/*******************  Bit definition for CRS_ISR register  *********************/
N#define CRS_ISR_SYNCOKF_Pos       (0U)                                         
N#define CRS_ISR_SYNCOKF_Msk       (0x1U << CRS_ISR_SYNCOKF_Pos)                /*!< 0x00000001 */
N#define CRS_ISR_SYNCOKF           CRS_ISR_SYNCOKF_Msk                          /* SYNC event OK flag             */
N#define CRS_ISR_SYNCWARNF_Pos     (1U)                                         
N#define CRS_ISR_SYNCWARNF_Msk     (0x1U << CRS_ISR_SYNCWARNF_Pos)              /*!< 0x00000002 */
N#define CRS_ISR_SYNCWARNF         CRS_ISR_SYNCWARNF_Msk                        /* SYNC warning                   */
N#define CRS_ISR_ERRF_Pos          (2U)                                         
N#define CRS_ISR_ERRF_Msk          (0x1U << CRS_ISR_ERRF_Pos)                   /*!< 0x00000004 */
N#define CRS_ISR_ERRF              CRS_ISR_ERRF_Msk                             /* SYNC error flag                */
N#define CRS_ISR_ESYNCF_Pos        (3U)                                         
N#define CRS_ISR_ESYNCF_Msk        (0x1U << CRS_ISR_ESYNCF_Pos)                 /*!< 0x00000008 */
N#define CRS_ISR_ESYNCF            CRS_ISR_ESYNCF_Msk                           /* Expected SYNC flag             */
N#define CRS_ISR_SYNCERR_Pos       (8U)                                         
N#define CRS_ISR_SYNCERR_Msk       (0x1U << CRS_ISR_SYNCERR_Pos)                /*!< 0x00000100 */
N#define CRS_ISR_SYNCERR           CRS_ISR_SYNCERR_Msk                          /* SYNC error                     */
N#define CRS_ISR_SYNCMISS_Pos      (9U)                                         
N#define CRS_ISR_SYNCMISS_Msk      (0x1U << CRS_ISR_SYNCMISS_Pos)               /*!< 0x00000200 */
N#define CRS_ISR_SYNCMISS          CRS_ISR_SYNCMISS_Msk                         /* SYNC missed                    */
N#define CRS_ISR_TRIMOVF_Pos       (10U)                                        
N#define CRS_ISR_TRIMOVF_Msk       (0x1U << CRS_ISR_TRIMOVF_Pos)                /*!< 0x00000400 */
N#define CRS_ISR_TRIMOVF           CRS_ISR_TRIMOVF_Msk                          /* Trimming overflow or underflow */
N#define CRS_ISR_FEDIR_Pos         (15U)                                        
N#define CRS_ISR_FEDIR_Msk         (0x1U << CRS_ISR_FEDIR_Pos)                  /*!< 0x00008000 */
N#define CRS_ISR_FEDIR             CRS_ISR_FEDIR_Msk                            /* Frequency error direction      */
N#define CRS_ISR_FECAP_Pos         (16U)                                        
N#define CRS_ISR_FECAP_Msk         (0xFFFFU << CRS_ISR_FECAP_Pos)               /*!< 0xFFFF0000 */
N#define CRS_ISR_FECAP             CRS_ISR_FECAP_Msk                            /* Frequency error capture        */
N
N/*******************  Bit definition for CRS_ICR register  *********************/
N#define CRS_ICR_SYNCOKC_Pos       (0U)                                         
N#define CRS_ICR_SYNCOKC_Msk       (0x1U << CRS_ICR_SYNCOKC_Pos)                /*!< 0x00000001 */
N#define CRS_ICR_SYNCOKC           CRS_ICR_SYNCOKC_Msk                          /* SYNC event OK clear flag     */
N#define CRS_ICR_SYNCWARNC_Pos     (1U)                                         
N#define CRS_ICR_SYNCWARNC_Msk     (0x1U << CRS_ICR_SYNCWARNC_Pos)              /*!< 0x00000002 */
N#define CRS_ICR_SYNCWARNC         CRS_ICR_SYNCWARNC_Msk                        /* SYNC warning clear flag      */
N#define CRS_ICR_ERRC_Pos          (2U)                                         
N#define CRS_ICR_ERRC_Msk          (0x1U << CRS_ICR_ERRC_Pos)                   /*!< 0x00000004 */
N#define CRS_ICR_ERRC              CRS_ICR_ERRC_Msk                             /* Error clear flag        */
N#define CRS_ICR_ESYNCC_Pos        (3U)                                         
N#define CRS_ICR_ESYNCC_Msk        (0x1U << CRS_ICR_ESYNCC_Pos)                 /*!< 0x00000008 */
N#define CRS_ICR_ESYNCC            CRS_ICR_ESYNCC_Msk                           /* Expected SYNC clear flag     */
N
N/******************************************************************************/
N/*                                                                            */
N/*                 Digital to Analog Converter (DAC)                          */
N/*                                                                            */
N/******************************************************************************/
N
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32F0 serie)
N */
N#define DAC_CHANNEL2_SUPPORT                       /*!< DAC feature available only on specific devices: availability of DAC channel 2 */
N
N/********************  Bit definition for DAC_CR register  ********************/
N#define DAC_CR_EN1_Pos              (0U)                                       
N#define DAC_CR_EN1_Msk              (0x1U << DAC_CR_EN1_Pos)                   /*!< 0x00000001 */
N#define DAC_CR_EN1                  DAC_CR_EN1_Msk                             /*!< DAC channel1 enable */
N#define DAC_CR_BOFF1_Pos            (1U)                                       
N#define DAC_CR_BOFF1_Msk            (0x1U << DAC_CR_BOFF1_Pos)                 /*!< 0x00000002 */
N#define DAC_CR_BOFF1                DAC_CR_BOFF1_Msk                           /*!< DAC channel1 output buffer disable */
N#define DAC_CR_TEN1_Pos             (2U)                                       
N#define DAC_CR_TEN1_Msk             (0x1U << DAC_CR_TEN1_Pos)                  /*!< 0x00000004 */
N#define DAC_CR_TEN1                 DAC_CR_TEN1_Msk                            /*!< DAC channel1 Trigger enable */
N
N#define DAC_CR_TSEL1_Pos            (3U)                                       
N#define DAC_CR_TSEL1_Msk            (0x7U << DAC_CR_TSEL1_Pos)                 /*!< 0x00000038 */
N#define DAC_CR_TSEL1                DAC_CR_TSEL1_Msk                           /*!< TSEL1[2:0] (DAC channel1 Trigger selection) */
N#define DAC_CR_TSEL1_0              (0x1U << DAC_CR_TSEL1_Pos)                 /*!< 0x00000008 */
N#define DAC_CR_TSEL1_1              (0x2U << DAC_CR_TSEL1_Pos)                 /*!< 0x00000010 */
N#define DAC_CR_TSEL1_2              (0x4U << DAC_CR_TSEL1_Pos)                 /*!< 0x00000020 */
N
N#define DAC_CR_WAVE1_Pos            (6U)                                       
N#define DAC_CR_WAVE1_Msk            (0x3U << DAC_CR_WAVE1_Pos)                 /*!< 0x000000C0 */
N#define DAC_CR_WAVE1                DAC_CR_WAVE1_Msk                           /*!< WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
N#define DAC_CR_WAVE1_0              (0x1U << DAC_CR_WAVE1_Pos)                 /*!< 0x00000040 */
N#define DAC_CR_WAVE1_1              (0x2U << DAC_CR_WAVE1_Pos)                 /*!< 0x00000080 */
N
N#define DAC_CR_MAMP1_Pos            (8U)                                       
N#define DAC_CR_MAMP1_Msk            (0xFU << DAC_CR_MAMP1_Pos)                 /*!< 0x00000F00 */
N#define DAC_CR_MAMP1                DAC_CR_MAMP1_Msk                           /*!< MAMP1[3:0] (DAC channel1 Mask/Amplitude selector)  */
N#define DAC_CR_MAMP1_0              (0x1U << DAC_CR_MAMP1_Pos)                 /*!< 0x00000100 */
N#define DAC_CR_MAMP1_1              (0x2U << DAC_CR_MAMP1_Pos)                 /*!< 0x00000200 */
N#define DAC_CR_MAMP1_2              (0x4U << DAC_CR_MAMP1_Pos)                 /*!< 0x00000400 */
N#define DAC_CR_MAMP1_3              (0x8U << DAC_CR_MAMP1_Pos)                 /*!< 0x00000800 */
N
N#define DAC_CR_DMAEN1_Pos           (12U)                                      
N#define DAC_CR_DMAEN1_Msk           (0x1U << DAC_CR_DMAEN1_Pos)                /*!< 0x00001000 */
N#define DAC_CR_DMAEN1               DAC_CR_DMAEN1_Msk                          /*!< DAC channel1 DMA enable */
N#define DAC_CR_DMAUDRIE1_Pos        (13U)                                      
N#define DAC_CR_DMAUDRIE1_Msk        (0x1U << DAC_CR_DMAUDRIE1_Pos)             /*!< 0x00002000 */
N#define DAC_CR_DMAUDRIE1            DAC_CR_DMAUDRIE1_Msk                       /*!< DAC channel1 DMA Underrun Interrupt enable */
N
N#define DAC_CR_EN2_Pos              (16U)                                      
N#define DAC_CR_EN2_Msk              (0x1U << DAC_CR_EN2_Pos)                   /*!< 0x00010000 */
N#define DAC_CR_EN2                  DAC_CR_EN2_Msk                             /*!< DAC channel2 enable */
N#define DAC_CR_BOFF2_Pos            (17U)                                      
N#define DAC_CR_BOFF2_Msk            (0x1U << DAC_CR_BOFF2_Pos)                 /*!< 0x00020000 */
N#define DAC_CR_BOFF2                DAC_CR_BOFF2_Msk                           /*!< DAC channel2 output buffer disable */
N#define DAC_CR_TEN2_Pos             (18U)                                      
N#define DAC_CR_TEN2_Msk             (0x1U << DAC_CR_TEN2_Pos)                  /*!< 0x00040000 */
N#define DAC_CR_TEN2                 DAC_CR_TEN2_Msk                            /*!< DAC channel2 Trigger enable */
N
N#define DAC_CR_TSEL2_Pos            (19U)                                      
N#define DAC_CR_TSEL2_Msk            (0x7U << DAC_CR_TSEL2_Pos)                 /*!< 0x00380000 */
N#define DAC_CR_TSEL2                DAC_CR_TSEL2_Msk                           /*!< TSEL2[2:0] (DAC channel2 Trigger selection) */
N#define DAC_CR_TSEL2_0              (0x1U << DAC_CR_TSEL2_Pos)                 /*!< 0x00080000 */
N#define DAC_CR_TSEL2_1              (0x2U << DAC_CR_TSEL2_Pos)                 /*!< 0x00100000 */
N#define DAC_CR_TSEL2_2              (0x4U << DAC_CR_TSEL2_Pos)                 /*!< 0x00200000 */
N
N#define DAC_CR_WAVE2_Pos            (22U)                                      
N#define DAC_CR_WAVE2_Msk            (0x3U << DAC_CR_WAVE2_Pos)                 /*!< 0x00C00000 */
N#define DAC_CR_WAVE2                DAC_CR_WAVE2_Msk                           /*!< WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
N#define DAC_CR_WAVE2_0              (0x1U << DAC_CR_WAVE2_Pos)                 /*!< 0x00400000 */
N#define DAC_CR_WAVE2_1              (0x2U << DAC_CR_WAVE2_Pos)                 /*!< 0x00800000 */
N
N#define DAC_CR_MAMP2_Pos            (24U)                                      
N#define DAC_CR_MAMP2_Msk            (0xFU << DAC_CR_MAMP2_Pos)                 /*!< 0x0F000000 */
N#define DAC_CR_MAMP2                DAC_CR_MAMP2_Msk                           /*!< MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
N#define DAC_CR_MAMP2_0              (0x1U << DAC_CR_MAMP2_Pos)                 /*!< 0x01000000 */
N#define DAC_CR_MAMP2_1              (0x2U << DAC_CR_MAMP2_Pos)                 /*!< 0x02000000 */
N#define DAC_CR_MAMP2_2              (0x4U << DAC_CR_MAMP2_Pos)                 /*!< 0x04000000 */
N#define DAC_CR_MAMP2_3              (0x8U << DAC_CR_MAMP2_Pos)                 /*!< 0x08000000 */
N
N#define DAC_CR_DMAEN2_Pos           (28U)                                      
N#define DAC_CR_DMAEN2_Msk           (0x1U << DAC_CR_DMAEN2_Pos)                /*!< 0x10000000 */
N#define DAC_CR_DMAEN2               DAC_CR_DMAEN2_Msk                          /*!< DAC channel2 DMA enabled */
N#define DAC_CR_DMAUDRIE2_Pos        (29U)                                      
N#define DAC_CR_DMAUDRIE2_Msk        (0x1U << DAC_CR_DMAUDRIE2_Pos)             /*!< 0x20000000 */
N#define DAC_CR_DMAUDRIE2            DAC_CR_DMAUDRIE2_Msk                       /*!< DAC channel2 DMA Underrun Interrupt enable */
N
N/*****************  Bit definition for DAC_SWTRIGR register  ******************/
N#define DAC_SWTRIGR_SWTRIG1_Pos     (0U)                                       
N#define DAC_SWTRIGR_SWTRIG1_Msk     (0x1U << DAC_SWTRIGR_SWTRIG1_Pos)          /*!< 0x00000001 */
N#define DAC_SWTRIGR_SWTRIG1         DAC_SWTRIGR_SWTRIG1_Msk                    /*!< DAC channel1 software trigger */
N#define DAC_SWTRIGR_SWTRIG2_Pos     (1U)                                       
N#define DAC_SWTRIGR_SWTRIG2_Msk     (0x1U << DAC_SWTRIGR_SWTRIG2_Pos)          /*!< 0x00000002 */
N#define DAC_SWTRIGR_SWTRIG2         DAC_SWTRIGR_SWTRIG2_Msk                    /*!< DAC channel2 software trigger */
N
N/*****************  Bit definition for DAC_DHR12R1 register  ******************/
N#define DAC_DHR12R1_DACC1DHR_Pos    (0U)                                       
N#define DAC_DHR12R1_DACC1DHR_Msk    (0xFFFU << DAC_DHR12R1_DACC1DHR_Pos)       /*!< 0x00000FFF */
N#define DAC_DHR12R1_DACC1DHR        DAC_DHR12R1_DACC1DHR_Msk                   /*!< DAC channel1 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L1 register  ******************/
N#define DAC_DHR12L1_DACC1DHR_Pos    (4U)                                       
N#define DAC_DHR12L1_DACC1DHR_Msk    (0xFFFU << DAC_DHR12L1_DACC1DHR_Pos)       /*!< 0x0000FFF0 */
N#define DAC_DHR12L1_DACC1DHR        DAC_DHR12L1_DACC1DHR_Msk                   /*!< DAC channel1 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R1 register  ******************/
N#define DAC_DHR8R1_DACC1DHR_Pos     (0U)                                       
N#define DAC_DHR8R1_DACC1DHR_Msk     (0xFFU << DAC_DHR8R1_DACC1DHR_Pos)         /*!< 0x000000FF */
N#define DAC_DHR8R1_DACC1DHR         DAC_DHR8R1_DACC1DHR_Msk                    /*!< DAC channel1 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12R2 register  ******************/
N#define DAC_DHR12R2_DACC2DHR_Pos    (0U)                                       
N#define DAC_DHR12R2_DACC2DHR_Msk    (0xFFFU << DAC_DHR12R2_DACC2DHR_Pos)       /*!< 0x00000FFF */
N#define DAC_DHR12R2_DACC2DHR        DAC_DHR12R2_DACC2DHR_Msk                   /*!< DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L2 register  ******************/
N#define DAC_DHR12L2_DACC2DHR_Pos    (4U)                                       
N#define DAC_DHR12L2_DACC2DHR_Msk    (0xFFFU << DAC_DHR12L2_DACC2DHR_Pos)       /*!< 0x0000FFF0 */
N#define DAC_DHR12L2_DACC2DHR        DAC_DHR12L2_DACC2DHR_Msk                   /*!< DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R2 register  ******************/
N#define DAC_DHR8R2_DACC2DHR_Pos     (0U)                                       
N#define DAC_DHR8R2_DACC2DHR_Msk     (0xFFU << DAC_DHR8R2_DACC2DHR_Pos)         /*!< 0x000000FF */
N#define DAC_DHR8R2_DACC2DHR         DAC_DHR8R2_DACC2DHR_Msk                    /*!< DAC channel2 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12RD register  ******************/
N#define DAC_DHR12RD_DACC1DHR_Pos    (0U)                                       
N#define DAC_DHR12RD_DACC1DHR_Msk    (0xFFFU << DAC_DHR12RD_DACC1DHR_Pos)       /*!< 0x00000FFF */
N#define DAC_DHR12RD_DACC1DHR        DAC_DHR12RD_DACC1DHR_Msk                   /*!< DAC channel1 12-bit Right aligned data */
N#define DAC_DHR12RD_DACC2DHR_Pos    (16U)                                      
N#define DAC_DHR12RD_DACC2DHR_Msk    (0xFFFU << DAC_DHR12RD_DACC2DHR_Pos)       /*!< 0x0FFF0000 */
N#define DAC_DHR12RD_DACC2DHR        DAC_DHR12RD_DACC2DHR_Msk                   /*!< DAC channel2 12-bit Right aligned data  */
N
N/*****************  Bit definition for DAC_DHR12LD register  ******************/
N#define DAC_DHR12LD_DACC1DHR_Pos    (4U)                                       
N#define DAC_DHR12LD_DACC1DHR_Msk    (0xFFFU << DAC_DHR12LD_DACC1DHR_Pos)       /*!< 0x0000FFF0 */
N#define DAC_DHR12LD_DACC1DHR        DAC_DHR12LD_DACC1DHR_Msk                   /*!< DAC channel1 12-bit Left aligned data */
N#define DAC_DHR12LD_DACC2DHR_Pos    (20U)                                      
N#define DAC_DHR12LD_DACC2DHR_Msk    (0xFFFU << DAC_DHR12LD_DACC2DHR_Pos)       /*!< 0xFFF00000 */
N#define DAC_DHR12LD_DACC2DHR        DAC_DHR12LD_DACC2DHR_Msk                   /*!< DAC channel2 12-bit Left aligned data  */
N
N/******************  Bit definition for DAC_DHR8RD register  ******************/
N#define DAC_DHR8RD_DACC1DHR_Pos     (0U)                                       
N#define DAC_DHR8RD_DACC1DHR_Msk     (0xFFU << DAC_DHR8RD_DACC1DHR_Pos)         /*!< 0x000000FF */
N#define DAC_DHR8RD_DACC1DHR         DAC_DHR8RD_DACC1DHR_Msk                    /*!< DAC channel1 8-bit Right aligned data */
N#define DAC_DHR8RD_DACC2DHR_Pos     (8U)                                       
N#define DAC_DHR8RD_DACC2DHR_Msk     (0xFFU << DAC_DHR8RD_DACC2DHR_Pos)         /*!< 0x0000FF00 */
N#define DAC_DHR8RD_DACC2DHR         DAC_DHR8RD_DACC2DHR_Msk                    /*!< DAC channel2 8-bit Right aligned data */
N
N/*******************  Bit definition for DAC_DOR1 register  *******************/
N#define DAC_DOR1_DACC1DOR_Pos       (0U)                                       
N#define DAC_DOR1_DACC1DOR_Msk       (0xFFFU << DAC_DOR1_DACC1DOR_Pos)          /*!< 0x00000FFF */
N#define DAC_DOR1_DACC1DOR           DAC_DOR1_DACC1DOR_Msk                      /*!< DAC channel1 data output */
N
N/*******************  Bit definition for DAC_DOR2 register  *******************/
N#define DAC_DOR2_DACC2DOR_Pos       (0U)                                       
N#define DAC_DOR2_DACC2DOR_Msk       (0xFFFU << DAC_DOR2_DACC2DOR_Pos)          /*!< 0x00000FFF */
N#define DAC_DOR2_DACC2DOR           DAC_DOR2_DACC2DOR_Msk                      /*!< DAC channel2 data output */
N
N/********************  Bit definition for DAC_SR register  ********************/
N#define DAC_SR_DMAUDR1_Pos          (13U)                                      
N#define DAC_SR_DMAUDR1_Msk          (0x1U << DAC_SR_DMAUDR1_Pos)               /*!< 0x00002000 */
N#define DAC_SR_DMAUDR1              DAC_SR_DMAUDR1_Msk                         /*!< DAC channel1 DMA underrun flag */
N#define DAC_SR_DMAUDR2_Pos          (29U)                                      
N#define DAC_SR_DMAUDR2_Msk          (0x1U << DAC_SR_DMAUDR2_Pos)               /*!< 0x20000000 */
N#define DAC_SR_DMAUDR2              DAC_SR_DMAUDR2_Msk                         /*!< DAC channel2 DMA underrun flag  */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Debug MCU (DBGMCU)                               */
N/*                                                                            */
N/******************************************************************************/
N
N/****************  Bit definition for DBGMCU_IDCODE register  *****************/
N#define DBGMCU_IDCODE_DEV_ID_Pos                     (0U)                      
N#define DBGMCU_IDCODE_DEV_ID_Msk                     (0xFFFU << DBGMCU_IDCODE_DEV_ID_Pos) /*!< 0x00000FFF */
N#define DBGMCU_IDCODE_DEV_ID                         DBGMCU_IDCODE_DEV_ID_Msk  /*!< Device Identifier */
N
N#define DBGMCU_IDCODE_REV_ID_Pos                     (16U)                     
N#define DBGMCU_IDCODE_REV_ID_Msk                     (0xFFFFU << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0xFFFF0000 */
N#define DBGMCU_IDCODE_REV_ID                         DBGMCU_IDCODE_REV_ID_Msk  /*!< REV_ID[15:0] bits (Revision Identifier) */
N#define DBGMCU_IDCODE_REV_ID_0                       (0x0001U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00010000 */
N#define DBGMCU_IDCODE_REV_ID_1                       (0x0002U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00020000 */
N#define DBGMCU_IDCODE_REV_ID_2                       (0x0004U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00040000 */
N#define DBGMCU_IDCODE_REV_ID_3                       (0x0008U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00080000 */
N#define DBGMCU_IDCODE_REV_ID_4                       (0x0010U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00100000 */
N#define DBGMCU_IDCODE_REV_ID_5                       (0x0020U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00200000 */
N#define DBGMCU_IDCODE_REV_ID_6                       (0x0040U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00400000 */
N#define DBGMCU_IDCODE_REV_ID_7                       (0x0080U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00800000 */
N#define DBGMCU_IDCODE_REV_ID_8                       (0x0100U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x01000000 */
N#define DBGMCU_IDCODE_REV_ID_9                       (0x0200U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x02000000 */
N#define DBGMCU_IDCODE_REV_ID_10                      (0x0400U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x04000000 */
N#define DBGMCU_IDCODE_REV_ID_11                      (0x0800U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x08000000 */
N#define DBGMCU_IDCODE_REV_ID_12                      (0x1000U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x10000000 */
N#define DBGMCU_IDCODE_REV_ID_13                      (0x2000U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x20000000 */
N#define DBGMCU_IDCODE_REV_ID_14                      (0x4000U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x40000000 */
N#define DBGMCU_IDCODE_REV_ID_15                      (0x8000U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x80000000 */
N
N/******************  Bit definition for DBGMCU_CR register  *******************/
N#define DBGMCU_CR_DBG_STOP_Pos                       (1U)                      
N#define DBGMCU_CR_DBG_STOP_Msk                       (0x1U << DBGMCU_CR_DBG_STOP_Pos) /*!< 0x00000002 */
N#define DBGMCU_CR_DBG_STOP                           DBGMCU_CR_DBG_STOP_Msk    /*!< Debug Stop Mode */
N#define DBGMCU_CR_DBG_STANDBY_Pos                    (2U)                      
N#define DBGMCU_CR_DBG_STANDBY_Msk                    (0x1U << DBGMCU_CR_DBG_STANDBY_Pos) /*!< 0x00000004 */
N#define DBGMCU_CR_DBG_STANDBY                        DBGMCU_CR_DBG_STANDBY_Msk /*!< Debug Standby mode */
N
N/******************  Bit definition for DBGMCU_APB1_FZ register  **************/
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP_Pos             (0U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP_Msk             (0x1U << DBGMCU_APB1_FZ_DBG_TIM2_STOP_Pos) /*!< 0x00000001 */
N#define DBGMCU_APB1_FZ_DBG_TIM2_STOP                 DBGMCU_APB1_FZ_DBG_TIM2_STOP_Msk /*!< TIM2 counter stopped when core is halted */
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP_Pos             (1U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP_Msk             (0x1U << DBGMCU_APB1_FZ_DBG_TIM3_STOP_Pos) /*!< 0x00000002 */
N#define DBGMCU_APB1_FZ_DBG_TIM3_STOP                 DBGMCU_APB1_FZ_DBG_TIM3_STOP_Msk /*!< TIM3 counter stopped when core is halted */
N#define DBGMCU_APB1_FZ_DBG_TIM6_STOP_Pos             (4U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM6_STOP_Msk             (0x1U << DBGMCU_APB1_FZ_DBG_TIM6_STOP_Pos) /*!< 0x00000010 */
N#define DBGMCU_APB1_FZ_DBG_TIM6_STOP                 DBGMCU_APB1_FZ_DBG_TIM6_STOP_Msk /*!< TIM6 counter stopped when core is halted */
N#define DBGMCU_APB1_FZ_DBG_TIM7_STOP_Pos             (5U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM7_STOP_Msk             (0x1U << DBGMCU_APB1_FZ_DBG_TIM7_STOP_Pos) /*!< 0x00000020 */
N#define DBGMCU_APB1_FZ_DBG_TIM7_STOP                 DBGMCU_APB1_FZ_DBG_TIM7_STOP_Msk /*!< TIM7 counter stopped when core is halted  */
N#define DBGMCU_APB1_FZ_DBG_TIM14_STOP_Pos            (8U)                      
N#define DBGMCU_APB1_FZ_DBG_TIM14_STOP_Msk            (0x1U << DBGMCU_APB1_FZ_DBG_TIM14_STOP_Pos) /*!< 0x00000100 */
N#define DBGMCU_APB1_FZ_DBG_TIM14_STOP                DBGMCU_APB1_FZ_DBG_TIM14_STOP_Msk /*!< TIM14 counter stopped when core is halted */
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP_Pos              (10U)                     
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP_Msk              (0x1U << DBGMCU_APB1_FZ_DBG_RTC_STOP_Pos) /*!< 0x00000400 */
N#define DBGMCU_APB1_FZ_DBG_RTC_STOP                  DBGMCU_APB1_FZ_DBG_RTC_STOP_Msk /*!< RTC Calendar frozen when core is halted */
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP_Pos             (11U)                     
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP_Msk             (0x1U << DBGMCU_APB1_FZ_DBG_WWDG_STOP_Pos) /*!< 0x00000800 */
N#define DBGMCU_APB1_FZ_DBG_WWDG_STOP                 DBGMCU_APB1_FZ_DBG_WWDG_STOP_Msk /*!< Debug Window Watchdog stopped when Core is halted */
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP_Pos             (12U)                     
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP_Msk             (0x1U << DBGMCU_APB1_FZ_DBG_IWDG_STOP_Pos) /*!< 0x00001000 */
N#define DBGMCU_APB1_FZ_DBG_IWDG_STOP                 DBGMCU_APB1_FZ_DBG_IWDG_STOP_Msk /*!< Debug Independent Watchdog stopped when Core is halted */
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Pos    (21U)                     
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Msk    (0x1U << DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Pos) /*!< 0x00200000 */
N#define DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT        DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Msk /*!< I2C1 SMBUS timeout mode stopped when Core is halted */
N#define DBGMCU_APB1_FZ_DBG_CAN_STOP_Pos              (25U)                     
N#define DBGMCU_APB1_FZ_DBG_CAN_STOP_Msk              (0x1U << DBGMCU_APB1_FZ_DBG_CAN_STOP_Pos) /*!< 0x02000000 */
N#define DBGMCU_APB1_FZ_DBG_CAN_STOP                  DBGMCU_APB1_FZ_DBG_CAN_STOP_Msk /*!< CAN debug stopped when Core is halted  */
N
N/******************  Bit definition for DBGMCU_APB2_FZ register  **************/
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP_Pos             (11U)                     
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP_Msk             (0x1U << DBGMCU_APB2_FZ_DBG_TIM1_STOP_Pos) /*!< 0x00000800 */
N#define DBGMCU_APB2_FZ_DBG_TIM1_STOP                 DBGMCU_APB2_FZ_DBG_TIM1_STOP_Msk /*!< TIM1 counter stopped when core is halted */
N#define DBGMCU_APB2_FZ_DBG_TIM15_STOP_Pos            (16U)                     
N#define DBGMCU_APB2_FZ_DBG_TIM15_STOP_Msk            (0x1U << DBGMCU_APB2_FZ_DBG_TIM15_STOP_Pos) /*!< 0x00010000 */
N#define DBGMCU_APB2_FZ_DBG_TIM15_STOP                DBGMCU_APB2_FZ_DBG_TIM15_STOP_Msk /*!< TIM15 counter stopped when core is halted  */
N#define DBGMCU_APB2_FZ_DBG_TIM16_STOP_Pos            (17U)                     
N#define DBGMCU_APB2_FZ_DBG_TIM16_STOP_Msk            (0x1U << DBGMCU_APB2_FZ_DBG_TIM16_STOP_Pos) /*!< 0x00020000 */
N#define DBGMCU_APB2_FZ_DBG_TIM16_STOP                DBGMCU_APB2_FZ_DBG_TIM16_STOP_Msk /*!< TIM16 counter stopped when core is halted */
N#define DBGMCU_APB2_FZ_DBG_TIM17_STOP_Pos            (18U)                     
N#define DBGMCU_APB2_FZ_DBG_TIM17_STOP_Msk            (0x1U << DBGMCU_APB2_FZ_DBG_TIM17_STOP_Pos) /*!< 0x00040000 */
N#define DBGMCU_APB2_FZ_DBG_TIM17_STOP                DBGMCU_APB2_FZ_DBG_TIM17_STOP_Msk /*!< TIM17 counter stopped when core is halted */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           DMA Controller (DMA)                             */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for DMA_ISR register  ********************/
N#define DMA_ISR_GIF1_Pos       (0U)                                            
N#define DMA_ISR_GIF1_Msk       (0x1U << DMA_ISR_GIF1_Pos)                      /*!< 0x00000001 */
N#define DMA_ISR_GIF1           DMA_ISR_GIF1_Msk                                /*!< Channel 1 Global interrupt flag    */
N#define DMA_ISR_TCIF1_Pos      (1U)                                            
N#define DMA_ISR_TCIF1_Msk      (0x1U << DMA_ISR_TCIF1_Pos)                     /*!< 0x00000002 */
N#define DMA_ISR_TCIF1          DMA_ISR_TCIF1_Msk                               /*!< Channel 1 Transfer Complete flag   */
N#define DMA_ISR_HTIF1_Pos      (2U)                                            
N#define DMA_ISR_HTIF1_Msk      (0x1U << DMA_ISR_HTIF1_Pos)                     /*!< 0x00000004 */
N#define DMA_ISR_HTIF1          DMA_ISR_HTIF1_Msk                               /*!< Channel 1 Half Transfer flag       */
N#define DMA_ISR_TEIF1_Pos      (3U)                                            
N#define DMA_ISR_TEIF1_Msk      (0x1U << DMA_ISR_TEIF1_Pos)                     /*!< 0x00000008 */
N#define DMA_ISR_TEIF1          DMA_ISR_TEIF1_Msk                               /*!< Channel 1 Transfer Error flag      */
N#define DMA_ISR_GIF2_Pos       (4U)                                            
N#define DMA_ISR_GIF2_Msk       (0x1U << DMA_ISR_GIF2_Pos)                      /*!< 0x00000010 */
N#define DMA_ISR_GIF2           DMA_ISR_GIF2_Msk                                /*!< Channel 2 Global interrupt flag    */
N#define DMA_ISR_TCIF2_Pos      (5U)                                            
N#define DMA_ISR_TCIF2_Msk      (0x1U << DMA_ISR_TCIF2_Pos)                     /*!< 0x00000020 */
N#define DMA_ISR_TCIF2          DMA_ISR_TCIF2_Msk                               /*!< Channel 2 Transfer Complete flag   */
N#define DMA_ISR_HTIF2_Pos      (6U)                                            
N#define DMA_ISR_HTIF2_Msk      (0x1U << DMA_ISR_HTIF2_Pos)                     /*!< 0x00000040 */
N#define DMA_ISR_HTIF2          DMA_ISR_HTIF2_Msk                               /*!< Channel 2 Half Transfer flag       */
N#define DMA_ISR_TEIF2_Pos      (7U)                                            
N#define DMA_ISR_TEIF2_Msk      (0x1U << DMA_ISR_TEIF2_Pos)                     /*!< 0x00000080 */
N#define DMA_ISR_TEIF2          DMA_ISR_TEIF2_Msk                               /*!< Channel 2 Transfer Error flag      */
N#define DMA_ISR_GIF3_Pos       (8U)                                            
N#define DMA_ISR_GIF3_Msk       (0x1U << DMA_ISR_GIF3_Pos)                      /*!< 0x00000100 */
N#define DMA_ISR_GIF3           DMA_ISR_GIF3_Msk                                /*!< Channel 3 Global interrupt flag    */
N#define DMA_ISR_TCIF3_Pos      (9U)                                            
N#define DMA_ISR_TCIF3_Msk      (0x1U << DMA_ISR_TCIF3_Pos)                     /*!< 0x00000200 */
N#define DMA_ISR_TCIF3          DMA_ISR_TCIF3_Msk                               /*!< Channel 3 Transfer Complete flag   */
N#define DMA_ISR_HTIF3_Pos      (10U)                                           
N#define DMA_ISR_HTIF3_Msk      (0x1U << DMA_ISR_HTIF3_Pos)                     /*!< 0x00000400 */
N#define DMA_ISR_HTIF3          DMA_ISR_HTIF3_Msk                               /*!< Channel 3 Half Transfer flag       */
N#define DMA_ISR_TEIF3_Pos      (11U)                                           
N#define DMA_ISR_TEIF3_Msk      (0x1U << DMA_ISR_TEIF3_Pos)                     /*!< 0x00000800 */
N#define DMA_ISR_TEIF3          DMA_ISR_TEIF3_Msk                               /*!< Channel 3 Transfer Error flag      */
N#define DMA_ISR_GIF4_Pos       (12U)                                           
N#define DMA_ISR_GIF4_Msk       (0x1U << DMA_ISR_GIF4_Pos)                      /*!< 0x00001000 */
N#define DMA_ISR_GIF4           DMA_ISR_GIF4_Msk                                /*!< Channel 4 Global interrupt flag    */
N#define DMA_ISR_TCIF4_Pos      (13U)                                           
N#define DMA_ISR_TCIF4_Msk      (0x1U << DMA_ISR_TCIF4_Pos)                     /*!< 0x00002000 */
N#define DMA_ISR_TCIF4          DMA_ISR_TCIF4_Msk                               /*!< Channel 4 Transfer Complete flag   */
N#define DMA_ISR_HTIF4_Pos      (14U)                                           
N#define DMA_ISR_HTIF4_Msk      (0x1U << DMA_ISR_HTIF4_Pos)                     /*!< 0x00004000 */
N#define DMA_ISR_HTIF4          DMA_ISR_HTIF4_Msk                               /*!< Channel 4 Half Transfer flag       */
N#define DMA_ISR_TEIF4_Pos      (15U)                                           
N#define DMA_ISR_TEIF4_Msk      (0x1U << DMA_ISR_TEIF4_Pos)                     /*!< 0x00008000 */
N#define DMA_ISR_TEIF4          DMA_ISR_TEIF4_Msk                               /*!< Channel 4 Transfer Error flag      */
N#define DMA_ISR_GIF5_Pos       (16U)                                           
N#define DMA_ISR_GIF5_Msk       (0x1U << DMA_ISR_GIF5_Pos)                      /*!< 0x00010000 */
N#define DMA_ISR_GIF5           DMA_ISR_GIF5_Msk                                /*!< Channel 5 Global interrupt flag    */
N#define DMA_ISR_TCIF5_Pos      (17U)                                           
N#define DMA_ISR_TCIF5_Msk      (0x1U << DMA_ISR_TCIF5_Pos)                     /*!< 0x00020000 */
N#define DMA_ISR_TCIF5          DMA_ISR_TCIF5_Msk                               /*!< Channel 5 Transfer Complete flag   */
N#define DMA_ISR_HTIF5_Pos      (18U)                                           
N#define DMA_ISR_HTIF5_Msk      (0x1U << DMA_ISR_HTIF5_Pos)                     /*!< 0x00040000 */
N#define DMA_ISR_HTIF5          DMA_ISR_HTIF5_Msk                               /*!< Channel 5 Half Transfer flag       */
N#define DMA_ISR_TEIF5_Pos      (19U)                                           
N#define DMA_ISR_TEIF5_Msk      (0x1U << DMA_ISR_TEIF5_Pos)                     /*!< 0x00080000 */
N#define DMA_ISR_TEIF5          DMA_ISR_TEIF5_Msk                               /*!< Channel 5 Transfer Error flag      */
N#define DMA_ISR_GIF6_Pos       (20U)                                           
N#define DMA_ISR_GIF6_Msk       (0x1U << DMA_ISR_GIF6_Pos)                      /*!< 0x00100000 */
N#define DMA_ISR_GIF6           DMA_ISR_GIF6_Msk                                /*!< Channel 6 Global interrupt flag    */
N#define DMA_ISR_TCIF6_Pos      (21U)                                           
N#define DMA_ISR_TCIF6_Msk      (0x1U << DMA_ISR_TCIF6_Pos)                     /*!< 0x00200000 */
N#define DMA_ISR_TCIF6          DMA_ISR_TCIF6_Msk                               /*!< Channel 6 Transfer Complete flag   */
N#define DMA_ISR_HTIF6_Pos      (22U)                                           
N#define DMA_ISR_HTIF6_Msk      (0x1U << DMA_ISR_HTIF6_Pos)                     /*!< 0x00400000 */
N#define DMA_ISR_HTIF6          DMA_ISR_HTIF6_Msk                               /*!< Channel 6 Half Transfer flag       */
N#define DMA_ISR_TEIF6_Pos      (23U)                                           
N#define DMA_ISR_TEIF6_Msk      (0x1U << DMA_ISR_TEIF6_Pos)                     /*!< 0x00800000 */
N#define DMA_ISR_TEIF6          DMA_ISR_TEIF6_Msk                               /*!< Channel 6 Transfer Error flag      */
N#define DMA_ISR_GIF7_Pos       (24U)                                           
N#define DMA_ISR_GIF7_Msk       (0x1U << DMA_ISR_GIF7_Pos)                      /*!< 0x01000000 */
N#define DMA_ISR_GIF7           DMA_ISR_GIF7_Msk                                /*!< Channel 7 Global interrupt flag    */
N#define DMA_ISR_TCIF7_Pos      (25U)                                           
N#define DMA_ISR_TCIF7_Msk      (0x1U << DMA_ISR_TCIF7_Pos)                     /*!< 0x02000000 */
N#define DMA_ISR_TCIF7          DMA_ISR_TCIF7_Msk                               /*!< Channel 7 Transfer Complete flag   */
N#define DMA_ISR_HTIF7_Pos      (26U)                                           
N#define DMA_ISR_HTIF7_Msk      (0x1U << DMA_ISR_HTIF7_Pos)                     /*!< 0x04000000 */
N#define DMA_ISR_HTIF7          DMA_ISR_HTIF7_Msk                               /*!< Channel 7 Half Transfer flag       */
N#define DMA_ISR_TEIF7_Pos      (27U)                                           
N#define DMA_ISR_TEIF7_Msk      (0x1U << DMA_ISR_TEIF7_Pos)                     /*!< 0x08000000 */
N#define DMA_ISR_TEIF7          DMA_ISR_TEIF7_Msk                               /*!< Channel 7 Transfer Error flag      */
N
N/*******************  Bit definition for DMA_IFCR register  *******************/
N#define DMA_IFCR_CGIF1_Pos     (0U)                                            
N#define DMA_IFCR_CGIF1_Msk     (0x1U << DMA_IFCR_CGIF1_Pos)                    /*!< 0x00000001 */
N#define DMA_IFCR_CGIF1         DMA_IFCR_CGIF1_Msk                              /*!< Channel 1 Global interrupt clear    */
N#define DMA_IFCR_CTCIF1_Pos    (1U)                                            
N#define DMA_IFCR_CTCIF1_Msk    (0x1U << DMA_IFCR_CTCIF1_Pos)                   /*!< 0x00000002 */
N#define DMA_IFCR_CTCIF1        DMA_IFCR_CTCIF1_Msk                             /*!< Channel 1 Transfer Complete clear   */
N#define DMA_IFCR_CHTIF1_Pos    (2U)                                            
N#define DMA_IFCR_CHTIF1_Msk    (0x1U << DMA_IFCR_CHTIF1_Pos)                   /*!< 0x00000004 */
N#define DMA_IFCR_CHTIF1        DMA_IFCR_CHTIF1_Msk                             /*!< Channel 1 Half Transfer clear       */
N#define DMA_IFCR_CTEIF1_Pos    (3U)                                            
N#define DMA_IFCR_CTEIF1_Msk    (0x1U << DMA_IFCR_CTEIF1_Pos)                   /*!< 0x00000008 */
N#define DMA_IFCR_CTEIF1        DMA_IFCR_CTEIF1_Msk                             /*!< Channel 1 Transfer Error clear      */
N#define DMA_IFCR_CGIF2_Pos     (4U)                                            
N#define DMA_IFCR_CGIF2_Msk     (0x1U << DMA_IFCR_CGIF2_Pos)                    /*!< 0x00000010 */
N#define DMA_IFCR_CGIF2         DMA_IFCR_CGIF2_Msk                              /*!< Channel 2 Global interrupt clear    */
N#define DMA_IFCR_CTCIF2_Pos    (5U)                                            
N#define DMA_IFCR_CTCIF2_Msk    (0x1U << DMA_IFCR_CTCIF2_Pos)                   /*!< 0x00000020 */
N#define DMA_IFCR_CTCIF2        DMA_IFCR_CTCIF2_Msk                             /*!< Channel 2 Transfer Complete clear   */
N#define DMA_IFCR_CHTIF2_Pos    (6U)                                            
N#define DMA_IFCR_CHTIF2_Msk    (0x1U << DMA_IFCR_CHTIF2_Pos)                   /*!< 0x00000040 */
N#define DMA_IFCR_CHTIF2        DMA_IFCR_CHTIF2_Msk                             /*!< Channel 2 Half Transfer clear       */
N#define DMA_IFCR_CTEIF2_Pos    (7U)                                            
N#define DMA_IFCR_CTEIF2_Msk    (0x1U << DMA_IFCR_CTEIF2_Pos)                   /*!< 0x00000080 */
N#define DMA_IFCR_CTEIF2        DMA_IFCR_CTEIF2_Msk                             /*!< Channel 2 Transfer Error clear      */
N#define DMA_IFCR_CGIF3_Pos     (8U)                                            
N#define DMA_IFCR_CGIF3_Msk     (0x1U << DMA_IFCR_CGIF3_Pos)                    /*!< 0x00000100 */
N#define DMA_IFCR_CGIF3         DMA_IFCR_CGIF3_Msk                              /*!< Channel 3 Global interrupt clear    */
N#define DMA_IFCR_CTCIF3_Pos    (9U)                                            
N#define DMA_IFCR_CTCIF3_Msk    (0x1U << DMA_IFCR_CTCIF3_Pos)                   /*!< 0x00000200 */
N#define DMA_IFCR_CTCIF3        DMA_IFCR_CTCIF3_Msk                             /*!< Channel 3 Transfer Complete clear   */
N#define DMA_IFCR_CHTIF3_Pos    (10U)                                           
N#define DMA_IFCR_CHTIF3_Msk    (0x1U << DMA_IFCR_CHTIF3_Pos)                   /*!< 0x00000400 */
N#define DMA_IFCR_CHTIF3        DMA_IFCR_CHTIF3_Msk                             /*!< Channel 3 Half Transfer clear       */
N#define DMA_IFCR_CTEIF3_Pos    (11U)                                           
N#define DMA_IFCR_CTEIF3_Msk    (0x1U << DMA_IFCR_CTEIF3_Pos)                   /*!< 0x00000800 */
N#define DMA_IFCR_CTEIF3        DMA_IFCR_CTEIF3_Msk                             /*!< Channel 3 Transfer Error clear      */
N#define DMA_IFCR_CGIF4_Pos     (12U)                                           
N#define DMA_IFCR_CGIF4_Msk     (0x1U << DMA_IFCR_CGIF4_Pos)                    /*!< 0x00001000 */
N#define DMA_IFCR_CGIF4         DMA_IFCR_CGIF4_Msk                              /*!< Channel 4 Global interrupt clear    */
N#define DMA_IFCR_CTCIF4_Pos    (13U)                                           
N#define DMA_IFCR_CTCIF4_Msk    (0x1U << DMA_IFCR_CTCIF4_Pos)                   /*!< 0x00002000 */
N#define DMA_IFCR_CTCIF4        DMA_IFCR_CTCIF4_Msk                             /*!< Channel 4 Transfer Complete clear   */
N#define DMA_IFCR_CHTIF4_Pos    (14U)                                           
N#define DMA_IFCR_CHTIF4_Msk    (0x1U << DMA_IFCR_CHTIF4_Pos)                   /*!< 0x00004000 */
N#define DMA_IFCR_CHTIF4        DMA_IFCR_CHTIF4_Msk                             /*!< Channel 4 Half Transfer clear       */
N#define DMA_IFCR_CTEIF4_Pos    (15U)                                           
N#define DMA_IFCR_CTEIF4_Msk    (0x1U << DMA_IFCR_CTEIF4_Pos)                   /*!< 0x00008000 */
N#define DMA_IFCR_CTEIF4        DMA_IFCR_CTEIF4_Msk                             /*!< Channel 4 Transfer Error clear      */
N#define DMA_IFCR_CGIF5_Pos     (16U)                                           
N#define DMA_IFCR_CGIF5_Msk     (0x1U << DMA_IFCR_CGIF5_Pos)                    /*!< 0x00010000 */
N#define DMA_IFCR_CGIF5         DMA_IFCR_CGIF5_Msk                              /*!< Channel 5 Global interrupt clear    */
N#define DMA_IFCR_CTCIF5_Pos    (17U)                                           
N#define DMA_IFCR_CTCIF5_Msk    (0x1U << DMA_IFCR_CTCIF5_Pos)                   /*!< 0x00020000 */
N#define DMA_IFCR_CTCIF5        DMA_IFCR_CTCIF5_Msk                             /*!< Channel 5 Transfer Complete clear   */
N#define DMA_IFCR_CHTIF5_Pos    (18U)                                           
N#define DMA_IFCR_CHTIF5_Msk    (0x1U << DMA_IFCR_CHTIF5_Pos)                   /*!< 0x00040000 */
N#define DMA_IFCR_CHTIF5        DMA_IFCR_CHTIF5_Msk                             /*!< Channel 5 Half Transfer clear       */
N#define DMA_IFCR_CTEIF5_Pos    (19U)                                           
N#define DMA_IFCR_CTEIF5_Msk    (0x1U << DMA_IFCR_CTEIF5_Pos)                   /*!< 0x00080000 */
N#define DMA_IFCR_CTEIF5        DMA_IFCR_CTEIF5_Msk                             /*!< Channel 5 Transfer Error clear      */
N#define DMA_IFCR_CGIF6_Pos     (20U)                                           
N#define DMA_IFCR_CGIF6_Msk     (0x1U << DMA_IFCR_CGIF6_Pos)                    /*!< 0x00100000 */
N#define DMA_IFCR_CGIF6         DMA_IFCR_CGIF6_Msk                              /*!< Channel 6 Global interrupt clear    */
N#define DMA_IFCR_CTCIF6_Pos    (21U)                                           
N#define DMA_IFCR_CTCIF6_Msk    (0x1U << DMA_IFCR_CTCIF6_Pos)                   /*!< 0x00200000 */
N#define DMA_IFCR_CTCIF6        DMA_IFCR_CTCIF6_Msk                             /*!< Channel 6 Transfer Complete clear   */
N#define DMA_IFCR_CHTIF6_Pos    (22U)                                           
N#define DMA_IFCR_CHTIF6_Msk    (0x1U << DMA_IFCR_CHTIF6_Pos)                   /*!< 0x00400000 */
N#define DMA_IFCR_CHTIF6        DMA_IFCR_CHTIF6_Msk                             /*!< Channel 6 Half Transfer clear       */
N#define DMA_IFCR_CTEIF6_Pos    (23U)                                           
N#define DMA_IFCR_CTEIF6_Msk    (0x1U << DMA_IFCR_CTEIF6_Pos)                   /*!< 0x00800000 */
N#define DMA_IFCR_CTEIF6        DMA_IFCR_CTEIF6_Msk                             /*!< Channel 6 Transfer Error clear      */
N#define DMA_IFCR_CGIF7_Pos     (24U)                                           
N#define DMA_IFCR_CGIF7_Msk     (0x1U << DMA_IFCR_CGIF7_Pos)                    /*!< 0x01000000 */
N#define DMA_IFCR_CGIF7         DMA_IFCR_CGIF7_Msk                              /*!< Channel 7 Global interrupt clear    */
N#define DMA_IFCR_CTCIF7_Pos    (25U)                                           
N#define DMA_IFCR_CTCIF7_Msk    (0x1U << DMA_IFCR_CTCIF7_Pos)                   /*!< 0x02000000 */
N#define DMA_IFCR_CTCIF7        DMA_IFCR_CTCIF7_Msk                             /*!< Channel 7 Transfer Complete clear   */
N#define DMA_IFCR_CHTIF7_Pos    (26U)                                           
N#define DMA_IFCR_CHTIF7_Msk    (0x1U << DMA_IFCR_CHTIF7_Pos)                   /*!< 0x04000000 */
N#define DMA_IFCR_CHTIF7        DMA_IFCR_CHTIF7_Msk                             /*!< Channel 7 Half Transfer clear       */
N#define DMA_IFCR_CTEIF7_Pos    (27U)                                           
N#define DMA_IFCR_CTEIF7_Msk    (0x1U << DMA_IFCR_CTEIF7_Pos)                   /*!< 0x08000000 */
N#define DMA_IFCR_CTEIF7        DMA_IFCR_CTEIF7_Msk                             /*!< Channel 7 Transfer Error clear      */
N
N/*******************  Bit definition for DMA_CCR register  ********************/
N#define DMA_CCR_EN_Pos         (0U)                                            
N#define DMA_CCR_EN_Msk         (0x1U << DMA_CCR_EN_Pos)                        /*!< 0x00000001 */
N#define DMA_CCR_EN             DMA_CCR_EN_Msk                                  /*!< Channel enable                      */
N#define DMA_CCR_TCIE_Pos       (1U)                                            
N#define DMA_CCR_TCIE_Msk       (0x1U << DMA_CCR_TCIE_Pos)                      /*!< 0x00000002 */
N#define DMA_CCR_TCIE           DMA_CCR_TCIE_Msk                                /*!< Transfer complete interrupt enable  */
N#define DMA_CCR_HTIE_Pos       (2U)                                            
N#define DMA_CCR_HTIE_Msk       (0x1U << DMA_CCR_HTIE_Pos)                      /*!< 0x00000004 */
N#define DMA_CCR_HTIE           DMA_CCR_HTIE_Msk                                /*!< Half Transfer interrupt enable      */
N#define DMA_CCR_TEIE_Pos       (3U)                                            
N#define DMA_CCR_TEIE_Msk       (0x1U << DMA_CCR_TEIE_Pos)                      /*!< 0x00000008 */
N#define DMA_CCR_TEIE           DMA_CCR_TEIE_Msk                                /*!< Transfer error interrupt enable     */
N#define DMA_CCR_DIR_Pos        (4U)                                            
N#define DMA_CCR_DIR_Msk        (0x1U << DMA_CCR_DIR_Pos)                       /*!< 0x00000010 */
N#define DMA_CCR_DIR            DMA_CCR_DIR_Msk                                 /*!< Data transfer direction             */
N#define DMA_CCR_CIRC_Pos       (5U)                                            
N#define DMA_CCR_CIRC_Msk       (0x1U << DMA_CCR_CIRC_Pos)                      /*!< 0x00000020 */
N#define DMA_CCR_CIRC           DMA_CCR_CIRC_Msk                                /*!< Circular mode                       */
N#define DMA_CCR_PINC_Pos       (6U)                                            
N#define DMA_CCR_PINC_Msk       (0x1U << DMA_CCR_PINC_Pos)                      /*!< 0x00000040 */
N#define DMA_CCR_PINC           DMA_CCR_PINC_Msk                                /*!< Peripheral increment mode           */
N#define DMA_CCR_MINC_Pos       (7U)                                            
N#define DMA_CCR_MINC_Msk       (0x1U << DMA_CCR_MINC_Pos)                      /*!< 0x00000080 */
N#define DMA_CCR_MINC           DMA_CCR_MINC_Msk                                /*!< Memory increment mode               */
N
N#define DMA_CCR_PSIZE_Pos      (8U)                                            
N#define DMA_CCR_PSIZE_Msk      (0x3U << DMA_CCR_PSIZE_Pos)                     /*!< 0x00000300 */
N#define DMA_CCR_PSIZE          DMA_CCR_PSIZE_Msk                               /*!< PSIZE[1:0] bits (Peripheral size)   */
N#define DMA_CCR_PSIZE_0        (0x1U << DMA_CCR_PSIZE_Pos)                     /*!< 0x00000100 */
N#define DMA_CCR_PSIZE_1        (0x2U << DMA_CCR_PSIZE_Pos)                     /*!< 0x00000200 */
N
N#define DMA_CCR_MSIZE_Pos      (10U)                                           
N#define DMA_CCR_MSIZE_Msk      (0x3U << DMA_CCR_MSIZE_Pos)                     /*!< 0x00000C00 */
N#define DMA_CCR_MSIZE          DMA_CCR_MSIZE_Msk                               /*!< MSIZE[1:0] bits (Memory size)       */
N#define DMA_CCR_MSIZE_0        (0x1U << DMA_CCR_MSIZE_Pos)                     /*!< 0x00000400 */
N#define DMA_CCR_MSIZE_1        (0x2U << DMA_CCR_MSIZE_Pos)                     /*!< 0x00000800 */
N
N#define DMA_CCR_PL_Pos         (12U)                                           
N#define DMA_CCR_PL_Msk         (0x3U << DMA_CCR_PL_Pos)                        /*!< 0x00003000 */
N#define DMA_CCR_PL             DMA_CCR_PL_Msk                                  /*!< PL[1:0] bits(Channel Priority level)*/
N#define DMA_CCR_PL_0           (0x1U << DMA_CCR_PL_Pos)                        /*!< 0x00001000 */
N#define DMA_CCR_PL_1           (0x2U << DMA_CCR_PL_Pos)                        /*!< 0x00002000 */
N
N#define DMA_CCR_MEM2MEM_Pos    (14U)                                           
N#define DMA_CCR_MEM2MEM_Msk    (0x1U << DMA_CCR_MEM2MEM_Pos)                   /*!< 0x00004000 */
N#define DMA_CCR_MEM2MEM        DMA_CCR_MEM2MEM_Msk                             /*!< Memory to memory mode               */
N
N/******************  Bit definition for DMA_CNDTR register  *******************/
N#define DMA_CNDTR_NDT_Pos      (0U)                                            
N#define DMA_CNDTR_NDT_Msk      (0xFFFFU << DMA_CNDTR_NDT_Pos)                  /*!< 0x0000FFFF */
N#define DMA_CNDTR_NDT          DMA_CNDTR_NDT_Msk                               /*!< Number of data to Transfer          */
N
N/******************  Bit definition for DMA_CPAR register  ********************/
N#define DMA_CPAR_PA_Pos        (0U)                                            
N#define DMA_CPAR_PA_Msk        (0xFFFFFFFFU << DMA_CPAR_PA_Pos)                /*!< 0xFFFFFFFF */
N#define DMA_CPAR_PA            DMA_CPAR_PA_Msk                                 /*!< Peripheral Address                  */
N
N/******************  Bit definition for DMA_CMAR register  ********************/
N#define DMA_CMAR_MA_Pos        (0U)                                            
N#define DMA_CMAR_MA_Msk        (0xFFFFFFFFU << DMA_CMAR_MA_Pos)                /*!< 0xFFFFFFFF */
N#define DMA_CMAR_MA            DMA_CMAR_MA_Msk                                 /*!< Memory Address                      */
N
N/******************  Bit definition for DMA1_CSELR register  ********************/
N#define DMA_CSELR_C1S_Pos      (0U)                                            
N#define DMA_CSELR_C1S_Msk      (0xFU << DMA_CSELR_C1S_Pos)                     /*!< 0x0000000F */
N#define DMA_CSELR_C1S          DMA_CSELR_C1S_Msk                               /*!< Channel 1 Selection */
N#define DMA_CSELR_C2S_Pos      (4U)                                            
N#define DMA_CSELR_C2S_Msk      (0xFU << DMA_CSELR_C2S_Pos)                     /*!< 0x000000F0 */
N#define DMA_CSELR_C2S          DMA_CSELR_C2S_Msk                               /*!< Channel 2 Selection */
N#define DMA_CSELR_C3S_Pos      (8U)                                            
N#define DMA_CSELR_C3S_Msk      (0xFU << DMA_CSELR_C3S_Pos)                     /*!< 0x00000F00 */
N#define DMA_CSELR_C3S          DMA_CSELR_C3S_Msk                               /*!< Channel 3 Selection */
N#define DMA_CSELR_C4S_Pos      (12U)                                           
N#define DMA_CSELR_C4S_Msk      (0xFU << DMA_CSELR_C4S_Pos)                     /*!< 0x0000F000 */
N#define DMA_CSELR_C4S          DMA_CSELR_C4S_Msk                               /*!< Channel 4 Selection */
N#define DMA_CSELR_C5S_Pos      (16U)                                           
N#define DMA_CSELR_C5S_Msk      (0xFU << DMA_CSELR_C5S_Pos)                     /*!< 0x000F0000 */
N#define DMA_CSELR_C5S          DMA_CSELR_C5S_Msk                               /*!< Channel 5 Selection */
N#define DMA_CSELR_C6S_Pos      (20U)                                           
N#define DMA_CSELR_C6S_Msk      (0xFU << DMA_CSELR_C6S_Pos)                     /*!< 0x00F00000 */
N#define DMA_CSELR_C6S          DMA_CSELR_C6S_Msk                               /*!< Channel 6 Selection */
N#define DMA_CSELR_C7S_Pos      (24U)                                           
N#define DMA_CSELR_C7S_Msk      (0xFU << DMA_CSELR_C7S_Pos)                     /*!< 0x0F000000 */
N#define DMA_CSELR_C7S          DMA_CSELR_C7S_Msk                               /*!< Channel 7 Selection */
N
N#define DMA1_CSELR_DEFAULT              (0x00000000U)                          /*!< Default remap position for DMA1 */
N#define DMA1_CSELR_CH1_ADC_Pos          (0U)                                   
N#define DMA1_CSELR_CH1_ADC_Msk          (0x1U << DMA1_CSELR_CH1_ADC_Pos)       /*!< 0x00000001 */
N#define DMA1_CSELR_CH1_ADC              DMA1_CSELR_CH1_ADC_Msk                 /*!< Remap ADC on DMA1 Channel 1*/
N#define DMA1_CSELR_CH1_TIM17_CH1_Pos    (0U)                                   
N#define DMA1_CSELR_CH1_TIM17_CH1_Msk    (0x7U << DMA1_CSELR_CH1_TIM17_CH1_Pos) /*!< 0x00000007 */
N#define DMA1_CSELR_CH1_TIM17_CH1        DMA1_CSELR_CH1_TIM17_CH1_Msk           /*!< Remap TIM17 channel 1 on DMA1 channel 1 */
N#define DMA1_CSELR_CH1_TIM17_UP_Pos     (0U)                                   
N#define DMA1_CSELR_CH1_TIM17_UP_Msk     (0x7U << DMA1_CSELR_CH1_TIM17_UP_Pos)  /*!< 0x00000007 */
N#define DMA1_CSELR_CH1_TIM17_UP         DMA1_CSELR_CH1_TIM17_UP_Msk            /*!< Remap TIM17 up on DMA1 channel 1 */
N#define DMA1_CSELR_CH1_USART1_RX_Pos    (3U)                                   
N#define DMA1_CSELR_CH1_USART1_RX_Msk    (0x1U << DMA1_CSELR_CH1_USART1_RX_Pos) /*!< 0x00000008 */
N#define DMA1_CSELR_CH1_USART1_RX        DMA1_CSELR_CH1_USART1_RX_Msk           /*!< Remap USART1 Rx on DMA1 channel 1 */
N#define DMA1_CSELR_CH1_USART2_RX_Pos    (0U)                                   
N#define DMA1_CSELR_CH1_USART2_RX_Msk    (0x9U << DMA1_CSELR_CH1_USART2_RX_Pos) /*!< 0x00000009 */
N#define DMA1_CSELR_CH1_USART2_RX        DMA1_CSELR_CH1_USART2_RX_Msk           /*!< Remap USART2 Rx on DMA1 channel 1 */
N#define DMA1_CSELR_CH1_USART3_RX_Pos    (1U)                                   
N#define DMA1_CSELR_CH1_USART3_RX_Msk    (0x5U << DMA1_CSELR_CH1_USART3_RX_Pos) /*!< 0x0000000A */
N#define DMA1_CSELR_CH1_USART3_RX        DMA1_CSELR_CH1_USART3_RX_Msk           /*!< Remap USART3 Rx on DMA1 channel 1 */
N#define DMA1_CSELR_CH1_USART4_RX_Pos    (0U)                                   
N#define DMA1_CSELR_CH1_USART4_RX_Msk    (0xBU << DMA1_CSELR_CH1_USART4_RX_Pos) /*!< 0x0000000B */
N#define DMA1_CSELR_CH1_USART4_RX        DMA1_CSELR_CH1_USART4_RX_Msk           /*!< Remap USART4 Rx on DMA1 channel 1 */
N#define DMA1_CSELR_CH1_USART5_RX_Pos    (2U)                                   
N#define DMA1_CSELR_CH1_USART5_RX_Msk    (0x3U << DMA1_CSELR_CH1_USART5_RX_Pos) /*!< 0x0000000C */
N#define DMA1_CSELR_CH1_USART5_RX        DMA1_CSELR_CH1_USART5_RX_Msk           /*!< Remap USART5 Rx on DMA1 channel 1 */
N#define DMA1_CSELR_CH1_USART6_RX_Pos    (0U)                                   
N#define DMA1_CSELR_CH1_USART6_RX_Msk    (0xDU << DMA1_CSELR_CH1_USART6_RX_Pos) /*!< 0x0000000D */
N#define DMA1_CSELR_CH1_USART6_RX        DMA1_CSELR_CH1_USART6_RX_Msk           /*!< Remap USART6 Rx on DMA1 channel 1 */
N#define DMA1_CSELR_CH1_USART7_RX_Pos    (1U)                                   
N#define DMA1_CSELR_CH1_USART7_RX_Msk    (0x7U << DMA1_CSELR_CH1_USART7_RX_Pos) /*!< 0x0000000E */
N#define DMA1_CSELR_CH1_USART7_RX        DMA1_CSELR_CH1_USART7_RX_Msk           /*!< Remap USART7 Rx on DMA1 channel 1 */
N#define DMA1_CSELR_CH1_USART8_RX_Pos    (0U)                                   
N#define DMA1_CSELR_CH1_USART8_RX_Msk    (0xFU << DMA1_CSELR_CH1_USART8_RX_Pos) /*!< 0x0000000F */
N#define DMA1_CSELR_CH1_USART8_RX        DMA1_CSELR_CH1_USART8_RX_Msk           /*!< Remap USART8 Rx on DMA1 channel 1 */
N#define DMA1_CSELR_CH2_ADC_Pos          (4U)                                   
N#define DMA1_CSELR_CH2_ADC_Msk          (0x1U << DMA1_CSELR_CH2_ADC_Pos)       /*!< 0x00000010 */
N#define DMA1_CSELR_CH2_ADC              DMA1_CSELR_CH2_ADC_Msk                 /*!< Remap ADC on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_I2C1_TX_Pos      (5U)                                   
N#define DMA1_CSELR_CH2_I2C1_TX_Msk      (0x1U << DMA1_CSELR_CH2_I2C1_TX_Pos)   /*!< 0x00000020 */
N#define DMA1_CSELR_CH2_I2C1_TX          DMA1_CSELR_CH2_I2C1_TX_Msk             /*!< Remap I2C1 Tx on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_SPI1_RX_Pos      (4U)                                   
N#define DMA1_CSELR_CH2_SPI1_RX_Msk      (0x3U << DMA1_CSELR_CH2_SPI1_RX_Pos)   /*!< 0x00000030 */
N#define DMA1_CSELR_CH2_SPI1_RX          DMA1_CSELR_CH2_SPI1_RX_Msk             /*!< Remap SPI1 Rx on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_TIM1_CH1_Pos     (6U)                                   
N#define DMA1_CSELR_CH2_TIM1_CH1_Msk     (0x1U << DMA1_CSELR_CH2_TIM1_CH1_Pos)  /*!< 0x00000040 */
N#define DMA1_CSELR_CH2_TIM1_CH1         DMA1_CSELR_CH2_TIM1_CH1_Msk            /*!< Remap TIM1 channel 1 on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_TIM17_CH1_Pos    (4U)                                   
N#define DMA1_CSELR_CH2_TIM17_CH1_Msk    (0x7U << DMA1_CSELR_CH2_TIM17_CH1_Pos) /*!< 0x00000070 */
N#define DMA1_CSELR_CH2_TIM17_CH1        DMA1_CSELR_CH2_TIM17_CH1_Msk           /*!< Remap TIM17 channel 1 on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_TIM17_UP_Pos     (4U)                                   
N#define DMA1_CSELR_CH2_TIM17_UP_Msk     (0x7U << DMA1_CSELR_CH2_TIM17_UP_Pos)  /*!< 0x00000070 */
N#define DMA1_CSELR_CH2_TIM17_UP         DMA1_CSELR_CH2_TIM17_UP_Msk            /*!< Remap TIM17 up on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_USART1_TX_Pos    (7U)                                   
N#define DMA1_CSELR_CH2_USART1_TX_Msk    (0x1U << DMA1_CSELR_CH2_USART1_TX_Pos) /*!< 0x00000080 */
N#define DMA1_CSELR_CH2_USART1_TX        DMA1_CSELR_CH2_USART1_TX_Msk           /*!< Remap USART1 Tx on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_USART2_TX_Pos    (4U)                                   
N#define DMA1_CSELR_CH2_USART2_TX_Msk    (0x9U << DMA1_CSELR_CH2_USART2_TX_Pos) /*!< 0x00000090 */
N#define DMA1_CSELR_CH2_USART2_TX        DMA1_CSELR_CH2_USART2_TX_Msk           /*!< Remap USART2 Tx on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_USART3_TX_Pos    (5U)                                   
N#define DMA1_CSELR_CH2_USART3_TX_Msk    (0x5U << DMA1_CSELR_CH2_USART3_TX_Pos) /*!< 0x000000A0 */
N#define DMA1_CSELR_CH2_USART3_TX        DMA1_CSELR_CH2_USART3_TX_Msk           /*!< Remap USART3 Tx on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_USART4_TX_Pos    (4U)                                   
N#define DMA1_CSELR_CH2_USART4_TX_Msk    (0xBU << DMA1_CSELR_CH2_USART4_TX_Pos) /*!< 0x000000B0 */
N#define DMA1_CSELR_CH2_USART4_TX        DMA1_CSELR_CH2_USART4_TX_Msk           /*!< Remap USART4 Tx on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_USART5_TX_Pos    (6U)                                   
N#define DMA1_CSELR_CH2_USART5_TX_Msk    (0x3U << DMA1_CSELR_CH2_USART5_TX_Pos) /*!< 0x000000C0 */
N#define DMA1_CSELR_CH2_USART5_TX        DMA1_CSELR_CH2_USART5_TX_Msk           /*!< Remap USART5 Tx on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_USART6_TX_Pos    (4U)                                   
N#define DMA1_CSELR_CH2_USART6_TX_Msk    (0xDU << DMA1_CSELR_CH2_USART6_TX_Pos) /*!< 0x000000D0 */
N#define DMA1_CSELR_CH2_USART6_TX        DMA1_CSELR_CH2_USART6_TX_Msk           /*!< Remap USART6 Tx on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_USART7_TX_Pos    (5U)                                   
N#define DMA1_CSELR_CH2_USART7_TX_Msk    (0x7U << DMA1_CSELR_CH2_USART7_TX_Pos) /*!< 0x000000E0 */
N#define DMA1_CSELR_CH2_USART7_TX        DMA1_CSELR_CH2_USART7_TX_Msk           /*!< Remap USART7 Tx on DMA1 channel 2 */
N#define DMA1_CSELR_CH2_USART8_TX_Pos    (4U)                                   
N#define DMA1_CSELR_CH2_USART8_TX_Msk    (0xFU << DMA1_CSELR_CH2_USART8_TX_Pos) /*!< 0x000000F0 */
N#define DMA1_CSELR_CH2_USART8_TX        DMA1_CSELR_CH2_USART8_TX_Msk           /*!< Remap USART8 Tx on DMA1 channel 2 */
N#define DMA1_CSELR_CH3_TIM6_UP_Pos      (8U)                                   
N#define DMA1_CSELR_CH3_TIM6_UP_Msk      (0x1U << DMA1_CSELR_CH3_TIM6_UP_Pos)   /*!< 0x00000100 */
N#define DMA1_CSELR_CH3_TIM6_UP          DMA1_CSELR_CH3_TIM6_UP_Msk             /*!< Remap TIM6 up on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_DAC_CH1_Pos      (8U)                                   
N#define DMA1_CSELR_CH3_DAC_CH1_Msk      (0x1U << DMA1_CSELR_CH3_DAC_CH1_Pos)   /*!< 0x00000100 */
N#define DMA1_CSELR_CH3_DAC_CH1          DMA1_CSELR_CH3_DAC_CH1_Msk             /*!< Remap DAC Channel 1on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_I2C1_RX_Pos      (9U)                                   
N#define DMA1_CSELR_CH3_I2C1_RX_Msk      (0x1U << DMA1_CSELR_CH3_I2C1_RX_Pos)   /*!< 0x00000200 */
N#define DMA1_CSELR_CH3_I2C1_RX          DMA1_CSELR_CH3_I2C1_RX_Msk             /*!< Remap I2C1 Rx on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_SPI1_TX_Pos      (8U)                                   
N#define DMA1_CSELR_CH3_SPI1_TX_Msk      (0x3U << DMA1_CSELR_CH3_SPI1_TX_Pos)   /*!< 0x00000300 */
N#define DMA1_CSELR_CH3_SPI1_TX          DMA1_CSELR_CH3_SPI1_TX_Msk             /*!< Remap SPI1 Tx on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_TIM1_CH2_Pos     (10U)                                  
N#define DMA1_CSELR_CH3_TIM1_CH2_Msk     (0x1U << DMA1_CSELR_CH3_TIM1_CH2_Pos)  /*!< 0x00000400 */
N#define DMA1_CSELR_CH3_TIM1_CH2         DMA1_CSELR_CH3_TIM1_CH2_Msk            /*!< Remap TIM1 channel 2 on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_TIM2_CH2_Pos     (8U)                                   
N#define DMA1_CSELR_CH3_TIM2_CH2_Msk     (0x5U << DMA1_CSELR_CH3_TIM2_CH2_Pos)  /*!< 0x00000500 */
N#define DMA1_CSELR_CH3_TIM2_CH2         DMA1_CSELR_CH3_TIM2_CH2_Msk            /*!< Remap TIM2 channel 2 on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_TIM16_CH1_Pos    (8U)                                   
N#define DMA1_CSELR_CH3_TIM16_CH1_Msk    (0x7U << DMA1_CSELR_CH3_TIM16_CH1_Pos) /*!< 0x00000700 */
N#define DMA1_CSELR_CH3_TIM16_CH1        DMA1_CSELR_CH3_TIM16_CH1_Msk           /*!< Remap TIM16 channel 1 on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_TIM16_UP_Pos     (8U)                                   
N#define DMA1_CSELR_CH3_TIM16_UP_Msk     (0x7U << DMA1_CSELR_CH3_TIM16_UP_Pos)  /*!< 0x00000700 */
N#define DMA1_CSELR_CH3_TIM16_UP         DMA1_CSELR_CH3_TIM16_UP_Msk            /*!< Remap TIM16 up on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_USART1_RX_Pos    (11U)                                  
N#define DMA1_CSELR_CH3_USART1_RX_Msk    (0x1U << DMA1_CSELR_CH3_USART1_RX_Pos) /*!< 0x00000800 */
N#define DMA1_CSELR_CH3_USART1_RX        DMA1_CSELR_CH3_USART1_RX_Msk           /*!< Remap USART1 Rx on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_USART2_RX_Pos    (8U)                                   
N#define DMA1_CSELR_CH3_USART2_RX_Msk    (0x9U << DMA1_CSELR_CH3_USART2_RX_Pos) /*!< 0x00000900 */
N#define DMA1_CSELR_CH3_USART2_RX        DMA1_CSELR_CH3_USART2_RX_Msk           /*!< Remap USART2 Rx on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_USART3_RX_Pos    (9U)                                   
N#define DMA1_CSELR_CH3_USART3_RX_Msk    (0x5U << DMA1_CSELR_CH3_USART3_RX_Pos) /*!< 0x00000A00 */
N#define DMA1_CSELR_CH3_USART3_RX        DMA1_CSELR_CH3_USART3_RX_Msk           /*!< Remap USART3 Rx on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_USART4_RX_Pos    (8U)                                   
N#define DMA1_CSELR_CH3_USART4_RX_Msk    (0xBU << DMA1_CSELR_CH3_USART4_RX_Pos) /*!< 0x00000B00 */
N#define DMA1_CSELR_CH3_USART4_RX        DMA1_CSELR_CH3_USART4_RX_Msk           /*!< Remap USART4 Rx on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_USART5_RX_Pos    (10U)                                  
N#define DMA1_CSELR_CH3_USART5_RX_Msk    (0x3U << DMA1_CSELR_CH3_USART5_RX_Pos) /*!< 0x00000C00 */
N#define DMA1_CSELR_CH3_USART5_RX        DMA1_CSELR_CH3_USART5_RX_Msk           /*!< Remap USART5 Rx on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_USART6_RX_Pos    (8U)                                   
N#define DMA1_CSELR_CH3_USART6_RX_Msk    (0xDU << DMA1_CSELR_CH3_USART6_RX_Pos) /*!< 0x00000D00 */
N#define DMA1_CSELR_CH3_USART6_RX        DMA1_CSELR_CH3_USART6_RX_Msk           /*!< Remap USART6 Rx on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_USART7_RX_Pos    (9U)                                   
N#define DMA1_CSELR_CH3_USART7_RX_Msk    (0x7U << DMA1_CSELR_CH3_USART7_RX_Pos) /*!< 0x00000E00 */
N#define DMA1_CSELR_CH3_USART7_RX        DMA1_CSELR_CH3_USART7_RX_Msk           /*!< Remap USART7 Rx on DMA1 channel 3 */
N#define DMA1_CSELR_CH3_USART8_RX_Pos    (8U)                                   
N#define DMA1_CSELR_CH3_USART8_RX_Msk    (0xFU << DMA1_CSELR_CH3_USART8_RX_Pos) /*!< 0x00000F00 */
N#define DMA1_CSELR_CH3_USART8_RX        DMA1_CSELR_CH3_USART8_RX_Msk           /*!< Remap USART8 Rx on DMA1 channel 3 */
N#define DMA1_CSELR_CH4_TIM7_UP_Pos      (12U)                                  
N#define DMA1_CSELR_CH4_TIM7_UP_Msk      (0x1U << DMA1_CSELR_CH4_TIM7_UP_Pos)   /*!< 0x00001000 */
N#define DMA1_CSELR_CH4_TIM7_UP          DMA1_CSELR_CH4_TIM7_UP_Msk             /*!< Remap TIM7 up on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_DAC_CH2_Pos      (12U)                                  
N#define DMA1_CSELR_CH4_DAC_CH2_Msk      (0x1U << DMA1_CSELR_CH4_DAC_CH2_Pos)   /*!< 0x00001000 */
N#define DMA1_CSELR_CH4_DAC_CH2          DMA1_CSELR_CH4_DAC_CH2_Msk             /*!< Remap DAC Channel 2 on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_I2C2_TX_Pos      (13U)                                  
N#define DMA1_CSELR_CH4_I2C2_TX_Msk      (0x1U << DMA1_CSELR_CH4_I2C2_TX_Pos)   /*!< 0x00002000 */
N#define DMA1_CSELR_CH4_I2C2_TX          DMA1_CSELR_CH4_I2C2_TX_Msk             /*!< Remap I2C2 Tx on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_SPI2_RX_Pos      (12U)                                  
N#define DMA1_CSELR_CH4_SPI2_RX_Msk      (0x3U << DMA1_CSELR_CH4_SPI2_RX_Pos)   /*!< 0x00003000 */
N#define DMA1_CSELR_CH4_SPI2_RX          DMA1_CSELR_CH4_SPI2_RX_Msk             /*!< Remap SPI2 Rx on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_TIM2_CH4_Pos     (12U)                                  
N#define DMA1_CSELR_CH4_TIM2_CH4_Msk     (0x5U << DMA1_CSELR_CH4_TIM2_CH4_Pos)  /*!< 0x00005000 */
N#define DMA1_CSELR_CH4_TIM2_CH4         DMA1_CSELR_CH4_TIM2_CH4_Msk            /*!< Remap TIM2 channel 4 on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_TIM3_CH1_Pos     (13U)                                  
N#define DMA1_CSELR_CH4_TIM3_CH1_Msk     (0x3U << DMA1_CSELR_CH4_TIM3_CH1_Pos)  /*!< 0x00006000 */
N#define DMA1_CSELR_CH4_TIM3_CH1         DMA1_CSELR_CH4_TIM3_CH1_Msk            /*!< Remap TIM3 channel 1 on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_TIM3_TRIG_Pos    (13U)                                  
N#define DMA1_CSELR_CH4_TIM3_TRIG_Msk    (0x3U << DMA1_CSELR_CH4_TIM3_TRIG_Pos) /*!< 0x00006000 */
N#define DMA1_CSELR_CH4_TIM3_TRIG        DMA1_CSELR_CH4_TIM3_TRIG_Msk           /*!< Remap TIM3 Trig on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_TIM16_CH1_Pos    (12U)                                  
N#define DMA1_CSELR_CH4_TIM16_CH1_Msk    (0x7U << DMA1_CSELR_CH4_TIM16_CH1_Pos) /*!< 0x00007000 */
N#define DMA1_CSELR_CH4_TIM16_CH1        DMA1_CSELR_CH4_TIM16_CH1_Msk           /*!< Remap TIM16 channel 1 on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_TIM16_UP_Pos     (12U)                                  
N#define DMA1_CSELR_CH4_TIM16_UP_Msk     (0x7U << DMA1_CSELR_CH4_TIM16_UP_Pos)  /*!< 0x00007000 */
N#define DMA1_CSELR_CH4_TIM16_UP         DMA1_CSELR_CH4_TIM16_UP_Msk            /*!< Remap TIM16 up on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_USART1_TX_Pos    (15U)                                  
N#define DMA1_CSELR_CH4_USART1_TX_Msk    (0x1U << DMA1_CSELR_CH4_USART1_TX_Pos) /*!< 0x00008000 */
N#define DMA1_CSELR_CH4_USART1_TX        DMA1_CSELR_CH4_USART1_TX_Msk           /*!< Remap USART1 Tx on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_USART2_TX_Pos    (12U)                                  
N#define DMA1_CSELR_CH4_USART2_TX_Msk    (0x9U << DMA1_CSELR_CH4_USART2_TX_Pos) /*!< 0x00009000 */
N#define DMA1_CSELR_CH4_USART2_TX        DMA1_CSELR_CH4_USART2_TX_Msk           /*!< Remap USART2 Tx on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_USART3_TX_Pos    (13U)                                  
N#define DMA1_CSELR_CH4_USART3_TX_Msk    (0x5U << DMA1_CSELR_CH4_USART3_TX_Pos) /*!< 0x0000A000 */
N#define DMA1_CSELR_CH4_USART3_TX        DMA1_CSELR_CH4_USART3_TX_Msk           /*!< Remap USART3 Tx on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_USART4_TX_Pos    (12U)                                  
N#define DMA1_CSELR_CH4_USART4_TX_Msk    (0xBU << DMA1_CSELR_CH4_USART4_TX_Pos) /*!< 0x0000B000 */
N#define DMA1_CSELR_CH4_USART4_TX        DMA1_CSELR_CH4_USART4_TX_Msk           /*!< Remap USART4 Tx on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_USART5_TX_Pos    (14U)                                  
N#define DMA1_CSELR_CH4_USART5_TX_Msk    (0x3U << DMA1_CSELR_CH4_USART5_TX_Pos) /*!< 0x0000C000 */
N#define DMA1_CSELR_CH4_USART5_TX        DMA1_CSELR_CH4_USART5_TX_Msk           /*!< Remap USART5 Tx on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_USART6_TX_Pos    (12U)                                  
N#define DMA1_CSELR_CH4_USART6_TX_Msk    (0xDU << DMA1_CSELR_CH4_USART6_TX_Pos) /*!< 0x0000D000 */
N#define DMA1_CSELR_CH4_USART6_TX        DMA1_CSELR_CH4_USART6_TX_Msk           /*!< Remap USART6 Tx on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_USART7_TX_Pos    (13U)                                  
N#define DMA1_CSELR_CH4_USART7_TX_Msk    (0x7U << DMA1_CSELR_CH4_USART7_TX_Pos) /*!< 0x0000E000 */
N#define DMA1_CSELR_CH4_USART7_TX        DMA1_CSELR_CH4_USART7_TX_Msk           /*!< Remap USART7 Tx on DMA1 channel 4 */
N#define DMA1_CSELR_CH4_USART8_TX_Pos    (12U)                                  
N#define DMA1_CSELR_CH4_USART8_TX_Msk    (0xFU << DMA1_CSELR_CH4_USART8_TX_Pos) /*!< 0x0000F000 */
N#define DMA1_CSELR_CH4_USART8_TX        DMA1_CSELR_CH4_USART8_TX_Msk           /*!< Remap USART8 Tx on DMA1 channel 4 */
N#define DMA1_CSELR_CH5_I2C2_RX_Pos      (17U)                                  
N#define DMA1_CSELR_CH5_I2C2_RX_Msk      (0x1U << DMA1_CSELR_CH5_I2C2_RX_Pos)   /*!< 0x00020000 */
N#define DMA1_CSELR_CH5_I2C2_RX          DMA1_CSELR_CH5_I2C2_RX_Msk             /*!< Remap I2C2 Rx on DMA1 channel 5 */
N#define DMA1_CSELR_CH5_SPI2_TX_Pos      (16U)                                  
N#define DMA1_CSELR_CH5_SPI2_TX_Msk      (0x3U << DMA1_CSELR_CH5_SPI2_TX_Pos)   /*!< 0x00030000 */
N#define DMA1_CSELR_CH5_SPI2_TX          DMA1_CSELR_CH5_SPI2_TX_Msk             /*!< Remap SPI1 Tx on DMA1 channel 5 */
N#define DMA1_CSELR_CH5_TIM1_CH3_Pos     (18U)                                  
N#define DMA1_CSELR_CH5_TIM1_CH3_Msk     (0x1U << DMA1_CSELR_CH5_TIM1_CH3_Pos)  /*!< 0x00040000 */
N#define DMA1_CSELR_CH5_TIM1_CH3         DMA1_CSELR_CH5_TIM1_CH3_Msk            /*!< Remap TIM1 channel 3 on DMA1 channel 5 */
N#define DMA1_CSELR_CH5_USART1_RX_Pos    (19U)                                  
N#define DMA1_CSELR_CH5_USART1_RX_Msk    (0x1U << DMA1_CSELR_CH5_USART1_RX_Pos) /*!< 0x00080000 */
N#define DMA1_CSELR_CH5_USART1_RX        DMA1_CSELR_CH5_USART1_RX_Msk           /*!< Remap USART1 Rx on DMA1 channel 5 */
N#define DMA1_CSELR_CH5_USART2_RX_Pos    (16U)                                  
N#define DMA1_CSELR_CH5_USART2_RX_Msk    (0x9U << DMA1_CSELR_CH5_USART2_RX_Pos) /*!< 0x00090000 */
N#define DMA1_CSELR_CH5_USART2_RX        DMA1_CSELR_CH5_USART2_RX_Msk           /*!< Remap USART2 Rx on DMA1 channel 5 */
N#define DMA1_CSELR_CH5_USART3_RX_Pos    (17U)                                  
N#define DMA1_CSELR_CH5_USART3_RX_Msk    (0x5U << DMA1_CSELR_CH5_USART3_RX_Pos) /*!< 0x000A0000 */
N#define DMA1_CSELR_CH5_USART3_RX        DMA1_CSELR_CH5_USART3_RX_Msk           /*!< Remap USART3 Rx on DMA1 channel 5 */
N#define DMA1_CSELR_CH5_USART4_RX_Pos    (16U)                                  
N#define DMA1_CSELR_CH5_USART4_RX_Msk    (0xBU << DMA1_CSELR_CH5_USART4_RX_Pos) /*!< 0x000B0000 */
N#define DMA1_CSELR_CH5_USART4_RX        DMA1_CSELR_CH5_USART4_RX_Msk           /*!< Remap USART4 Rx on DMA1 channel 5 */
N#define DMA1_CSELR_CH5_USART5_RX_Pos    (18U)                                  
N#define DMA1_CSELR_CH5_USART5_RX_Msk    (0x3U << DMA1_CSELR_CH5_USART5_RX_Pos) /*!< 0x000C0000 */
N#define DMA1_CSELR_CH5_USART5_RX        DMA1_CSELR_CH5_USART5_RX_Msk           /*!< Remap USART5 Rx on DMA1 channel 5 */
N#define DMA1_CSELR_CH5_USART6_RX_Pos    (16U)                                  
N#define DMA1_CSELR_CH5_USART6_RX_Msk    (0xDU << DMA1_CSELR_CH5_USART6_RX_Pos) /*!< 0x000D0000 */
N#define DMA1_CSELR_CH5_USART6_RX        DMA1_CSELR_CH5_USART6_RX_Msk           /*!< Remap USART6 Rx on DMA1 channel 5 */
N#define DMA1_CSELR_CH5_USART7_RX_Pos    (17U)                                  
N#define DMA1_CSELR_CH5_USART7_RX_Msk    (0x7U << DMA1_CSELR_CH5_USART7_RX_Pos) /*!< 0x000E0000 */
N#define DMA1_CSELR_CH5_USART7_RX        DMA1_CSELR_CH5_USART7_RX_Msk           /*!< Remap USART7 Rx on DMA1 channel 5 */
N#define DMA1_CSELR_CH5_USART8_RX_Pos    (16U)                                  
N#define DMA1_CSELR_CH5_USART8_RX_Msk    (0xFU << DMA1_CSELR_CH5_USART8_RX_Pos) /*!< 0x000F0000 */
N#define DMA1_CSELR_CH5_USART8_RX        DMA1_CSELR_CH5_USART8_RX_Msk           /*!< Remap USART8 Rx on DMA1 channel 5 */
N#define DMA1_CSELR_CH6_I2C1_TX_Pos      (21U)                                  
N#define DMA1_CSELR_CH6_I2C1_TX_Msk      (0x1U << DMA1_CSELR_CH6_I2C1_TX_Pos)   /*!< 0x00200000 */
N#define DMA1_CSELR_CH6_I2C1_TX          DMA1_CSELR_CH6_I2C1_TX_Msk             /*!< Remap I2C1 Tx on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_SPI2_RX_Pos      (20U)                                  
N#define DMA1_CSELR_CH6_SPI2_RX_Msk      (0x3U << DMA1_CSELR_CH6_SPI2_RX_Pos)   /*!< 0x00300000 */
N#define DMA1_CSELR_CH6_SPI2_RX          DMA1_CSELR_CH6_SPI2_RX_Msk             /*!< Remap SPI2 Rx on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_TIM1_CH1_Pos     (22U)                                  
N#define DMA1_CSELR_CH6_TIM1_CH1_Msk     (0x1U << DMA1_CSELR_CH6_TIM1_CH1_Pos)  /*!< 0x00400000 */
N#define DMA1_CSELR_CH6_TIM1_CH1         DMA1_CSELR_CH6_TIM1_CH1_Msk            /*!< Remap TIM1 channel 1 on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_TIM1_CH2_Pos     (22U)                                  
N#define DMA1_CSELR_CH6_TIM1_CH2_Msk     (0x1U << DMA1_CSELR_CH6_TIM1_CH2_Pos)  /*!< 0x00400000 */
N#define DMA1_CSELR_CH6_TIM1_CH2         DMA1_CSELR_CH6_TIM1_CH2_Msk            /*!< Remap TIM1 channel 2 on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_TIM1_CH3_Pos     (22U)                                  
N#define DMA1_CSELR_CH6_TIM1_CH3_Msk     (0x1U << DMA1_CSELR_CH6_TIM1_CH3_Pos)  /*!< 0x00400000 */
N#define DMA1_CSELR_CH6_TIM1_CH3         DMA1_CSELR_CH6_TIM1_CH3_Msk            /*!< Remap TIM1 channel 3 on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_TIM3_CH1_Pos     (21U)                                  
N#define DMA1_CSELR_CH6_TIM3_CH1_Msk     (0x3U << DMA1_CSELR_CH6_TIM3_CH1_Pos)  /*!< 0x00600000 */
N#define DMA1_CSELR_CH6_TIM3_CH1         DMA1_CSELR_CH6_TIM3_CH1_Msk            /*!< Remap TIM3 channel 1 on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_TIM3_TRIG_Pos    (21U)                                  
N#define DMA1_CSELR_CH6_TIM3_TRIG_Msk    (0x3U << DMA1_CSELR_CH6_TIM3_TRIG_Pos) /*!< 0x00600000 */
N#define DMA1_CSELR_CH6_TIM3_TRIG        DMA1_CSELR_CH6_TIM3_TRIG_Msk           /*!< Remap TIM3 Trig on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_TIM16_CH1_Pos    (20U)                                  
N#define DMA1_CSELR_CH6_TIM16_CH1_Msk    (0x7U << DMA1_CSELR_CH6_TIM16_CH1_Pos) /*!< 0x00700000 */
N#define DMA1_CSELR_CH6_TIM16_CH1        DMA1_CSELR_CH6_TIM16_CH1_Msk           /*!< Remap TIM16 channel 1 on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_TIM16_UP_Pos     (20U)                                  
N#define DMA1_CSELR_CH6_TIM16_UP_Msk     (0x7U << DMA1_CSELR_CH6_TIM16_UP_Pos)  /*!< 0x00700000 */
N#define DMA1_CSELR_CH6_TIM16_UP         DMA1_CSELR_CH6_TIM16_UP_Msk            /*!< Remap TIM16 up on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_USART1_RX_Pos    (23U)                                  
N#define DMA1_CSELR_CH6_USART1_RX_Msk    (0x1U << DMA1_CSELR_CH6_USART1_RX_Pos) /*!< 0x00800000 */
N#define DMA1_CSELR_CH6_USART1_RX        DMA1_CSELR_CH6_USART1_RX_Msk           /*!< Remap USART1 Rx on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_USART2_RX_Pos    (20U)                                  
N#define DMA1_CSELR_CH6_USART2_RX_Msk    (0x9U << DMA1_CSELR_CH6_USART2_RX_Pos) /*!< 0x00900000 */
N#define DMA1_CSELR_CH6_USART2_RX        DMA1_CSELR_CH6_USART2_RX_Msk           /*!< Remap USART2 Rx on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_USART3_RX_Pos    (21U)                                  
N#define DMA1_CSELR_CH6_USART3_RX_Msk    (0x5U << DMA1_CSELR_CH6_USART3_RX_Pos) /*!< 0x00A00000 */
N#define DMA1_CSELR_CH6_USART3_RX        DMA1_CSELR_CH6_USART3_RX_Msk           /*!< Remap USART3 Rx on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_USART4_RX_Pos    (20U)                                  
N#define DMA1_CSELR_CH6_USART4_RX_Msk    (0xBU << DMA1_CSELR_CH6_USART4_RX_Pos) /*!< 0x00B00000 */
N#define DMA1_CSELR_CH6_USART4_RX        DMA1_CSELR_CH6_USART4_RX_Msk           /*!< Remap USART4 Rx on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_USART5_RX_Pos    (22U)                                  
N#define DMA1_CSELR_CH6_USART5_RX_Msk    (0x3U << DMA1_CSELR_CH6_USART5_RX_Pos) /*!< 0x00C00000 */
N#define DMA1_CSELR_CH6_USART5_RX        DMA1_CSELR_CH6_USART5_RX_Msk           /*!< Remap USART5 Rx on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_USART6_RX_Pos    (20U)                                  
N#define DMA1_CSELR_CH6_USART6_RX_Msk    (0xDU << DMA1_CSELR_CH6_USART6_RX_Pos) /*!< 0x00D00000 */
N#define DMA1_CSELR_CH6_USART6_RX        DMA1_CSELR_CH6_USART6_RX_Msk           /*!< Remap USART6 Rx on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_USART7_RX_Pos    (21U)                                  
N#define DMA1_CSELR_CH6_USART7_RX_Msk    (0x7U << DMA1_CSELR_CH6_USART7_RX_Pos) /*!< 0x00E00000 */
N#define DMA1_CSELR_CH6_USART7_RX        DMA1_CSELR_CH6_USART7_RX_Msk           /*!< Remap USART7 Rx on DMA1 channel 6 */
N#define DMA1_CSELR_CH6_USART8_RX_Pos    (20U)                                  
N#define DMA1_CSELR_CH6_USART8_RX_Msk    (0xFU << DMA1_CSELR_CH6_USART8_RX_Pos) /*!< 0x00F00000 */
N#define DMA1_CSELR_CH6_USART8_RX        DMA1_CSELR_CH6_USART8_RX_Msk           /*!< Remap USART8 Rx on DMA1 channel 6 */
N#define DMA1_CSELR_CH7_I2C1_RX_Pos      (25U)                                  
N#define DMA1_CSELR_CH7_I2C1_RX_Msk      (0x1U << DMA1_CSELR_CH7_I2C1_RX_Pos)   /*!< 0x02000000 */
N#define DMA1_CSELR_CH7_I2C1_RX          DMA1_CSELR_CH7_I2C1_RX_Msk             /*!< Remap I2C1 Rx on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_SPI2_TX_Pos      (24U)                                  
N#define DMA1_CSELR_CH7_SPI2_TX_Msk      (0x3U << DMA1_CSELR_CH7_SPI2_TX_Pos)   /*!< 0x03000000 */
N#define DMA1_CSELR_CH7_SPI2_TX          DMA1_CSELR_CH7_SPI2_TX_Msk             /*!< Remap SPI2 Tx on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_TIM2_CH2_Pos     (24U)                                  
N#define DMA1_CSELR_CH7_TIM2_CH2_Msk     (0x5U << DMA1_CSELR_CH7_TIM2_CH2_Pos)  /*!< 0x05000000 */
N#define DMA1_CSELR_CH7_TIM2_CH2         DMA1_CSELR_CH7_TIM2_CH2_Msk            /*!< Remap TIM2 channel 2 on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_TIM2_CH4_Pos     (24U)                                  
N#define DMA1_CSELR_CH7_TIM2_CH4_Msk     (0x5U << DMA1_CSELR_CH7_TIM2_CH4_Pos)  /*!< 0x05000000 */
N#define DMA1_CSELR_CH7_TIM2_CH4         DMA1_CSELR_CH7_TIM2_CH4_Msk            /*!< Remap TIM2 channel 4 on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_TIM17_CH1_Pos    (24U)                                  
N#define DMA1_CSELR_CH7_TIM17_CH1_Msk    (0x7U << DMA1_CSELR_CH7_TIM17_CH1_Pos) /*!< 0x07000000 */
N#define DMA1_CSELR_CH7_TIM17_CH1        DMA1_CSELR_CH7_TIM17_CH1_Msk           /*!< Remap TIM17 channel 1 on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_TIM17_UP_Pos     (24U)                                  
N#define DMA1_CSELR_CH7_TIM17_UP_Msk     (0x7U << DMA1_CSELR_CH7_TIM17_UP_Pos)  /*!< 0x07000000 */
N#define DMA1_CSELR_CH7_TIM17_UP         DMA1_CSELR_CH7_TIM17_UP_Msk            /*!< Remap TIM17 up on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_USART1_TX_Pos    (27U)                                  
N#define DMA1_CSELR_CH7_USART1_TX_Msk    (0x1U << DMA1_CSELR_CH7_USART1_TX_Pos) /*!< 0x08000000 */
N#define DMA1_CSELR_CH7_USART1_TX        DMA1_CSELR_CH7_USART1_TX_Msk           /*!< Remap USART1 Tx on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_USART2_TX_Pos    (24U)                                  
N#define DMA1_CSELR_CH7_USART2_TX_Msk    (0x9U << DMA1_CSELR_CH7_USART2_TX_Pos) /*!< 0x09000000 */
N#define DMA1_CSELR_CH7_USART2_TX        DMA1_CSELR_CH7_USART2_TX_Msk           /*!< Remap USART2 Tx on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_USART3_TX_Pos    (25U)                                  
N#define DMA1_CSELR_CH7_USART3_TX_Msk    (0x5U << DMA1_CSELR_CH7_USART3_TX_Pos) /*!< 0x0A000000 */
N#define DMA1_CSELR_CH7_USART3_TX        DMA1_CSELR_CH7_USART3_TX_Msk           /*!< Remap USART3 Tx on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_USART4_TX_Pos    (24U)                                  
N#define DMA1_CSELR_CH7_USART4_TX_Msk    (0xBU << DMA1_CSELR_CH7_USART4_TX_Pos) /*!< 0x0B000000 */
N#define DMA1_CSELR_CH7_USART4_TX        DMA1_CSELR_CH7_USART4_TX_Msk           /*!< Remap USART4 Tx on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_USART5_TX_Pos    (26U)                                  
N#define DMA1_CSELR_CH7_USART5_TX_Msk    (0x3U << DMA1_CSELR_CH7_USART5_TX_Pos) /*!< 0x0C000000 */
N#define DMA1_CSELR_CH7_USART5_TX        DMA1_CSELR_CH7_USART5_TX_Msk           /*!< Remap USART5 Tx on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_USART6_TX_Pos    (24U)                                  
N#define DMA1_CSELR_CH7_USART6_TX_Msk    (0xDU << DMA1_CSELR_CH7_USART6_TX_Pos) /*!< 0x0D000000 */
N#define DMA1_CSELR_CH7_USART6_TX        DMA1_CSELR_CH7_USART6_TX_Msk           /*!< Remap USART6 Tx on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_USART7_TX_Pos    (25U)                                  
N#define DMA1_CSELR_CH7_USART7_TX_Msk    (0x7U << DMA1_CSELR_CH7_USART7_TX_Pos) /*!< 0x0E000000 */
N#define DMA1_CSELR_CH7_USART7_TX        DMA1_CSELR_CH7_USART7_TX_Msk           /*!< Remap USART7 Tx on DMA1 channel 7 */
N#define DMA1_CSELR_CH7_USART8_TX_Pos    (24U)                                  
N#define DMA1_CSELR_CH7_USART8_TX_Msk    (0xFU << DMA1_CSELR_CH7_USART8_TX_Pos) /*!< 0x0F000000 */
N#define DMA1_CSELR_CH7_USART8_TX        DMA1_CSELR_CH7_USART8_TX_Msk           /*!< Remap USART8 Tx on DMA1 channel 7 */
N
N/******************  Bit definition for DMA2_CSELR register  ********************/
N#define DMA2_CSELR_DEFAULT              (0x00000000U)                          /*!< Default remap position for DMA2 */
N#define DMA2_CSELR_CH1_I2C2_TX_Pos      (1U)                                   
N#define DMA2_CSELR_CH1_I2C2_TX_Msk      (0x1U << DMA2_CSELR_CH1_I2C2_TX_Pos)   /*!< 0x00000002 */
N#define DMA2_CSELR_CH1_I2C2_TX          DMA2_CSELR_CH1_I2C2_TX_Msk             /*!< Remap I2C2 TX on DMA2 channel 1 */
N#define DMA2_CSELR_CH1_USART1_TX_Pos    (3U)                                   
N#define DMA2_CSELR_CH1_USART1_TX_Msk    (0x1U << DMA2_CSELR_CH1_USART1_TX_Pos) /*!< 0x00000008 */
N#define DMA2_CSELR_CH1_USART1_TX        DMA2_CSELR_CH1_USART1_TX_Msk           /*!< Remap USART1 Tx on DMA2 channel 1 */
N#define DMA2_CSELR_CH1_USART2_TX_Pos    (0U)                                   
N#define DMA2_CSELR_CH1_USART2_TX_Msk    (0x9U << DMA2_CSELR_CH1_USART2_TX_Pos) /*!< 0x00000009 */
N#define DMA2_CSELR_CH1_USART2_TX        DMA2_CSELR_CH1_USART2_TX_Msk           /*!< Remap USART2 Tx on DMA2 channel 1 */
N#define DMA2_CSELR_CH1_USART3_TX_Pos    (1U)                                   
N#define DMA2_CSELR_CH1_USART3_TX_Msk    (0x5U << DMA2_CSELR_CH1_USART3_TX_Pos) /*!< 0x0000000A */
N#define DMA2_CSELR_CH1_USART3_TX        DMA2_CSELR_CH1_USART3_TX_Msk           /*!< Remap USART3 Tx on DMA2 channel 1 */
N#define DMA2_CSELR_CH1_USART4_TX_Pos    (0U)                                   
N#define DMA2_CSELR_CH1_USART4_TX_Msk    (0xBU << DMA2_CSELR_CH1_USART4_TX_Pos) /*!< 0x0000000B */
N#define DMA2_CSELR_CH1_USART4_TX        DMA2_CSELR_CH1_USART4_TX_Msk           /*!< Remap USART4 Tx on DMA2 channel 1 */
N#define DMA2_CSELR_CH1_USART5_TX_Pos    (2U)                                   
N#define DMA2_CSELR_CH1_USART5_TX_Msk    (0x3U << DMA2_CSELR_CH1_USART5_TX_Pos) /*!< 0x0000000C */
N#define DMA2_CSELR_CH1_USART5_TX        DMA2_CSELR_CH1_USART5_TX_Msk           /*!< Remap USART5 Tx on DMA2 channel 1 */
N#define DMA2_CSELR_CH1_USART6_TX_Pos    (0U)                                   
N#define DMA2_CSELR_CH1_USART6_TX_Msk    (0xDU << DMA2_CSELR_CH1_USART6_TX_Pos) /*!< 0x0000000D */
N#define DMA2_CSELR_CH1_USART6_TX        DMA2_CSELR_CH1_USART6_TX_Msk           /*!< Remap USART6 Tx on DMA2 channel 1 */
N#define DMA2_CSELR_CH1_USART7_TX_Pos    (1U)                                   
N#define DMA2_CSELR_CH1_USART7_TX_Msk    (0x7U << DMA2_CSELR_CH1_USART7_TX_Pos) /*!< 0x0000000E */
N#define DMA2_CSELR_CH1_USART7_TX        DMA2_CSELR_CH1_USART7_TX_Msk           /*!< Remap USART7 Tx on DMA2 channel 1 */
N#define DMA2_CSELR_CH1_USART8_TX_Pos    (0U)                                   
N#define DMA2_CSELR_CH1_USART8_TX_Msk    (0xFU << DMA2_CSELR_CH1_USART8_TX_Pos) /*!< 0x0000000F */
N#define DMA2_CSELR_CH1_USART8_TX        DMA2_CSELR_CH1_USART8_TX_Msk           /*!< Remap USART8 Tx on DMA2 channel 1 */
N#define DMA2_CSELR_CH2_I2C2_RX_Pos      (5U)                                   
N#define DMA2_CSELR_CH2_I2C2_RX_Msk      (0x1U << DMA2_CSELR_CH2_I2C2_RX_Pos)   /*!< 0x00000020 */
N#define DMA2_CSELR_CH2_I2C2_RX          DMA2_CSELR_CH2_I2C2_RX_Msk             /*!< Remap I2C2 Rx on DMA2 channel 2 */
N#define DMA2_CSELR_CH2_USART1_RX_Pos    (7U)                                   
N#define DMA2_CSELR_CH2_USART1_RX_Msk    (0x1U << DMA2_CSELR_CH2_USART1_RX_Pos) /*!< 0x00000080 */
N#define DMA2_CSELR_CH2_USART1_RX        DMA2_CSELR_CH2_USART1_RX_Msk           /*!< Remap USART1 Rx on DMA2 channel 2 */
N#define DMA2_CSELR_CH2_USART2_RX_Pos    (4U)                                   
N#define DMA2_CSELR_CH2_USART2_RX_Msk    (0x9U << DMA2_CSELR_CH2_USART2_RX_Pos) /*!< 0x00000090 */
N#define DMA2_CSELR_CH2_USART2_RX        DMA2_CSELR_CH2_USART2_RX_Msk           /*!< Remap USART2 Rx on DMA2 channel 2 */
N#define DMA2_CSELR_CH2_USART3_RX_Pos    (5U)                                   
N#define DMA2_CSELR_CH2_USART3_RX_Msk    (0x5U << DMA2_CSELR_CH2_USART3_RX_Pos) /*!< 0x000000A0 */
N#define DMA2_CSELR_CH2_USART3_RX        DMA2_CSELR_CH2_USART3_RX_Msk           /*!< Remap USART3 Rx on DMA2 channel 2 */
N#define DMA2_CSELR_CH2_USART4_RX_Pos    (4U)                                   
N#define DMA2_CSELR_CH2_USART4_RX_Msk    (0xBU << DMA2_CSELR_CH2_USART4_RX_Pos) /*!< 0x000000B0 */
N#define DMA2_CSELR_CH2_USART4_RX        DMA2_CSELR_CH2_USART4_RX_Msk           /*!< Remap USART4 Rx on DMA2 channel 2 */
N#define DMA2_CSELR_CH2_USART5_RX_Pos    (6U)                                   
N#define DMA2_CSELR_CH2_USART5_RX_Msk    (0x3U << DMA2_CSELR_CH2_USART5_RX_Pos) /*!< 0x000000C0 */
N#define DMA2_CSELR_CH2_USART5_RX        DMA2_CSELR_CH2_USART5_RX_Msk           /*!< Remap USART5 Rx on DMA2 channel 2 */
N#define DMA2_CSELR_CH2_USART6_RX_Pos    (4U)                                   
N#define DMA2_CSELR_CH2_USART6_RX_Msk    (0xDU << DMA2_CSELR_CH2_USART6_RX_Pos) /*!< 0x000000D0 */
N#define DMA2_CSELR_CH2_USART6_RX        DMA2_CSELR_CH2_USART6_RX_Msk           /*!< Remap USART6 Rx on DMA2 channel 2 */
N#define DMA2_CSELR_CH2_USART7_RX_Pos    (5U)                                   
N#define DMA2_CSELR_CH2_USART7_RX_Msk    (0x7U << DMA2_CSELR_CH2_USART7_RX_Pos) /*!< 0x000000E0 */
N#define DMA2_CSELR_CH2_USART7_RX        DMA2_CSELR_CH2_USART7_RX_Msk           /*!< Remap USART7 Rx on DMA2 channel 2 */
N#define DMA2_CSELR_CH2_USART8_RX_Pos    (4U)                                   
N#define DMA2_CSELR_CH2_USART8_RX_Msk    (0xFU << DMA2_CSELR_CH2_USART8_RX_Pos) /*!< 0x000000F0 */
N#define DMA2_CSELR_CH2_USART8_RX        DMA2_CSELR_CH2_USART8_RX_Msk           /*!< Remap USART8 Rx on DMA2 channel 2 */
N#define DMA2_CSELR_CH3_TIM6_UP_Pos      (8U)                                   
N#define DMA2_CSELR_CH3_TIM6_UP_Msk      (0x1U << DMA2_CSELR_CH3_TIM6_UP_Pos)   /*!< 0x00000100 */
N#define DMA2_CSELR_CH3_TIM6_UP          DMA2_CSELR_CH3_TIM6_UP_Msk             /*!< Remap TIM6 up on DMA2 channel 3 */
N#define DMA2_CSELR_CH3_DAC_CH1_Pos      (8U)                                   
N#define DMA2_CSELR_CH3_DAC_CH1_Msk      (0x1U << DMA2_CSELR_CH3_DAC_CH1_Pos)   /*!< 0x00000100 */
N#define DMA2_CSELR_CH3_DAC_CH1          DMA2_CSELR_CH3_DAC_CH1_Msk             /*!< Remap DAC channel 1 on DMA2 channel 3 */
N#define DMA2_CSELR_CH3_SPI1_RX_Pos      (8U)                                   
N#define DMA2_CSELR_CH3_SPI1_RX_Msk      (0x3U << DMA2_CSELR_CH3_SPI1_RX_Pos)   /*!< 0x00000300 */
N#define DMA2_CSELR_CH3_SPI1_RX          DMA2_CSELR_CH3_SPI1_RX_Msk             /*!< Remap SPI1 Rx on DMA2 channel 3 */
N#define DMA2_CSELR_CH3_USART1_RX_Pos    (11U)                                  
N#define DMA2_CSELR_CH3_USART1_RX_Msk    (0x1U << DMA2_CSELR_CH3_USART1_RX_Pos) /*!< 0x00000800 */
N#define DMA2_CSELR_CH3_USART1_RX        DMA2_CSELR_CH3_USART1_RX_Msk           /*!< Remap USART1 Rx on DMA2 channel 3 */
N#define DMA2_CSELR_CH3_USART2_RX_Pos    (8U)                                   
N#define DMA2_CSELR_CH3_USART2_RX_Msk    (0x9U << DMA2_CSELR_CH3_USART2_RX_Pos) /*!< 0x00000900 */
N#define DMA2_CSELR_CH3_USART2_RX        DMA2_CSELR_CH3_USART2_RX_Msk           /*!< Remap USART2 Rx on DMA2 channel 3 */
N#define DMA2_CSELR_CH3_USART3_RX_Pos    (9U)                                   
N#define DMA2_CSELR_CH3_USART3_RX_Msk    (0x5U << DMA2_CSELR_CH3_USART3_RX_Pos) /*!< 0x00000A00 */
N#define DMA2_CSELR_CH3_USART3_RX        DMA2_CSELR_CH3_USART3_RX_Msk           /*!< Remap USART3 Rx on DMA2 channel 3 */
N#define DMA2_CSELR_CH3_USART4_RX_Pos    (8U)                                   
N#define DMA2_CSELR_CH3_USART4_RX_Msk    (0xBU << DMA2_CSELR_CH3_USART4_RX_Pos) /*!< 0x00000B00 */
N#define DMA2_CSELR_CH3_USART4_RX        DMA2_CSELR_CH3_USART4_RX_Msk           /*!< Remap USART4 Rx on DMA2 channel 3 */
N#define DMA2_CSELR_CH3_USART5_RX_Pos    (10U)                                  
N#define DMA2_CSELR_CH3_USART5_RX_Msk    (0x3U << DMA2_CSELR_CH3_USART5_RX_Pos) /*!< 0x00000C00 */
N#define DMA2_CSELR_CH3_USART5_RX        DMA2_CSELR_CH3_USART5_RX_Msk           /*!< Remap USART5 Rx on DMA2 channel 3 */
N#define DMA2_CSELR_CH3_USART6_RX_Pos    (8U)                                   
N#define DMA2_CSELR_CH3_USART6_RX_Msk    (0xDU << DMA2_CSELR_CH3_USART6_RX_Pos) /*!< 0x00000D00 */
N#define DMA2_CSELR_CH3_USART6_RX        DMA2_CSELR_CH3_USART6_RX_Msk           /*!< Remap USART6 Rx on DMA2 channel 3 */
N#define DMA2_CSELR_CH3_USART7_RX_Pos    (9U)                                   
N#define DMA2_CSELR_CH3_USART7_RX_Msk    (0x7U << DMA2_CSELR_CH3_USART7_RX_Pos) /*!< 0x00000E00 */
N#define DMA2_CSELR_CH3_USART7_RX        DMA2_CSELR_CH3_USART7_RX_Msk           /*!< Remap USART7 Rx on DMA2 channel 3 */
N#define DMA2_CSELR_CH3_USART8_RX_Pos    (8U)                                   
N#define DMA2_CSELR_CH3_USART8_RX_Msk    (0xFU << DMA2_CSELR_CH3_USART8_RX_Pos) /*!< 0x00000F00 */
N#define DMA2_CSELR_CH3_USART8_RX        DMA2_CSELR_CH3_USART8_RX_Msk           /*!< Remap USART8 Rx on DMA2 channel 3 */
N#define DMA2_CSELR_CH4_TIM7_UP_Pos      (12U)                                  
N#define DMA2_CSELR_CH4_TIM7_UP_Msk      (0x1U << DMA2_CSELR_CH4_TIM7_UP_Pos)   /*!< 0x00001000 */
N#define DMA2_CSELR_CH4_TIM7_UP          DMA2_CSELR_CH4_TIM7_UP_Msk             /*!< Remap TIM7 up on DMA2 channel 4 */
N#define DMA2_CSELR_CH4_DAC_CH2_Pos      (12U)                                  
N#define DMA2_CSELR_CH4_DAC_CH2_Msk      (0x1U << DMA2_CSELR_CH4_DAC_CH2_Pos)   /*!< 0x00001000 */
N#define DMA2_CSELR_CH4_DAC_CH2          DMA2_CSELR_CH4_DAC_CH2_Msk             /*!< Remap DAC channel 2 on DMA2 channel 4 */
N#define DMA2_CSELR_CH4_SPI1_TX_Pos      (12U)                                  
N#define DMA2_CSELR_CH4_SPI1_TX_Msk      (0x3U << DMA2_CSELR_CH4_SPI1_TX_Pos)   /*!< 0x00003000 */
N#define DMA2_CSELR_CH4_SPI1_TX          DMA2_CSELR_CH4_SPI1_TX_Msk             /*!< Remap SPI1 Tx on DMA2 channel 4 */
N#define DMA2_CSELR_CH4_USART1_TX_Pos    (15U)                                  
N#define DMA2_CSELR_CH4_USART1_TX_Msk    (0x1U << DMA2_CSELR_CH4_USART1_TX_Pos) /*!< 0x00008000 */
N#define DMA2_CSELR_CH4_USART1_TX        DMA2_CSELR_CH4_USART1_TX_Msk           /*!< Remap USART1 Tx on DMA2 channel 4 */
N#define DMA2_CSELR_CH4_USART2_TX_Pos    (12U)                                  
N#define DMA2_CSELR_CH4_USART2_TX_Msk    (0x9U << DMA2_CSELR_CH4_USART2_TX_Pos) /*!< 0x00009000 */
N#define DMA2_CSELR_CH4_USART2_TX        DMA2_CSELR_CH4_USART2_TX_Msk           /*!< Remap USART2 Tx on DMA2 channel 4 */
N#define DMA2_CSELR_CH4_USART3_TX_Pos    (13U)                                  
N#define DMA2_CSELR_CH4_USART3_TX_Msk    (0x5U << DMA2_CSELR_CH4_USART3_TX_Pos) /*!< 0x0000A000 */
N#define DMA2_CSELR_CH4_USART3_TX        DMA2_CSELR_CH4_USART3_TX_Msk           /*!< Remap USART3 Tx on DMA2 channel 4 */
N#define DMA2_CSELR_CH4_USART4_TX_Pos    (12U)                                  
N#define DMA2_CSELR_CH4_USART4_TX_Msk    (0xBU << DMA2_CSELR_CH4_USART4_TX_Pos) /*!< 0x0000B000 */
N#define DMA2_CSELR_CH4_USART4_TX        DMA2_CSELR_CH4_USART4_TX_Msk           /*!< Remap USART4 Tx on DMA2 channel 4 */
N#define DMA2_CSELR_CH4_USART5_TX_Pos    (14U)                                  
N#define DMA2_CSELR_CH4_USART5_TX_Msk    (0x3U << DMA2_CSELR_CH4_USART5_TX_Pos) /*!< 0x0000C000 */
N#define DMA2_CSELR_CH4_USART5_TX        DMA2_CSELR_CH4_USART5_TX_Msk           /*!< Remap USART5 Tx on DMA2 channel 4 */
N#define DMA2_CSELR_CH4_USART6_TX_Pos    (12U)                                  
N#define DMA2_CSELR_CH4_USART6_TX_Msk    (0xDU << DMA2_CSELR_CH4_USART6_TX_Pos) /*!< 0x0000D000 */
N#define DMA2_CSELR_CH4_USART6_TX        DMA2_CSELR_CH4_USART6_TX_Msk           /*!< Remap USART6 Tx on DMA2 channel 4 */
N#define DMA2_CSELR_CH4_USART7_TX_Pos    (13U)                                  
N#define DMA2_CSELR_CH4_USART7_TX_Msk    (0x7U << DMA2_CSELR_CH4_USART7_TX_Pos) /*!< 0x0000E000 */
N#define DMA2_CSELR_CH4_USART7_TX        DMA2_CSELR_CH4_USART7_TX_Msk           /*!< Remap USART7 Tx on DMA2 channel 4 */
N#define DMA2_CSELR_CH4_USART8_TX_Pos    (12U)                                  
N#define DMA2_CSELR_CH4_USART8_TX_Msk    (0xFU << DMA2_CSELR_CH4_USART8_TX_Pos) /*!< 0x0000F000 */
N#define DMA2_CSELR_CH4_USART8_TX        DMA2_CSELR_CH4_USART8_TX_Msk           /*!< Remap USART8 Tx on DMA2 channel 4 */
N#define DMA2_CSELR_CH5_ADC_Pos          (16U)                                  
N#define DMA2_CSELR_CH5_ADC_Msk          (0x1U << DMA2_CSELR_CH5_ADC_Pos)       /*!< 0x00010000 */
N#define DMA2_CSELR_CH5_ADC              DMA2_CSELR_CH5_ADC_Msk                 /*!< Remap ADC on DMA2 channel 5 */
N#define DMA2_CSELR_CH5_USART1_TX_Pos    (19U)                                  
N#define DMA2_CSELR_CH5_USART1_TX_Msk    (0x1U << DMA2_CSELR_CH5_USART1_TX_Pos) /*!< 0x00080000 */
N#define DMA2_CSELR_CH5_USART1_TX        DMA2_CSELR_CH5_USART1_TX_Msk           /*!< Remap USART1 Tx on DMA2 channel 5 */
N#define DMA2_CSELR_CH5_USART2_TX_Pos    (16U)                                  
N#define DMA2_CSELR_CH5_USART2_TX_Msk    (0x9U << DMA2_CSELR_CH5_USART2_TX_Pos) /*!< 0x00090000 */
N#define DMA2_CSELR_CH5_USART2_TX        DMA2_CSELR_CH5_USART2_TX_Msk           /*!< Remap USART2 Tx on DMA2 channel 5 */
N#define DMA2_CSELR_CH5_USART3_TX_Pos    (17U)                                  
N#define DMA2_CSELR_CH5_USART3_TX_Msk    (0x5U << DMA2_CSELR_CH5_USART3_TX_Pos) /*!< 0x000A0000 */
N#define DMA2_CSELR_CH5_USART3_TX        DMA2_CSELR_CH5_USART3_TX_Msk           /*!< Remap USART3 Tx on DMA2 channel 5 */
N#define DMA2_CSELR_CH5_USART4_TX_Pos    (16U)                                  
N#define DMA2_CSELR_CH5_USART4_TX_Msk    (0xBU << DMA2_CSELR_CH5_USART4_TX_Pos) /*!< 0x000B0000 */
N#define DMA2_CSELR_CH5_USART4_TX        DMA2_CSELR_CH5_USART4_TX_Msk           /*!< Remap USART4 Tx on DMA2 channel 5 */
N#define DMA2_CSELR_CH5_USART5_TX_Pos    (18U)                                  
N#define DMA2_CSELR_CH5_USART5_TX_Msk    (0x3U << DMA2_CSELR_CH5_USART5_TX_Pos) /*!< 0x000C0000 */
N#define DMA2_CSELR_CH5_USART5_TX        DMA2_CSELR_CH5_USART5_TX_Msk           /*!< Remap USART5 Tx on DMA2 channel 5 */
N#define DMA2_CSELR_CH5_USART6_TX_Pos    (16U)                                  
N#define DMA2_CSELR_CH5_USART6_TX_Msk    (0xDU << DMA2_CSELR_CH5_USART6_TX_Pos) /*!< 0x000D0000 */
N#define DMA2_CSELR_CH5_USART6_TX        DMA2_CSELR_CH5_USART6_TX_Msk           /*!< Remap USART6 Tx on DMA2 channel 5 */
N#define DMA2_CSELR_CH5_USART7_TX_Pos    (17U)                                  
N#define DMA2_CSELR_CH5_USART7_TX_Msk    (0x7U << DMA2_CSELR_CH5_USART7_TX_Pos) /*!< 0x000E0000 */
N#define DMA2_CSELR_CH5_USART7_TX        DMA2_CSELR_CH5_USART7_TX_Msk           /*!< Remap USART7 Tx on DMA2 channel 5 */
N#define DMA2_CSELR_CH5_USART8_TX_Pos    (16U)                                  
N#define DMA2_CSELR_CH5_USART8_TX_Msk    (0xFU << DMA2_CSELR_CH5_USART8_TX_Pos) /*!< 0x000F0000 */
N#define DMA2_CSELR_CH5_USART8_TX        DMA2_CSELR_CH5_USART8_TX_Msk           /*!< Remap USART8 Tx on DMA2 channel 5 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                 External Interrupt/Event Controller (EXTI)                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define EXTI_IMR_MR0_Pos          (0U)                                         
N#define EXTI_IMR_MR0_Msk          (0x1U << EXTI_IMR_MR0_Pos)                   /*!< 0x00000001 */
N#define EXTI_IMR_MR0              EXTI_IMR_MR0_Msk                             /*!< Interrupt Mask on line 0  */
N#define EXTI_IMR_MR1_Pos          (1U)                                         
N#define EXTI_IMR_MR1_Msk          (0x1U << EXTI_IMR_MR1_Pos)                   /*!< 0x00000002 */
N#define EXTI_IMR_MR1              EXTI_IMR_MR1_Msk                             /*!< Interrupt Mask on line 1  */
N#define EXTI_IMR_MR2_Pos          (2U)                                         
N#define EXTI_IMR_MR2_Msk          (0x1U << EXTI_IMR_MR2_Pos)                   /*!< 0x00000004 */
N#define EXTI_IMR_MR2              EXTI_IMR_MR2_Msk                             /*!< Interrupt Mask on line 2  */
N#define EXTI_IMR_MR3_Pos          (3U)                                         
N#define EXTI_IMR_MR3_Msk          (0x1U << EXTI_IMR_MR3_Pos)                   /*!< 0x00000008 */
N#define EXTI_IMR_MR3              EXTI_IMR_MR3_Msk                             /*!< Interrupt Mask on line 3  */
N#define EXTI_IMR_MR4_Pos          (4U)                                         
N#define EXTI_IMR_MR4_Msk          (0x1U << EXTI_IMR_MR4_Pos)                   /*!< 0x00000010 */
N#define EXTI_IMR_MR4              EXTI_IMR_MR4_Msk                             /*!< Interrupt Mask on line 4  */
N#define EXTI_IMR_MR5_Pos          (5U)                                         
N#define EXTI_IMR_MR5_Msk          (0x1U << EXTI_IMR_MR5_Pos)                   /*!< 0x00000020 */
N#define EXTI_IMR_MR5              EXTI_IMR_MR5_Msk                             /*!< Interrupt Mask on line 5  */
N#define EXTI_IMR_MR6_Pos          (6U)                                         
N#define EXTI_IMR_MR6_Msk          (0x1U << EXTI_IMR_MR6_Pos)                   /*!< 0x00000040 */
N#define EXTI_IMR_MR6              EXTI_IMR_MR6_Msk                             /*!< Interrupt Mask on line 6  */
N#define EXTI_IMR_MR7_Pos          (7U)                                         
N#define EXTI_IMR_MR7_Msk          (0x1U << EXTI_IMR_MR7_Pos)                   /*!< 0x00000080 */
N#define EXTI_IMR_MR7              EXTI_IMR_MR7_Msk                             /*!< Interrupt Mask on line 7  */
N#define EXTI_IMR_MR8_Pos          (8U)                                         
N#define EXTI_IMR_MR8_Msk          (0x1U << EXTI_IMR_MR8_Pos)                   /*!< 0x00000100 */
N#define EXTI_IMR_MR8              EXTI_IMR_MR8_Msk                             /*!< Interrupt Mask on line 8  */
N#define EXTI_IMR_MR9_Pos          (9U)                                         
N#define EXTI_IMR_MR9_Msk          (0x1U << EXTI_IMR_MR9_Pos)                   /*!< 0x00000200 */
N#define EXTI_IMR_MR9              EXTI_IMR_MR9_Msk                             /*!< Interrupt Mask on line 9  */
N#define EXTI_IMR_MR10_Pos         (10U)                                        
N#define EXTI_IMR_MR10_Msk         (0x1U << EXTI_IMR_MR10_Pos)                  /*!< 0x00000400 */
N#define EXTI_IMR_MR10             EXTI_IMR_MR10_Msk                            /*!< Interrupt Mask on line 10 */
N#define EXTI_IMR_MR11_Pos         (11U)                                        
N#define EXTI_IMR_MR11_Msk         (0x1U << EXTI_IMR_MR11_Pos)                  /*!< 0x00000800 */
N#define EXTI_IMR_MR11             EXTI_IMR_MR11_Msk                            /*!< Interrupt Mask on line 11 */
N#define EXTI_IMR_MR12_Pos         (12U)                                        
N#define EXTI_IMR_MR12_Msk         (0x1U << EXTI_IMR_MR12_Pos)                  /*!< 0x00001000 */
N#define EXTI_IMR_MR12             EXTI_IMR_MR12_Msk                            /*!< Interrupt Mask on line 12 */
N#define EXTI_IMR_MR13_Pos         (13U)                                        
N#define EXTI_IMR_MR13_Msk         (0x1U << EXTI_IMR_MR13_Pos)                  /*!< 0x00002000 */
N#define EXTI_IMR_MR13             EXTI_IMR_MR13_Msk                            /*!< Interrupt Mask on line 13 */
N#define EXTI_IMR_MR14_Pos         (14U)                                        
N#define EXTI_IMR_MR14_Msk         (0x1U << EXTI_IMR_MR14_Pos)                  /*!< 0x00004000 */
N#define EXTI_IMR_MR14             EXTI_IMR_MR14_Msk                            /*!< Interrupt Mask on line 14 */
N#define EXTI_IMR_MR15_Pos         (15U)                                        
N#define EXTI_IMR_MR15_Msk         (0x1U << EXTI_IMR_MR15_Pos)                  /*!< 0x00008000 */
N#define EXTI_IMR_MR15             EXTI_IMR_MR15_Msk                            /*!< Interrupt Mask on line 15 */
N#define EXTI_IMR_MR16_Pos         (16U)                                        
N#define EXTI_IMR_MR16_Msk         (0x1U << EXTI_IMR_MR16_Pos)                  /*!< 0x00010000 */
N#define EXTI_IMR_MR16             EXTI_IMR_MR16_Msk                            /*!< Interrupt Mask on line 16 */
N#define EXTI_IMR_MR17_Pos         (17U)                                        
N#define EXTI_IMR_MR17_Msk         (0x1U << EXTI_IMR_MR17_Pos)                  /*!< 0x00020000 */
N#define EXTI_IMR_MR17             EXTI_IMR_MR17_Msk                            /*!< Interrupt Mask on line 17 */
N#define EXTI_IMR_MR18_Pos         (18U)                                        
N#define EXTI_IMR_MR18_Msk         (0x1U << EXTI_IMR_MR18_Pos)                  /*!< 0x00040000 */
N#define EXTI_IMR_MR18             EXTI_IMR_MR18_Msk                            /*!< Interrupt Mask on line 18 */
N#define EXTI_IMR_MR19_Pos         (19U)                                        
N#define EXTI_IMR_MR19_Msk         (0x1U << EXTI_IMR_MR19_Pos)                  /*!< 0x00080000 */
N#define EXTI_IMR_MR19             EXTI_IMR_MR19_Msk                            /*!< Interrupt Mask on line 19 */
N#define EXTI_IMR_MR20_Pos         (20U)                                        
N#define EXTI_IMR_MR20_Msk         (0x1U << EXTI_IMR_MR20_Pos)                  /*!< 0x00100000 */
N#define EXTI_IMR_MR20             EXTI_IMR_MR20_Msk                            /*!< Interrupt Mask on line 20 */
N#define EXTI_IMR_MR21_Pos         (21U)                                        
N#define EXTI_IMR_MR21_Msk         (0x1U << EXTI_IMR_MR21_Pos)                  /*!< 0x00200000 */
N#define EXTI_IMR_MR21             EXTI_IMR_MR21_Msk                            /*!< Interrupt Mask on line 21 */
N#define EXTI_IMR_MR22_Pos         (22U)                                        
N#define EXTI_IMR_MR22_Msk         (0x1U << EXTI_IMR_MR22_Pos)                  /*!< 0x00400000 */
N#define EXTI_IMR_MR22             EXTI_IMR_MR22_Msk                            /*!< Interrupt Mask on line 22 */
N#define EXTI_IMR_MR23_Pos         (23U)                                        
N#define EXTI_IMR_MR23_Msk         (0x1U << EXTI_IMR_MR23_Pos)                  /*!< 0x00800000 */
N#define EXTI_IMR_MR23             EXTI_IMR_MR23_Msk                            /*!< Interrupt Mask on line 23 */
N#define EXTI_IMR_MR25_Pos         (25U)                                        
N#define EXTI_IMR_MR25_Msk         (0x1U << EXTI_IMR_MR25_Pos)                  /*!< 0x02000000 */
N#define EXTI_IMR_MR25             EXTI_IMR_MR25_Msk                            /*!< Interrupt Mask on line 25 */
N#define EXTI_IMR_MR26_Pos         (26U)                                        
N#define EXTI_IMR_MR26_Msk         (0x1U << EXTI_IMR_MR26_Pos)                  /*!< 0x04000000 */
N#define EXTI_IMR_MR26             EXTI_IMR_MR26_Msk                            /*!< Interrupt Mask on line 26 */
N#define EXTI_IMR_MR27_Pos         (27U)                                        
N#define EXTI_IMR_MR27_Msk         (0x1U << EXTI_IMR_MR27_Pos)                  /*!< 0x08000000 */
N#define EXTI_IMR_MR27             EXTI_IMR_MR27_Msk                            /*!< Interrupt Mask on line 27 */
N#define EXTI_IMR_MR28_Pos         (28U)                                        
N#define EXTI_IMR_MR28_Msk         (0x1U << EXTI_IMR_MR28_Pos)                  /*!< 0x10000000 */
N#define EXTI_IMR_MR28             EXTI_IMR_MR28_Msk                            /*!< Interrupt Mask on line 28 */
N#define EXTI_IMR_MR31_Pos         (31U)                                        
N#define EXTI_IMR_MR31_Msk         (0x1U << EXTI_IMR_MR31_Pos)                  /*!< 0x80000000 */
N#define EXTI_IMR_MR31             EXTI_IMR_MR31_Msk                            /*!< Interrupt Mask on line 31 */
N
N/* References Defines */
N#define  EXTI_IMR_IM0 EXTI_IMR_MR0
N#define  EXTI_IMR_IM1 EXTI_IMR_MR1
N#define  EXTI_IMR_IM2 EXTI_IMR_MR2
N#define  EXTI_IMR_IM3 EXTI_IMR_MR3
N#define  EXTI_IMR_IM4 EXTI_IMR_MR4
N#define  EXTI_IMR_IM5 EXTI_IMR_MR5
N#define  EXTI_IMR_IM6 EXTI_IMR_MR6
N#define  EXTI_IMR_IM7 EXTI_IMR_MR7
N#define  EXTI_IMR_IM8 EXTI_IMR_MR8
N#define  EXTI_IMR_IM9 EXTI_IMR_MR9
N#define  EXTI_IMR_IM10 EXTI_IMR_MR10
N#define  EXTI_IMR_IM11 EXTI_IMR_MR11
N#define  EXTI_IMR_IM12 EXTI_IMR_MR12
N#define  EXTI_IMR_IM13 EXTI_IMR_MR13
N#define  EXTI_IMR_IM14 EXTI_IMR_MR14
N#define  EXTI_IMR_IM15 EXTI_IMR_MR15
N#define  EXTI_IMR_IM16 EXTI_IMR_MR16
N#define  EXTI_IMR_IM17 EXTI_IMR_MR17
N#define  EXTI_IMR_IM18 EXTI_IMR_MR18
N#define  EXTI_IMR_IM19 EXTI_IMR_MR19
N#define  EXTI_IMR_IM20 EXTI_IMR_MR20
N#define  EXTI_IMR_IM21 EXTI_IMR_MR21
N#define  EXTI_IMR_IM22 EXTI_IMR_MR22
N#define  EXTI_IMR_IM23 EXTI_IMR_MR23
N#define  EXTI_IMR_IM25 EXTI_IMR_MR25
N#define  EXTI_IMR_IM26 EXTI_IMR_MR26
N#define  EXTI_IMR_IM27 EXTI_IMR_MR27
N#define  EXTI_IMR_IM28 EXTI_IMR_MR28 
N#define  EXTI_IMR_IM31 EXTI_IMR_MR31
N
N#define EXTI_IMR_IM_Pos           (0U)                                         
N#define EXTI_IMR_IM_Msk           (0x9EFFFFFFU << EXTI_IMR_IM_Pos)             /*!< 0x9EFFFFFF */
N#define EXTI_IMR_IM               EXTI_IMR_IM_Msk                              /*!< Interrupt Mask All */
N
N
N/******************  Bit definition for EXTI_EMR register  ********************/
N#define EXTI_EMR_MR0_Pos          (0U)                                         
N#define EXTI_EMR_MR0_Msk          (0x1U << EXTI_EMR_MR0_Pos)                   /*!< 0x00000001 */
N#define EXTI_EMR_MR0              EXTI_EMR_MR0_Msk                             /*!< Event Mask on line 0  */
N#define EXTI_EMR_MR1_Pos          (1U)                                         
N#define EXTI_EMR_MR1_Msk          (0x1U << EXTI_EMR_MR1_Pos)                   /*!< 0x00000002 */
N#define EXTI_EMR_MR1              EXTI_EMR_MR1_Msk                             /*!< Event Mask on line 1  */
N#define EXTI_EMR_MR2_Pos          (2U)                                         
N#define EXTI_EMR_MR2_Msk          (0x1U << EXTI_EMR_MR2_Pos)                   /*!< 0x00000004 */
N#define EXTI_EMR_MR2              EXTI_EMR_MR2_Msk                             /*!< Event Mask on line 2  */
N#define EXTI_EMR_MR3_Pos          (3U)                                         
N#define EXTI_EMR_MR3_Msk          (0x1U << EXTI_EMR_MR3_Pos)                   /*!< 0x00000008 */
N#define EXTI_EMR_MR3              EXTI_EMR_MR3_Msk                             /*!< Event Mask on line 3  */
N#define EXTI_EMR_MR4_Pos          (4U)                                         
N#define EXTI_EMR_MR4_Msk          (0x1U << EXTI_EMR_MR4_Pos)                   /*!< 0x00000010 */
N#define EXTI_EMR_MR4              EXTI_EMR_MR4_Msk                             /*!< Event Mask on line 4  */
N#define EXTI_EMR_MR5_Pos          (5U)                                         
N#define EXTI_EMR_MR5_Msk          (0x1U << EXTI_EMR_MR5_Pos)                   /*!< 0x00000020 */
N#define EXTI_EMR_MR5              EXTI_EMR_MR5_Msk                             /*!< Event Mask on line 5  */
N#define EXTI_EMR_MR6_Pos          (6U)                                         
N#define EXTI_EMR_MR6_Msk          (0x1U << EXTI_EMR_MR6_Pos)                   /*!< 0x00000040 */
N#define EXTI_EMR_MR6              EXTI_EMR_MR6_Msk                             /*!< Event Mask on line 6  */
N#define EXTI_EMR_MR7_Pos          (7U)                                         
N#define EXTI_EMR_MR7_Msk          (0x1U << EXTI_EMR_MR7_Pos)                   /*!< 0x00000080 */
N#define EXTI_EMR_MR7              EXTI_EMR_MR7_Msk                             /*!< Event Mask on line 7  */
N#define EXTI_EMR_MR8_Pos          (8U)                                         
N#define EXTI_EMR_MR8_Msk          (0x1U << EXTI_EMR_MR8_Pos)                   /*!< 0x00000100 */
N#define EXTI_EMR_MR8              EXTI_EMR_MR8_Msk                             /*!< Event Mask on line 8  */
N#define EXTI_EMR_MR9_Pos          (9U)                                         
N#define EXTI_EMR_MR9_Msk          (0x1U << EXTI_EMR_MR9_Pos)                   /*!< 0x00000200 */
N#define EXTI_EMR_MR9              EXTI_EMR_MR9_Msk                             /*!< Event Mask on line 9  */
N#define EXTI_EMR_MR10_Pos         (10U)                                        
N#define EXTI_EMR_MR10_Msk         (0x1U << EXTI_EMR_MR10_Pos)                  /*!< 0x00000400 */
N#define EXTI_EMR_MR10             EXTI_EMR_MR10_Msk                            /*!< Event Mask on line 10 */
N#define EXTI_EMR_MR11_Pos         (11U)                                        
N#define EXTI_EMR_MR11_Msk         (0x1U << EXTI_EMR_MR11_Pos)                  /*!< 0x00000800 */
N#define EXTI_EMR_MR11             EXTI_EMR_MR11_Msk                            /*!< Event Mask on line 11 */
N#define EXTI_EMR_MR12_Pos         (12U)                                        
N#define EXTI_EMR_MR12_Msk         (0x1U << EXTI_EMR_MR12_Pos)                  /*!< 0x00001000 */
N#define EXTI_EMR_MR12             EXTI_EMR_MR12_Msk                            /*!< Event Mask on line 12 */
N#define EXTI_EMR_MR13_Pos         (13U)                                        
N#define EXTI_EMR_MR13_Msk         (0x1U << EXTI_EMR_MR13_Pos)                  /*!< 0x00002000 */
N#define EXTI_EMR_MR13             EXTI_EMR_MR13_Msk                            /*!< Event Mask on line 13 */
N#define EXTI_EMR_MR14_Pos         (14U)                                        
N#define EXTI_EMR_MR14_Msk         (0x1U << EXTI_EMR_MR14_Pos)                  /*!< 0x00004000 */
N#define EXTI_EMR_MR14             EXTI_EMR_MR14_Msk                            /*!< Event Mask on line 14 */
N#define EXTI_EMR_MR15_Pos         (15U)                                        
N#define EXTI_EMR_MR15_Msk         (0x1U << EXTI_EMR_MR15_Pos)                  /*!< 0x00008000 */
N#define EXTI_EMR_MR15             EXTI_EMR_MR15_Msk                            /*!< Event Mask on line 15 */
N#define EXTI_EMR_MR16_Pos         (16U)                                        
N#define EXTI_EMR_MR16_Msk         (0x1U << EXTI_EMR_MR16_Pos)                  /*!< 0x00010000 */
N#define EXTI_EMR_MR16             EXTI_EMR_MR16_Msk                            /*!< Event Mask on line 16 */
N#define EXTI_EMR_MR17_Pos         (17U)                                        
N#define EXTI_EMR_MR17_Msk         (0x1U << EXTI_EMR_MR17_Pos)                  /*!< 0x00020000 */
N#define EXTI_EMR_MR17             EXTI_EMR_MR17_Msk                            /*!< Event Mask on line 17 */
N#define EXTI_EMR_MR18_Pos         (18U)                                        
N#define EXTI_EMR_MR18_Msk         (0x1U << EXTI_EMR_MR18_Pos)                  /*!< 0x00040000 */
N#define EXTI_EMR_MR18             EXTI_EMR_MR18_Msk                            /*!< Event Mask on line 18 */
N#define EXTI_EMR_MR19_Pos         (19U)                                        
N#define EXTI_EMR_MR19_Msk         (0x1U << EXTI_EMR_MR19_Pos)                  /*!< 0x00080000 */
N#define EXTI_EMR_MR19             EXTI_EMR_MR19_Msk                            /*!< Event Mask on line 19 */
N#define EXTI_EMR_MR20_Pos         (20U)                                        
N#define EXTI_EMR_MR20_Msk         (0x1U << EXTI_EMR_MR20_Pos)                  /*!< 0x00100000 */
N#define EXTI_EMR_MR20             EXTI_EMR_MR20_Msk                            /*!< Event Mask on line 20 */
N#define EXTI_EMR_MR21_Pos         (21U)                                        
N#define EXTI_EMR_MR21_Msk         (0x1U << EXTI_EMR_MR21_Pos)                  /*!< 0x00200000 */
N#define EXTI_EMR_MR21             EXTI_EMR_MR21_Msk                            /*!< Event Mask on line 21 */
N#define EXTI_EMR_MR22_Pos         (22U)                                        
N#define EXTI_EMR_MR22_Msk         (0x1U << EXTI_EMR_MR22_Pos)                  /*!< 0x00400000 */
N#define EXTI_EMR_MR22             EXTI_EMR_MR22_Msk                            /*!< Event Mask on line 22 */
N#define EXTI_EMR_MR23_Pos         (23U)                                        
N#define EXTI_EMR_MR23_Msk         (0x1U << EXTI_EMR_MR23_Pos)                  /*!< 0x00800000 */
N#define EXTI_EMR_MR23             EXTI_EMR_MR23_Msk                            /*!< Event Mask on line 23 */
N#define EXTI_EMR_MR25_Pos         (25U)                                        
N#define EXTI_EMR_MR25_Msk         (0x1U << EXTI_EMR_MR25_Pos)                  /*!< 0x02000000 */
N#define EXTI_EMR_MR25             EXTI_EMR_MR25_Msk                            /*!< Event Mask on line 25 */
N#define EXTI_EMR_MR26_Pos         (26U)                                        
N#define EXTI_EMR_MR26_Msk         (0x1U << EXTI_EMR_MR26_Pos)                  /*!< 0x04000000 */
N#define EXTI_EMR_MR26             EXTI_EMR_MR26_Msk                            /*!< Event Mask on line 26 */
N#define EXTI_EMR_MR27_Pos         (27U)                                        
N#define EXTI_EMR_MR27_Msk         (0x1U << EXTI_EMR_MR27_Pos)                  /*!< 0x08000000 */
N#define EXTI_EMR_MR27             EXTI_EMR_MR27_Msk                            /*!< Event Mask on line 27 */
N#define EXTI_EMR_MR28_Pos         (28U)                                        
N#define EXTI_EMR_MR28_Msk         (0x1U << EXTI_EMR_MR28_Pos)                  /*!< 0x10000000 */
N#define EXTI_EMR_MR28             EXTI_EMR_MR28_Msk                            /*!< Event Mask on line 28 */
N#define EXTI_EMR_MR31_Pos         (31U)                                        
N#define EXTI_EMR_MR31_Msk         (0x1U << EXTI_EMR_MR31_Pos)                  /*!< 0x80000000 */
N#define EXTI_EMR_MR31             EXTI_EMR_MR31_Msk                            /*!< Event Mask on line 31 */
N
N/* References Defines */
N#define  EXTI_EMR_EM0 EXTI_EMR_MR0
N#define  EXTI_EMR_EM1 EXTI_EMR_MR1
N#define  EXTI_EMR_EM2 EXTI_EMR_MR2
N#define  EXTI_EMR_EM3 EXTI_EMR_MR3
N#define  EXTI_EMR_EM4 EXTI_EMR_MR4
N#define  EXTI_EMR_EM5 EXTI_EMR_MR5
N#define  EXTI_EMR_EM6 EXTI_EMR_MR6
N#define  EXTI_EMR_EM7 EXTI_EMR_MR7
N#define  EXTI_EMR_EM8 EXTI_EMR_MR8
N#define  EXTI_EMR_EM9 EXTI_EMR_MR9
N#define  EXTI_EMR_EM10 EXTI_EMR_MR10
N#define  EXTI_EMR_EM11 EXTI_EMR_MR11
N#define  EXTI_EMR_EM12 EXTI_EMR_MR12
N#define  EXTI_EMR_EM13 EXTI_EMR_MR13
N#define  EXTI_EMR_EM14 EXTI_EMR_MR14
N#define  EXTI_EMR_EM15 EXTI_EMR_MR15
N#define  EXTI_EMR_EM16 EXTI_EMR_MR16
N#define  EXTI_EMR_EM17 EXTI_EMR_MR17
N#define  EXTI_EMR_EM18 EXTI_EMR_MR18
N#define  EXTI_EMR_EM19 EXTI_EMR_MR19
N#define  EXTI_EMR_EM20 EXTI_EMR_MR20
N#define  EXTI_EMR_EM21 EXTI_EMR_MR21
N#define  EXTI_EMR_EM22 EXTI_EMR_MR22
N#define  EXTI_EMR_EM23 EXTI_EMR_MR23
N#define  EXTI_EMR_EM25 EXTI_EMR_MR25
N#define  EXTI_EMR_EM26 EXTI_EMR_MR26
N#define  EXTI_EMR_EM27 EXTI_EMR_MR27
N#define  EXTI_EMR_EM28 EXTI_EMR_MR28
N#define  EXTI_EMR_EM31 EXTI_EMR_MR31
N
N/*******************  Bit definition for EXTI_RTSR register  ******************/
N#define EXTI_RTSR_TR0_Pos         (0U)                                         
N#define EXTI_RTSR_TR0_Msk         (0x1U << EXTI_RTSR_TR0_Pos)                  /*!< 0x00000001 */
N#define EXTI_RTSR_TR0             EXTI_RTSR_TR0_Msk                            /*!< Rising trigger event configuration bit of line 0 */
N#define EXTI_RTSR_TR1_Pos         (1U)                                         
N#define EXTI_RTSR_TR1_Msk         (0x1U << EXTI_RTSR_TR1_Pos)                  /*!< 0x00000002 */
N#define EXTI_RTSR_TR1             EXTI_RTSR_TR1_Msk                            /*!< Rising trigger event configuration bit of line 1 */
N#define EXTI_RTSR_TR2_Pos         (2U)                                         
N#define EXTI_RTSR_TR2_Msk         (0x1U << EXTI_RTSR_TR2_Pos)                  /*!< 0x00000004 */
N#define EXTI_RTSR_TR2             EXTI_RTSR_TR2_Msk                            /*!< Rising trigger event configuration bit of line 2 */
N#define EXTI_RTSR_TR3_Pos         (3U)                                         
N#define EXTI_RTSR_TR3_Msk         (0x1U << EXTI_RTSR_TR3_Pos)                  /*!< 0x00000008 */
N#define EXTI_RTSR_TR3             EXTI_RTSR_TR3_Msk                            /*!< Rising trigger event configuration bit of line 3 */
N#define EXTI_RTSR_TR4_Pos         (4U)                                         
N#define EXTI_RTSR_TR4_Msk         (0x1U << EXTI_RTSR_TR4_Pos)                  /*!< 0x00000010 */
N#define EXTI_RTSR_TR4             EXTI_RTSR_TR4_Msk                            /*!< Rising trigger event configuration bit of line 4 */
N#define EXTI_RTSR_TR5_Pos         (5U)                                         
N#define EXTI_RTSR_TR5_Msk         (0x1U << EXTI_RTSR_TR5_Pos)                  /*!< 0x00000020 */
N#define EXTI_RTSR_TR5             EXTI_RTSR_TR5_Msk                            /*!< Rising trigger event configuration bit of line 5 */
N#define EXTI_RTSR_TR6_Pos         (6U)                                         
N#define EXTI_RTSR_TR6_Msk         (0x1U << EXTI_RTSR_TR6_Pos)                  /*!< 0x00000040 */
N#define EXTI_RTSR_TR6             EXTI_RTSR_TR6_Msk                            /*!< Rising trigger event configuration bit of line 6 */
N#define EXTI_RTSR_TR7_Pos         (7U)                                         
N#define EXTI_RTSR_TR7_Msk         (0x1U << EXTI_RTSR_TR7_Pos)                  /*!< 0x00000080 */
N#define EXTI_RTSR_TR7             EXTI_RTSR_TR7_Msk                            /*!< Rising trigger event configuration bit of line 7 */
N#define EXTI_RTSR_TR8_Pos         (8U)                                         
N#define EXTI_RTSR_TR8_Msk         (0x1U << EXTI_RTSR_TR8_Pos)                  /*!< 0x00000100 */
N#define EXTI_RTSR_TR8             EXTI_RTSR_TR8_Msk                            /*!< Rising trigger event configuration bit of line 8 */
N#define EXTI_RTSR_TR9_Pos         (9U)                                         
N#define EXTI_RTSR_TR9_Msk         (0x1U << EXTI_RTSR_TR9_Pos)                  /*!< 0x00000200 */
N#define EXTI_RTSR_TR9             EXTI_RTSR_TR9_Msk                            /*!< Rising trigger event configuration bit of line 9 */
N#define EXTI_RTSR_TR10_Pos        (10U)                                        
N#define EXTI_RTSR_TR10_Msk        (0x1U << EXTI_RTSR_TR10_Pos)                 /*!< 0x00000400 */
N#define EXTI_RTSR_TR10            EXTI_RTSR_TR10_Msk                           /*!< Rising trigger event configuration bit of line 10 */
N#define EXTI_RTSR_TR11_Pos        (11U)                                        
N#define EXTI_RTSR_TR11_Msk        (0x1U << EXTI_RTSR_TR11_Pos)                 /*!< 0x00000800 */
N#define EXTI_RTSR_TR11            EXTI_RTSR_TR11_Msk                           /*!< Rising trigger event configuration bit of line 11 */
N#define EXTI_RTSR_TR12_Pos        (12U)                                        
N#define EXTI_RTSR_TR12_Msk        (0x1U << EXTI_RTSR_TR12_Pos)                 /*!< 0x00001000 */
N#define EXTI_RTSR_TR12            EXTI_RTSR_TR12_Msk                           /*!< Rising trigger event configuration bit of line 12 */
N#define EXTI_RTSR_TR13_Pos        (13U)                                        
N#define EXTI_RTSR_TR13_Msk        (0x1U << EXTI_RTSR_TR13_Pos)                 /*!< 0x00002000 */
N#define EXTI_RTSR_TR13            EXTI_RTSR_TR13_Msk                           /*!< Rising trigger event configuration bit of line 13 */
N#define EXTI_RTSR_TR14_Pos        (14U)                                        
N#define EXTI_RTSR_TR14_Msk        (0x1U << EXTI_RTSR_TR14_Pos)                 /*!< 0x00004000 */
N#define EXTI_RTSR_TR14            EXTI_RTSR_TR14_Msk                           /*!< Rising trigger event configuration bit of line 14 */
N#define EXTI_RTSR_TR15_Pos        (15U)                                        
N#define EXTI_RTSR_TR15_Msk        (0x1U << EXTI_RTSR_TR15_Pos)                 /*!< 0x00008000 */
N#define EXTI_RTSR_TR15            EXTI_RTSR_TR15_Msk                           /*!< Rising trigger event configuration bit of line 15 */
N#define EXTI_RTSR_TR16_Pos        (16U)                                        
N#define EXTI_RTSR_TR16_Msk        (0x1U << EXTI_RTSR_TR16_Pos)                 /*!< 0x00010000 */
N#define EXTI_RTSR_TR16            EXTI_RTSR_TR16_Msk                           /*!< Rising trigger event configuration bit of line 16 */
N#define EXTI_RTSR_TR17_Pos        (17U)                                        
N#define EXTI_RTSR_TR17_Msk        (0x1U << EXTI_RTSR_TR17_Pos)                 /*!< 0x00020000 */
N#define EXTI_RTSR_TR17            EXTI_RTSR_TR17_Msk                           /*!< Rising trigger event configuration bit of line 17 */
N#define EXTI_RTSR_TR19_Pos        (19U)                                        
N#define EXTI_RTSR_TR19_Msk        (0x1U << EXTI_RTSR_TR19_Pos)                 /*!< 0x00080000 */
N#define EXTI_RTSR_TR19            EXTI_RTSR_TR19_Msk                           /*!< Rising trigger event configuration bit of line 19 */
N#define EXTI_RTSR_TR20_Pos        (20U)                                        
N#define EXTI_RTSR_TR20_Msk        (0x1U << EXTI_RTSR_TR20_Pos)                 /*!< 0x00100000 */
N#define EXTI_RTSR_TR20            EXTI_RTSR_TR20_Msk                           /*!< Rising trigger event configuration bit of line 20 */
N#define EXTI_RTSR_TR21_Pos        (21U)                                        
N#define EXTI_RTSR_TR21_Msk        (0x1U << EXTI_RTSR_TR21_Pos)                 /*!< 0x00200000 */
N#define EXTI_RTSR_TR21            EXTI_RTSR_TR21_Msk                           /*!< Rising trigger event configuration bit of line 21 */
N#define EXTI_RTSR_TR22_Pos        (22U)                                        
N#define EXTI_RTSR_TR22_Msk        (0x1U << EXTI_RTSR_TR22_Pos)                 /*!< 0x00400000 */
N#define EXTI_RTSR_TR22            EXTI_RTSR_TR22_Msk                           /*!< Rising trigger event configuration bit of line 22 */
N#define EXTI_RTSR_TR31_Pos        (31U)                                        
N#define EXTI_RTSR_TR31_Msk        (0x1U << EXTI_RTSR_TR31_Pos)                 /*!< 0x80000000 */
N#define EXTI_RTSR_TR31            EXTI_RTSR_TR31_Msk                           /*!< Rising trigger event configuration bit of line 31 */
N
N/* References Defines */
N#define EXTI_RTSR_RT0 EXTI_RTSR_TR0
N#define EXTI_RTSR_RT1 EXTI_RTSR_TR1
N#define EXTI_RTSR_RT2 EXTI_RTSR_TR2
N#define EXTI_RTSR_RT3 EXTI_RTSR_TR3
N#define EXTI_RTSR_RT4 EXTI_RTSR_TR4
N#define EXTI_RTSR_RT5 EXTI_RTSR_TR5
N#define EXTI_RTSR_RT6 EXTI_RTSR_TR6
N#define EXTI_RTSR_RT7 EXTI_RTSR_TR7
N#define EXTI_RTSR_RT8 EXTI_RTSR_TR8
N#define EXTI_RTSR_RT9 EXTI_RTSR_TR9
N#define EXTI_RTSR_RT10 EXTI_RTSR_TR10
N#define EXTI_RTSR_RT11 EXTI_RTSR_TR11
N#define EXTI_RTSR_RT12 EXTI_RTSR_TR12
N#define EXTI_RTSR_RT13 EXTI_RTSR_TR13
N#define EXTI_RTSR_RT14 EXTI_RTSR_TR14
N#define EXTI_RTSR_RT15 EXTI_RTSR_TR15
N#define EXTI_RTSR_RT16 EXTI_RTSR_TR16
N#define EXTI_RTSR_RT17 EXTI_RTSR_TR17
N#define EXTI_RTSR_RT19 EXTI_RTSR_TR19
N#define EXTI_RTSR_RT20 EXTI_RTSR_TR20
N#define EXTI_RTSR_RT21 EXTI_RTSR_TR21
N#define EXTI_RTSR_RT22 EXTI_RTSR_TR22
N#define  EXTI_RTSR_RT31 EXTI_RTSR_TR31
N
N/*******************  Bit definition for EXTI_FTSR register *******************/
N#define EXTI_FTSR_TR0_Pos         (0U)                                         
N#define EXTI_FTSR_TR0_Msk         (0x1U << EXTI_FTSR_TR0_Pos)                  /*!< 0x00000001 */
N#define EXTI_FTSR_TR0             EXTI_FTSR_TR0_Msk                            /*!< Falling trigger event configuration bit of line 0 */
N#define EXTI_FTSR_TR1_Pos         (1U)                                         
N#define EXTI_FTSR_TR1_Msk         (0x1U << EXTI_FTSR_TR1_Pos)                  /*!< 0x00000002 */
N#define EXTI_FTSR_TR1             EXTI_FTSR_TR1_Msk                            /*!< Falling trigger event configuration bit of line 1 */
N#define EXTI_FTSR_TR2_Pos         (2U)                                         
N#define EXTI_FTSR_TR2_Msk         (0x1U << EXTI_FTSR_TR2_Pos)                  /*!< 0x00000004 */
N#define EXTI_FTSR_TR2             EXTI_FTSR_TR2_Msk                            /*!< Falling trigger event configuration bit of line 2 */
N#define EXTI_FTSR_TR3_Pos         (3U)                                         
N#define EXTI_FTSR_TR3_Msk         (0x1U << EXTI_FTSR_TR3_Pos)                  /*!< 0x00000008 */
N#define EXTI_FTSR_TR3             EXTI_FTSR_TR3_Msk                            /*!< Falling trigger event configuration bit of line 3 */
N#define EXTI_FTSR_TR4_Pos         (4U)                                         
N#define EXTI_FTSR_TR4_Msk         (0x1U << EXTI_FTSR_TR4_Pos)                  /*!< 0x00000010 */
N#define EXTI_FTSR_TR4             EXTI_FTSR_TR4_Msk                            /*!< Falling trigger event configuration bit of line 4 */
N#define EXTI_FTSR_TR5_Pos         (5U)                                         
N#define EXTI_FTSR_TR5_Msk         (0x1U << EXTI_FTSR_TR5_Pos)                  /*!< 0x00000020 */
N#define EXTI_FTSR_TR5             EXTI_FTSR_TR5_Msk                            /*!< Falling trigger event configuration bit of line 5 */
N#define EXTI_FTSR_TR6_Pos         (6U)                                         
N#define EXTI_FTSR_TR6_Msk         (0x1U << EXTI_FTSR_TR6_Pos)                  /*!< 0x00000040 */
N#define EXTI_FTSR_TR6             EXTI_FTSR_TR6_Msk                            /*!< Falling trigger event configuration bit of line 6 */
N#define EXTI_FTSR_TR7_Pos         (7U)                                         
N#define EXTI_FTSR_TR7_Msk         (0x1U << EXTI_FTSR_TR7_Pos)                  /*!< 0x00000080 */
N#define EXTI_FTSR_TR7             EXTI_FTSR_TR7_Msk                            /*!< Falling trigger event configuration bit of line 7 */
N#define EXTI_FTSR_TR8_Pos         (8U)                                         
N#define EXTI_FTSR_TR8_Msk         (0x1U << EXTI_FTSR_TR8_Pos)                  /*!< 0x00000100 */
N#define EXTI_FTSR_TR8             EXTI_FTSR_TR8_Msk                            /*!< Falling trigger event configuration bit of line 8 */
N#define EXTI_FTSR_TR9_Pos         (9U)                                         
N#define EXTI_FTSR_TR9_Msk         (0x1U << EXTI_FTSR_TR9_Pos)                  /*!< 0x00000200 */
N#define EXTI_FTSR_TR9             EXTI_FTSR_TR9_Msk                            /*!< Falling trigger event configuration bit of line 9 */
N#define EXTI_FTSR_TR10_Pos        (10U)                                        
N#define EXTI_FTSR_TR10_Msk        (0x1U << EXTI_FTSR_TR10_Pos)                 /*!< 0x00000400 */
N#define EXTI_FTSR_TR10            EXTI_FTSR_TR10_Msk                           /*!< Falling trigger event configuration bit of line 10 */
N#define EXTI_FTSR_TR11_Pos        (11U)                                        
N#define EXTI_FTSR_TR11_Msk        (0x1U << EXTI_FTSR_TR11_Pos)                 /*!< 0x00000800 */
N#define EXTI_FTSR_TR11            EXTI_FTSR_TR11_Msk                           /*!< Falling trigger event configuration bit of line 11 */
N#define EXTI_FTSR_TR12_Pos        (12U)                                        
N#define EXTI_FTSR_TR12_Msk        (0x1U << EXTI_FTSR_TR12_Pos)                 /*!< 0x00001000 */
N#define EXTI_FTSR_TR12            EXTI_FTSR_TR12_Msk                           /*!< Falling trigger event configuration bit of line 12 */
N#define EXTI_FTSR_TR13_Pos        (13U)                                        
N#define EXTI_FTSR_TR13_Msk        (0x1U << EXTI_FTSR_TR13_Pos)                 /*!< 0x00002000 */
N#define EXTI_FTSR_TR13            EXTI_FTSR_TR13_Msk                           /*!< Falling trigger event configuration bit of line 13 */
N#define EXTI_FTSR_TR14_Pos        (14U)                                        
N#define EXTI_FTSR_TR14_Msk        (0x1U << EXTI_FTSR_TR14_Pos)                 /*!< 0x00004000 */
N#define EXTI_FTSR_TR14            EXTI_FTSR_TR14_Msk                           /*!< Falling trigger event configuration bit of line 14 */
N#define EXTI_FTSR_TR15_Pos        (15U)                                        
N#define EXTI_FTSR_TR15_Msk        (0x1U << EXTI_FTSR_TR15_Pos)                 /*!< 0x00008000 */
N#define EXTI_FTSR_TR15            EXTI_FTSR_TR15_Msk                           /*!< Falling trigger event configuration bit of line 15 */
N#define EXTI_FTSR_TR16_Pos        (16U)                                        
N#define EXTI_FTSR_TR16_Msk        (0x1U << EXTI_FTSR_TR16_Pos)                 /*!< 0x00010000 */
N#define EXTI_FTSR_TR16            EXTI_FTSR_TR16_Msk                           /*!< Falling trigger event configuration bit of line 16 */
N#define EXTI_FTSR_TR17_Pos        (17U)                                        
N#define EXTI_FTSR_TR17_Msk        (0x1U << EXTI_FTSR_TR17_Pos)                 /*!< 0x00020000 */
N#define EXTI_FTSR_TR17            EXTI_FTSR_TR17_Msk                           /*!< Falling trigger event configuration bit of line 17 */
N#define EXTI_FTSR_TR19_Pos        (19U)                                        
N#define EXTI_FTSR_TR19_Msk        (0x1U << EXTI_FTSR_TR19_Pos)                 /*!< 0x00080000 */
N#define EXTI_FTSR_TR19            EXTI_FTSR_TR19_Msk                           /*!< Falling trigger event configuration bit of line 19 */
N#define EXTI_FTSR_TR20_Pos        (20U)                                        
N#define EXTI_FTSR_TR20_Msk        (0x1U << EXTI_FTSR_TR20_Pos)                 /*!< 0x00100000 */
N#define EXTI_FTSR_TR20            EXTI_FTSR_TR20_Msk                           /*!< Falling trigger event configuration bit of line 20 */
N#define EXTI_FTSR_TR21_Pos        (21U)                                        
N#define EXTI_FTSR_TR21_Msk        (0x1U << EXTI_FTSR_TR21_Pos)                 /*!< 0x00200000 */
N#define EXTI_FTSR_TR21            EXTI_FTSR_TR21_Msk                           /*!< Falling trigger event configuration bit of line 21 */
N#define EXTI_FTSR_TR22_Pos        (22U)                                        
N#define EXTI_FTSR_TR22_Msk        (0x1U << EXTI_FTSR_TR22_Pos)                 /*!< 0x00400000 */
N#define EXTI_FTSR_TR22            EXTI_FTSR_TR22_Msk                           /*!< Falling trigger event configuration bit of line 22 */
N#define EXTI_FTSR_TR31_Pos        (31U)                                        
N#define EXTI_FTSR_TR31_Msk        (0x1U << EXTI_FTSR_TR31_Pos)                 /*!< 0x80000000 */
N#define EXTI_FTSR_TR31            EXTI_FTSR_TR31_Msk                           /*!< Falling trigger event configuration bit of line 31 */
N
N/* References Defines */
N#define EXTI_FTSR_FT0 EXTI_FTSR_TR0
N#define EXTI_FTSR_FT1 EXTI_FTSR_TR1
N#define EXTI_FTSR_FT2 EXTI_FTSR_TR2
N#define EXTI_FTSR_FT3 EXTI_FTSR_TR3
N#define EXTI_FTSR_FT4 EXTI_FTSR_TR4
N#define EXTI_FTSR_FT5 EXTI_FTSR_TR5
N#define EXTI_FTSR_FT6 EXTI_FTSR_TR6
N#define EXTI_FTSR_FT7 EXTI_FTSR_TR7
N#define EXTI_FTSR_FT8 EXTI_FTSR_TR8
N#define EXTI_FTSR_FT9 EXTI_FTSR_TR9
N#define EXTI_FTSR_FT10 EXTI_FTSR_TR10
N#define EXTI_FTSR_FT11 EXTI_FTSR_TR11
N#define EXTI_FTSR_FT12 EXTI_FTSR_TR12
N#define EXTI_FTSR_FT13 EXTI_FTSR_TR13
N#define EXTI_FTSR_FT14 EXTI_FTSR_TR14
N#define EXTI_FTSR_FT15 EXTI_FTSR_TR15
N#define EXTI_FTSR_FT16 EXTI_FTSR_TR16
N#define EXTI_FTSR_FT17 EXTI_FTSR_TR17
N#define EXTI_FTSR_FT19 EXTI_FTSR_TR19
N#define EXTI_FTSR_FT20 EXTI_FTSR_TR20
N#define EXTI_FTSR_FT21 EXTI_FTSR_TR21
N#define EXTI_FTSR_FT22 EXTI_FTSR_TR22
N#define EXTI_FTSR_FT31 EXTI_FTSR_TR31
N
N/******************* Bit definition for EXTI_SWIER register *******************/
N#define EXTI_SWIER_SWIER0_Pos     (0U)                                         
N#define EXTI_SWIER_SWIER0_Msk     (0x1U << EXTI_SWIER_SWIER0_Pos)              /*!< 0x00000001 */
N#define EXTI_SWIER_SWIER0         EXTI_SWIER_SWIER0_Msk                        /*!< Software Interrupt on line 0  */
N#define EXTI_SWIER_SWIER1_Pos     (1U)                                         
N#define EXTI_SWIER_SWIER1_Msk     (0x1U << EXTI_SWIER_SWIER1_Pos)              /*!< 0x00000002 */
N#define EXTI_SWIER_SWIER1         EXTI_SWIER_SWIER1_Msk                        /*!< Software Interrupt on line 1  */
N#define EXTI_SWIER_SWIER2_Pos     (2U)                                         
N#define EXTI_SWIER_SWIER2_Msk     (0x1U << EXTI_SWIER_SWIER2_Pos)              /*!< 0x00000004 */
N#define EXTI_SWIER_SWIER2         EXTI_SWIER_SWIER2_Msk                        /*!< Software Interrupt on line 2  */
N#define EXTI_SWIER_SWIER3_Pos     (3U)                                         
N#define EXTI_SWIER_SWIER3_Msk     (0x1U << EXTI_SWIER_SWIER3_Pos)              /*!< 0x00000008 */
N#define EXTI_SWIER_SWIER3         EXTI_SWIER_SWIER3_Msk                        /*!< Software Interrupt on line 3  */
N#define EXTI_SWIER_SWIER4_Pos     (4U)                                         
N#define EXTI_SWIER_SWIER4_Msk     (0x1U << EXTI_SWIER_SWIER4_Pos)              /*!< 0x00000010 */
N#define EXTI_SWIER_SWIER4         EXTI_SWIER_SWIER4_Msk                        /*!< Software Interrupt on line 4  */
N#define EXTI_SWIER_SWIER5_Pos     (5U)                                         
N#define EXTI_SWIER_SWIER5_Msk     (0x1U << EXTI_SWIER_SWIER5_Pos)              /*!< 0x00000020 */
N#define EXTI_SWIER_SWIER5         EXTI_SWIER_SWIER5_Msk                        /*!< Software Interrupt on line 5  */
N#define EXTI_SWIER_SWIER6_Pos     (6U)                                         
N#define EXTI_SWIER_SWIER6_Msk     (0x1U << EXTI_SWIER_SWIER6_Pos)              /*!< 0x00000040 */
N#define EXTI_SWIER_SWIER6         EXTI_SWIER_SWIER6_Msk                        /*!< Software Interrupt on line 6  */
N#define EXTI_SWIER_SWIER7_Pos     (7U)                                         
N#define EXTI_SWIER_SWIER7_Msk     (0x1U << EXTI_SWIER_SWIER7_Pos)              /*!< 0x00000080 */
N#define EXTI_SWIER_SWIER7         EXTI_SWIER_SWIER7_Msk                        /*!< Software Interrupt on line 7  */
N#define EXTI_SWIER_SWIER8_Pos     (8U)                                         
N#define EXTI_SWIER_SWIER8_Msk     (0x1U << EXTI_SWIER_SWIER8_Pos)              /*!< 0x00000100 */
N#define EXTI_SWIER_SWIER8         EXTI_SWIER_SWIER8_Msk                        /*!< Software Interrupt on line 8  */
N#define EXTI_SWIER_SWIER9_Pos     (9U)                                         
N#define EXTI_SWIER_SWIER9_Msk     (0x1U << EXTI_SWIER_SWIER9_Pos)              /*!< 0x00000200 */
N#define EXTI_SWIER_SWIER9         EXTI_SWIER_SWIER9_Msk                        /*!< Software Interrupt on line 9  */
N#define EXTI_SWIER_SWIER10_Pos    (10U)                                        
N#define EXTI_SWIER_SWIER10_Msk    (0x1U << EXTI_SWIER_SWIER10_Pos)             /*!< 0x00000400 */
N#define EXTI_SWIER_SWIER10        EXTI_SWIER_SWIER10_Msk                       /*!< Software Interrupt on line 10 */
N#define EXTI_SWIER_SWIER11_Pos    (11U)                                        
N#define EXTI_SWIER_SWIER11_Msk    (0x1U << EXTI_SWIER_SWIER11_Pos)             /*!< 0x00000800 */
N#define EXTI_SWIER_SWIER11        EXTI_SWIER_SWIER11_Msk                       /*!< Software Interrupt on line 11 */
N#define EXTI_SWIER_SWIER12_Pos    (12U)                                        
N#define EXTI_SWIER_SWIER12_Msk    (0x1U << EXTI_SWIER_SWIER12_Pos)             /*!< 0x00001000 */
N#define EXTI_SWIER_SWIER12        EXTI_SWIER_SWIER12_Msk                       /*!< Software Interrupt on line 12 */
N#define EXTI_SWIER_SWIER13_Pos    (13U)                                        
N#define EXTI_SWIER_SWIER13_Msk    (0x1U << EXTI_SWIER_SWIER13_Pos)             /*!< 0x00002000 */
N#define EXTI_SWIER_SWIER13        EXTI_SWIER_SWIER13_Msk                       /*!< Software Interrupt on line 13 */
N#define EXTI_SWIER_SWIER14_Pos    (14U)                                        
N#define EXTI_SWIER_SWIER14_Msk    (0x1U << EXTI_SWIER_SWIER14_Pos)             /*!< 0x00004000 */
N#define EXTI_SWIER_SWIER14        EXTI_SWIER_SWIER14_Msk                       /*!< Software Interrupt on line 14 */
N#define EXTI_SWIER_SWIER15_Pos    (15U)                                        
N#define EXTI_SWIER_SWIER15_Msk    (0x1U << EXTI_SWIER_SWIER15_Pos)             /*!< 0x00008000 */
N#define EXTI_SWIER_SWIER15        EXTI_SWIER_SWIER15_Msk                       /*!< Software Interrupt on line 15 */
N#define EXTI_SWIER_SWIER16_Pos    (16U)                                        
N#define EXTI_SWIER_SWIER16_Msk    (0x1U << EXTI_SWIER_SWIER16_Pos)             /*!< 0x00010000 */
N#define EXTI_SWIER_SWIER16        EXTI_SWIER_SWIER16_Msk                       /*!< Software Interrupt on line 16 */
N#define EXTI_SWIER_SWIER17_Pos    (17U)                                        
N#define EXTI_SWIER_SWIER17_Msk    (0x1U << EXTI_SWIER_SWIER17_Pos)             /*!< 0x00020000 */
N#define EXTI_SWIER_SWIER17        EXTI_SWIER_SWIER17_Msk                       /*!< Software Interrupt on line 17 */
N#define EXTI_SWIER_SWIER19_Pos    (19U)                                        
N#define EXTI_SWIER_SWIER19_Msk    (0x1U << EXTI_SWIER_SWIER19_Pos)             /*!< 0x00080000 */
N#define EXTI_SWIER_SWIER19        EXTI_SWIER_SWIER19_Msk                       /*!< Software Interrupt on line 19 */
N#define EXTI_SWIER_SWIER20_Pos    (20U)                                        
N#define EXTI_SWIER_SWIER20_Msk    (0x1U << EXTI_SWIER_SWIER20_Pos)             /*!< 0x00100000 */
N#define EXTI_SWIER_SWIER20        EXTI_SWIER_SWIER20_Msk                       /*!< Software Interrupt on line 20 */
N#define EXTI_SWIER_SWIER21_Pos    (21U)                                        
N#define EXTI_SWIER_SWIER21_Msk    (0x1U << EXTI_SWIER_SWIER21_Pos)             /*!< 0x00200000 */
N#define EXTI_SWIER_SWIER21        EXTI_SWIER_SWIER21_Msk                       /*!< Software Interrupt on line 21 */
N#define EXTI_SWIER_SWIER22_Pos    (22U)                                        
N#define EXTI_SWIER_SWIER22_Msk    (0x1U << EXTI_SWIER_SWIER22_Pos)             /*!< 0x00400000 */
N#define EXTI_SWIER_SWIER22        EXTI_SWIER_SWIER22_Msk                       /*!< Software Interrupt on line 22 */
N#define EXTI_SWIER_SWIER31_Pos    (31U)                                        
N#define EXTI_SWIER_SWIER31_Msk    (0x1U << EXTI_SWIER_SWIER31_Pos)             /*!< 0x80000000 */
N#define EXTI_SWIER_SWIER31        EXTI_SWIER_SWIER31_Msk                       /*!< Software Interrupt on line 31 */
N
N/* References Defines */
N#define EXTI_SWIER_SWI0 EXTI_SWIER_SWIER0
N#define EXTI_SWIER_SWI1 EXTI_SWIER_SWIER1
N#define EXTI_SWIER_SWI2 EXTI_SWIER_SWIER2
N#define EXTI_SWIER_SWI3 EXTI_SWIER_SWIER3
N#define EXTI_SWIER_SWI4 EXTI_SWIER_SWIER4
N#define EXTI_SWIER_SWI5 EXTI_SWIER_SWIER5
N#define EXTI_SWIER_SWI6 EXTI_SWIER_SWIER6
N#define EXTI_SWIER_SWI7 EXTI_SWIER_SWIER7
N#define EXTI_SWIER_SWI8 EXTI_SWIER_SWIER8
N#define EXTI_SWIER_SWI9 EXTI_SWIER_SWIER9
N#define EXTI_SWIER_SWI10 EXTI_SWIER_SWIER10
N#define EXTI_SWIER_SWI11 EXTI_SWIER_SWIER11
N#define EXTI_SWIER_SWI12 EXTI_SWIER_SWIER12
N#define EXTI_SWIER_SWI13 EXTI_SWIER_SWIER13
N#define EXTI_SWIER_SWI14 EXTI_SWIER_SWIER14
N#define EXTI_SWIER_SWI15 EXTI_SWIER_SWIER15
N#define EXTI_SWIER_SWI16 EXTI_SWIER_SWIER16
N#define EXTI_SWIER_SWI17 EXTI_SWIER_SWIER17
N#define EXTI_SWIER_SWI19 EXTI_SWIER_SWIER19
N#define EXTI_SWIER_SWI20 EXTI_SWIER_SWIER20
N#define EXTI_SWIER_SWI21 EXTI_SWIER_SWIER21
N#define EXTI_SWIER_SWI22 EXTI_SWIER_SWIER22
N#define  EXTI_SWIER_SWI31 EXTI_SWIER_SWIER31
N
N/******************  Bit definition for EXTI_PR register  *********************/
N#define EXTI_PR_PR0_Pos           (0U)                                         
N#define EXTI_PR_PR0_Msk           (0x1U << EXTI_PR_PR0_Pos)                    /*!< 0x00000001 */
N#define EXTI_PR_PR0               EXTI_PR_PR0_Msk                              /*!< Pending bit 0  */
N#define EXTI_PR_PR1_Pos           (1U)                                         
N#define EXTI_PR_PR1_Msk           (0x1U << EXTI_PR_PR1_Pos)                    /*!< 0x00000002 */
N#define EXTI_PR_PR1               EXTI_PR_PR1_Msk                              /*!< Pending bit 1  */
N#define EXTI_PR_PR2_Pos           (2U)                                         
N#define EXTI_PR_PR2_Msk           (0x1U << EXTI_PR_PR2_Pos)                    /*!< 0x00000004 */
N#define EXTI_PR_PR2               EXTI_PR_PR2_Msk                              /*!< Pending bit 2  */
N#define EXTI_PR_PR3_Pos           (3U)                                         
N#define EXTI_PR_PR3_Msk           (0x1U << EXTI_PR_PR3_Pos)                    /*!< 0x00000008 */
N#define EXTI_PR_PR3               EXTI_PR_PR3_Msk                              /*!< Pending bit 3  */
N#define EXTI_PR_PR4_Pos           (4U)                                         
N#define EXTI_PR_PR4_Msk           (0x1U << EXTI_PR_PR4_Pos)                    /*!< 0x00000010 */
N#define EXTI_PR_PR4               EXTI_PR_PR4_Msk                              /*!< Pending bit 4  */
N#define EXTI_PR_PR5_Pos           (5U)                                         
N#define EXTI_PR_PR5_Msk           (0x1U << EXTI_PR_PR5_Pos)                    /*!< 0x00000020 */
N#define EXTI_PR_PR5               EXTI_PR_PR5_Msk                              /*!< Pending bit 5  */
N#define EXTI_PR_PR6_Pos           (6U)                                         
N#define EXTI_PR_PR6_Msk           (0x1U << EXTI_PR_PR6_Pos)                    /*!< 0x00000040 */
N#define EXTI_PR_PR6               EXTI_PR_PR6_Msk                              /*!< Pending bit 6  */
N#define EXTI_PR_PR7_Pos           (7U)                                         
N#define EXTI_PR_PR7_Msk           (0x1U << EXTI_PR_PR7_Pos)                    /*!< 0x00000080 */
N#define EXTI_PR_PR7               EXTI_PR_PR7_Msk                              /*!< Pending bit 7  */
N#define EXTI_PR_PR8_Pos           (8U)                                         
N#define EXTI_PR_PR8_Msk           (0x1U << EXTI_PR_PR8_Pos)                    /*!< 0x00000100 */
N#define EXTI_PR_PR8               EXTI_PR_PR8_Msk                              /*!< Pending bit 8  */
N#define EXTI_PR_PR9_Pos           (9U)                                         
N#define EXTI_PR_PR9_Msk           (0x1U << EXTI_PR_PR9_Pos)                    /*!< 0x00000200 */
N#define EXTI_PR_PR9               EXTI_PR_PR9_Msk                              /*!< Pending bit 9  */
N#define EXTI_PR_PR10_Pos          (10U)                                        
N#define EXTI_PR_PR10_Msk          (0x1U << EXTI_PR_PR10_Pos)                   /*!< 0x00000400 */
N#define EXTI_PR_PR10              EXTI_PR_PR10_Msk                             /*!< Pending bit 10 */
N#define EXTI_PR_PR11_Pos          (11U)                                        
N#define EXTI_PR_PR11_Msk          (0x1U << EXTI_PR_PR11_Pos)                   /*!< 0x00000800 */
N#define EXTI_PR_PR11              EXTI_PR_PR11_Msk                             /*!< Pending bit 11 */
N#define EXTI_PR_PR12_Pos          (12U)                                        
N#define EXTI_PR_PR12_Msk          (0x1U << EXTI_PR_PR12_Pos)                   /*!< 0x00001000 */
N#define EXTI_PR_PR12              EXTI_PR_PR12_Msk                             /*!< Pending bit 12 */
N#define EXTI_PR_PR13_Pos          (13U)                                        
N#define EXTI_PR_PR13_Msk          (0x1U << EXTI_PR_PR13_Pos)                   /*!< 0x00002000 */
N#define EXTI_PR_PR13              EXTI_PR_PR13_Msk                             /*!< Pending bit 13 */
N#define EXTI_PR_PR14_Pos          (14U)                                        
N#define EXTI_PR_PR14_Msk          (0x1U << EXTI_PR_PR14_Pos)                   /*!< 0x00004000 */
N#define EXTI_PR_PR14              EXTI_PR_PR14_Msk                             /*!< Pending bit 14 */
N#define EXTI_PR_PR15_Pos          (15U)                                        
N#define EXTI_PR_PR15_Msk          (0x1U << EXTI_PR_PR15_Pos)                   /*!< 0x00008000 */
N#define EXTI_PR_PR15              EXTI_PR_PR15_Msk                             /*!< Pending bit 15 */
N#define EXTI_PR_PR16_Pos          (16U)                                        
N#define EXTI_PR_PR16_Msk          (0x1U << EXTI_PR_PR16_Pos)                   /*!< 0x00010000 */
N#define EXTI_PR_PR16              EXTI_PR_PR16_Msk                             /*!< Pending bit 16 */
N#define EXTI_PR_PR17_Pos          (17U)                                        
N#define EXTI_PR_PR17_Msk          (0x1U << EXTI_PR_PR17_Pos)                   /*!< 0x00020000 */
N#define EXTI_PR_PR17              EXTI_PR_PR17_Msk                             /*!< Pending bit 17 */
N#define EXTI_PR_PR19_Pos          (19U)                                        
N#define EXTI_PR_PR19_Msk          (0x1U << EXTI_PR_PR19_Pos)                   /*!< 0x00080000 */
N#define EXTI_PR_PR19              EXTI_PR_PR19_Msk                             /*!< Pending bit 19 */
N#define EXTI_PR_PR20_Pos          (20U)                                        
N#define EXTI_PR_PR20_Msk          (0x1U << EXTI_PR_PR20_Pos)                   /*!< 0x00100000 */
N#define EXTI_PR_PR20              EXTI_PR_PR20_Msk                             /*!< Pending bit 20 */
N#define EXTI_PR_PR21_Pos          (21U)                                        
N#define EXTI_PR_PR21_Msk          (0x1U << EXTI_PR_PR21_Pos)                   /*!< 0x00200000 */
N#define EXTI_PR_PR21              EXTI_PR_PR21_Msk                             /*!< Pending bit 21 */
N#define EXTI_PR_PR22_Pos          (22U)                                        
N#define EXTI_PR_PR22_Msk          (0x1U << EXTI_PR_PR22_Pos)                   /*!< 0x00400000 */
N#define EXTI_PR_PR22              EXTI_PR_PR22_Msk                             /*!< Pending bit 22 */
N#define EXTI_PR_PR31_Pos          (31U)                                        
N#define EXTI_PR_PR31_Msk          (0x1U << EXTI_PR_PR31_Pos)                   /*!< 0x80000000 */
N#define EXTI_PR_PR31              EXTI_PR_PR31_Msk                             /*!< Pending bit 31 */
N
N/* References Defines */
N#define EXTI_PR_PIF0 EXTI_PR_PR0
N#define EXTI_PR_PIF1 EXTI_PR_PR1
N#define EXTI_PR_PIF2 EXTI_PR_PR2
N#define EXTI_PR_PIF3 EXTI_PR_PR3
N#define EXTI_PR_PIF4 EXTI_PR_PR4
N#define EXTI_PR_PIF5 EXTI_PR_PR5
N#define EXTI_PR_PIF6 EXTI_PR_PR6
N#define EXTI_PR_PIF7 EXTI_PR_PR7
N#define EXTI_PR_PIF8 EXTI_PR_PR8
N#define EXTI_PR_PIF9 EXTI_PR_PR9
N#define EXTI_PR_PIF10 EXTI_PR_PR10
N#define EXTI_PR_PIF11 EXTI_PR_PR11
N#define EXTI_PR_PIF12 EXTI_PR_PR12
N#define EXTI_PR_PIF13 EXTI_PR_PR13
N#define EXTI_PR_PIF14 EXTI_PR_PR14
N#define EXTI_PR_PIF15 EXTI_PR_PR15
N#define EXTI_PR_PIF16 EXTI_PR_PR16
N#define EXTI_PR_PIF17 EXTI_PR_PR17
N#define EXTI_PR_PIF19 EXTI_PR_PR19
N#define EXTI_PR_PIF20 EXTI_PR_PR20
N#define EXTI_PR_PIF21 EXTI_PR_PR21
N#define EXTI_PR_PIF22 EXTI_PR_PR22
N#define EXTI_PR_PIF31 EXTI_PR_PR31
N
N/******************************************************************************/
N/*                                                                            */
N/*                      FLASH and Option Bytes Registers                      */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for FLASH_ACR register  ******************/
N#define FLASH_ACR_LATENCY_Pos             (0U)                                 
N#define FLASH_ACR_LATENCY_Msk             (0x1U << FLASH_ACR_LATENCY_Pos)      /*!< 0x00000001 */
N#define FLASH_ACR_LATENCY                 FLASH_ACR_LATENCY_Msk                /*!< LATENCY bit (Latency) */
N
N#define FLASH_ACR_PRFTBE_Pos              (4U)                                 
N#define FLASH_ACR_PRFTBE_Msk              (0x1U << FLASH_ACR_PRFTBE_Pos)       /*!< 0x00000010 */
N#define FLASH_ACR_PRFTBE                  FLASH_ACR_PRFTBE_Msk                 /*!< Prefetch Buffer Enable */
N#define FLASH_ACR_PRFTBS_Pos              (5U)                                 
N#define FLASH_ACR_PRFTBS_Msk              (0x1U << FLASH_ACR_PRFTBS_Pos)       /*!< 0x00000020 */
N#define FLASH_ACR_PRFTBS                  FLASH_ACR_PRFTBS_Msk                 /*!< Prefetch Buffer Status */
N
N/******************  Bit definition for FLASH_KEYR register  ******************/
N#define FLASH_KEYR_FKEYR_Pos              (0U)                                 
N#define FLASH_KEYR_FKEYR_Msk              (0xFFFFFFFFU << FLASH_KEYR_FKEYR_Pos) /*!< 0xFFFFFFFF */
N#define FLASH_KEYR_FKEYR                  FLASH_KEYR_FKEYR_Msk                 /*!< FPEC Key */
N
N/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
N#define FLASH_OPTKEYR_OPTKEYR_Pos         (0U)                                 
N#define FLASH_OPTKEYR_OPTKEYR_Msk         (0xFFFFFFFFU << FLASH_OPTKEYR_OPTKEYR_Pos) /*!< 0xFFFFFFFF */
N#define FLASH_OPTKEYR_OPTKEYR             FLASH_OPTKEYR_OPTKEYR_Msk            /*!< Option Byte Key */
N
N/******************  FLASH Keys  **********************************************/
N#define FLASH_KEY1_Pos                    (0U)                                 
N#define FLASH_KEY1_Msk                    (0x45670123U << FLASH_KEY1_Pos)      /*!< 0x45670123 */
N#define FLASH_KEY1                        FLASH_KEY1_Msk                       /*!< Flash program erase key1 */
N#define FLASH_KEY2_Pos                    (0U)                                 
N#define FLASH_KEY2_Msk                    (0xCDEF89ABU << FLASH_KEY2_Pos)      /*!< 0xCDEF89AB */
N#define FLASH_KEY2                        FLASH_KEY2_Msk                       /*!< Flash program erase key2: used with FLASH_PEKEY1
N                                                                                to unlock the write access to the FPEC. */
N                                                               
N#define FLASH_OPTKEY1_Pos                 (0U)                                 
N#define FLASH_OPTKEY1_Msk                 (0x45670123U << FLASH_OPTKEY1_Pos)   /*!< 0x45670123 */
N#define FLASH_OPTKEY1                     FLASH_OPTKEY1_Msk                    /*!< Flash option key1 */
N#define FLASH_OPTKEY2_Pos                 (0U)                                 
N#define FLASH_OPTKEY2_Msk                 (0xCDEF89ABU << FLASH_OPTKEY2_Pos)   /*!< 0xCDEF89AB */
N#define FLASH_OPTKEY2                     FLASH_OPTKEY2_Msk                    /*!< Flash option key2: used with FLASH_OPTKEY1 to
N                                                                                unlock the write access to the option byte block */
N
N/******************  Bit definition for FLASH_SR register  *******************/
N#define FLASH_SR_BSY_Pos                  (0U)                                 
N#define FLASH_SR_BSY_Msk                  (0x1U << FLASH_SR_BSY_Pos)           /*!< 0x00000001 */
N#define FLASH_SR_BSY                      FLASH_SR_BSY_Msk                     /*!< Busy */
N#define FLASH_SR_PGERR_Pos                (2U)                                 
N#define FLASH_SR_PGERR_Msk                (0x1U << FLASH_SR_PGERR_Pos)         /*!< 0x00000004 */
N#define FLASH_SR_PGERR                    FLASH_SR_PGERR_Msk                   /*!< Programming Error */
N#define FLASH_SR_WRPRTERR_Pos             (4U)                                 
N#define FLASH_SR_WRPRTERR_Msk             (0x1U << FLASH_SR_WRPRTERR_Pos)      /*!< 0x00000010 */
N#define FLASH_SR_WRPRTERR                 FLASH_SR_WRPRTERR_Msk                /*!< Write Protection Error */
N#define FLASH_SR_EOP_Pos                  (5U)                                 
N#define FLASH_SR_EOP_Msk                  (0x1U << FLASH_SR_EOP_Pos)           /*!< 0x00000020 */
N#define FLASH_SR_EOP                      FLASH_SR_EOP_Msk                     /*!< End of operation */
N#define  FLASH_SR_WRPERR                     FLASH_SR_WRPRTERR             /*!< Legacy of Write Protection Error */
N
N/*******************  Bit definition for FLASH_CR register  *******************/
N#define FLASH_CR_PG_Pos                   (0U)                                 
N#define FLASH_CR_PG_Msk                   (0x1U << FLASH_CR_PG_Pos)            /*!< 0x00000001 */
N#define FLASH_CR_PG                       FLASH_CR_PG_Msk                      /*!< Programming */
N#define FLASH_CR_PER_Pos                  (1U)                                 
N#define FLASH_CR_PER_Msk                  (0x1U << FLASH_CR_PER_Pos)           /*!< 0x00000002 */
N#define FLASH_CR_PER                      FLASH_CR_PER_Msk                     /*!< Page Erase */
N#define FLASH_CR_MER_Pos                  (2U)                                 
N#define FLASH_CR_MER_Msk                  (0x1U << FLASH_CR_MER_Pos)           /*!< 0x00000004 */
N#define FLASH_CR_MER                      FLASH_CR_MER_Msk                     /*!< Mass Erase */
N#define FLASH_CR_OPTPG_Pos                (4U)                                 
N#define FLASH_CR_OPTPG_Msk                (0x1U << FLASH_CR_OPTPG_Pos)         /*!< 0x00000010 */
N#define FLASH_CR_OPTPG                    FLASH_CR_OPTPG_Msk                   /*!< Option Byte Programming */
N#define FLASH_CR_OPTER_Pos                (5U)                                 
N#define FLASH_CR_OPTER_Msk                (0x1U << FLASH_CR_OPTER_Pos)         /*!< 0x00000020 */
N#define FLASH_CR_OPTER                    FLASH_CR_OPTER_Msk                   /*!< Option Byte Erase */
N#define FLASH_CR_STRT_Pos                 (6U)                                 
N#define FLASH_CR_STRT_Msk                 (0x1U << FLASH_CR_STRT_Pos)          /*!< 0x00000040 */
N#define FLASH_CR_STRT                     FLASH_CR_STRT_Msk                    /*!< Start */
N#define FLASH_CR_LOCK_Pos                 (7U)                                 
N#define FLASH_CR_LOCK_Msk                 (0x1U << FLASH_CR_LOCK_Pos)          /*!< 0x00000080 */
N#define FLASH_CR_LOCK                     FLASH_CR_LOCK_Msk                    /*!< Lock */
N#define FLASH_CR_OPTWRE_Pos               (9U)                                 
N#define FLASH_CR_OPTWRE_Msk               (0x1U << FLASH_CR_OPTWRE_Pos)        /*!< 0x00000200 */
N#define FLASH_CR_OPTWRE                   FLASH_CR_OPTWRE_Msk                  /*!< Option Bytes Write Enable */
N#define FLASH_CR_ERRIE_Pos                (10U)                                
N#define FLASH_CR_ERRIE_Msk                (0x1U << FLASH_CR_ERRIE_Pos)         /*!< 0x00000400 */
N#define FLASH_CR_ERRIE                    FLASH_CR_ERRIE_Msk                   /*!< Error Interrupt Enable */
N#define FLASH_CR_EOPIE_Pos                (12U)                                
N#define FLASH_CR_EOPIE_Msk                (0x1U << FLASH_CR_EOPIE_Pos)         /*!< 0x00001000 */
N#define FLASH_CR_EOPIE                    FLASH_CR_EOPIE_Msk                   /*!< End of operation interrupt enable */
N#define FLASH_CR_OBL_LAUNCH_Pos           (13U)                                
N#define FLASH_CR_OBL_LAUNCH_Msk           (0x1U << FLASH_CR_OBL_LAUNCH_Pos)    /*!< 0x00002000 */
N#define FLASH_CR_OBL_LAUNCH               FLASH_CR_OBL_LAUNCH_Msk              /*!< Option Bytes Loader Launch */
N
N/*******************  Bit definition for FLASH_AR register  *******************/
N#define FLASH_AR_FAR_Pos                  (0U)                                 
N#define FLASH_AR_FAR_Msk                  (0xFFFFFFFFU << FLASH_AR_FAR_Pos)    /*!< 0xFFFFFFFF */
N#define FLASH_AR_FAR                      FLASH_AR_FAR_Msk                     /*!< Flash Address */
N
N/******************  Bit definition for FLASH_OBR register  *******************/
N#define FLASH_OBR_OPTERR_Pos              (0U)                                 
N#define FLASH_OBR_OPTERR_Msk              (0x1U << FLASH_OBR_OPTERR_Pos)       /*!< 0x00000001 */
N#define FLASH_OBR_OPTERR                  FLASH_OBR_OPTERR_Msk                 /*!< Option Byte Error */
N#define FLASH_OBR_RDPRT1_Pos              (1U)                                 
N#define FLASH_OBR_RDPRT1_Msk              (0x1U << FLASH_OBR_RDPRT1_Pos)       /*!< 0x00000002 */
N#define FLASH_OBR_RDPRT1                  FLASH_OBR_RDPRT1_Msk                 /*!< Read protection Level 1 */
N#define FLASH_OBR_RDPRT2_Pos              (2U)                                 
N#define FLASH_OBR_RDPRT2_Msk              (0x1U << FLASH_OBR_RDPRT2_Pos)       /*!< 0x00000004 */
N#define FLASH_OBR_RDPRT2                  FLASH_OBR_RDPRT2_Msk                 /*!< Read protection Level 2 */
N
N#define FLASH_OBR_USER_Pos                (8U)                                 
N#define FLASH_OBR_USER_Msk                (0xFFU << FLASH_OBR_USER_Pos)        /*!< 0x0000FF00 */
N#define FLASH_OBR_USER                    FLASH_OBR_USER_Msk                   /*!< User Option Bytes */
N#define FLASH_OBR_IWDG_SW_Pos             (8U)                                 
N#define FLASH_OBR_IWDG_SW_Msk             (0x1U << FLASH_OBR_IWDG_SW_Pos)      /*!< 0x00000100 */
N#define FLASH_OBR_IWDG_SW                 FLASH_OBR_IWDG_SW_Msk                /*!< IWDG SW */
N#define FLASH_OBR_nRST_STOP_Pos           (9U)                                 
N#define FLASH_OBR_nRST_STOP_Msk           (0x1U << FLASH_OBR_nRST_STOP_Pos)    /*!< 0x00000200 */
N#define FLASH_OBR_nRST_STOP               FLASH_OBR_nRST_STOP_Msk              /*!< nRST_STOP */
N#define FLASH_OBR_nRST_STDBY_Pos          (10U)                                
N#define FLASH_OBR_nRST_STDBY_Msk          (0x1U << FLASH_OBR_nRST_STDBY_Pos)   /*!< 0x00000400 */
N#define FLASH_OBR_nRST_STDBY              FLASH_OBR_nRST_STDBY_Msk             /*!< nRST_STDBY */
N#define FLASH_OBR_nBOOT0_Pos              (11U)                                
N#define FLASH_OBR_nBOOT0_Msk              (0x1U << FLASH_OBR_nBOOT0_Pos)       /*!< 0x00000800 */
N#define FLASH_OBR_nBOOT0                  FLASH_OBR_nBOOT0_Msk                 /*!< nBOOT0 */
N#define FLASH_OBR_nBOOT1_Pos              (12U)                                
N#define FLASH_OBR_nBOOT1_Msk              (0x1U << FLASH_OBR_nBOOT1_Pos)       /*!< 0x00001000 */
N#define FLASH_OBR_nBOOT1                  FLASH_OBR_nBOOT1_Msk                 /*!< nBOOT1 */
N#define FLASH_OBR_VDDA_MONITOR_Pos        (13U)                                
N#define FLASH_OBR_VDDA_MONITOR_Msk        (0x1U << FLASH_OBR_VDDA_MONITOR_Pos) /*!< 0x00002000 */
N#define FLASH_OBR_VDDA_MONITOR            FLASH_OBR_VDDA_MONITOR_Msk           /*!< VDDA power supply supervisor */
N#define FLASH_OBR_RAM_PARITY_CHECK_Pos    (14U)                                
N#define FLASH_OBR_RAM_PARITY_CHECK_Msk    (0x1U << FLASH_OBR_RAM_PARITY_CHECK_Pos) /*!< 0x00004000 */
N#define FLASH_OBR_RAM_PARITY_CHECK        FLASH_OBR_RAM_PARITY_CHECK_Msk       /*!< RAM parity check */
N#define FLASH_OBR_BOOT_SEL_Pos            (15U)                                
N#define FLASH_OBR_BOOT_SEL_Msk            (0x1U << FLASH_OBR_BOOT_SEL_Pos)     /*!< 0x00008000 */
N#define FLASH_OBR_BOOT_SEL                FLASH_OBR_BOOT_SEL_Msk               /*!< BOOT selection */
N#define FLASH_OBR_DATA0_Pos               (16U)                                
N#define FLASH_OBR_DATA0_Msk               (0xFFU << FLASH_OBR_DATA0_Pos)       /*!< 0x00FF0000 */
N#define FLASH_OBR_DATA0                   FLASH_OBR_DATA0_Msk                  /*!< Data0 */
N#define FLASH_OBR_DATA1_Pos               (24U)                                
N#define FLASH_OBR_DATA1_Msk               (0xFFU << FLASH_OBR_DATA1_Pos)       /*!< 0xFF000000 */
N#define FLASH_OBR_DATA1                   FLASH_OBR_DATA1_Msk                  /*!< Data1 */
N
N/* Old BOOT1 bit definition, maintained for legacy purpose */
N#define FLASH_OBR_BOOT1                      FLASH_OBR_nBOOT1
N
N/* Old OBR_VDDA bit definition, maintained for legacy purpose */
N#define FLASH_OBR_VDDA_ANALOG                FLASH_OBR_VDDA_MONITOR
N
N/******************  Bit definition for FLASH_WRPR register  ******************/
N#define FLASH_WRPR_WRP_Pos                (0U)                                 
N#define FLASH_WRPR_WRP_Msk                (0xFFFFU << FLASH_WRPR_WRP_Pos)      /*!< 0x0000FFFF */
N#define FLASH_WRPR_WRP                    FLASH_WRPR_WRP_Msk                   /*!< Write Protect */
N
N/*----------------------------------------------------------------------------*/
N
N/******************  Bit definition for OB_RDP register  **********************/
N#define OB_RDP_RDP_Pos       (0U)                                              
N#define OB_RDP_RDP_Msk       (0xFFU << OB_RDP_RDP_Pos)                         /*!< 0x000000FF */
N#define OB_RDP_RDP           OB_RDP_RDP_Msk                                    /*!< Read protection option byte */
N#define OB_RDP_nRDP_Pos      (8U)                                              
N#define OB_RDP_nRDP_Msk      (0xFFU << OB_RDP_nRDP_Pos)                        /*!< 0x0000FF00 */
N#define OB_RDP_nRDP          OB_RDP_nRDP_Msk                                   /*!< Read protection complemented option byte */
N
N/******************  Bit definition for OB_USER register  *********************/
N#define OB_USER_USER_Pos     (16U)                                             
N#define OB_USER_USER_Msk     (0xFFU << OB_USER_USER_Pos)                       /*!< 0x00FF0000 */
N#define OB_USER_USER         OB_USER_USER_Msk                                  /*!< User option byte */
N#define OB_USER_nUSER_Pos    (24U)                                             
N#define OB_USER_nUSER_Msk    (0xFFU << OB_USER_nUSER_Pos)                      /*!< 0xFF000000 */
N#define OB_USER_nUSER        OB_USER_nUSER_Msk                                 /*!< User complemented option byte */
N
N/******************  Bit definition for OB_WRP0 register  *********************/
N#define OB_WRP0_WRP0_Pos     (0U)                                              
N#define OB_WRP0_WRP0_Msk     (0xFFU << OB_WRP0_WRP0_Pos)                       /*!< 0x000000FF */
N#define OB_WRP0_WRP0         OB_WRP0_WRP0_Msk                                  /*!< Flash memory write protection option bytes */
N#define OB_WRP0_nWRP0_Pos    (8U)                                              
N#define OB_WRP0_nWRP0_Msk    (0xFFU << OB_WRP0_nWRP0_Pos)                      /*!< 0x0000FF00 */
N#define OB_WRP0_nWRP0        OB_WRP0_nWRP0_Msk                                 /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for OB_WRP1 register  *********************/
N#define OB_WRP1_WRP1_Pos     (16U)                                             
N#define OB_WRP1_WRP1_Msk     (0xFFU << OB_WRP1_WRP1_Pos)                       /*!< 0x00FF0000 */
N#define OB_WRP1_WRP1         OB_WRP1_WRP1_Msk                                  /*!< Flash memory write protection option bytes */
N#define OB_WRP1_nWRP1_Pos    (24U)                                             
N#define OB_WRP1_nWRP1_Msk    (0xFFU << OB_WRP1_nWRP1_Pos)                      /*!< 0xFF000000 */
N#define OB_WRP1_nWRP1        OB_WRP1_nWRP1_Msk                                 /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for OB_WRP2 register  *********************/
N#define OB_WRP2_WRP2_Pos     (0U)                                              
N#define OB_WRP2_WRP2_Msk     (0xFFU << OB_WRP2_WRP2_Pos)                       /*!< 0x000000FF */
N#define OB_WRP2_WRP2         OB_WRP2_WRP2_Msk                                  /*!< Flash memory write protection option bytes */
N#define OB_WRP2_nWRP2_Pos    (8U)                                              
N#define OB_WRP2_nWRP2_Msk    (0xFFU << OB_WRP2_nWRP2_Pos)                      /*!< 0x0000FF00 */
N#define OB_WRP2_nWRP2        OB_WRP2_nWRP2_Msk                                 /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for OB_WRP3 register  *********************/
N#define OB_WRP3_WRP3_Pos     (16U)                                             
N#define OB_WRP3_WRP3_Msk     (0xFFU << OB_WRP3_WRP3_Pos)                       /*!< 0x00FF0000 */
N#define OB_WRP3_WRP3         OB_WRP3_WRP3_Msk                                  /*!< Flash memory write protection option bytes */
N#define OB_WRP3_nWRP3_Pos    (24U)                                             
N#define OB_WRP3_nWRP3_Msk    (0xFFU << OB_WRP3_nWRP3_Pos)                      /*!< 0xFF000000 */
N#define OB_WRP3_nWRP3        OB_WRP3_nWRP3_Msk                                 /*!< Flash memory write protection complemented option bytes */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       General Purpose IOs (GPIO)                           */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for GPIO_MODER register  *****************/
N#define GPIO_MODER_MODER0_Pos           (0U)                                   
N#define GPIO_MODER_MODER0_Msk           (0x3U << GPIO_MODER_MODER0_Pos)        /*!< 0x00000003 */
N#define GPIO_MODER_MODER0               GPIO_MODER_MODER0_Msk                  
N#define GPIO_MODER_MODER0_0             (0x1U << GPIO_MODER_MODER0_Pos)        /*!< 0x00000001 */
N#define GPIO_MODER_MODER0_1             (0x2U << GPIO_MODER_MODER0_Pos)        /*!< 0x00000002 */
N#define GPIO_MODER_MODER1_Pos           (2U)                                   
N#define GPIO_MODER_MODER1_Msk           (0x3U << GPIO_MODER_MODER1_Pos)        /*!< 0x0000000C */
N#define GPIO_MODER_MODER1               GPIO_MODER_MODER1_Msk                  
N#define GPIO_MODER_MODER1_0             (0x1U << GPIO_MODER_MODER1_Pos)        /*!< 0x00000004 */
N#define GPIO_MODER_MODER1_1             (0x2U << GPIO_MODER_MODER1_Pos)        /*!< 0x00000008 */
N#define GPIO_MODER_MODER2_Pos           (4U)                                   
N#define GPIO_MODER_MODER2_Msk           (0x3U << GPIO_MODER_MODER2_Pos)        /*!< 0x00000030 */
N#define GPIO_MODER_MODER2               GPIO_MODER_MODER2_Msk                  
N#define GPIO_MODER_MODER2_0             (0x1U << GPIO_MODER_MODER2_Pos)        /*!< 0x00000010 */
N#define GPIO_MODER_MODER2_1             (0x2U << GPIO_MODER_MODER2_Pos)        /*!< 0x00000020 */
N#define GPIO_MODER_MODER3_Pos           (6U)                                   
N#define GPIO_MODER_MODER3_Msk           (0x3U << GPIO_MODER_MODER3_Pos)        /*!< 0x000000C0 */
N#define GPIO_MODER_MODER3               GPIO_MODER_MODER3_Msk                  
N#define GPIO_MODER_MODER3_0             (0x1U << GPIO_MODER_MODER3_Pos)        /*!< 0x00000040 */
N#define GPIO_MODER_MODER3_1             (0x2U << GPIO_MODER_MODER3_Pos)        /*!< 0x00000080 */
N#define GPIO_MODER_MODER4_Pos           (8U)                                   
N#define GPIO_MODER_MODER4_Msk           (0x3U << GPIO_MODER_MODER4_Pos)        /*!< 0x00000300 */
N#define GPIO_MODER_MODER4               GPIO_MODER_MODER4_Msk                  
N#define GPIO_MODER_MODER4_0             (0x1U << GPIO_MODER_MODER4_Pos)        /*!< 0x00000100 */
N#define GPIO_MODER_MODER4_1             (0x2U << GPIO_MODER_MODER4_Pos)        /*!< 0x00000200 */
N#define GPIO_MODER_MODER5_Pos           (10U)                                  
N#define GPIO_MODER_MODER5_Msk           (0x3U << GPIO_MODER_MODER5_Pos)        /*!< 0x00000C00 */
N#define GPIO_MODER_MODER5               GPIO_MODER_MODER5_Msk                  
N#define GPIO_MODER_MODER5_0             (0x1U << GPIO_MODER_MODER5_Pos)        /*!< 0x00000400 */
N#define GPIO_MODER_MODER5_1             (0x2U << GPIO_MODER_MODER5_Pos)        /*!< 0x00000800 */
N#define GPIO_MODER_MODER6_Pos           (12U)                                  
N#define GPIO_MODER_MODER6_Msk           (0x3U << GPIO_MODER_MODER6_Pos)        /*!< 0x00003000 */
N#define GPIO_MODER_MODER6               GPIO_MODER_MODER6_Msk                  
N#define GPIO_MODER_MODER6_0             (0x1U << GPIO_MODER_MODER6_Pos)        /*!< 0x00001000 */
N#define GPIO_MODER_MODER6_1             (0x2U << GPIO_MODER_MODER6_Pos)        /*!< 0x00002000 */
N#define GPIO_MODER_MODER7_Pos           (14U)                                  
N#define GPIO_MODER_MODER7_Msk           (0x3U << GPIO_MODER_MODER7_Pos)        /*!< 0x0000C000 */
N#define GPIO_MODER_MODER7               GPIO_MODER_MODER7_Msk                  
N#define GPIO_MODER_MODER7_0             (0x1U << GPIO_MODER_MODER7_Pos)        /*!< 0x00004000 */
N#define GPIO_MODER_MODER7_1             (0x2U << GPIO_MODER_MODER7_Pos)        /*!< 0x00008000 */
N#define GPIO_MODER_MODER8_Pos           (16U)                                  
N#define GPIO_MODER_MODER8_Msk           (0x3U << GPIO_MODER_MODER8_Pos)        /*!< 0x00030000 */
N#define GPIO_MODER_MODER8               GPIO_MODER_MODER8_Msk                  
N#define GPIO_MODER_MODER8_0             (0x1U << GPIO_MODER_MODER8_Pos)        /*!< 0x00010000 */
N#define GPIO_MODER_MODER8_1             (0x2U << GPIO_MODER_MODER8_Pos)        /*!< 0x00020000 */
N#define GPIO_MODER_MODER9_Pos           (18U)                                  
N#define GPIO_MODER_MODER9_Msk           (0x3U << GPIO_MODER_MODER9_Pos)        /*!< 0x000C0000 */
N#define GPIO_MODER_MODER9               GPIO_MODER_MODER9_Msk                  
N#define GPIO_MODER_MODER9_0             (0x1U << GPIO_MODER_MODER9_Pos)        /*!< 0x00040000 */
N#define GPIO_MODER_MODER9_1             (0x2U << GPIO_MODER_MODER9_Pos)        /*!< 0x00080000 */
N#define GPIO_MODER_MODER10_Pos          (20U)                                  
N#define GPIO_MODER_MODER10_Msk          (0x3U << GPIO_MODER_MODER10_Pos)       /*!< 0x00300000 */
N#define GPIO_MODER_MODER10              GPIO_MODER_MODER10_Msk                 
N#define GPIO_MODER_MODER10_0            (0x1U << GPIO_MODER_MODER10_Pos)       /*!< 0x00100000 */
N#define GPIO_MODER_MODER10_1            (0x2U << GPIO_MODER_MODER10_Pos)       /*!< 0x00200000 */
N#define GPIO_MODER_MODER11_Pos          (22U)                                  
N#define GPIO_MODER_MODER11_Msk          (0x3U << GPIO_MODER_MODER11_Pos)       /*!< 0x00C00000 */
N#define GPIO_MODER_MODER11              GPIO_MODER_MODER11_Msk                 
N#define GPIO_MODER_MODER11_0            (0x1U << GPIO_MODER_MODER11_Pos)       /*!< 0x00400000 */
N#define GPIO_MODER_MODER11_1            (0x2U << GPIO_MODER_MODER11_Pos)       /*!< 0x00800000 */
N#define GPIO_MODER_MODER12_Pos          (24U)                                  
N#define GPIO_MODER_MODER12_Msk          (0x3U << GPIO_MODER_MODER12_Pos)       /*!< 0x03000000 */
N#define GPIO_MODER_MODER12              GPIO_MODER_MODER12_Msk                 
N#define GPIO_MODER_MODER12_0            (0x1U << GPIO_MODER_MODER12_Pos)       /*!< 0x01000000 */
N#define GPIO_MODER_MODER12_1            (0x2U << GPIO_MODER_MODER12_Pos)       /*!< 0x02000000 */
N#define GPIO_MODER_MODER13_Pos          (26U)                                  
N#define GPIO_MODER_MODER13_Msk          (0x3U << GPIO_MODER_MODER13_Pos)       /*!< 0x0C000000 */
N#define GPIO_MODER_MODER13              GPIO_MODER_MODER13_Msk                 
N#define GPIO_MODER_MODER13_0            (0x1U << GPIO_MODER_MODER13_Pos)       /*!< 0x04000000 */
N#define GPIO_MODER_MODER13_1            (0x2U << GPIO_MODER_MODER13_Pos)       /*!< 0x08000000 */
N#define GPIO_MODER_MODER14_Pos          (28U)                                  
N#define GPIO_MODER_MODER14_Msk          (0x3U << GPIO_MODER_MODER14_Pos)       /*!< 0x30000000 */
N#define GPIO_MODER_MODER14              GPIO_MODER_MODER14_Msk                 
N#define GPIO_MODER_MODER14_0            (0x1U << GPIO_MODER_MODER14_Pos)       /*!< 0x10000000 */
N#define GPIO_MODER_MODER14_1            (0x2U << GPIO_MODER_MODER14_Pos)       /*!< 0x20000000 */
N#define GPIO_MODER_MODER15_Pos          (30U)                                  
N#define GPIO_MODER_MODER15_Msk          (0x3U << GPIO_MODER_MODER15_Pos)       /*!< 0xC0000000 */
N#define GPIO_MODER_MODER15              GPIO_MODER_MODER15_Msk                 
N#define GPIO_MODER_MODER15_0            (0x1U << GPIO_MODER_MODER15_Pos)       /*!< 0x40000000 */
N#define GPIO_MODER_MODER15_1            (0x2U << GPIO_MODER_MODER15_Pos)       /*!< 0x80000000 */
N
N/******************  Bit definition for GPIO_OTYPER register  *****************/
N#define GPIO_OTYPER_OT_0                (0x00000001U)                          
N#define GPIO_OTYPER_OT_1                (0x00000002U)                          
N#define GPIO_OTYPER_OT_2                (0x00000004U)                          
N#define GPIO_OTYPER_OT_3                (0x00000008U)                          
N#define GPIO_OTYPER_OT_4                (0x00000010U)                          
N#define GPIO_OTYPER_OT_5                (0x00000020U)                          
N#define GPIO_OTYPER_OT_6                (0x00000040U)                          
N#define GPIO_OTYPER_OT_7                (0x00000080U)                          
N#define GPIO_OTYPER_OT_8                (0x00000100U)                          
N#define GPIO_OTYPER_OT_9                (0x00000200U)                          
N#define GPIO_OTYPER_OT_10               (0x00000400U)                          
N#define GPIO_OTYPER_OT_11               (0x00000800U)                          
N#define GPIO_OTYPER_OT_12               (0x00001000U)                          
N#define GPIO_OTYPER_OT_13               (0x00002000U)                          
N#define GPIO_OTYPER_OT_14               (0x00004000U)                          
N#define GPIO_OTYPER_OT_15               (0x00008000U)                          
N
N/****************  Bit definition for GPIO_OSPEEDR register  ******************/
N#define GPIO_OSPEEDR_OSPEEDR0_Pos       (0U)                                   
N#define GPIO_OSPEEDR_OSPEEDR0_Msk       (0x3U << GPIO_OSPEEDR_OSPEEDR0_Pos)    /*!< 0x00000003 */
N#define GPIO_OSPEEDR_OSPEEDR0           GPIO_OSPEEDR_OSPEEDR0_Msk              
N#define GPIO_OSPEEDR_OSPEEDR0_0         (0x1U << GPIO_OSPEEDR_OSPEEDR0_Pos)    /*!< 0x00000001 */
N#define GPIO_OSPEEDR_OSPEEDR0_1         (0x2U << GPIO_OSPEEDR_OSPEEDR0_Pos)    /*!< 0x00000002 */
N#define GPIO_OSPEEDR_OSPEEDR1_Pos       (2U)                                   
N#define GPIO_OSPEEDR_OSPEEDR1_Msk       (0x3U << GPIO_OSPEEDR_OSPEEDR1_Pos)    /*!< 0x0000000C */
N#define GPIO_OSPEEDR_OSPEEDR1           GPIO_OSPEEDR_OSPEEDR1_Msk              
N#define GPIO_OSPEEDR_OSPEEDR1_0         (0x1U << GPIO_OSPEEDR_OSPEEDR1_Pos)    /*!< 0x00000004 */
N#define GPIO_OSPEEDR_OSPEEDR1_1         (0x2U << GPIO_OSPEEDR_OSPEEDR1_Pos)    /*!< 0x00000008 */
N#define GPIO_OSPEEDR_OSPEEDR2_Pos       (4U)                                   
N#define GPIO_OSPEEDR_OSPEEDR2_Msk       (0x3U << GPIO_OSPEEDR_OSPEEDR2_Pos)    /*!< 0x00000030 */
N#define GPIO_OSPEEDR_OSPEEDR2           GPIO_OSPEEDR_OSPEEDR2_Msk              
N#define GPIO_OSPEEDR_OSPEEDR2_0         (0x1U << GPIO_OSPEEDR_OSPEEDR2_Pos)    /*!< 0x00000010 */
N#define GPIO_OSPEEDR_OSPEEDR2_1         (0x2U << GPIO_OSPEEDR_OSPEEDR2_Pos)    /*!< 0x00000020 */
N#define GPIO_OSPEEDR_OSPEEDR3_Pos       (6U)                                   
N#define GPIO_OSPEEDR_OSPEEDR3_Msk       (0x3U << GPIO_OSPEEDR_OSPEEDR3_Pos)    /*!< 0x000000C0 */
N#define GPIO_OSPEEDR_OSPEEDR3           GPIO_OSPEEDR_OSPEEDR3_Msk              
N#define GPIO_OSPEEDR_OSPEEDR3_0         (0x1U << GPIO_OSPEEDR_OSPEEDR3_Pos)    /*!< 0x00000040 */
N#define GPIO_OSPEEDR_OSPEEDR3_1         (0x2U << GPIO_OSPEEDR_OSPEEDR3_Pos)    /*!< 0x00000080 */
N#define GPIO_OSPEEDR_OSPEEDR4_Pos       (8U)                                   
N#define GPIO_OSPEEDR_OSPEEDR4_Msk       (0x3U << GPIO_OSPEEDR_OSPEEDR4_Pos)    /*!< 0x00000300 */
N#define GPIO_OSPEEDR_OSPEEDR4           GPIO_OSPEEDR_OSPEEDR4_Msk              
N#define GPIO_OSPEEDR_OSPEEDR4_0         (0x1U << GPIO_OSPEEDR_OSPEEDR4_Pos)    /*!< 0x00000100 */
N#define GPIO_OSPEEDR_OSPEEDR4_1         (0x2U << GPIO_OSPEEDR_OSPEEDR4_Pos)    /*!< 0x00000200 */
N#define GPIO_OSPEEDR_OSPEEDR5_Pos       (10U)                                  
N#define GPIO_OSPEEDR_OSPEEDR5_Msk       (0x3U << GPIO_OSPEEDR_OSPEEDR5_Pos)    /*!< 0x00000C00 */
N#define GPIO_OSPEEDR_OSPEEDR5           GPIO_OSPEEDR_OSPEEDR5_Msk              
N#define GPIO_OSPEEDR_OSPEEDR5_0         (0x1U << GPIO_OSPEEDR_OSPEEDR5_Pos)    /*!< 0x00000400 */
N#define GPIO_OSPEEDR_OSPEEDR5_1         (0x2U << GPIO_OSPEEDR_OSPEEDR5_Pos)    /*!< 0x00000800 */
N#define GPIO_OSPEEDR_OSPEEDR6_Pos       (12U)                                  
N#define GPIO_OSPEEDR_OSPEEDR6_Msk       (0x3U << GPIO_OSPEEDR_OSPEEDR6_Pos)    /*!< 0x00003000 */
N#define GPIO_OSPEEDR_OSPEEDR6           GPIO_OSPEEDR_OSPEEDR6_Msk              
N#define GPIO_OSPEEDR_OSPEEDR6_0         (0x1U << GPIO_OSPEEDR_OSPEEDR6_Pos)    /*!< 0x00001000 */
N#define GPIO_OSPEEDR_OSPEEDR6_1         (0x2U << GPIO_OSPEEDR_OSPEEDR6_Pos)    /*!< 0x00002000 */
N#define GPIO_OSPEEDR_OSPEEDR7_Pos       (14U)                                  
N#define GPIO_OSPEEDR_OSPEEDR7_Msk       (0x3U << GPIO_OSPEEDR_OSPEEDR7_Pos)    /*!< 0x0000C000 */
N#define GPIO_OSPEEDR_OSPEEDR7           GPIO_OSPEEDR_OSPEEDR7_Msk              
N#define GPIO_OSPEEDR_OSPEEDR7_0         (0x1U << GPIO_OSPEEDR_OSPEEDR7_Pos)    /*!< 0x00004000 */
N#define GPIO_OSPEEDR_OSPEEDR7_1         (0x2U << GPIO_OSPEEDR_OSPEEDR7_Pos)    /*!< 0x00008000 */
N#define GPIO_OSPEEDR_OSPEEDR8_Pos       (16U)                                  
N#define GPIO_OSPEEDR_OSPEEDR8_Msk       (0x3U << GPIO_OSPEEDR_OSPEEDR8_Pos)    /*!< 0x00030000 */
N#define GPIO_OSPEEDR_OSPEEDR8           GPIO_OSPEEDR_OSPEEDR8_Msk              
N#define GPIO_OSPEEDR_OSPEEDR8_0         (0x1U << GPIO_OSPEEDR_OSPEEDR8_Pos)    /*!< 0x00010000 */
N#define GPIO_OSPEEDR_OSPEEDR8_1         (0x2U << GPIO_OSPEEDR_OSPEEDR8_Pos)    /*!< 0x00020000 */
N#define GPIO_OSPEEDR_OSPEEDR9_Pos       (18U)                                  
N#define GPIO_OSPEEDR_OSPEEDR9_Msk       (0x3U << GPIO_OSPEEDR_OSPEEDR9_Pos)    /*!< 0x000C0000 */
N#define GPIO_OSPEEDR_OSPEEDR9           GPIO_OSPEEDR_OSPEEDR9_Msk              
N#define GPIO_OSPEEDR_OSPEEDR9_0         (0x1U << GPIO_OSPEEDR_OSPEEDR9_Pos)    /*!< 0x00040000 */
N#define GPIO_OSPEEDR_OSPEEDR9_1         (0x2U << GPIO_OSPEEDR_OSPEEDR9_Pos)    /*!< 0x00080000 */
N#define GPIO_OSPEEDR_OSPEEDR10_Pos      (20U)                                  
N#define GPIO_OSPEEDR_OSPEEDR10_Msk      (0x3U << GPIO_OSPEEDR_OSPEEDR10_Pos)   /*!< 0x00300000 */
N#define GPIO_OSPEEDR_OSPEEDR10          GPIO_OSPEEDR_OSPEEDR10_Msk             
N#define GPIO_OSPEEDR_OSPEEDR10_0        (0x1U << GPIO_OSPEEDR_OSPEEDR10_Pos)   /*!< 0x00100000 */
N#define GPIO_OSPEEDR_OSPEEDR10_1        (0x2U << GPIO_OSPEEDR_OSPEEDR10_Pos)   /*!< 0x00200000 */
N#define GPIO_OSPEEDR_OSPEEDR11_Pos      (22U)                                  
N#define GPIO_OSPEEDR_OSPEEDR11_Msk      (0x3U << GPIO_OSPEEDR_OSPEEDR11_Pos)   /*!< 0x00C00000 */
N#define GPIO_OSPEEDR_OSPEEDR11          GPIO_OSPEEDR_OSPEEDR11_Msk             
N#define GPIO_OSPEEDR_OSPEEDR11_0        (0x1U << GPIO_OSPEEDR_OSPEEDR11_Pos)   /*!< 0x00400000 */
N#define GPIO_OSPEEDR_OSPEEDR11_1        (0x2U << GPIO_OSPEEDR_OSPEEDR11_Pos)   /*!< 0x00800000 */
N#define GPIO_OSPEEDR_OSPEEDR12_Pos      (24U)                                  
N#define GPIO_OSPEEDR_OSPEEDR12_Msk      (0x3U << GPIO_OSPEEDR_OSPEEDR12_Pos)   /*!< 0x03000000 */
N#define GPIO_OSPEEDR_OSPEEDR12          GPIO_OSPEEDR_OSPEEDR12_Msk             
N#define GPIO_OSPEEDR_OSPEEDR12_0        (0x1U << GPIO_OSPEEDR_OSPEEDR12_Pos)   /*!< 0x01000000 */
N#define GPIO_OSPEEDR_OSPEEDR12_1        (0x2U << GPIO_OSPEEDR_OSPEEDR12_Pos)   /*!< 0x02000000 */
N#define GPIO_OSPEEDR_OSPEEDR13_Pos      (26U)                                  
N#define GPIO_OSPEEDR_OSPEEDR13_Msk      (0x3U << GPIO_OSPEEDR_OSPEEDR13_Pos)   /*!< 0x0C000000 */
N#define GPIO_OSPEEDR_OSPEEDR13          GPIO_OSPEEDR_OSPEEDR13_Msk             
N#define GPIO_OSPEEDR_OSPEEDR13_0        (0x1U << GPIO_OSPEEDR_OSPEEDR13_Pos)   /*!< 0x04000000 */
N#define GPIO_OSPEEDR_OSPEEDR13_1        (0x2U << GPIO_OSPEEDR_OSPEEDR13_Pos)   /*!< 0x08000000 */
N#define GPIO_OSPEEDR_OSPEEDR14_Pos      (28U)                                  
N#define GPIO_OSPEEDR_OSPEEDR14_Msk      (0x3U << GPIO_OSPEEDR_OSPEEDR14_Pos)   /*!< 0x30000000 */
N#define GPIO_OSPEEDR_OSPEEDR14          GPIO_OSPEEDR_OSPEEDR14_Msk             
N#define GPIO_OSPEEDR_OSPEEDR14_0        (0x1U << GPIO_OSPEEDR_OSPEEDR14_Pos)   /*!< 0x10000000 */
N#define GPIO_OSPEEDR_OSPEEDR14_1        (0x2U << GPIO_OSPEEDR_OSPEEDR14_Pos)   /*!< 0x20000000 */
N#define GPIO_OSPEEDR_OSPEEDR15_Pos      (30U)                                  
N#define GPIO_OSPEEDR_OSPEEDR15_Msk      (0x3U << GPIO_OSPEEDR_OSPEEDR15_Pos)   /*!< 0xC0000000 */
N#define GPIO_OSPEEDR_OSPEEDR15          GPIO_OSPEEDR_OSPEEDR15_Msk             
N#define GPIO_OSPEEDR_OSPEEDR15_0        (0x1U << GPIO_OSPEEDR_OSPEEDR15_Pos)   /*!< 0x40000000 */
N#define GPIO_OSPEEDR_OSPEEDR15_1        (0x2U << GPIO_OSPEEDR_OSPEEDR15_Pos)   /*!< 0x80000000 */
N
N/* Old Bit definition for GPIO_OSPEEDR register maintained for legacy purpose */
N#define GPIO_OSPEEDER_OSPEEDR0     GPIO_OSPEEDR_OSPEEDR0
N#define GPIO_OSPEEDER_OSPEEDR0_0   GPIO_OSPEEDR_OSPEEDR0_0
N#define GPIO_OSPEEDER_OSPEEDR0_1   GPIO_OSPEEDR_OSPEEDR0_1
N#define GPIO_OSPEEDER_OSPEEDR1     GPIO_OSPEEDR_OSPEEDR1
N#define GPIO_OSPEEDER_OSPEEDR1_0   GPIO_OSPEEDR_OSPEEDR1_0
N#define GPIO_OSPEEDER_OSPEEDR1_1   GPIO_OSPEEDR_OSPEEDR1_1
N#define GPIO_OSPEEDER_OSPEEDR2     GPIO_OSPEEDR_OSPEEDR2
N#define GPIO_OSPEEDER_OSPEEDR2_0   GPIO_OSPEEDR_OSPEEDR2_0
N#define GPIO_OSPEEDER_OSPEEDR2_1   GPIO_OSPEEDR_OSPEEDR2_1
N#define GPIO_OSPEEDER_OSPEEDR3     GPIO_OSPEEDR_OSPEEDR3
N#define GPIO_OSPEEDER_OSPEEDR3_0   GPIO_OSPEEDR_OSPEEDR3_0
N#define GPIO_OSPEEDER_OSPEEDR3_1   GPIO_OSPEEDR_OSPEEDR3_1
N#define GPIO_OSPEEDER_OSPEEDR4     GPIO_OSPEEDR_OSPEEDR4
N#define GPIO_OSPEEDER_OSPEEDR4_0   GPIO_OSPEEDR_OSPEEDR4_0
N#define GPIO_OSPEEDER_OSPEEDR4_1   GPIO_OSPEEDR_OSPEEDR4_1
N#define GPIO_OSPEEDER_OSPEEDR5     GPIO_OSPEEDR_OSPEEDR5
N#define GPIO_OSPEEDER_OSPEEDR5_0   GPIO_OSPEEDR_OSPEEDR5_0
N#define GPIO_OSPEEDER_OSPEEDR5_1   GPIO_OSPEEDR_OSPEEDR5_1
N#define GPIO_OSPEEDER_OSPEEDR6     GPIO_OSPEEDR_OSPEEDR6
N#define GPIO_OSPEEDER_OSPEEDR6_0   GPIO_OSPEEDR_OSPEEDR6_0
N#define GPIO_OSPEEDER_OSPEEDR6_1   GPIO_OSPEEDR_OSPEEDR6_1
N#define GPIO_OSPEEDER_OSPEEDR7     GPIO_OSPEEDR_OSPEEDR7
N#define GPIO_OSPEEDER_OSPEEDR7_0   GPIO_OSPEEDR_OSPEEDR7_0
N#define GPIO_OSPEEDER_OSPEEDR7_1   GPIO_OSPEEDR_OSPEEDR7_1
N#define GPIO_OSPEEDER_OSPEEDR8     GPIO_OSPEEDR_OSPEEDR8
N#define GPIO_OSPEEDER_OSPEEDR8_0   GPIO_OSPEEDR_OSPEEDR8_0
N#define GPIO_OSPEEDER_OSPEEDR8_1   GPIO_OSPEEDR_OSPEEDR8_1
N#define GPIO_OSPEEDER_OSPEEDR9     GPIO_OSPEEDR_OSPEEDR9
N#define GPIO_OSPEEDER_OSPEEDR9_0   GPIO_OSPEEDR_OSPEEDR9_0
N#define GPIO_OSPEEDER_OSPEEDR9_1   GPIO_OSPEEDR_OSPEEDR9_1
N#define GPIO_OSPEEDER_OSPEEDR10    GPIO_OSPEEDR_OSPEEDR10
N#define GPIO_OSPEEDER_OSPEEDR10_0  GPIO_OSPEEDR_OSPEEDR10_0
N#define GPIO_OSPEEDER_OSPEEDR10_1  GPIO_OSPEEDR_OSPEEDR10_1
N#define GPIO_OSPEEDER_OSPEEDR11    GPIO_OSPEEDR_OSPEEDR11
N#define GPIO_OSPEEDER_OSPEEDR11_0  GPIO_OSPEEDR_OSPEEDR11_0
N#define GPIO_OSPEEDER_OSPEEDR11_1  GPIO_OSPEEDR_OSPEEDR11_1
N#define GPIO_OSPEEDER_OSPEEDR12    GPIO_OSPEEDR_OSPEEDR12
N#define GPIO_OSPEEDER_OSPEEDR12_0  GPIO_OSPEEDR_OSPEEDR12_0
N#define GPIO_OSPEEDER_OSPEEDR12_1  GPIO_OSPEEDR_OSPEEDR12_1
N#define GPIO_OSPEEDER_OSPEEDR13    GPIO_OSPEEDR_OSPEEDR13
N#define GPIO_OSPEEDER_OSPEEDR13_0  GPIO_OSPEEDR_OSPEEDR13_0
N#define GPIO_OSPEEDER_OSPEEDR13_1  GPIO_OSPEEDR_OSPEEDR13_1
N#define GPIO_OSPEEDER_OSPEEDR14    GPIO_OSPEEDR_OSPEEDR14
N#define GPIO_OSPEEDER_OSPEEDR14_0  GPIO_OSPEEDR_OSPEEDR14_0
N#define GPIO_OSPEEDER_OSPEEDR14_1  GPIO_OSPEEDR_OSPEEDR14_1
N#define GPIO_OSPEEDER_OSPEEDR15    GPIO_OSPEEDR_OSPEEDR15
N#define GPIO_OSPEEDER_OSPEEDR15_0  GPIO_OSPEEDR_OSPEEDR15_0
N#define GPIO_OSPEEDER_OSPEEDR15_1  GPIO_OSPEEDR_OSPEEDR15_1
N
N/*******************  Bit definition for GPIO_PUPDR register ******************/
N#define GPIO_PUPDR_PUPDR0_Pos           (0U)                                   
N#define GPIO_PUPDR_PUPDR0_Msk           (0x3U << GPIO_PUPDR_PUPDR0_Pos)        /*!< 0x00000003 */
N#define GPIO_PUPDR_PUPDR0               GPIO_PUPDR_PUPDR0_Msk                  
N#define GPIO_PUPDR_PUPDR0_0             (0x1U << GPIO_PUPDR_PUPDR0_Pos)        /*!< 0x00000001 */
N#define GPIO_PUPDR_PUPDR0_1             (0x2U << GPIO_PUPDR_PUPDR0_Pos)        /*!< 0x00000002 */
N#define GPIO_PUPDR_PUPDR1_Pos           (2U)                                   
N#define GPIO_PUPDR_PUPDR1_Msk           (0x3U << GPIO_PUPDR_PUPDR1_Pos)        /*!< 0x0000000C */
N#define GPIO_PUPDR_PUPDR1               GPIO_PUPDR_PUPDR1_Msk                  
N#define GPIO_PUPDR_PUPDR1_0             (0x1U << GPIO_PUPDR_PUPDR1_Pos)        /*!< 0x00000004 */
N#define GPIO_PUPDR_PUPDR1_1             (0x2U << GPIO_PUPDR_PUPDR1_Pos)        /*!< 0x00000008 */
N#define GPIO_PUPDR_PUPDR2_Pos           (4U)                                   
N#define GPIO_PUPDR_PUPDR2_Msk           (0x3U << GPIO_PUPDR_PUPDR2_Pos)        /*!< 0x00000030 */
N#define GPIO_PUPDR_PUPDR2               GPIO_PUPDR_PUPDR2_Msk                  
N#define GPIO_PUPDR_PUPDR2_0             (0x1U << GPIO_PUPDR_PUPDR2_Pos)        /*!< 0x00000010 */
N#define GPIO_PUPDR_PUPDR2_1             (0x2U << GPIO_PUPDR_PUPDR2_Pos)        /*!< 0x00000020 */
N#define GPIO_PUPDR_PUPDR3_Pos           (6U)                                   
N#define GPIO_PUPDR_PUPDR3_Msk           (0x3U << GPIO_PUPDR_PUPDR3_Pos)        /*!< 0x000000C0 */
N#define GPIO_PUPDR_PUPDR3               GPIO_PUPDR_PUPDR3_Msk                  
N#define GPIO_PUPDR_PUPDR3_0             (0x1U << GPIO_PUPDR_PUPDR3_Pos)        /*!< 0x00000040 */
N#define GPIO_PUPDR_PUPDR3_1             (0x2U << GPIO_PUPDR_PUPDR3_Pos)        /*!< 0x00000080 */
N#define GPIO_PUPDR_PUPDR4_Pos           (8U)                                   
N#define GPIO_PUPDR_PUPDR4_Msk           (0x3U << GPIO_PUPDR_PUPDR4_Pos)        /*!< 0x00000300 */
N#define GPIO_PUPDR_PUPDR4               GPIO_PUPDR_PUPDR4_Msk                  
N#define GPIO_PUPDR_PUPDR4_0             (0x1U << GPIO_PUPDR_PUPDR4_Pos)        /*!< 0x00000100 */
N#define GPIO_PUPDR_PUPDR4_1             (0x2U << GPIO_PUPDR_PUPDR4_Pos)        /*!< 0x00000200 */
N#define GPIO_PUPDR_PUPDR5_Pos           (10U)                                  
N#define GPIO_PUPDR_PUPDR5_Msk           (0x3U << GPIO_PUPDR_PUPDR5_Pos)        /*!< 0x00000C00 */
N#define GPIO_PUPDR_PUPDR5               GPIO_PUPDR_PUPDR5_Msk                  
N#define GPIO_PUPDR_PUPDR5_0             (0x1U << GPIO_PUPDR_PUPDR5_Pos)        /*!< 0x00000400 */
N#define GPIO_PUPDR_PUPDR5_1             (0x2U << GPIO_PUPDR_PUPDR5_Pos)        /*!< 0x00000800 */
N#define GPIO_PUPDR_PUPDR6_Pos           (12U)                                  
N#define GPIO_PUPDR_PUPDR6_Msk           (0x3U << GPIO_PUPDR_PUPDR6_Pos)        /*!< 0x00003000 */
N#define GPIO_PUPDR_PUPDR6               GPIO_PUPDR_PUPDR6_Msk                  
N#define GPIO_PUPDR_PUPDR6_0             (0x1U << GPIO_PUPDR_PUPDR6_Pos)        /*!< 0x00001000 */
N#define GPIO_PUPDR_PUPDR6_1             (0x2U << GPIO_PUPDR_PUPDR6_Pos)        /*!< 0x00002000 */
N#define GPIO_PUPDR_PUPDR7_Pos           (14U)                                  
N#define GPIO_PUPDR_PUPDR7_Msk           (0x3U << GPIO_PUPDR_PUPDR7_Pos)        /*!< 0x0000C000 */
N#define GPIO_PUPDR_PUPDR7               GPIO_PUPDR_PUPDR7_Msk                  
N#define GPIO_PUPDR_PUPDR7_0             (0x1U << GPIO_PUPDR_PUPDR7_Pos)        /*!< 0x00004000 */
N#define GPIO_PUPDR_PUPDR7_1             (0x2U << GPIO_PUPDR_PUPDR7_Pos)        /*!< 0x00008000 */
N#define GPIO_PUPDR_PUPDR8_Pos           (16U)                                  
N#define GPIO_PUPDR_PUPDR8_Msk           (0x3U << GPIO_PUPDR_PUPDR8_Pos)        /*!< 0x00030000 */
N#define GPIO_PUPDR_PUPDR8               GPIO_PUPDR_PUPDR8_Msk                  
N#define GPIO_PUPDR_PUPDR8_0             (0x1U << GPIO_PUPDR_PUPDR8_Pos)        /*!< 0x00010000 */
N#define GPIO_PUPDR_PUPDR8_1             (0x2U << GPIO_PUPDR_PUPDR8_Pos)        /*!< 0x00020000 */
N#define GPIO_PUPDR_PUPDR9_Pos           (18U)                                  
N#define GPIO_PUPDR_PUPDR9_Msk           (0x3U << GPIO_PUPDR_PUPDR9_Pos)        /*!< 0x000C0000 */
N#define GPIO_PUPDR_PUPDR9               GPIO_PUPDR_PUPDR9_Msk                  
N#define GPIO_PUPDR_PUPDR9_0             (0x1U << GPIO_PUPDR_PUPDR9_Pos)        /*!< 0x00040000 */
N#define GPIO_PUPDR_PUPDR9_1             (0x2U << GPIO_PUPDR_PUPDR9_Pos)        /*!< 0x00080000 */
N#define GPIO_PUPDR_PUPDR10_Pos          (20U)                                  
N#define GPIO_PUPDR_PUPDR10_Msk          (0x3U << GPIO_PUPDR_PUPDR10_Pos)       /*!< 0x00300000 */
N#define GPIO_PUPDR_PUPDR10              GPIO_PUPDR_PUPDR10_Msk                 
N#define GPIO_PUPDR_PUPDR10_0            (0x1U << GPIO_PUPDR_PUPDR10_Pos)       /*!< 0x00100000 */
N#define GPIO_PUPDR_PUPDR10_1            (0x2U << GPIO_PUPDR_PUPDR10_Pos)       /*!< 0x00200000 */
N#define GPIO_PUPDR_PUPDR11_Pos          (22U)                                  
N#define GPIO_PUPDR_PUPDR11_Msk          (0x3U << GPIO_PUPDR_PUPDR11_Pos)       /*!< 0x00C00000 */
N#define GPIO_PUPDR_PUPDR11              GPIO_PUPDR_PUPDR11_Msk                 
N#define GPIO_PUPDR_PUPDR11_0            (0x1U << GPIO_PUPDR_PUPDR11_Pos)       /*!< 0x00400000 */
N#define GPIO_PUPDR_PUPDR11_1            (0x2U << GPIO_PUPDR_PUPDR11_Pos)       /*!< 0x00800000 */
N#define GPIO_PUPDR_PUPDR12_Pos          (24U)                                  
N#define GPIO_PUPDR_PUPDR12_Msk          (0x3U << GPIO_PUPDR_PUPDR12_Pos)       /*!< 0x03000000 */
N#define GPIO_PUPDR_PUPDR12              GPIO_PUPDR_PUPDR12_Msk                 
N#define GPIO_PUPDR_PUPDR12_0            (0x1U << GPIO_PUPDR_PUPDR12_Pos)       /*!< 0x01000000 */
N#define GPIO_PUPDR_PUPDR12_1            (0x2U << GPIO_PUPDR_PUPDR12_Pos)       /*!< 0x02000000 */
N#define GPIO_PUPDR_PUPDR13_Pos          (26U)                                  
N#define GPIO_PUPDR_PUPDR13_Msk          (0x3U << GPIO_PUPDR_PUPDR13_Pos)       /*!< 0x0C000000 */
N#define GPIO_PUPDR_PUPDR13              GPIO_PUPDR_PUPDR13_Msk                 
N#define GPIO_PUPDR_PUPDR13_0            (0x1U << GPIO_PUPDR_PUPDR13_Pos)       /*!< 0x04000000 */
N#define GPIO_PUPDR_PUPDR13_1            (0x2U << GPIO_PUPDR_PUPDR13_Pos)       /*!< 0x08000000 */
N#define GPIO_PUPDR_PUPDR14_Pos          (28U)                                  
N#define GPIO_PUPDR_PUPDR14_Msk          (0x3U << GPIO_PUPDR_PUPDR14_Pos)       /*!< 0x30000000 */
N#define GPIO_PUPDR_PUPDR14              GPIO_PUPDR_PUPDR14_Msk                 
N#define GPIO_PUPDR_PUPDR14_0            (0x1U << GPIO_PUPDR_PUPDR14_Pos)       /*!< 0x10000000 */
N#define GPIO_PUPDR_PUPDR14_1            (0x2U << GPIO_PUPDR_PUPDR14_Pos)       /*!< 0x20000000 */
N#define GPIO_PUPDR_PUPDR15_Pos          (30U)                                  
N#define GPIO_PUPDR_PUPDR15_Msk          (0x3U << GPIO_PUPDR_PUPDR15_Pos)       /*!< 0xC0000000 */
N#define GPIO_PUPDR_PUPDR15              GPIO_PUPDR_PUPDR15_Msk                 
N#define GPIO_PUPDR_PUPDR15_0            (0x1U << GPIO_PUPDR_PUPDR15_Pos)       /*!< 0x40000000 */
N#define GPIO_PUPDR_PUPDR15_1            (0x2U << GPIO_PUPDR_PUPDR15_Pos)       /*!< 0x80000000 */
N
N/*******************  Bit definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_0                      (0x00000001U)                          
N#define GPIO_IDR_1                      (0x00000002U)                          
N#define GPIO_IDR_2                      (0x00000004U)                          
N#define GPIO_IDR_3                      (0x00000008U)                          
N#define GPIO_IDR_4                      (0x00000010U)                          
N#define GPIO_IDR_5                      (0x00000020U)                          
N#define GPIO_IDR_6                      (0x00000040U)                          
N#define GPIO_IDR_7                      (0x00000080U)                          
N#define GPIO_IDR_8                      (0x00000100U)                          
N#define GPIO_IDR_9                      (0x00000200U)                          
N#define GPIO_IDR_10                     (0x00000400U)                          
N#define GPIO_IDR_11                     (0x00000800U)                          
N#define GPIO_IDR_12                     (0x00001000U)                          
N#define GPIO_IDR_13                     (0x00002000U)                          
N#define GPIO_IDR_14                     (0x00004000U)                          
N#define GPIO_IDR_15                     (0x00008000U)                          
N
N/******************  Bit definition for GPIO_ODR register  ********************/
N#define GPIO_ODR_0                      (0x00000001U)                          
N#define GPIO_ODR_1                      (0x00000002U)                          
N#define GPIO_ODR_2                      (0x00000004U)                          
N#define GPIO_ODR_3                      (0x00000008U)                          
N#define GPIO_ODR_4                      (0x00000010U)                          
N#define GPIO_ODR_5                      (0x00000020U)                          
N#define GPIO_ODR_6                      (0x00000040U)                          
N#define GPIO_ODR_7                      (0x00000080U)                          
N#define GPIO_ODR_8                      (0x00000100U)                          
N#define GPIO_ODR_9                      (0x00000200U)                          
N#define GPIO_ODR_10                     (0x00000400U)                          
N#define GPIO_ODR_11                     (0x00000800U)                          
N#define GPIO_ODR_12                     (0x00001000U)                          
N#define GPIO_ODR_13                     (0x00002000U)                          
N#define GPIO_ODR_14                     (0x00004000U)                          
N#define GPIO_ODR_15                     (0x00008000U)                          
N
N/****************** Bit definition for GPIO_BSRR register  ********************/
N#define GPIO_BSRR_BS_0                  (0x00000001U)                          
N#define GPIO_BSRR_BS_1                  (0x00000002U)                          
N#define GPIO_BSRR_BS_2                  (0x00000004U)                          
N#define GPIO_BSRR_BS_3                  (0x00000008U)                          
N#define GPIO_BSRR_BS_4                  (0x00000010U)                          
N#define GPIO_BSRR_BS_5                  (0x00000020U)                          
N#define GPIO_BSRR_BS_6                  (0x00000040U)                          
N#define GPIO_BSRR_BS_7                  (0x00000080U)                          
N#define GPIO_BSRR_BS_8                  (0x00000100U)                          
N#define GPIO_BSRR_BS_9                  (0x00000200U)                          
N#define GPIO_BSRR_BS_10                 (0x00000400U)                          
N#define GPIO_BSRR_BS_11                 (0x00000800U)                          
N#define GPIO_BSRR_BS_12                 (0x00001000U)                          
N#define GPIO_BSRR_BS_13                 (0x00002000U)                          
N#define GPIO_BSRR_BS_14                 (0x00004000U)                          
N#define GPIO_BSRR_BS_15                 (0x00008000U)                          
N#define GPIO_BSRR_BR_0                  (0x00010000U)                          
N#define GPIO_BSRR_BR_1                  (0x00020000U)                          
N#define GPIO_BSRR_BR_2                  (0x00040000U)                          
N#define GPIO_BSRR_BR_3                  (0x00080000U)                          
N#define GPIO_BSRR_BR_4                  (0x00100000U)                          
N#define GPIO_BSRR_BR_5                  (0x00200000U)                          
N#define GPIO_BSRR_BR_6                  (0x00400000U)                          
N#define GPIO_BSRR_BR_7                  (0x00800000U)                          
N#define GPIO_BSRR_BR_8                  (0x01000000U)                          
N#define GPIO_BSRR_BR_9                  (0x02000000U)                          
N#define GPIO_BSRR_BR_10                 (0x04000000U)                          
N#define GPIO_BSRR_BR_11                 (0x08000000U)                          
N#define GPIO_BSRR_BR_12                 (0x10000000U)                          
N#define GPIO_BSRR_BR_13                 (0x20000000U)                          
N#define GPIO_BSRR_BR_14                 (0x40000000U)                          
N#define GPIO_BSRR_BR_15                 (0x80000000U)                          
N
N/****************** Bit definition for GPIO_LCKR register  ********************/
N#define GPIO_LCKR_LCK0_Pos              (0U)                                   
N#define GPIO_LCKR_LCK0_Msk              (0x1U << GPIO_LCKR_LCK0_Pos)           /*!< 0x00000001 */
N#define GPIO_LCKR_LCK0                  GPIO_LCKR_LCK0_Msk                     
N#define GPIO_LCKR_LCK1_Pos              (1U)                                   
N#define GPIO_LCKR_LCK1_Msk              (0x1U << GPIO_LCKR_LCK1_Pos)           /*!< 0x00000002 */
N#define GPIO_LCKR_LCK1                  GPIO_LCKR_LCK1_Msk                     
N#define GPIO_LCKR_LCK2_Pos              (2U)                                   
N#define GPIO_LCKR_LCK2_Msk              (0x1U << GPIO_LCKR_LCK2_Pos)           /*!< 0x00000004 */
N#define GPIO_LCKR_LCK2                  GPIO_LCKR_LCK2_Msk                     
N#define GPIO_LCKR_LCK3_Pos              (3U)                                   
N#define GPIO_LCKR_LCK3_Msk              (0x1U << GPIO_LCKR_LCK3_Pos)           /*!< 0x00000008 */
N#define GPIO_LCKR_LCK3                  GPIO_LCKR_LCK3_Msk                     
N#define GPIO_LCKR_LCK4_Pos              (4U)                                   
N#define GPIO_LCKR_LCK4_Msk              (0x1U << GPIO_LCKR_LCK4_Pos)           /*!< 0x00000010 */
N#define GPIO_LCKR_LCK4                  GPIO_LCKR_LCK4_Msk                     
N#define GPIO_LCKR_LCK5_Pos              (5U)                                   
N#define GPIO_LCKR_LCK5_Msk              (0x1U << GPIO_LCKR_LCK5_Pos)           /*!< 0x00000020 */
N#define GPIO_LCKR_LCK5                  GPIO_LCKR_LCK5_Msk                     
N#define GPIO_LCKR_LCK6_Pos              (6U)                                   
N#define GPIO_LCKR_LCK6_Msk              (0x1U << GPIO_LCKR_LCK6_Pos)           /*!< 0x00000040 */
N#define GPIO_LCKR_LCK6                  GPIO_LCKR_LCK6_Msk                     
N#define GPIO_LCKR_LCK7_Pos              (7U)                                   
N#define GPIO_LCKR_LCK7_Msk              (0x1U << GPIO_LCKR_LCK7_Pos)           /*!< 0x00000080 */
N#define GPIO_LCKR_LCK7                  GPIO_LCKR_LCK7_Msk                     
N#define GPIO_LCKR_LCK8_Pos              (8U)                                   
N#define GPIO_LCKR_LCK8_Msk              (0x1U << GPIO_LCKR_LCK8_Pos)           /*!< 0x00000100 */
N#define GPIO_LCKR_LCK8                  GPIO_LCKR_LCK8_Msk                     
N#define GPIO_LCKR_LCK9_Pos              (9U)                                   
N#define GPIO_LCKR_LCK9_Msk              (0x1U << GPIO_LCKR_LCK9_Pos)           /*!< 0x00000200 */
N#define GPIO_LCKR_LCK9                  GPIO_LCKR_LCK9_Msk                     
N#define GPIO_LCKR_LCK10_Pos             (10U)                                  
N#define GPIO_LCKR_LCK10_Msk             (0x1U << GPIO_LCKR_LCK10_Pos)          /*!< 0x00000400 */
N#define GPIO_LCKR_LCK10                 GPIO_LCKR_LCK10_Msk                    
N#define GPIO_LCKR_LCK11_Pos             (11U)                                  
N#define GPIO_LCKR_LCK11_Msk             (0x1U << GPIO_LCKR_LCK11_Pos)          /*!< 0x00000800 */
N#define GPIO_LCKR_LCK11                 GPIO_LCKR_LCK11_Msk                    
N#define GPIO_LCKR_LCK12_Pos             (12U)                                  
N#define GPIO_LCKR_LCK12_Msk             (0x1U << GPIO_LCKR_LCK12_Pos)          /*!< 0x00001000 */
N#define GPIO_LCKR_LCK12                 GPIO_LCKR_LCK12_Msk                    
N#define GPIO_LCKR_LCK13_Pos             (13U)                                  
N#define GPIO_LCKR_LCK13_Msk             (0x1U << GPIO_LCKR_LCK13_Pos)          /*!< 0x00002000 */
N#define GPIO_LCKR_LCK13                 GPIO_LCKR_LCK13_Msk                    
N#define GPIO_LCKR_LCK14_Pos             (14U)                                  
N#define GPIO_LCKR_LCK14_Msk             (0x1U << GPIO_LCKR_LCK14_Pos)          /*!< 0x00004000 */
N#define GPIO_LCKR_LCK14                 GPIO_LCKR_LCK14_Msk                    
N#define GPIO_LCKR_LCK15_Pos             (15U)                                  
N#define GPIO_LCKR_LCK15_Msk             (0x1U << GPIO_LCKR_LCK15_Pos)          /*!< 0x00008000 */
N#define GPIO_LCKR_LCK15                 GPIO_LCKR_LCK15_Msk                    
N#define GPIO_LCKR_LCKK_Pos              (16U)                                  
N#define GPIO_LCKR_LCKK_Msk              (0x1U << GPIO_LCKR_LCKK_Pos)           /*!< 0x00010000 */
N#define GPIO_LCKR_LCKK                  GPIO_LCKR_LCKK_Msk                     
N
N/****************** Bit definition for GPIO_AFRL register  ********************/
N#define GPIO_AFRL_AFSEL0_Pos            (0U)                                   
N#define GPIO_AFRL_AFSEL0_Msk            (0xFU << GPIO_AFRL_AFSEL0_Pos)         /*!< 0x0000000F */
N#define GPIO_AFRL_AFSEL0                GPIO_AFRL_AFSEL0_Msk                    
N#define GPIO_AFRL_AFSEL1_Pos            (4U)                                   
N#define GPIO_AFRL_AFSEL1_Msk            (0xFU << GPIO_AFRL_AFSEL1_Pos)         /*!< 0x000000F0 */
N#define GPIO_AFRL_AFSEL1                GPIO_AFRL_AFSEL1_Msk                    
N#define GPIO_AFRL_AFSEL2_Pos            (8U)                                   
N#define GPIO_AFRL_AFSEL2_Msk            (0xFU << GPIO_AFRL_AFSEL2_Pos)         /*!< 0x00000F00 */
N#define GPIO_AFRL_AFSEL2                GPIO_AFRL_AFSEL2_Msk                    
N#define GPIO_AFRL_AFSEL3_Pos            (12U)                                  
N#define GPIO_AFRL_AFSEL3_Msk            (0xFU << GPIO_AFRL_AFSEL3_Pos)         /*!< 0x0000F000 */
N#define GPIO_AFRL_AFSEL3                GPIO_AFRL_AFSEL3_Msk                    
N#define GPIO_AFRL_AFSEL4_Pos            (16U)                                  
N#define GPIO_AFRL_AFSEL4_Msk            (0xFU << GPIO_AFRL_AFSEL4_Pos)         /*!< 0x000F0000 */
N#define GPIO_AFRL_AFSEL4                GPIO_AFRL_AFSEL4_Msk                    
N#define GPIO_AFRL_AFSEL5_Pos            (20U)                                  
N#define GPIO_AFRL_AFSEL5_Msk            (0xFU << GPIO_AFRL_AFSEL5_Pos)         /*!< 0x00F00000 */
N#define GPIO_AFRL_AFSEL5                GPIO_AFRL_AFSEL5_Msk                    
N#define GPIO_AFRL_AFSEL6_Pos            (24U)                                  
N#define GPIO_AFRL_AFSEL6_Msk            (0xFU << GPIO_AFRL_AFSEL6_Pos)         /*!< 0x0F000000 */
N#define GPIO_AFRL_AFSEL6                GPIO_AFRL_AFSEL6_Msk                    
N#define GPIO_AFRL_AFSEL7_Pos            (28U)                                  
N#define GPIO_AFRL_AFSEL7_Msk            (0xFU << GPIO_AFRL_AFSEL7_Pos)         /*!< 0xF0000000 */
N#define GPIO_AFRL_AFSEL7                GPIO_AFRL_AFSEL7_Msk  
N
N/* Legacy aliases */                  
N#define GPIO_AFRL_AFRL0_Pos             GPIO_AFRL_AFSEL0_Pos                                  
N#define GPIO_AFRL_AFRL0_Msk             GPIO_AFRL_AFSEL0_Msk
N#define GPIO_AFRL_AFRL0                 GPIO_AFRL_AFSEL0
N#define GPIO_AFRL_AFRL1_Pos             GPIO_AFRL_AFSEL1_Pos
N#define GPIO_AFRL_AFRL1_Msk             GPIO_AFRL_AFSEL1_Msk
N#define GPIO_AFRL_AFRL1                 GPIO_AFRL_AFSEL1
N#define GPIO_AFRL_AFRL2_Pos             GPIO_AFRL_AFSEL2_Pos
N#define GPIO_AFRL_AFRL2_Msk             GPIO_AFRL_AFSEL2_Msk
N#define GPIO_AFRL_AFRL2                 GPIO_AFRL_AFSEL2
N#define GPIO_AFRL_AFRL3_Pos             GPIO_AFRL_AFSEL3_Pos
N#define GPIO_AFRL_AFRL3_Msk             GPIO_AFRL_AFSEL3_Msk
N#define GPIO_AFRL_AFRL3                 GPIO_AFRL_AFSEL3
N#define GPIO_AFRL_AFRL4_Pos             GPIO_AFRL_AFSEL4_Pos
N#define GPIO_AFRL_AFRL4_Msk             GPIO_AFRL_AFSEL4_Msk
N#define GPIO_AFRL_AFRL4                 GPIO_AFRL_AFSEL4
N#define GPIO_AFRL_AFRL5_Pos             GPIO_AFRL_AFSEL5_Pos
N#define GPIO_AFRL_AFRL5_Msk             GPIO_AFRL_AFSEL5_Msk
N#define GPIO_AFRL_AFRL5                 GPIO_AFRL_AFSEL5
N#define GPIO_AFRL_AFRL6_Pos             GPIO_AFRL_AFSEL6_Pos
N#define GPIO_AFRL_AFRL6_Msk             GPIO_AFRL_AFSEL6_Msk
N#define GPIO_AFRL_AFRL6                 GPIO_AFRL_AFSEL6
N#define GPIO_AFRL_AFRL7_Pos             GPIO_AFRL_AFSEL7_Pos
N#define GPIO_AFRL_AFRL7_Msk             GPIO_AFRL_AFSEL7_Msk
N#define GPIO_AFRL_AFRL7                 GPIO_AFRL_AFSEL7
N 
N/****************** Bit definition for GPIO_AFRH register  ********************/
N#define GPIO_AFRH_AFSEL8_Pos            (0U)                                   
N#define GPIO_AFRH_AFSEL8_Msk            (0xFU << GPIO_AFRH_AFSEL8_Pos)         /*!< 0x0000000F */
N#define GPIO_AFRH_AFSEL8                GPIO_AFRH_AFSEL8_Msk                    
N#define GPIO_AFRH_AFSEL9_Pos            (4U)                                   
N#define GPIO_AFRH_AFSEL9_Msk            (0xFU << GPIO_AFRH_AFSEL9_Pos)         /*!< 0x000000F0 */
N#define GPIO_AFRH_AFSEL9                GPIO_AFRH_AFSEL9_Msk                    
N#define GPIO_AFRH_AFSEL10_Pos           (8U)                                   
N#define GPIO_AFRH_AFSEL10_Msk           (0xFU << GPIO_AFRH_AFSEL10_Pos)        /*!< 0x00000F00 */
N#define GPIO_AFRH_AFSEL10               GPIO_AFRH_AFSEL10_Msk                    
N#define GPIO_AFRH_AFSEL11_Pos           (12U)                                  
N#define GPIO_AFRH_AFSEL11_Msk           (0xFU << GPIO_AFRH_AFSEL11_Pos)        /*!< 0x0000F000 */
N#define GPIO_AFRH_AFSEL11               GPIO_AFRH_AFSEL11_Msk                    
N#define GPIO_AFRH_AFSEL12_Pos           (16U)                                  
N#define GPIO_AFRH_AFSEL12_Msk           (0xFU << GPIO_AFRH_AFSEL12_Pos)        /*!< 0x000F0000 */
N#define GPIO_AFRH_AFSEL12               GPIO_AFRH_AFSEL12_Msk                    
N#define GPIO_AFRH_AFSEL13_Pos           (20U)                                  
N#define GPIO_AFRH_AFSEL13_Msk           (0xFU << GPIO_AFRH_AFSEL13_Pos)        /*!< 0x00F00000 */
N#define GPIO_AFRH_AFSEL13               GPIO_AFRH_AFSEL13_Msk                    
N#define GPIO_AFRH_AFSEL14_Pos           (24U)                                  
N#define GPIO_AFRH_AFSEL14_Msk           (0xFU << GPIO_AFRH_AFSEL14_Pos)        /*!< 0x0F000000 */
N#define GPIO_AFRH_AFSEL14               GPIO_AFRH_AFSEL14_Msk                    
N#define GPIO_AFRH_AFSEL15_Pos           (28U)                                  
N#define GPIO_AFRH_AFSEL15_Msk           (0xFU << GPIO_AFRH_AFSEL15_Pos)        /*!< 0xF0000000 */
N#define GPIO_AFRH_AFSEL15               GPIO_AFRH_AFSEL15_Msk                    
N
N/* Legacy aliases */                  
N#define GPIO_AFRH_AFRH0_Pos             GPIO_AFRH_AFSEL8_Pos
N#define GPIO_AFRH_AFRH0_Msk             GPIO_AFRH_AFSEL8_Msk
N#define GPIO_AFRH_AFRH0                 GPIO_AFRH_AFSEL8
N#define GPIO_AFRH_AFRH1_Pos             GPIO_AFRH_AFSEL9_Pos
N#define GPIO_AFRH_AFRH1_Msk             GPIO_AFRH_AFSEL9_Msk
N#define GPIO_AFRH_AFRH1                 GPIO_AFRH_AFSEL9
N#define GPIO_AFRH_AFRH2_Pos             GPIO_AFRH_AFSEL10_Pos
N#define GPIO_AFRH_AFRH2_Msk             GPIO_AFRH_AFSEL10_Msk
N#define GPIO_AFRH_AFRH2                 GPIO_AFRH_AFSEL10
N#define GPIO_AFRH_AFRH3_Pos             GPIO_AFRH_AFSEL11_Pos
N#define GPIO_AFRH_AFRH3_Msk             GPIO_AFRH_AFSEL11_Msk
N#define GPIO_AFRH_AFRH3                 GPIO_AFRH_AFSEL11
N#define GPIO_AFRH_AFRH4_Pos             GPIO_AFRH_AFSEL12_Pos
N#define GPIO_AFRH_AFRH4_Msk             GPIO_AFRH_AFSEL12_Msk
N#define GPIO_AFRH_AFRH4                 GPIO_AFRH_AFSEL12
N#define GPIO_AFRH_AFRH5_Pos             GPIO_AFRH_AFSEL13_Pos
N#define GPIO_AFRH_AFRH5_Msk             GPIO_AFRH_AFSEL13_Msk
N#define GPIO_AFRH_AFRH5                 GPIO_AFRH_AFSEL13
N#define GPIO_AFRH_AFRH6_Pos             GPIO_AFRH_AFSEL14_Pos
N#define GPIO_AFRH_AFRH6_Msk             GPIO_AFRH_AFSEL14_Msk
N#define GPIO_AFRH_AFRH6                 GPIO_AFRH_AFSEL14
N#define GPIO_AFRH_AFRH7_Pos             GPIO_AFRH_AFSEL15_Pos
N#define GPIO_AFRH_AFRH7_Msk             GPIO_AFRH_AFSEL15_Msk
N#define GPIO_AFRH_AFRH7                 GPIO_AFRH_AFSEL15
N
N/****************** Bit definition for GPIO_BRR register  *********************/
N#define GPIO_BRR_BR_0                   (0x00000001U)                          
N#define GPIO_BRR_BR_1                   (0x00000002U)                          
N#define GPIO_BRR_BR_2                   (0x00000004U)                          
N#define GPIO_BRR_BR_3                   (0x00000008U)                          
N#define GPIO_BRR_BR_4                   (0x00000010U)                          
N#define GPIO_BRR_BR_5                   (0x00000020U)                          
N#define GPIO_BRR_BR_6                   (0x00000040U)                          
N#define GPIO_BRR_BR_7                   (0x00000080U)                          
N#define GPIO_BRR_BR_8                   (0x00000100U)                          
N#define GPIO_BRR_BR_9                   (0x00000200U)                          
N#define GPIO_BRR_BR_10                  (0x00000400U)                          
N#define GPIO_BRR_BR_11                  (0x00000800U)                          
N#define GPIO_BRR_BR_12                  (0x00001000U)                          
N#define GPIO_BRR_BR_13                  (0x00002000U)                          
N#define GPIO_BRR_BR_14                  (0x00004000U)                          
N#define GPIO_BRR_BR_15                  (0x00008000U)                          
N
N/******************************************************************************/
N/*                                                                            */
N/*                   Inter-integrated Circuit Interface (I2C)                 */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for I2C_CR1 register  *******************/
N#define I2C_CR1_PE_Pos               (0U)                                      
N#define I2C_CR1_PE_Msk               (0x1U << I2C_CR1_PE_Pos)                  /*!< 0x00000001 */
N#define I2C_CR1_PE                   I2C_CR1_PE_Msk                            /*!< Peripheral enable */
N#define I2C_CR1_TXIE_Pos             (1U)                                      
N#define I2C_CR1_TXIE_Msk             (0x1U << I2C_CR1_TXIE_Pos)                /*!< 0x00000002 */
N#define I2C_CR1_TXIE                 I2C_CR1_TXIE_Msk                          /*!< TX interrupt enable */
N#define I2C_CR1_RXIE_Pos             (2U)                                      
N#define I2C_CR1_RXIE_Msk             (0x1U << I2C_CR1_RXIE_Pos)                /*!< 0x00000004 */
N#define I2C_CR1_RXIE                 I2C_CR1_RXIE_Msk                          /*!< RX interrupt enable */
N#define I2C_CR1_ADDRIE_Pos           (3U)                                      
N#define I2C_CR1_ADDRIE_Msk           (0x1U << I2C_CR1_ADDRIE_Pos)              /*!< 0x00000008 */
N#define I2C_CR1_ADDRIE               I2C_CR1_ADDRIE_Msk                        /*!< Address match interrupt enable */
N#define I2C_CR1_NACKIE_Pos           (4U)                                      
N#define I2C_CR1_NACKIE_Msk           (0x1U << I2C_CR1_NACKIE_Pos)              /*!< 0x00000010 */
N#define I2C_CR1_NACKIE               I2C_CR1_NACKIE_Msk                        /*!< NACK received interrupt enable */
N#define I2C_CR1_STOPIE_Pos           (5U)                                      
N#define I2C_CR1_STOPIE_Msk           (0x1U << I2C_CR1_STOPIE_Pos)              /*!< 0x00000020 */
N#define I2C_CR1_STOPIE               I2C_CR1_STOPIE_Msk                        /*!< STOP detection interrupt enable */
N#define I2C_CR1_TCIE_Pos             (6U)                                      
N#define I2C_CR1_TCIE_Msk             (0x1U << I2C_CR1_TCIE_Pos)                /*!< 0x00000040 */
N#define I2C_CR1_TCIE                 I2C_CR1_TCIE_Msk                          /*!< Transfer complete interrupt enable */
N#define I2C_CR1_ERRIE_Pos            (7U)                                      
N#define I2C_CR1_ERRIE_Msk            (0x1U << I2C_CR1_ERRIE_Pos)               /*!< 0x00000080 */
N#define I2C_CR1_ERRIE                I2C_CR1_ERRIE_Msk                         /*!< Errors interrupt enable */
N#define I2C_CR1_DNF_Pos              (8U)                                      
N#define I2C_CR1_DNF_Msk              (0xFU << I2C_CR1_DNF_Pos)                 /*!< 0x00000F00 */
N#define I2C_CR1_DNF                  I2C_CR1_DNF_Msk                           /*!< Digital noise filter */
N#define I2C_CR1_ANFOFF_Pos           (12U)                                     
N#define I2C_CR1_ANFOFF_Msk           (0x1U << I2C_CR1_ANFOFF_Pos)              /*!< 0x00001000 */
N#define I2C_CR1_ANFOFF               I2C_CR1_ANFOFF_Msk                        /*!< Analog noise filter OFF */
N#define I2C_CR1_SWRST_Pos            (13U)                                     
N#define I2C_CR1_SWRST_Msk            (0x1U << I2C_CR1_SWRST_Pos)               /*!< 0x00002000 */
N#define I2C_CR1_SWRST                I2C_CR1_SWRST_Msk                         /*!< Software reset */
N#define I2C_CR1_TXDMAEN_Pos          (14U)                                     
N#define I2C_CR1_TXDMAEN_Msk          (0x1U << I2C_CR1_TXDMAEN_Pos)             /*!< 0x00004000 */
N#define I2C_CR1_TXDMAEN              I2C_CR1_TXDMAEN_Msk                       /*!< DMA transmission requests enable */
N#define I2C_CR1_RXDMAEN_Pos          (15U)                                     
N#define I2C_CR1_RXDMAEN_Msk          (0x1U << I2C_CR1_RXDMAEN_Pos)             /*!< 0x00008000 */
N#define I2C_CR1_RXDMAEN              I2C_CR1_RXDMAEN_Msk                       /*!< DMA reception requests enable */
N#define I2C_CR1_SBC_Pos              (16U)                                     
N#define I2C_CR1_SBC_Msk              (0x1U << I2C_CR1_SBC_Pos)                 /*!< 0x00010000 */
N#define I2C_CR1_SBC                  I2C_CR1_SBC_Msk                           /*!< Slave byte control */
N#define I2C_CR1_NOSTRETCH_Pos        (17U)                                     
N#define I2C_CR1_NOSTRETCH_Msk        (0x1U << I2C_CR1_NOSTRETCH_Pos)           /*!< 0x00020000 */
N#define I2C_CR1_NOSTRETCH            I2C_CR1_NOSTRETCH_Msk                     /*!< Clock stretching disable */
N#define I2C_CR1_WUPEN_Pos            (18U)                                     
N#define I2C_CR1_WUPEN_Msk            (0x1U << I2C_CR1_WUPEN_Pos)               /*!< 0x00040000 */
N#define I2C_CR1_WUPEN                I2C_CR1_WUPEN_Msk                         /*!< Wakeup from STOP enable */
N#define I2C_CR1_GCEN_Pos             (19U)                                     
N#define I2C_CR1_GCEN_Msk             (0x1U << I2C_CR1_GCEN_Pos)                /*!< 0x00080000 */
N#define I2C_CR1_GCEN                 I2C_CR1_GCEN_Msk                          /*!< General call enable */
N#define I2C_CR1_SMBHEN_Pos           (20U)                                     
N#define I2C_CR1_SMBHEN_Msk           (0x1U << I2C_CR1_SMBHEN_Pos)              /*!< 0x00100000 */
N#define I2C_CR1_SMBHEN               I2C_CR1_SMBHEN_Msk                        /*!< SMBus host address enable */
N#define I2C_CR1_SMBDEN_Pos           (21U)                                     
N#define I2C_CR1_SMBDEN_Msk           (0x1U << I2C_CR1_SMBDEN_Pos)              /*!< 0x00200000 */
N#define I2C_CR1_SMBDEN               I2C_CR1_SMBDEN_Msk                        /*!< SMBus device default address enable */
N#define I2C_CR1_ALERTEN_Pos          (22U)                                     
N#define I2C_CR1_ALERTEN_Msk          (0x1U << I2C_CR1_ALERTEN_Pos)             /*!< 0x00400000 */
N#define I2C_CR1_ALERTEN              I2C_CR1_ALERTEN_Msk                       /*!< SMBus alert enable */
N#define I2C_CR1_PECEN_Pos            (23U)                                     
N#define I2C_CR1_PECEN_Msk            (0x1U << I2C_CR1_PECEN_Pos)               /*!< 0x00800000 */
N#define I2C_CR1_PECEN                I2C_CR1_PECEN_Msk                         /*!< PEC enable */
N
N/******************  Bit definition for I2C_CR2 register  ********************/
N#define I2C_CR2_SADD_Pos             (0U)                                      
N#define I2C_CR2_SADD_Msk             (0x3FFU << I2C_CR2_SADD_Pos)              /*!< 0x000003FF */
N#define I2C_CR2_SADD                 I2C_CR2_SADD_Msk                          /*!< Slave address (master mode) */
N#define I2C_CR2_RD_WRN_Pos           (10U)                                     
N#define I2C_CR2_RD_WRN_Msk           (0x1U << I2C_CR2_RD_WRN_Pos)              /*!< 0x00000400 */
N#define I2C_CR2_RD_WRN               I2C_CR2_RD_WRN_Msk                        /*!< Transfer direction (master mode) */
N#define I2C_CR2_ADD10_Pos            (11U)                                     
N#define I2C_CR2_ADD10_Msk            (0x1U << I2C_CR2_ADD10_Pos)               /*!< 0x00000800 */
N#define I2C_CR2_ADD10                I2C_CR2_ADD10_Msk                         /*!< 10-bit addressing mode (master mode) */
N#define I2C_CR2_HEAD10R_Pos          (12U)                                     
N#define I2C_CR2_HEAD10R_Msk          (0x1U << I2C_CR2_HEAD10R_Pos)             /*!< 0x00001000 */
N#define I2C_CR2_HEAD10R              I2C_CR2_HEAD10R_Msk                       /*!< 10-bit address header only read direction (master mode) */
N#define I2C_CR2_START_Pos            (13U)                                     
N#define I2C_CR2_START_Msk            (0x1U << I2C_CR2_START_Pos)               /*!< 0x00002000 */
N#define I2C_CR2_START                I2C_CR2_START_Msk                         /*!< START generation */
N#define I2C_CR2_STOP_Pos             (14U)                                     
N#define I2C_CR2_STOP_Msk             (0x1U << I2C_CR2_STOP_Pos)                /*!< 0x00004000 */
N#define I2C_CR2_STOP                 I2C_CR2_STOP_Msk                          /*!< STOP generation (master mode) */
N#define I2C_CR2_NACK_Pos             (15U)                                     
N#define I2C_CR2_NACK_Msk             (0x1U << I2C_CR2_NACK_Pos)                /*!< 0x00008000 */
N#define I2C_CR2_NACK                 I2C_CR2_NACK_Msk                          /*!< NACK generation (slave mode) */
N#define I2C_CR2_NBYTES_Pos           (16U)                                     
N#define I2C_CR2_NBYTES_Msk           (0xFFU << I2C_CR2_NBYTES_Pos)             /*!< 0x00FF0000 */
N#define I2C_CR2_NBYTES               I2C_CR2_NBYTES_Msk                        /*!< Number of bytes */
N#define I2C_CR2_RELOAD_Pos           (24U)                                     
N#define I2C_CR2_RELOAD_Msk           (0x1U << I2C_CR2_RELOAD_Pos)              /*!< 0x01000000 */
N#define I2C_CR2_RELOAD               I2C_CR2_RELOAD_Msk                        /*!< NBYTES reload mode */
N#define I2C_CR2_AUTOEND_Pos          (25U)                                     
N#define I2C_CR2_AUTOEND_Msk          (0x1U << I2C_CR2_AUTOEND_Pos)             /*!< 0x02000000 */
N#define I2C_CR2_AUTOEND              I2C_CR2_AUTOEND_Msk                       /*!< Automatic end mode (master mode) */
N#define I2C_CR2_PECBYTE_Pos          (26U)                                     
N#define I2C_CR2_PECBYTE_Msk          (0x1U << I2C_CR2_PECBYTE_Pos)             /*!< 0x04000000 */
N#define I2C_CR2_PECBYTE              I2C_CR2_PECBYTE_Msk                       /*!< Packet error checking byte */
N
N/*******************  Bit definition for I2C_OAR1 register  ******************/
N#define I2C_OAR1_OA1_Pos             (0U)                                      
N#define I2C_OAR1_OA1_Msk             (0x3FFU << I2C_OAR1_OA1_Pos)              /*!< 0x000003FF */
N#define I2C_OAR1_OA1                 I2C_OAR1_OA1_Msk                          /*!< Interface own address 1 */
N#define I2C_OAR1_OA1MODE_Pos         (10U)                                     
N#define I2C_OAR1_OA1MODE_Msk         (0x1U << I2C_OAR1_OA1MODE_Pos)            /*!< 0x00000400 */
N#define I2C_OAR1_OA1MODE             I2C_OAR1_OA1MODE_Msk                      /*!< Own address 1 10-bit mode */
N#define I2C_OAR1_OA1EN_Pos           (15U)                                     
N#define I2C_OAR1_OA1EN_Msk           (0x1U << I2C_OAR1_OA1EN_Pos)              /*!< 0x00008000 */
N#define I2C_OAR1_OA1EN               I2C_OAR1_OA1EN_Msk                        /*!< Own address 1 enable */
N
N/*******************  Bit definition for I2C_OAR2 register  ******************/
N#define I2C_OAR2_OA2_Pos             (1U)                                      
N#define I2C_OAR2_OA2_Msk             (0x7FU << I2C_OAR2_OA2_Pos)               /*!< 0x000000FE */
N#define I2C_OAR2_OA2                 I2C_OAR2_OA2_Msk                          /*!< Interface own address 2 */
N#define I2C_OAR2_OA2MSK_Pos          (8U)                                      
N#define I2C_OAR2_OA2MSK_Msk          (0x7U << I2C_OAR2_OA2MSK_Pos)             /*!< 0x00000700 */
N#define I2C_OAR2_OA2MSK              I2C_OAR2_OA2MSK_Msk                       /*!< Own address 2 masks */
N#define I2C_OAR2_OA2NOMASK           (0x00000000U)                             /*!< No mask                                        */
N#define I2C_OAR2_OA2MASK01_Pos       (8U)                                      
N#define I2C_OAR2_OA2MASK01_Msk       (0x1U << I2C_OAR2_OA2MASK01_Pos)          /*!< 0x00000100 */
N#define I2C_OAR2_OA2MASK01           I2C_OAR2_OA2MASK01_Msk                    /*!< OA2[1] is masked, Only OA2[7:2] are compared   */
N#define I2C_OAR2_OA2MASK02_Pos       (9U)                                      
N#define I2C_OAR2_OA2MASK02_Msk       (0x1U << I2C_OAR2_OA2MASK02_Pos)          /*!< 0x00000200 */
N#define I2C_OAR2_OA2MASK02           I2C_OAR2_OA2MASK02_Msk                    /*!< OA2[2:1] is masked, Only OA2[7:3] are compared */
N#define I2C_OAR2_OA2MASK03_Pos       (8U)                                      
N#define I2C_OAR2_OA2MASK03_Msk       (0x3U << I2C_OAR2_OA2MASK03_Pos)          /*!< 0x00000300 */
N#define I2C_OAR2_OA2MASK03           I2C_OAR2_OA2MASK03_Msk                    /*!< OA2[3:1] is masked, Only OA2[7:4] are compared */
N#define I2C_OAR2_OA2MASK04_Pos       (10U)                                     
N#define I2C_OAR2_OA2MASK04_Msk       (0x1U << I2C_OAR2_OA2MASK04_Pos)          /*!< 0x00000400 */
N#define I2C_OAR2_OA2MASK04           I2C_OAR2_OA2MASK04_Msk                    /*!< OA2[4:1] is masked, Only OA2[7:5] are compared */
N#define I2C_OAR2_OA2MASK05_Pos       (8U)                                      
N#define I2C_OAR2_OA2MASK05_Msk       (0x5U << I2C_OAR2_OA2MASK05_Pos)          /*!< 0x00000500 */
N#define I2C_OAR2_OA2MASK05           I2C_OAR2_OA2MASK05_Msk                    /*!< OA2[5:1] is masked, Only OA2[7:6] are compared */
N#define I2C_OAR2_OA2MASK06_Pos       (9U)                                      
N#define I2C_OAR2_OA2MASK06_Msk       (0x3U << I2C_OAR2_OA2MASK06_Pos)          /*!< 0x00000600 */
N#define I2C_OAR2_OA2MASK06           I2C_OAR2_OA2MASK06_Msk                    /*!< OA2[6:1] is masked, Only OA2[7] are compared   */
N#define I2C_OAR2_OA2MASK07_Pos       (8U)                                      
N#define I2C_OAR2_OA2MASK07_Msk       (0x7U << I2C_OAR2_OA2MASK07_Pos)          /*!< 0x00000700 */
N#define I2C_OAR2_OA2MASK07           I2C_OAR2_OA2MASK07_Msk                    /*!< OA2[7:1] is masked, No comparison is done      */
N#define I2C_OAR2_OA2EN_Pos           (15U)                                     
N#define I2C_OAR2_OA2EN_Msk           (0x1U << I2C_OAR2_OA2EN_Pos)              /*!< 0x00008000 */
N#define I2C_OAR2_OA2EN               I2C_OAR2_OA2EN_Msk                        /*!< Own address 2 enable */
N
N/*******************  Bit definition for I2C_TIMINGR register ****************/
N#define I2C_TIMINGR_SCLL_Pos         (0U)                                      
N#define I2C_TIMINGR_SCLL_Msk         (0xFFU << I2C_TIMINGR_SCLL_Pos)           /*!< 0x000000FF */
N#define I2C_TIMINGR_SCLL             I2C_TIMINGR_SCLL_Msk                      /*!< SCL low period (master mode) */
N#define I2C_TIMINGR_SCLH_Pos         (8U)                                      
N#define I2C_TIMINGR_SCLH_Msk         (0xFFU << I2C_TIMINGR_SCLH_Pos)           /*!< 0x0000FF00 */
N#define I2C_TIMINGR_SCLH             I2C_TIMINGR_SCLH_Msk                      /*!< SCL high period (master mode) */
N#define I2C_TIMINGR_SDADEL_Pos       (16U)                                     
N#define I2C_TIMINGR_SDADEL_Msk       (0xFU << I2C_TIMINGR_SDADEL_Pos)          /*!< 0x000F0000 */
N#define I2C_TIMINGR_SDADEL           I2C_TIMINGR_SDADEL_Msk                    /*!< Data hold time */
N#define I2C_TIMINGR_SCLDEL_Pos       (20U)                                     
N#define I2C_TIMINGR_SCLDEL_Msk       (0xFU << I2C_TIMINGR_SCLDEL_Pos)          /*!< 0x00F00000 */
N#define I2C_TIMINGR_SCLDEL           I2C_TIMINGR_SCLDEL_Msk                    /*!< Data setup time */
N#define I2C_TIMINGR_PRESC_Pos        (28U)                                     
N#define I2C_TIMINGR_PRESC_Msk        (0xFU << I2C_TIMINGR_PRESC_Pos)           /*!< 0xF0000000 */
N#define I2C_TIMINGR_PRESC            I2C_TIMINGR_PRESC_Msk                     /*!< Timings prescaler */
N
N/******************* Bit definition for I2C_TIMEOUTR register ****************/
N#define I2C_TIMEOUTR_TIMEOUTA_Pos    (0U)                                      
N#define I2C_TIMEOUTR_TIMEOUTA_Msk    (0xFFFU << I2C_TIMEOUTR_TIMEOUTA_Pos)     /*!< 0x00000FFF */
N#define I2C_TIMEOUTR_TIMEOUTA        I2C_TIMEOUTR_TIMEOUTA_Msk                 /*!< Bus timeout A */
N#define I2C_TIMEOUTR_TIDLE_Pos       (12U)                                     
N#define I2C_TIMEOUTR_TIDLE_Msk       (0x1U << I2C_TIMEOUTR_TIDLE_Pos)          /*!< 0x00001000 */
N#define I2C_TIMEOUTR_TIDLE           I2C_TIMEOUTR_TIDLE_Msk                    /*!< Idle clock timeout detection */
N#define I2C_TIMEOUTR_TIMOUTEN_Pos    (15U)                                     
N#define I2C_TIMEOUTR_TIMOUTEN_Msk    (0x1U << I2C_TIMEOUTR_TIMOUTEN_Pos)       /*!< 0x00008000 */
N#define I2C_TIMEOUTR_TIMOUTEN        I2C_TIMEOUTR_TIMOUTEN_Msk                 /*!< Clock timeout enable */
N#define I2C_TIMEOUTR_TIMEOUTB_Pos    (16U)                                     
N#define I2C_TIMEOUTR_TIMEOUTB_Msk    (0xFFFU << I2C_TIMEOUTR_TIMEOUTB_Pos)     /*!< 0x0FFF0000 */
N#define I2C_TIMEOUTR_TIMEOUTB        I2C_TIMEOUTR_TIMEOUTB_Msk                 /*!< Bus timeout B*/
N#define I2C_TIMEOUTR_TEXTEN_Pos      (31U)                                     
N#define I2C_TIMEOUTR_TEXTEN_Msk      (0x1U << I2C_TIMEOUTR_TEXTEN_Pos)         /*!< 0x80000000 */
N#define I2C_TIMEOUTR_TEXTEN          I2C_TIMEOUTR_TEXTEN_Msk                   /*!< Extended clock timeout enable */
N
N/******************  Bit definition for I2C_ISR register  ********************/
N#define I2C_ISR_TXE_Pos              (0U)                                      
N#define I2C_ISR_TXE_Msk              (0x1U << I2C_ISR_TXE_Pos)                 /*!< 0x00000001 */
N#define I2C_ISR_TXE                  I2C_ISR_TXE_Msk                           /*!< Transmit data register empty */
N#define I2C_ISR_TXIS_Pos             (1U)                                      
N#define I2C_ISR_TXIS_Msk             (0x1U << I2C_ISR_TXIS_Pos)                /*!< 0x00000002 */
N#define I2C_ISR_TXIS                 I2C_ISR_TXIS_Msk                          /*!< Transmit interrupt status */
N#define I2C_ISR_RXNE_Pos             (2U)                                      
N#define I2C_ISR_RXNE_Msk             (0x1U << I2C_ISR_RXNE_Pos)                /*!< 0x00000004 */
N#define I2C_ISR_RXNE                 I2C_ISR_RXNE_Msk                          /*!< Receive data register not empty */
N#define I2C_ISR_ADDR_Pos             (3U)                                      
N#define I2C_ISR_ADDR_Msk             (0x1U << I2C_ISR_ADDR_Pos)                /*!< 0x00000008 */
N#define I2C_ISR_ADDR                 I2C_ISR_ADDR_Msk                          /*!< Address matched (slave mode)*/
N#define I2C_ISR_NACKF_Pos            (4U)                                      
N#define I2C_ISR_NACKF_Msk            (0x1U << I2C_ISR_NACKF_Pos)               /*!< 0x00000010 */
N#define I2C_ISR_NACKF                I2C_ISR_NACKF_Msk                         /*!< NACK received flag */
N#define I2C_ISR_STOPF_Pos            (5U)                                      
N#define I2C_ISR_STOPF_Msk            (0x1U << I2C_ISR_STOPF_Pos)               /*!< 0x00000020 */
N#define I2C_ISR_STOPF                I2C_ISR_STOPF_Msk                         /*!< STOP detection flag */
N#define I2C_ISR_TC_Pos               (6U)                                      
N#define I2C_ISR_TC_Msk               (0x1U << I2C_ISR_TC_Pos)                  /*!< 0x00000040 */
N#define I2C_ISR_TC                   I2C_ISR_TC_Msk                            /*!< Transfer complete (master mode) */
N#define I2C_ISR_TCR_Pos              (7U)                                      
N#define I2C_ISR_TCR_Msk              (0x1U << I2C_ISR_TCR_Pos)                 /*!< 0x00000080 */
N#define I2C_ISR_TCR                  I2C_ISR_TCR_Msk                           /*!< Transfer complete reload */
N#define I2C_ISR_BERR_Pos             (8U)                                      
N#define I2C_ISR_BERR_Msk             (0x1U << I2C_ISR_BERR_Pos)                /*!< 0x00000100 */
N#define I2C_ISR_BERR                 I2C_ISR_BERR_Msk                          /*!< Bus error */
N#define I2C_ISR_ARLO_Pos             (9U)                                      
N#define I2C_ISR_ARLO_Msk             (0x1U << I2C_ISR_ARLO_Pos)                /*!< 0x00000200 */
N#define I2C_ISR_ARLO                 I2C_ISR_ARLO_Msk                          /*!< Arbitration lost */
N#define I2C_ISR_OVR_Pos              (10U)                                     
N#define I2C_ISR_OVR_Msk              (0x1U << I2C_ISR_OVR_Pos)                 /*!< 0x00000400 */
N#define I2C_ISR_OVR                  I2C_ISR_OVR_Msk                           /*!< Overrun/Underrun */
N#define I2C_ISR_PECERR_Pos           (11U)                                     
N#define I2C_ISR_PECERR_Msk           (0x1U << I2C_ISR_PECERR_Pos)              /*!< 0x00000800 */
N#define I2C_ISR_PECERR               I2C_ISR_PECERR_Msk                        /*!< PEC error in reception */
N#define I2C_ISR_TIMEOUT_Pos          (12U)                                     
N#define I2C_ISR_TIMEOUT_Msk          (0x1U << I2C_ISR_TIMEOUT_Pos)             /*!< 0x00001000 */
N#define I2C_ISR_TIMEOUT              I2C_ISR_TIMEOUT_Msk                       /*!< Timeout or Tlow detection flag */
N#define I2C_ISR_ALERT_Pos            (13U)                                     
N#define I2C_ISR_ALERT_Msk            (0x1U << I2C_ISR_ALERT_Pos)               /*!< 0x00002000 */
N#define I2C_ISR_ALERT                I2C_ISR_ALERT_Msk                         /*!< SMBus alert */
N#define I2C_ISR_BUSY_Pos             (15U)                                     
N#define I2C_ISR_BUSY_Msk             (0x1U << I2C_ISR_BUSY_Pos)                /*!< 0x00008000 */
N#define I2C_ISR_BUSY                 I2C_ISR_BUSY_Msk                          /*!< Bus busy */
N#define I2C_ISR_DIR_Pos              (16U)                                     
N#define I2C_ISR_DIR_Msk              (0x1U << I2C_ISR_DIR_Pos)                 /*!< 0x00010000 */
N#define I2C_ISR_DIR                  I2C_ISR_DIR_Msk                           /*!< Transfer direction (slave mode) */
N#define I2C_ISR_ADDCODE_Pos          (17U)                                     
N#define I2C_ISR_ADDCODE_Msk          (0x7FU << I2C_ISR_ADDCODE_Pos)            /*!< 0x00FE0000 */
N#define I2C_ISR_ADDCODE              I2C_ISR_ADDCODE_Msk                       /*!< Address match code (slave mode) */
N
N/******************  Bit definition for I2C_ICR register  ********************/
N#define I2C_ICR_ADDRCF_Pos           (3U)                                      
N#define I2C_ICR_ADDRCF_Msk           (0x1U << I2C_ICR_ADDRCF_Pos)              /*!< 0x00000008 */
N#define I2C_ICR_ADDRCF               I2C_ICR_ADDRCF_Msk                        /*!< Address matched clear flag */
N#define I2C_ICR_NACKCF_Pos           (4U)                                      
N#define I2C_ICR_NACKCF_Msk           (0x1U << I2C_ICR_NACKCF_Pos)              /*!< 0x00000010 */
N#define I2C_ICR_NACKCF               I2C_ICR_NACKCF_Msk                        /*!< NACK clear flag */
N#define I2C_ICR_STOPCF_Pos           (5U)                                      
N#define I2C_ICR_STOPCF_Msk           (0x1U << I2C_ICR_STOPCF_Pos)              /*!< 0x00000020 */
N#define I2C_ICR_STOPCF               I2C_ICR_STOPCF_Msk                        /*!< STOP detection clear flag */
N#define I2C_ICR_BERRCF_Pos           (8U)                                      
N#define I2C_ICR_BERRCF_Msk           (0x1U << I2C_ICR_BERRCF_Pos)              /*!< 0x00000100 */
N#define I2C_ICR_BERRCF               I2C_ICR_BERRCF_Msk                        /*!< Bus error clear flag */
N#define I2C_ICR_ARLOCF_Pos           (9U)                                      
N#define I2C_ICR_ARLOCF_Msk           (0x1U << I2C_ICR_ARLOCF_Pos)              /*!< 0x00000200 */
N#define I2C_ICR_ARLOCF               I2C_ICR_ARLOCF_Msk                        /*!< Arbitration lost clear flag */
N#define I2C_ICR_OVRCF_Pos            (10U)                                     
N#define I2C_ICR_OVRCF_Msk            (0x1U << I2C_ICR_OVRCF_Pos)               /*!< 0x00000400 */
N#define I2C_ICR_OVRCF                I2C_ICR_OVRCF_Msk                         /*!< Overrun/Underrun clear flag */
N#define I2C_ICR_PECCF_Pos            (11U)                                     
N#define I2C_ICR_PECCF_Msk            (0x1U << I2C_ICR_PECCF_Pos)               /*!< 0x00000800 */
N#define I2C_ICR_PECCF                I2C_ICR_PECCF_Msk                         /*!< PAC error clear flag */
N#define I2C_ICR_TIMOUTCF_Pos         (12U)                                     
N#define I2C_ICR_TIMOUTCF_Msk         (0x1U << I2C_ICR_TIMOUTCF_Pos)            /*!< 0x00001000 */
N#define I2C_ICR_TIMOUTCF             I2C_ICR_TIMOUTCF_Msk                      /*!< Timeout clear flag */
N#define I2C_ICR_ALERTCF_Pos          (13U)                                     
N#define I2C_ICR_ALERTCF_Msk          (0x1U << I2C_ICR_ALERTCF_Pos)             /*!< 0x00002000 */
N#define I2C_ICR_ALERTCF              I2C_ICR_ALERTCF_Msk                       /*!< Alert clear flag */
N
N/******************  Bit definition for I2C_PECR register  *******************/
N#define I2C_PECR_PEC_Pos             (0U)                                      
N#define I2C_PECR_PEC_Msk             (0xFFU << I2C_PECR_PEC_Pos)               /*!< 0x000000FF */
N#define I2C_PECR_PEC                 I2C_PECR_PEC_Msk                          /*!< PEC register */
N
N/******************  Bit definition for I2C_RXDR register  *********************/
N#define I2C_RXDR_RXDATA_Pos          (0U)                                      
N#define I2C_RXDR_RXDATA_Msk          (0xFFU << I2C_RXDR_RXDATA_Pos)            /*!< 0x000000FF */
N#define I2C_RXDR_RXDATA              I2C_RXDR_RXDATA_Msk                       /*!< 8-bit receive data */
N
N/******************  Bit definition for I2C_TXDR register  *******************/
N#define I2C_TXDR_TXDATA_Pos          (0U)                                      
N#define I2C_TXDR_TXDATA_Msk          (0xFFU << I2C_TXDR_TXDATA_Pos)            /*!< 0x000000FF */
N#define I2C_TXDR_TXDATA              I2C_TXDR_TXDATA_Msk                       /*!< 8-bit transmit data */
N
N/*****************************************************************************/
N/*                                                                           */
N/*                        Independent WATCHDOG (IWDG)                        */
N/*                                                                           */
N/*****************************************************************************/
N/*******************  Bit definition for IWDG_KR register  *******************/
N#define IWDG_KR_KEY_Pos      (0U)                                              
N#define IWDG_KR_KEY_Msk      (0xFFFFU << IWDG_KR_KEY_Pos)                      /*!< 0x0000FFFF */
N#define IWDG_KR_KEY          IWDG_KR_KEY_Msk                                   /*!< Key value (write only, read 0000h) */
N
N/*******************  Bit definition for IWDG_PR register  *******************/
N#define IWDG_PR_PR_Pos       (0U)                                              
N#define IWDG_PR_PR_Msk       (0x7U << IWDG_PR_PR_Pos)                          /*!< 0x00000007 */
N#define IWDG_PR_PR           IWDG_PR_PR_Msk                                    /*!< PR[2:0] (Prescaler divider) */
N#define IWDG_PR_PR_0         (0x1U << IWDG_PR_PR_Pos)                          /*!< 0x01 */
N#define IWDG_PR_PR_1         (0x2U << IWDG_PR_PR_Pos)                          /*!< 0x02 */
N#define IWDG_PR_PR_2         (0x4U << IWDG_PR_PR_Pos)                          /*!< 0x04 */
N
N/*******************  Bit definition for IWDG_RLR register  ******************/
N#define IWDG_RLR_RL_Pos      (0U)                                              
N#define IWDG_RLR_RL_Msk      (0xFFFU << IWDG_RLR_RL_Pos)                       /*!< 0x00000FFF */
N#define IWDG_RLR_RL          IWDG_RLR_RL_Msk                                   /*!< Watchdog counter reload value */
N
N/*******************  Bit definition for IWDG_SR register  *******************/
N#define IWDG_SR_PVU_Pos      (0U)                                              
N#define IWDG_SR_PVU_Msk      (0x1U << IWDG_SR_PVU_Pos)                         /*!< 0x00000001 */
N#define IWDG_SR_PVU          IWDG_SR_PVU_Msk                                   /*!< Watchdog prescaler value update */
N#define IWDG_SR_RVU_Pos      (1U)                                              
N#define IWDG_SR_RVU_Msk      (0x1U << IWDG_SR_RVU_Pos)                         /*!< 0x00000002 */
N#define IWDG_SR_RVU          IWDG_SR_RVU_Msk                                   /*!< Watchdog counter reload value update */
N#define IWDG_SR_WVU_Pos      (2U)                                              
N#define IWDG_SR_WVU_Msk      (0x1U << IWDG_SR_WVU_Pos)                         /*!< 0x00000004 */
N#define IWDG_SR_WVU          IWDG_SR_WVU_Msk                                   /*!< Watchdog counter window value update */
N
N/*******************  Bit definition for IWDG_KR register  *******************/
N#define IWDG_WINR_WIN_Pos    (0U)                                              
N#define IWDG_WINR_WIN_Msk    (0xFFFU << IWDG_WINR_WIN_Pos)                     /*!< 0x00000FFF */
N#define IWDG_WINR_WIN        IWDG_WINR_WIN_Msk                                 /*!< Watchdog counter window value */
N
N/*****************************************************************************/
N/*                                                                           */
N/*                          Power Control (PWR)                              */
N/*                                                                           */
N/*****************************************************************************/
N
N#define PWR_PVD_SUPPORT                       /*!< PWR feature available only on specific devices: Power Voltage Detection feature */
N
N
N/********************  Bit definition for PWR_CR register  *******************/
N#define PWR_CR_LPDS_Pos            (0U)                                        
N#define PWR_CR_LPDS_Msk            (0x1U << PWR_CR_LPDS_Pos)                   /*!< 0x00000001 */
N#define PWR_CR_LPDS                PWR_CR_LPDS_Msk                             /*!< Low-power Deepsleep */
N#define PWR_CR_PDDS_Pos            (1U)                                        
N#define PWR_CR_PDDS_Msk            (0x1U << PWR_CR_PDDS_Pos)                   /*!< 0x00000002 */
N#define PWR_CR_PDDS                PWR_CR_PDDS_Msk                             /*!< Power Down Deepsleep */
N#define PWR_CR_CWUF_Pos            (2U)                                        
N#define PWR_CR_CWUF_Msk            (0x1U << PWR_CR_CWUF_Pos)                   /*!< 0x00000004 */
N#define PWR_CR_CWUF                PWR_CR_CWUF_Msk                             /*!< Clear Wakeup Flag */
N#define PWR_CR_CSBF_Pos            (3U)                                        
N#define PWR_CR_CSBF_Msk            (0x1U << PWR_CR_CSBF_Pos)                   /*!< 0x00000008 */
N#define PWR_CR_CSBF                PWR_CR_CSBF_Msk                             /*!< Clear Standby Flag */
N#define PWR_CR_PVDE_Pos            (4U)                                        
N#define PWR_CR_PVDE_Msk            (0x1U << PWR_CR_PVDE_Pos)                   /*!< 0x00000010 */
N#define PWR_CR_PVDE                PWR_CR_PVDE_Msk                             /*!< Power Voltage Detector Enable */
N
N#define PWR_CR_PLS_Pos             (5U)                                        
N#define PWR_CR_PLS_Msk             (0x7U << PWR_CR_PLS_Pos)                    /*!< 0x000000E0 */
N#define PWR_CR_PLS                 PWR_CR_PLS_Msk                              /*!< PLS[2:0] bits (PVD Level Selection) */
N#define PWR_CR_PLS_0               (0x1U << PWR_CR_PLS_Pos)                    /*!< 0x00000020 */
N#define PWR_CR_PLS_1               (0x2U << PWR_CR_PLS_Pos)                    /*!< 0x00000040 */
N#define PWR_CR_PLS_2               (0x4U << PWR_CR_PLS_Pos)                    /*!< 0x00000080 */
N
N/*!< PVD level configuration */
N#define PWR_CR_PLS_LEV0            (0x00000000U)                               /*!< PVD level 0 */
N#define PWR_CR_PLS_LEV1            (0x00000020U)                               /*!< PVD level 1 */
N#define PWR_CR_PLS_LEV2            (0x00000040U)                               /*!< PVD level 2 */
N#define PWR_CR_PLS_LEV3            (0x00000060U)                               /*!< PVD level 3 */
N#define PWR_CR_PLS_LEV4            (0x00000080U)                               /*!< PVD level 4 */
N#define PWR_CR_PLS_LEV5            (0x000000A0U)                               /*!< PVD level 5 */
N#define PWR_CR_PLS_LEV6            (0x000000C0U)                               /*!< PVD level 6 */
N#define PWR_CR_PLS_LEV7            (0x000000E0U)                               /*!< PVD level 7 */
N
N#define PWR_CR_DBP_Pos             (8U)                                        
N#define PWR_CR_DBP_Msk             (0x1U << PWR_CR_DBP_Pos)                    /*!< 0x00000100 */
N#define PWR_CR_DBP                 PWR_CR_DBP_Msk                              /*!< Disable Backup Domain write protection */
N
N/*******************  Bit definition for PWR_CSR register  *******************/
N#define PWR_CSR_WUF_Pos            (0U)                                        
N#define PWR_CSR_WUF_Msk            (0x1U << PWR_CSR_WUF_Pos)                   /*!< 0x00000001 */
N#define PWR_CSR_WUF                PWR_CSR_WUF_Msk                             /*!< Wakeup Flag */
N#define PWR_CSR_SBF_Pos            (1U)                                        
N#define PWR_CSR_SBF_Msk            (0x1U << PWR_CSR_SBF_Pos)                   /*!< 0x00000002 */
N#define PWR_CSR_SBF                PWR_CSR_SBF_Msk                             /*!< Standby Flag */
N#define PWR_CSR_PVDO_Pos           (2U)                                        
N#define PWR_CSR_PVDO_Msk           (0x1U << PWR_CSR_PVDO_Pos)                  /*!< 0x00000004 */
N#define PWR_CSR_PVDO               PWR_CSR_PVDO_Msk                            /*!< PVD Output */
N#define PWR_CSR_VREFINTRDYF_Pos    (3U)                                        
N#define PWR_CSR_VREFINTRDYF_Msk    (0x1U << PWR_CSR_VREFINTRDYF_Pos)           /*!< 0x00000008 */
N#define PWR_CSR_VREFINTRDYF        PWR_CSR_VREFINTRDYF_Msk                     /*!< Internal voltage reference (VREFINT) ready flag */
N
N#define PWR_CSR_EWUP1_Pos          (8U)                                        
N#define PWR_CSR_EWUP1_Msk          (0x1U << PWR_CSR_EWUP1_Pos)                 /*!< 0x00000100 */
N#define PWR_CSR_EWUP1              PWR_CSR_EWUP1_Msk                           /*!< Enable WKUP pin 1 */
N#define PWR_CSR_EWUP2_Pos          (9U)                                        
N#define PWR_CSR_EWUP2_Msk          (0x1U << PWR_CSR_EWUP2_Pos)                 /*!< 0x00000200 */
N#define PWR_CSR_EWUP2              PWR_CSR_EWUP2_Msk                           /*!< Enable WKUP pin 2 */
N#define PWR_CSR_EWUP3_Pos          (10U)                                       
N#define PWR_CSR_EWUP3_Msk          (0x1U << PWR_CSR_EWUP3_Pos)                 /*!< 0x00000400 */
N#define PWR_CSR_EWUP3              PWR_CSR_EWUP3_Msk                           /*!< Enable WKUP pin 3 */
N#define PWR_CSR_EWUP4_Pos          (11U)                                       
N#define PWR_CSR_EWUP4_Msk          (0x1U << PWR_CSR_EWUP4_Pos)                 /*!< 0x00000800 */
N#define PWR_CSR_EWUP4              PWR_CSR_EWUP4_Msk                           /*!< Enable WKUP pin 4 */
N#define PWR_CSR_EWUP5_Pos          (12U)                                       
N#define PWR_CSR_EWUP5_Msk          (0x1U << PWR_CSR_EWUP5_Pos)                 /*!< 0x00001000 */
N#define PWR_CSR_EWUP5              PWR_CSR_EWUP5_Msk                           /*!< Enable WKUP pin 5 */
N#define PWR_CSR_EWUP6_Pos          (13U)                                       
N#define PWR_CSR_EWUP6_Msk          (0x1U << PWR_CSR_EWUP6_Pos)                 /*!< 0x00002000 */
N#define PWR_CSR_EWUP6              PWR_CSR_EWUP6_Msk                           /*!< Enable WKUP pin 6 */
N#define PWR_CSR_EWUP7_Pos          (14U)                                       
N#define PWR_CSR_EWUP7_Msk          (0x1U << PWR_CSR_EWUP7_Pos)                 /*!< 0x00004000 */
N#define PWR_CSR_EWUP7              PWR_CSR_EWUP7_Msk                           /*!< Enable WKUP pin 7 */
N#define PWR_CSR_EWUP8_Pos          (15U)                                       
N#define PWR_CSR_EWUP8_Msk          (0x1U << PWR_CSR_EWUP8_Pos)                 /*!< 0x00008000 */
N#define PWR_CSR_EWUP8              PWR_CSR_EWUP8_Msk                           /*!< Enable WKUP pin 8 */
N
N/*****************************************************************************/
N/*                                                                           */
N/*                         Reset and Clock Control                           */
N/*                                                                           */
N/*****************************************************************************/
N/*
N* @brief Specific device feature definitions  (not present on all devices in the STM32F0 serie)
N*/
N#define RCC_HSI48_SUPPORT           /*!< HSI48 feature support */
N#define RCC_PLLSRC_PREDIV1_SUPPORT  /*!< PREDIV support used as PLL source input  */
N
N/********************  Bit definition for RCC_CR register  *******************/
N#define RCC_CR_HSION_Pos                         (0U)                          
N#define RCC_CR_HSION_Msk                         (0x1U << RCC_CR_HSION_Pos)    /*!< 0x00000001 */
N#define RCC_CR_HSION                             RCC_CR_HSION_Msk              /*!< Internal High Speed clock enable */
N#define RCC_CR_HSIRDY_Pos                        (1U)                          
N#define RCC_CR_HSIRDY_Msk                        (0x1U << RCC_CR_HSIRDY_Pos)   /*!< 0x00000002 */
N#define RCC_CR_HSIRDY                            RCC_CR_HSIRDY_Msk             /*!< Internal High Speed clock ready flag */
N
N#define RCC_CR_HSITRIM_Pos                       (3U)                          
N#define RCC_CR_HSITRIM_Msk                       (0x1FU << RCC_CR_HSITRIM_Pos) /*!< 0x000000F8 */
N#define RCC_CR_HSITRIM                           RCC_CR_HSITRIM_Msk            /*!< Internal High Speed clock trimming */
N#define RCC_CR_HSITRIM_0                         (0x01U << RCC_CR_HSITRIM_Pos) /*!< 0x00000008 */
N#define RCC_CR_HSITRIM_1                         (0x02U << RCC_CR_HSITRIM_Pos) /*!< 0x00000010 */
N#define RCC_CR_HSITRIM_2                         (0x04U << RCC_CR_HSITRIM_Pos) /*!< 0x00000020 */
N#define RCC_CR_HSITRIM_3                         (0x08U << RCC_CR_HSITRIM_Pos) /*!< 0x00000040 */
N#define RCC_CR_HSITRIM_4                         (0x10U << RCC_CR_HSITRIM_Pos) /*!< 0x00000080 */
N
N#define RCC_CR_HSICAL_Pos                        (8U)                          
N#define RCC_CR_HSICAL_Msk                        (0xFFU << RCC_CR_HSICAL_Pos)  /*!< 0x0000FF00 */
N#define RCC_CR_HSICAL                            RCC_CR_HSICAL_Msk             /*!< Internal High Speed clock Calibration */
N#define RCC_CR_HSICAL_0                          (0x01U << RCC_CR_HSICAL_Pos)  /*!< 0x00000100 */
N#define RCC_CR_HSICAL_1                          (0x02U << RCC_CR_HSICAL_Pos)  /*!< 0x00000200 */
N#define RCC_CR_HSICAL_2                          (0x04U << RCC_CR_HSICAL_Pos)  /*!< 0x00000400 */
N#define RCC_CR_HSICAL_3                          (0x08U << RCC_CR_HSICAL_Pos)  /*!< 0x00000800 */
N#define RCC_CR_HSICAL_4                          (0x10U << RCC_CR_HSICAL_Pos)  /*!< 0x00001000 */
N#define RCC_CR_HSICAL_5                          (0x20U << RCC_CR_HSICAL_Pos)  /*!< 0x00002000 */
N#define RCC_CR_HSICAL_6                          (0x40U << RCC_CR_HSICAL_Pos)  /*!< 0x00004000 */
N#define RCC_CR_HSICAL_7                          (0x80U << RCC_CR_HSICAL_Pos)  /*!< 0x00008000 */
N
N#define RCC_CR_HSEON_Pos                         (16U)                         
N#define RCC_CR_HSEON_Msk                         (0x1U << RCC_CR_HSEON_Pos)    /*!< 0x00010000 */
N#define RCC_CR_HSEON                             RCC_CR_HSEON_Msk              /*!< External High Speed clock enable */
N#define RCC_CR_HSERDY_Pos                        (17U)                         
N#define RCC_CR_HSERDY_Msk                        (0x1U << RCC_CR_HSERDY_Pos)   /*!< 0x00020000 */
N#define RCC_CR_HSERDY                            RCC_CR_HSERDY_Msk             /*!< External High Speed clock ready flag */
N#define RCC_CR_HSEBYP_Pos                        (18U)                         
N#define RCC_CR_HSEBYP_Msk                        (0x1U << RCC_CR_HSEBYP_Pos)   /*!< 0x00040000 */
N#define RCC_CR_HSEBYP                            RCC_CR_HSEBYP_Msk             /*!< External High Speed clock Bypass */
N#define RCC_CR_CSSON_Pos                         (19U)                         
N#define RCC_CR_CSSON_Msk                         (0x1U << RCC_CR_CSSON_Pos)    /*!< 0x00080000 */
N#define RCC_CR_CSSON                             RCC_CR_CSSON_Msk              /*!< Clock Security System enable */
N#define RCC_CR_PLLON_Pos                         (24U)                         
N#define RCC_CR_PLLON_Msk                         (0x1U << RCC_CR_PLLON_Pos)    /*!< 0x01000000 */
N#define RCC_CR_PLLON                             RCC_CR_PLLON_Msk              /*!< PLL enable */
N#define RCC_CR_PLLRDY_Pos                        (25U)                         
N#define RCC_CR_PLLRDY_Msk                        (0x1U << RCC_CR_PLLRDY_Pos)   /*!< 0x02000000 */
N#define RCC_CR_PLLRDY                            RCC_CR_PLLRDY_Msk             /*!< PLL clock ready flag */
N
N/********************  Bit definition for RCC_CFGR register  *****************/
N/*!< SW configuration */
N#define RCC_CFGR_SW_Pos                          (0U)                          
N#define RCC_CFGR_SW_Msk                          (0x3U << RCC_CFGR_SW_Pos)     /*!< 0x00000003 */
N#define RCC_CFGR_SW                              RCC_CFGR_SW_Msk               /*!< SW[1:0] bits (System clock Switch) */
N#define RCC_CFGR_SW_0                            (0x1U << RCC_CFGR_SW_Pos)     /*!< 0x00000001 */
N#define RCC_CFGR_SW_1                            (0x2U << RCC_CFGR_SW_Pos)     /*!< 0x00000002 */
N
N#define RCC_CFGR_SW_HSI                          (0x00000000U)                 /*!< HSI selected as system clock */
N#define RCC_CFGR_SW_HSE                          (0x00000001U)                 /*!< HSE selected as system clock */
N#define RCC_CFGR_SW_PLL                          (0x00000002U)                 /*!< PLL selected as system clock */
N#define RCC_CFGR_SW_HSI48                        (0x00000003U)                 /*!< HSI48 selected as system clock */
N
N/*!< SWS configuration */
N#define RCC_CFGR_SWS_Pos                         (2U)                          
N#define RCC_CFGR_SWS_Msk                         (0x3U << RCC_CFGR_SWS_Pos)    /*!< 0x0000000C */
N#define RCC_CFGR_SWS                             RCC_CFGR_SWS_Msk              /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define RCC_CFGR_SWS_0                           (0x1U << RCC_CFGR_SWS_Pos)    /*!< 0x00000004 */
N#define RCC_CFGR_SWS_1                           (0x2U << RCC_CFGR_SWS_Pos)    /*!< 0x00000008 */
N
N#define RCC_CFGR_SWS_HSI                         (0x00000000U)                 /*!< HSI oscillator used as system clock */
N#define RCC_CFGR_SWS_HSE                         (0x00000004U)                 /*!< HSE oscillator used as system clock */
N#define RCC_CFGR_SWS_PLL                         (0x00000008U)                 /*!< PLL used as system clock */
N#define RCC_CFGR_SWS_HSI48                       (0x0000000CU)                 /*!< HSI48 oscillator used as system clock */
N
N/*!< HPRE configuration */
N#define RCC_CFGR_HPRE_Pos                        (4U)                          
N#define RCC_CFGR_HPRE_Msk                        (0xFU << RCC_CFGR_HPRE_Pos)   /*!< 0x000000F0 */
N#define RCC_CFGR_HPRE                            RCC_CFGR_HPRE_Msk             /*!< HPRE[3:0] bits (AHB prescaler) */
N#define RCC_CFGR_HPRE_0                          (0x1U << RCC_CFGR_HPRE_Pos)   /*!< 0x00000010 */
N#define RCC_CFGR_HPRE_1                          (0x2U << RCC_CFGR_HPRE_Pos)   /*!< 0x00000020 */
N#define RCC_CFGR_HPRE_2                          (0x4U << RCC_CFGR_HPRE_Pos)   /*!< 0x00000040 */
N#define RCC_CFGR_HPRE_3                          (0x8U << RCC_CFGR_HPRE_Pos)   /*!< 0x00000080 */
N
N#define RCC_CFGR_HPRE_DIV1                       (0x00000000U)                 /*!< SYSCLK not divided */
N#define RCC_CFGR_HPRE_DIV2                       (0x00000080U)                 /*!< SYSCLK divided by 2 */
N#define RCC_CFGR_HPRE_DIV4                       (0x00000090U)                 /*!< SYSCLK divided by 4 */
N#define RCC_CFGR_HPRE_DIV8                       (0x000000A0U)                 /*!< SYSCLK divided by 8 */
N#define RCC_CFGR_HPRE_DIV16                      (0x000000B0U)                 /*!< SYSCLK divided by 16 */
N#define RCC_CFGR_HPRE_DIV64                      (0x000000C0U)                 /*!< SYSCLK divided by 64 */
N#define RCC_CFGR_HPRE_DIV128                     (0x000000D0U)                 /*!< SYSCLK divided by 128 */
N#define RCC_CFGR_HPRE_DIV256                     (0x000000E0U)                 /*!< SYSCLK divided by 256 */
N#define RCC_CFGR_HPRE_DIV512                     (0x000000F0U)                 /*!< SYSCLK divided by 512 */
N
N/*!< PPRE configuration */
N#define RCC_CFGR_PPRE_Pos                        (8U)                          
N#define RCC_CFGR_PPRE_Msk                        (0x7U << RCC_CFGR_PPRE_Pos)   /*!< 0x00000700 */
N#define RCC_CFGR_PPRE                            RCC_CFGR_PPRE_Msk             /*!< PRE[2:0] bits (APB prescaler) */
N#define RCC_CFGR_PPRE_0                          (0x1U << RCC_CFGR_PPRE_Pos)   /*!< 0x00000100 */
N#define RCC_CFGR_PPRE_1                          (0x2U << RCC_CFGR_PPRE_Pos)   /*!< 0x00000200 */
N#define RCC_CFGR_PPRE_2                          (0x4U << RCC_CFGR_PPRE_Pos)   /*!< 0x00000400 */
N
N#define RCC_CFGR_PPRE_DIV1                       (0x00000000U)                 /*!< HCLK not divided */
N#define RCC_CFGR_PPRE_DIV2_Pos                   (10U)                         
N#define RCC_CFGR_PPRE_DIV2_Msk                   (0x1U << RCC_CFGR_PPRE_DIV2_Pos) /*!< 0x00000400 */
N#define RCC_CFGR_PPRE_DIV2                       RCC_CFGR_PPRE_DIV2_Msk        /*!< HCLK divided by 2 */
N#define RCC_CFGR_PPRE_DIV4_Pos                   (8U)                          
N#define RCC_CFGR_PPRE_DIV4_Msk                   (0x5U << RCC_CFGR_PPRE_DIV4_Pos) /*!< 0x00000500 */
N#define RCC_CFGR_PPRE_DIV4                       RCC_CFGR_PPRE_DIV4_Msk        /*!< HCLK divided by 4 */
N#define RCC_CFGR_PPRE_DIV8_Pos                   (9U)                          
N#define RCC_CFGR_PPRE_DIV8_Msk                   (0x3U << RCC_CFGR_PPRE_DIV8_Pos) /*!< 0x00000600 */
N#define RCC_CFGR_PPRE_DIV8                       RCC_CFGR_PPRE_DIV8_Msk        /*!< HCLK divided by 8 */
N#define RCC_CFGR_PPRE_DIV16_Pos                  (8U)                          
N#define RCC_CFGR_PPRE_DIV16_Msk                  (0x7U << RCC_CFGR_PPRE_DIV16_Pos) /*!< 0x00000700 */
N#define RCC_CFGR_PPRE_DIV16                      RCC_CFGR_PPRE_DIV16_Msk       /*!< HCLK divided by 16 */
N
N#define RCC_CFGR_PLLSRC_Pos                      (15U)                         
N#define RCC_CFGR_PLLSRC_Msk                      (0x3U << RCC_CFGR_PLLSRC_Pos) /*!< 0x00018000 */
N#define RCC_CFGR_PLLSRC                          RCC_CFGR_PLLSRC_Msk           /*!< PLL entry clock source */
N#define RCC_CFGR_PLLSRC_HSI_DIV2                 (0x00000000U)                 /*!< HSI clock divided by 2 selected as PLL entry clock source */
N#define RCC_CFGR_PLLSRC_HSI_PREDIV               (0x00008000U)                 /*!< HSI/PREDIV clock selected as PLL entry clock source */
N#define RCC_CFGR_PLLSRC_HSE_PREDIV               (0x00010000U)                 /*!< HSE/PREDIV clock selected as PLL entry clock source */
N#define RCC_CFGR_PLLSRC_HSI48_PREDIV             (0x00018000U)                 /*!< HSI48/PREDIV clock selected as PLL entry clock source */
N
N#define RCC_CFGR_PLLXTPRE_Pos                    (17U)                         
N#define RCC_CFGR_PLLXTPRE_Msk                    (0x1U << RCC_CFGR_PLLXTPRE_Pos) /*!< 0x00020000 */
N#define RCC_CFGR_PLLXTPRE                        RCC_CFGR_PLLXTPRE_Msk         /*!< HSE divider for PLL entry */
N#define RCC_CFGR_PLLXTPRE_HSE_PREDIV_DIV1        (0x00000000U)                 /*!< HSE/PREDIV clock not divided for PLL entry */
N#define RCC_CFGR_PLLXTPRE_HSE_PREDIV_DIV2        (0x00020000U)                 /*!< HSE/PREDIV clock divided by 2 for PLL entry */
N
N/*!< PLLMUL configuration */
N#define RCC_CFGR_PLLMUL_Pos                      (18U)                         
N#define RCC_CFGR_PLLMUL_Msk                      (0xFU << RCC_CFGR_PLLMUL_Pos) /*!< 0x003C0000 */
N#define RCC_CFGR_PLLMUL                          RCC_CFGR_PLLMUL_Msk           /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
N#define RCC_CFGR_PLLMUL_0                        (0x1U << RCC_CFGR_PLLMUL_Pos) /*!< 0x00040000 */
N#define RCC_CFGR_PLLMUL_1                        (0x2U << RCC_CFGR_PLLMUL_Pos) /*!< 0x00080000 */
N#define RCC_CFGR_PLLMUL_2                        (0x4U << RCC_CFGR_PLLMUL_Pos) /*!< 0x00100000 */
N#define RCC_CFGR_PLLMUL_3                        (0x8U << RCC_CFGR_PLLMUL_Pos) /*!< 0x00200000 */
N
N#define RCC_CFGR_PLLMUL2                         (0x00000000U)                 /*!< PLL input clock*2 */
N#define RCC_CFGR_PLLMUL3                         (0x00040000U)                 /*!< PLL input clock*3 */
N#define RCC_CFGR_PLLMUL4                         (0x00080000U)                 /*!< PLL input clock*4 */
N#define RCC_CFGR_PLLMUL5                         (0x000C0000U)                 /*!< PLL input clock*5 */
N#define RCC_CFGR_PLLMUL6                         (0x00100000U)                 /*!< PLL input clock*6 */
N#define RCC_CFGR_PLLMUL7                         (0x00140000U)                 /*!< PLL input clock*7 */
N#define RCC_CFGR_PLLMUL8                         (0x00180000U)                 /*!< PLL input clock*8 */
N#define RCC_CFGR_PLLMUL9                         (0x001C0000U)                 /*!< PLL input clock*9 */
N#define RCC_CFGR_PLLMUL10                        (0x00200000U)                 /*!< PLL input clock10 */
N#define RCC_CFGR_PLLMUL11                        (0x00240000U)                 /*!< PLL input clock*11 */
N#define RCC_CFGR_PLLMUL12                        (0x00280000U)                 /*!< PLL input clock*12 */
N#define RCC_CFGR_PLLMUL13                        (0x002C0000U)                 /*!< PLL input clock*13 */
N#define RCC_CFGR_PLLMUL14                        (0x00300000U)                 /*!< PLL input clock*14 */
N#define RCC_CFGR_PLLMUL15                        (0x00340000U)                 /*!< PLL input clock*15 */
N#define RCC_CFGR_PLLMUL16                        (0x00380000U)                 /*!< PLL input clock*16 */
N
N/*!< MCO configuration */
N#define RCC_CFGR_MCO_Pos                         (24U)                         
N#define RCC_CFGR_MCO_Msk                         (0xFU << RCC_CFGR_MCO_Pos)    /*!< 0x0F000000 */
N#define RCC_CFGR_MCO                             RCC_CFGR_MCO_Msk              /*!< MCO[3:0] bits (Microcontroller Clock Output) */
N#define RCC_CFGR_MCO_0                           (0x1U << RCC_CFGR_MCO_Pos)    /*!< 0x01000000 */
N#define RCC_CFGR_MCO_1                           (0x2U << RCC_CFGR_MCO_Pos)    /*!< 0x02000000 */
N#define RCC_CFGR_MCO_2                           (0x4U << RCC_CFGR_MCO_Pos)    /*!< 0x04000000 */
N#define RCC_CFGR_MCO_3                           (0x08000000U)                 /*!< Bit 3 */
N
N#define RCC_CFGR_MCO_NOCLOCK                     (0x00000000U)                 /*!< No clock */
N#define RCC_CFGR_MCO_HSI14                       (0x01000000U)                 /*!< HSI14 clock selected as MCO source */
N#define RCC_CFGR_MCO_LSI                         (0x02000000U)                 /*!< LSI clock selected as MCO source */
N#define RCC_CFGR_MCO_LSE                         (0x03000000U)                 /*!< LSE clock selected as MCO source */
N#define RCC_CFGR_MCO_SYSCLK                      (0x04000000U)                 /*!< System clock selected as MCO source */
N#define RCC_CFGR_MCO_HSI                         (0x05000000U)                 /*!< HSI clock selected as MCO source */
N#define RCC_CFGR_MCO_HSE                         (0x06000000U)                 /*!< HSE clock selected as MCO source  */
N#define RCC_CFGR_MCO_PLL                         (0x07000000U)                 /*!< PLL clock divided by 2 selected as MCO source */
N#define RCC_CFGR_MCO_HSI48                       (0x08000000U)                 /*!< HSI48 clock selected as MCO source */
N
N#define RCC_CFGR_MCOPRE_Pos                      (28U)                         
N#define RCC_CFGR_MCOPRE_Msk                      (0x7U << RCC_CFGR_MCOPRE_Pos) /*!< 0x70000000 */
N#define RCC_CFGR_MCOPRE                          RCC_CFGR_MCOPRE_Msk           /*!< MCO prescaler  */
N#define RCC_CFGR_MCOPRE_DIV1                     (0x00000000U)                 /*!< MCO is divided by 1  */
N#define RCC_CFGR_MCOPRE_DIV2                     (0x10000000U)                 /*!< MCO is divided by 2  */
N#define RCC_CFGR_MCOPRE_DIV4                     (0x20000000U)                 /*!< MCO is divided by 4  */
N#define RCC_CFGR_MCOPRE_DIV8                     (0x30000000U)                 /*!< MCO is divided by 8  */
N#define RCC_CFGR_MCOPRE_DIV16                    (0x40000000U)                 /*!< MCO is divided by 16  */
N#define RCC_CFGR_MCOPRE_DIV32                    (0x50000000U)                 /*!< MCO is divided by 32  */
N#define RCC_CFGR_MCOPRE_DIV64                    (0x60000000U)                 /*!< MCO is divided by 64  */
N#define RCC_CFGR_MCOPRE_DIV128                   (0x70000000U)                 /*!< MCO is divided by 128  */
N
N#define RCC_CFGR_PLLNODIV_Pos                    (31U)                         
N#define RCC_CFGR_PLLNODIV_Msk                    (0x1U << RCC_CFGR_PLLNODIV_Pos) /*!< 0x80000000 */
N#define RCC_CFGR_PLLNODIV                        RCC_CFGR_PLLNODIV_Msk         /*!< PLL is not divided to MCO  */
N
N/* Reference defines */
N#define RCC_CFGR_MCOSEL                      RCC_CFGR_MCO
N#define RCC_CFGR_MCOSEL_0                    RCC_CFGR_MCO_0
N#define RCC_CFGR_MCOSEL_1                    RCC_CFGR_MCO_1
N#define RCC_CFGR_MCOSEL_2                    RCC_CFGR_MCO_2
N#define RCC_CFGR_MCOSEL_3                    RCC_CFGR_MCO_3
N#define RCC_CFGR_MCOSEL_NOCLOCK              RCC_CFGR_MCO_NOCLOCK
N#define RCC_CFGR_MCOSEL_HSI14                RCC_CFGR_MCO_HSI14
N#define RCC_CFGR_MCOSEL_LSI                  RCC_CFGR_MCO_LSI
N#define RCC_CFGR_MCOSEL_LSE                  RCC_CFGR_MCO_LSE
N#define RCC_CFGR_MCOSEL_SYSCLK               RCC_CFGR_MCO_SYSCLK
N#define RCC_CFGR_MCOSEL_HSI                  RCC_CFGR_MCO_HSI
N#define RCC_CFGR_MCOSEL_HSE                  RCC_CFGR_MCO_HSE
N#define RCC_CFGR_MCOSEL_PLL_DIV2             RCC_CFGR_MCO_PLL
N#define RCC_CFGR_MCOSEL_HSI48                RCC_CFGR_MCO_HSI48
N
N/*!<******************  Bit definition for RCC_CIR register  *****************/
N#define RCC_CIR_LSIRDYF_Pos                      (0U)                          
N#define RCC_CIR_LSIRDYF_Msk                      (0x1U << RCC_CIR_LSIRDYF_Pos) /*!< 0x00000001 */
N#define RCC_CIR_LSIRDYF                          RCC_CIR_LSIRDYF_Msk           /*!< LSI Ready Interrupt flag */
N#define RCC_CIR_LSERDYF_Pos                      (1U)                          
N#define RCC_CIR_LSERDYF_Msk                      (0x1U << RCC_CIR_LSERDYF_Pos) /*!< 0x00000002 */
N#define RCC_CIR_LSERDYF                          RCC_CIR_LSERDYF_Msk           /*!< LSE Ready Interrupt flag */
N#define RCC_CIR_HSIRDYF_Pos                      (2U)                          
N#define RCC_CIR_HSIRDYF_Msk                      (0x1U << RCC_CIR_HSIRDYF_Pos) /*!< 0x00000004 */
N#define RCC_CIR_HSIRDYF                          RCC_CIR_HSIRDYF_Msk           /*!< HSI Ready Interrupt flag */
N#define RCC_CIR_HSERDYF_Pos                      (3U)                          
N#define RCC_CIR_HSERDYF_Msk                      (0x1U << RCC_CIR_HSERDYF_Pos) /*!< 0x00000008 */
N#define RCC_CIR_HSERDYF                          RCC_CIR_HSERDYF_Msk           /*!< HSE Ready Interrupt flag */
N#define RCC_CIR_PLLRDYF_Pos                      (4U)                          
N#define RCC_CIR_PLLRDYF_Msk                      (0x1U << RCC_CIR_PLLRDYF_Pos) /*!< 0x00000010 */
N#define RCC_CIR_PLLRDYF                          RCC_CIR_PLLRDYF_Msk           /*!< PLL Ready Interrupt flag */
N#define RCC_CIR_HSI14RDYF_Pos                    (5U)                          
N#define RCC_CIR_HSI14RDYF_Msk                    (0x1U << RCC_CIR_HSI14RDYF_Pos) /*!< 0x00000020 */
N#define RCC_CIR_HSI14RDYF                        RCC_CIR_HSI14RDYF_Msk         /*!< HSI14 Ready Interrupt flag */
N#define RCC_CIR_HSI48RDYF_Pos                    (6U)                          
N#define RCC_CIR_HSI48RDYF_Msk                    (0x1U << RCC_CIR_HSI48RDYF_Pos) /*!< 0x00000040 */
N#define RCC_CIR_HSI48RDYF                        RCC_CIR_HSI48RDYF_Msk         /*!< HSI48 Ready Interrupt flag */
N#define RCC_CIR_CSSF_Pos                         (7U)                          
N#define RCC_CIR_CSSF_Msk                         (0x1U << RCC_CIR_CSSF_Pos)    /*!< 0x00000080 */
N#define RCC_CIR_CSSF                             RCC_CIR_CSSF_Msk              /*!< Clock Security System Interrupt flag */
N#define RCC_CIR_LSIRDYIE_Pos                     (8U)                          
N#define RCC_CIR_LSIRDYIE_Msk                     (0x1U << RCC_CIR_LSIRDYIE_Pos) /*!< 0x00000100 */
N#define RCC_CIR_LSIRDYIE                         RCC_CIR_LSIRDYIE_Msk          /*!< LSI Ready Interrupt Enable */
N#define RCC_CIR_LSERDYIE_Pos                     (9U)                          
N#define RCC_CIR_LSERDYIE_Msk                     (0x1U << RCC_CIR_LSERDYIE_Pos) /*!< 0x00000200 */
N#define RCC_CIR_LSERDYIE                         RCC_CIR_LSERDYIE_Msk          /*!< LSE Ready Interrupt Enable */
N#define RCC_CIR_HSIRDYIE_Pos                     (10U)                         
N#define RCC_CIR_HSIRDYIE_Msk                     (0x1U << RCC_CIR_HSIRDYIE_Pos) /*!< 0x00000400 */
N#define RCC_CIR_HSIRDYIE                         RCC_CIR_HSIRDYIE_Msk          /*!< HSI Ready Interrupt Enable */
N#define RCC_CIR_HSERDYIE_Pos                     (11U)                         
N#define RCC_CIR_HSERDYIE_Msk                     (0x1U << RCC_CIR_HSERDYIE_Pos) /*!< 0x00000800 */
N#define RCC_CIR_HSERDYIE                         RCC_CIR_HSERDYIE_Msk          /*!< HSE Ready Interrupt Enable */
N#define RCC_CIR_PLLRDYIE_Pos                     (12U)                         
N#define RCC_CIR_PLLRDYIE_Msk                     (0x1U << RCC_CIR_PLLRDYIE_Pos) /*!< 0x00001000 */
N#define RCC_CIR_PLLRDYIE                         RCC_CIR_PLLRDYIE_Msk          /*!< PLL Ready Interrupt Enable */
N#define RCC_CIR_HSI14RDYIE_Pos                   (13U)                         
N#define RCC_CIR_HSI14RDYIE_Msk                   (0x1U << RCC_CIR_HSI14RDYIE_Pos) /*!< 0x00002000 */
N#define RCC_CIR_HSI14RDYIE                       RCC_CIR_HSI14RDYIE_Msk        /*!< HSI14 Ready Interrupt Enable */
N#define RCC_CIR_HSI48RDYIE_Pos                   (14U)                         
N#define RCC_CIR_HSI48RDYIE_Msk                   (0x1U << RCC_CIR_HSI48RDYIE_Pos) /*!< 0x00004000 */
N#define RCC_CIR_HSI48RDYIE                       RCC_CIR_HSI48RDYIE_Msk        /*!< HSI48 Ready Interrupt Enable */
N#define RCC_CIR_LSIRDYC_Pos                      (16U)                         
N#define RCC_CIR_LSIRDYC_Msk                      (0x1U << RCC_CIR_LSIRDYC_Pos) /*!< 0x00010000 */
N#define RCC_CIR_LSIRDYC                          RCC_CIR_LSIRDYC_Msk           /*!< LSI Ready Interrupt Clear */
N#define RCC_CIR_LSERDYC_Pos                      (17U)                         
N#define RCC_CIR_LSERDYC_Msk                      (0x1U << RCC_CIR_LSERDYC_Pos) /*!< 0x00020000 */
N#define RCC_CIR_LSERDYC                          RCC_CIR_LSERDYC_Msk           /*!< LSE Ready Interrupt Clear */
N#define RCC_CIR_HSIRDYC_Pos                      (18U)                         
N#define RCC_CIR_HSIRDYC_Msk                      (0x1U << RCC_CIR_HSIRDYC_Pos) /*!< 0x00040000 */
N#define RCC_CIR_HSIRDYC                          RCC_CIR_HSIRDYC_Msk           /*!< HSI Ready Interrupt Clear */
N#define RCC_CIR_HSERDYC_Pos                      (19U)                         
N#define RCC_CIR_HSERDYC_Msk                      (0x1U << RCC_CIR_HSERDYC_Pos) /*!< 0x00080000 */
N#define RCC_CIR_HSERDYC                          RCC_CIR_HSERDYC_Msk           /*!< HSE Ready Interrupt Clear */
N#define RCC_CIR_PLLRDYC_Pos                      (20U)                         
N#define RCC_CIR_PLLRDYC_Msk                      (0x1U << RCC_CIR_PLLRDYC_Pos) /*!< 0x00100000 */
N#define RCC_CIR_PLLRDYC                          RCC_CIR_PLLRDYC_Msk           /*!< PLL Ready Interrupt Clear */
N#define RCC_CIR_HSI14RDYC_Pos                    (21U)                         
N#define RCC_CIR_HSI14RDYC_Msk                    (0x1U << RCC_CIR_HSI14RDYC_Pos) /*!< 0x00200000 */
N#define RCC_CIR_HSI14RDYC                        RCC_CIR_HSI14RDYC_Msk         /*!< HSI14 Ready Interrupt Clear */
N#define RCC_CIR_HSI48RDYC_Pos                    (22U)                         
N#define RCC_CIR_HSI48RDYC_Msk                    (0x1U << RCC_CIR_HSI48RDYC_Pos) /*!< 0x00400000 */
N#define RCC_CIR_HSI48RDYC                        RCC_CIR_HSI48RDYC_Msk         /*!< HSI48 Ready Interrupt Clear */
N#define RCC_CIR_CSSC_Pos                         (23U)                         
N#define RCC_CIR_CSSC_Msk                         (0x1U << RCC_CIR_CSSC_Pos)    /*!< 0x00800000 */
N#define RCC_CIR_CSSC                             RCC_CIR_CSSC_Msk              /*!< Clock Security System Interrupt Clear */
N
N/*****************  Bit definition for RCC_APB2RSTR register  ****************/
N#define RCC_APB2RSTR_SYSCFGRST_Pos               (0U)                          
N#define RCC_APB2RSTR_SYSCFGRST_Msk               (0x1U << RCC_APB2RSTR_SYSCFGRST_Pos) /*!< 0x00000001 */
N#define RCC_APB2RSTR_SYSCFGRST                   RCC_APB2RSTR_SYSCFGRST_Msk    /*!< SYSCFG reset */
N#define RCC_APB2RSTR_USART6RST_Pos               (5U)                          
N#define RCC_APB2RSTR_USART6RST_Msk               (0x1U << RCC_APB2RSTR_USART6RST_Pos) /*!< 0x00000020 */
N#define RCC_APB2RSTR_USART6RST                   RCC_APB2RSTR_USART6RST_Msk    /*!< USART6 reset */
N#define RCC_APB2RSTR_USART7RST_Pos               (6U)                          
N#define RCC_APB2RSTR_USART7RST_Msk               (0x1U << RCC_APB2RSTR_USART7RST_Pos) /*!< 0x00000040 */
N#define RCC_APB2RSTR_USART7RST                   RCC_APB2RSTR_USART7RST_Msk    /*!< USART7 reset */
N#define RCC_APB2RSTR_USART8RST_Pos               (7U)                          
N#define RCC_APB2RSTR_USART8RST_Msk               (0x1U << RCC_APB2RSTR_USART8RST_Pos) /*!< 0x00000080 */
N#define RCC_APB2RSTR_USART8RST                   RCC_APB2RSTR_USART8RST_Msk    /*!< USART8 reset */
N#define RCC_APB2RSTR_ADCRST_Pos                  (9U)                          
N#define RCC_APB2RSTR_ADCRST_Msk                  (0x1U << RCC_APB2RSTR_ADCRST_Pos) /*!< 0x00000200 */
N#define RCC_APB2RSTR_ADCRST                      RCC_APB2RSTR_ADCRST_Msk       /*!< ADC reset */
N#define RCC_APB2RSTR_TIM1RST_Pos                 (11U)                         
N#define RCC_APB2RSTR_TIM1RST_Msk                 (0x1U << RCC_APB2RSTR_TIM1RST_Pos) /*!< 0x00000800 */
N#define RCC_APB2RSTR_TIM1RST                     RCC_APB2RSTR_TIM1RST_Msk      /*!< TIM1 reset */
N#define RCC_APB2RSTR_SPI1RST_Pos                 (12U)                         
N#define RCC_APB2RSTR_SPI1RST_Msk                 (0x1U << RCC_APB2RSTR_SPI1RST_Pos) /*!< 0x00001000 */
N#define RCC_APB2RSTR_SPI1RST                     RCC_APB2RSTR_SPI1RST_Msk      /*!< SPI1 reset */
N#define RCC_APB2RSTR_USART1RST_Pos               (14U)                         
N#define RCC_APB2RSTR_USART1RST_Msk               (0x1U << RCC_APB2RSTR_USART1RST_Pos) /*!< 0x00004000 */
N#define RCC_APB2RSTR_USART1RST                   RCC_APB2RSTR_USART1RST_Msk    /*!< USART1 reset */
N#define RCC_APB2RSTR_TIM15RST_Pos                (16U)                         
N#define RCC_APB2RSTR_TIM15RST_Msk                (0x1U << RCC_APB2RSTR_TIM15RST_Pos) /*!< 0x00010000 */
N#define RCC_APB2RSTR_TIM15RST                    RCC_APB2RSTR_TIM15RST_Msk     /*!< TIM15 reset */
N#define RCC_APB2RSTR_TIM16RST_Pos                (17U)                         
N#define RCC_APB2RSTR_TIM16RST_Msk                (0x1U << RCC_APB2RSTR_TIM16RST_Pos) /*!< 0x00020000 */
N#define RCC_APB2RSTR_TIM16RST                    RCC_APB2RSTR_TIM16RST_Msk     /*!< TIM16 reset */
N#define RCC_APB2RSTR_TIM17RST_Pos                (18U)                         
N#define RCC_APB2RSTR_TIM17RST_Msk                (0x1U << RCC_APB2RSTR_TIM17RST_Pos) /*!< 0x00040000 */
N#define RCC_APB2RSTR_TIM17RST                    RCC_APB2RSTR_TIM17RST_Msk     /*!< TIM17 reset */
N#define RCC_APB2RSTR_DBGMCURST_Pos               (22U)                         
N#define RCC_APB2RSTR_DBGMCURST_Msk               (0x1U << RCC_APB2RSTR_DBGMCURST_Pos) /*!< 0x00400000 */
N#define RCC_APB2RSTR_DBGMCURST                   RCC_APB2RSTR_DBGMCURST_Msk    /*!< DBGMCU reset */
N
N/*!< Old ADC1 reset bit definition maintained for legacy purpose */
N#define  RCC_APB2RSTR_ADC1RST                RCC_APB2RSTR_ADCRST          
N
N/*****************  Bit definition for RCC_APB1RSTR register  ****************/
N#define RCC_APB1RSTR_TIM2RST_Pos                 (0U)                          
N#define RCC_APB1RSTR_TIM2RST_Msk                 (0x1U << RCC_APB1RSTR_TIM2RST_Pos) /*!< 0x00000001 */
N#define RCC_APB1RSTR_TIM2RST                     RCC_APB1RSTR_TIM2RST_Msk      /*!< Timer 2 reset */
N#define RCC_APB1RSTR_TIM3RST_Pos                 (1U)                          
N#define RCC_APB1RSTR_TIM3RST_Msk                 (0x1U << RCC_APB1RSTR_TIM3RST_Pos) /*!< 0x00000002 */
N#define RCC_APB1RSTR_TIM3RST                     RCC_APB1RSTR_TIM3RST_Msk      /*!< Timer 3 reset */
N#define RCC_APB1RSTR_TIM6RST_Pos                 (4U)                          
N#define RCC_APB1RSTR_TIM6RST_Msk                 (0x1U << RCC_APB1RSTR_TIM6RST_Pos) /*!< 0x00000010 */
N#define RCC_APB1RSTR_TIM6RST                     RCC_APB1RSTR_TIM6RST_Msk      /*!< Timer 6 reset */
N#define RCC_APB1RSTR_TIM7RST_Pos                 (5U)                          
N#define RCC_APB1RSTR_TIM7RST_Msk                 (0x1U << RCC_APB1RSTR_TIM7RST_Pos) /*!< 0x00000020 */
N#define RCC_APB1RSTR_TIM7RST                     RCC_APB1RSTR_TIM7RST_Msk      /*!< Timer 7 reset */
N#define RCC_APB1RSTR_TIM14RST_Pos                (8U)                          
N#define RCC_APB1RSTR_TIM14RST_Msk                (0x1U << RCC_APB1RSTR_TIM14RST_Pos) /*!< 0x00000100 */
N#define RCC_APB1RSTR_TIM14RST                    RCC_APB1RSTR_TIM14RST_Msk     /*!< Timer 14 reset */
N#define RCC_APB1RSTR_WWDGRST_Pos                 (11U)                         
N#define RCC_APB1RSTR_WWDGRST_Msk                 (0x1U << RCC_APB1RSTR_WWDGRST_Pos) /*!< 0x00000800 */
N#define RCC_APB1RSTR_WWDGRST                     RCC_APB1RSTR_WWDGRST_Msk      /*!< Window Watchdog reset */
N#define RCC_APB1RSTR_SPI2RST_Pos                 (14U)                         
N#define RCC_APB1RSTR_SPI2RST_Msk                 (0x1U << RCC_APB1RSTR_SPI2RST_Pos) /*!< 0x00004000 */
N#define RCC_APB1RSTR_SPI2RST                     RCC_APB1RSTR_SPI2RST_Msk      /*!< SPI2 reset */
N#define RCC_APB1RSTR_USART2RST_Pos               (17U)                         
N#define RCC_APB1RSTR_USART2RST_Msk               (0x1U << RCC_APB1RSTR_USART2RST_Pos) /*!< 0x00020000 */
N#define RCC_APB1RSTR_USART2RST                   RCC_APB1RSTR_USART2RST_Msk    /*!< USART 2 reset */
N#define RCC_APB1RSTR_USART3RST_Pos               (18U)                         
N#define RCC_APB1RSTR_USART3RST_Msk               (0x1U << RCC_APB1RSTR_USART3RST_Pos) /*!< 0x00040000 */
N#define RCC_APB1RSTR_USART3RST                   RCC_APB1RSTR_USART3RST_Msk    /*!< USART 3 reset */
N#define RCC_APB1RSTR_USART4RST_Pos               (19U)                         
N#define RCC_APB1RSTR_USART4RST_Msk               (0x1U << RCC_APB1RSTR_USART4RST_Pos) /*!< 0x00080000 */
N#define RCC_APB1RSTR_USART4RST                   RCC_APB1RSTR_USART4RST_Msk    /*!< USART 4 reset */
N#define RCC_APB1RSTR_USART5RST_Pos               (20U)                         
N#define RCC_APB1RSTR_USART5RST_Msk               (0x1U << RCC_APB1RSTR_USART5RST_Pos) /*!< 0x00100000 */
N#define RCC_APB1RSTR_USART5RST                   RCC_APB1RSTR_USART5RST_Msk    /*!< USART 5 reset */
N#define RCC_APB1RSTR_I2C1RST_Pos                 (21U)                         
N#define RCC_APB1RSTR_I2C1RST_Msk                 (0x1U << RCC_APB1RSTR_I2C1RST_Pos) /*!< 0x00200000 */
N#define RCC_APB1RSTR_I2C1RST                     RCC_APB1RSTR_I2C1RST_Msk      /*!< I2C 1 reset */
N#define RCC_APB1RSTR_I2C2RST_Pos                 (22U)                         
N#define RCC_APB1RSTR_I2C2RST_Msk                 (0x1U << RCC_APB1RSTR_I2C2RST_Pos) /*!< 0x00400000 */
N#define RCC_APB1RSTR_I2C2RST                     RCC_APB1RSTR_I2C2RST_Msk      /*!< I2C 2 reset */
N#define RCC_APB1RSTR_CANRST_Pos                  (25U)                         
N#define RCC_APB1RSTR_CANRST_Msk                  (0x1U << RCC_APB1RSTR_CANRST_Pos) /*!< 0x02000000 */
N#define RCC_APB1RSTR_CANRST                      RCC_APB1RSTR_CANRST_Msk       /*!< CAN reset */
N#define RCC_APB1RSTR_CRSRST_Pos                  (27U)                         
N#define RCC_APB1RSTR_CRSRST_Msk                  (0x1U << RCC_APB1RSTR_CRSRST_Pos) /*!< 0x08000000 */
N#define RCC_APB1RSTR_CRSRST                      RCC_APB1RSTR_CRSRST_Msk       /*!< CRS reset */
N#define RCC_APB1RSTR_PWRRST_Pos                  (28U)                         
N#define RCC_APB1RSTR_PWRRST_Msk                  (0x1U << RCC_APB1RSTR_PWRRST_Pos) /*!< 0x10000000 */
N#define RCC_APB1RSTR_PWRRST                      RCC_APB1RSTR_PWRRST_Msk       /*!< PWR reset */
N#define RCC_APB1RSTR_DACRST_Pos                  (29U)                         
N#define RCC_APB1RSTR_DACRST_Msk                  (0x1U << RCC_APB1RSTR_DACRST_Pos) /*!< 0x20000000 */
N#define RCC_APB1RSTR_DACRST                      RCC_APB1RSTR_DACRST_Msk       /*!< DAC reset */
N#define RCC_APB1RSTR_CECRST_Pos                  (30U)                         
N#define RCC_APB1RSTR_CECRST_Msk                  (0x1U << RCC_APB1RSTR_CECRST_Pos) /*!< 0x40000000 */
N#define RCC_APB1RSTR_CECRST                      RCC_APB1RSTR_CECRST_Msk       /*!< CEC reset */
N
N/******************  Bit definition for RCC_AHBENR register  *****************/
N#define RCC_AHBENR_DMAEN_Pos                     (0U)                          
N#define RCC_AHBENR_DMAEN_Msk                     (0x1U << RCC_AHBENR_DMAEN_Pos) /*!< 0x00000001 */
N#define RCC_AHBENR_DMAEN                         RCC_AHBENR_DMAEN_Msk          /*!< DMA1 clock enable */
N#define RCC_AHBENR_DMA2EN_Pos                    (1U)                          
N#define RCC_AHBENR_DMA2EN_Msk                    (0x1U << RCC_AHBENR_DMA2EN_Pos) /*!< 0x00000002 */
N#define RCC_AHBENR_DMA2EN                        RCC_AHBENR_DMA2EN_Msk         /*!< DMA2 clock enable */
N#define RCC_AHBENR_SRAMEN_Pos                    (2U)                          
N#define RCC_AHBENR_SRAMEN_Msk                    (0x1U << RCC_AHBENR_SRAMEN_Pos) /*!< 0x00000004 */
N#define RCC_AHBENR_SRAMEN                        RCC_AHBENR_SRAMEN_Msk         /*!< SRAM interface clock enable */
N#define RCC_AHBENR_FLITFEN_Pos                   (4U)                          
N#define RCC_AHBENR_FLITFEN_Msk                   (0x1U << RCC_AHBENR_FLITFEN_Pos) /*!< 0x00000010 */
N#define RCC_AHBENR_FLITFEN                       RCC_AHBENR_FLITFEN_Msk        /*!< FLITF clock enable */
N#define RCC_AHBENR_CRCEN_Pos                     (6U)                          
N#define RCC_AHBENR_CRCEN_Msk                     (0x1U << RCC_AHBENR_CRCEN_Pos) /*!< 0x00000040 */
N#define RCC_AHBENR_CRCEN                         RCC_AHBENR_CRCEN_Msk          /*!< CRC clock enable */
N#define RCC_AHBENR_GPIOAEN_Pos                   (17U)                         
N#define RCC_AHBENR_GPIOAEN_Msk                   (0x1U << RCC_AHBENR_GPIOAEN_Pos) /*!< 0x00020000 */
N#define RCC_AHBENR_GPIOAEN                       RCC_AHBENR_GPIOAEN_Msk        /*!< GPIOA clock enable */
N#define RCC_AHBENR_GPIOBEN_Pos                   (18U)                         
N#define RCC_AHBENR_GPIOBEN_Msk                   (0x1U << RCC_AHBENR_GPIOBEN_Pos) /*!< 0x00040000 */
N#define RCC_AHBENR_GPIOBEN                       RCC_AHBENR_GPIOBEN_Msk        /*!< GPIOB clock enable */
N#define RCC_AHBENR_GPIOCEN_Pos                   (19U)                         
N#define RCC_AHBENR_GPIOCEN_Msk                   (0x1U << RCC_AHBENR_GPIOCEN_Pos) /*!< 0x00080000 */
N#define RCC_AHBENR_GPIOCEN                       RCC_AHBENR_GPIOCEN_Msk        /*!< GPIOC clock enable */
N#define RCC_AHBENR_GPIODEN_Pos                   (20U)                         
N#define RCC_AHBENR_GPIODEN_Msk                   (0x1U << RCC_AHBENR_GPIODEN_Pos) /*!< 0x00100000 */
N#define RCC_AHBENR_GPIODEN                       RCC_AHBENR_GPIODEN_Msk        /*!< GPIOD clock enable */
N#define RCC_AHBENR_GPIOEEN_Pos                   (21U)                         
N#define RCC_AHBENR_GPIOEEN_Msk                   (0x1U << RCC_AHBENR_GPIOEEN_Pos) /*!< 0x00200000 */
N#define RCC_AHBENR_GPIOEEN                       RCC_AHBENR_GPIOEEN_Msk        /*!< GPIOE clock enable */
N#define RCC_AHBENR_GPIOFEN_Pos                   (22U)                         
N#define RCC_AHBENR_GPIOFEN_Msk                   (0x1U << RCC_AHBENR_GPIOFEN_Pos) /*!< 0x00400000 */
N#define RCC_AHBENR_GPIOFEN                       RCC_AHBENR_GPIOFEN_Msk        /*!< GPIOF clock enable */
N#define RCC_AHBENR_TSCEN_Pos                     (24U)                         
N#define RCC_AHBENR_TSCEN_Msk                     (0x1U << RCC_AHBENR_TSCEN_Pos) /*!< 0x01000000 */
N#define RCC_AHBENR_TSCEN                         RCC_AHBENR_TSCEN_Msk          /*!< TS controller clock enable */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_AHBENR_DMA1EN                   RCC_AHBENR_DMAEN        /*!< DMA1 clock enable */
N#define  RCC_AHBENR_TSEN                     RCC_AHBENR_TSCEN        /*!< TS clock enable */
N
N/*****************  Bit definition for RCC_APB2ENR register  *****************/
N#define RCC_APB2ENR_SYSCFGCOMPEN_Pos             (0U)                          
N#define RCC_APB2ENR_SYSCFGCOMPEN_Msk             (0x1U << RCC_APB2ENR_SYSCFGCOMPEN_Pos) /*!< 0x00000001 */
N#define RCC_APB2ENR_SYSCFGCOMPEN                 RCC_APB2ENR_SYSCFGCOMPEN_Msk  /*!< SYSCFG and comparator clock enable */
N#define RCC_APB2ENR_USART6EN_Pos                 (5U)                          
N#define RCC_APB2ENR_USART6EN_Msk                 (0x1U << RCC_APB2ENR_USART6EN_Pos) /*!< 0x00000020 */
N#define RCC_APB2ENR_USART6EN                     RCC_APB2ENR_USART6EN_Msk      /*!< USART6 clock enable */
N#define RCC_APB2ENR_USART7EN_Pos                 (6U)                          
N#define RCC_APB2ENR_USART7EN_Msk                 (0x1U << RCC_APB2ENR_USART7EN_Pos) /*!< 0x00000040 */
N#define RCC_APB2ENR_USART7EN                     RCC_APB2ENR_USART7EN_Msk      /*!< USART7 clock enable */
N#define RCC_APB2ENR_USART8EN_Pos                 (7U)                          
N#define RCC_APB2ENR_USART8EN_Msk                 (0x1U << RCC_APB2ENR_USART8EN_Pos) /*!< 0x00000080 */
N#define RCC_APB2ENR_USART8EN                     RCC_APB2ENR_USART8EN_Msk      /*!< USART8 clock enable */
N#define RCC_APB2ENR_ADCEN_Pos                    (9U)                          
N#define RCC_APB2ENR_ADCEN_Msk                    (0x1U << RCC_APB2ENR_ADCEN_Pos) /*!< 0x00000200 */
N#define RCC_APB2ENR_ADCEN                        RCC_APB2ENR_ADCEN_Msk         /*!< ADC1 clock enable */
N#define RCC_APB2ENR_TIM1EN_Pos                   (11U)                         
N#define RCC_APB2ENR_TIM1EN_Msk                   (0x1U << RCC_APB2ENR_TIM1EN_Pos) /*!< 0x00000800 */
N#define RCC_APB2ENR_TIM1EN                       RCC_APB2ENR_TIM1EN_Msk        /*!< TIM1 clock enable */
N#define RCC_APB2ENR_SPI1EN_Pos                   (12U)                         
N#define RCC_APB2ENR_SPI1EN_Msk                   (0x1U << RCC_APB2ENR_SPI1EN_Pos) /*!< 0x00001000 */
N#define RCC_APB2ENR_SPI1EN                       RCC_APB2ENR_SPI1EN_Msk        /*!< SPI1 clock enable */
N#define RCC_APB2ENR_USART1EN_Pos                 (14U)                         
N#define RCC_APB2ENR_USART1EN_Msk                 (0x1U << RCC_APB2ENR_USART1EN_Pos) /*!< 0x00004000 */
N#define RCC_APB2ENR_USART1EN                     RCC_APB2ENR_USART1EN_Msk      /*!< USART1 clock enable */
N#define RCC_APB2ENR_TIM15EN_Pos                  (16U)                         
N#define RCC_APB2ENR_TIM15EN_Msk                  (0x1U << RCC_APB2ENR_TIM15EN_Pos) /*!< 0x00010000 */
N#define RCC_APB2ENR_TIM15EN                      RCC_APB2ENR_TIM15EN_Msk       /*!< TIM15 clock enable */
N#define RCC_APB2ENR_TIM16EN_Pos                  (17U)                         
N#define RCC_APB2ENR_TIM16EN_Msk                  (0x1U << RCC_APB2ENR_TIM16EN_Pos) /*!< 0x00020000 */
N#define RCC_APB2ENR_TIM16EN                      RCC_APB2ENR_TIM16EN_Msk       /*!< TIM16 clock enable */
N#define RCC_APB2ENR_TIM17EN_Pos                  (18U)                         
N#define RCC_APB2ENR_TIM17EN_Msk                  (0x1U << RCC_APB2ENR_TIM17EN_Pos) /*!< 0x00040000 */
N#define RCC_APB2ENR_TIM17EN                      RCC_APB2ENR_TIM17EN_Msk       /*!< TIM17 clock enable */
N#define RCC_APB2ENR_DBGMCUEN_Pos                 (22U)                         
N#define RCC_APB2ENR_DBGMCUEN_Msk                 (0x1U << RCC_APB2ENR_DBGMCUEN_Pos) /*!< 0x00400000 */
N#define RCC_APB2ENR_DBGMCUEN                     RCC_APB2ENR_DBGMCUEN_Msk      /*!< DBGMCU clock enable */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_APB2ENR_SYSCFGEN                RCC_APB2ENR_SYSCFGCOMPEN        /*!< SYSCFG clock enable */
N#define  RCC_APB2ENR_ADC1EN                  RCC_APB2ENR_ADCEN               /*!< ADC1 clock enable */
N
N/*****************  Bit definition for RCC_APB1ENR register  *****************/
N#define RCC_APB1ENR_TIM2EN_Pos                   (0U)                          
N#define RCC_APB1ENR_TIM2EN_Msk                   (0x1U << RCC_APB1ENR_TIM2EN_Pos) /*!< 0x00000001 */
N#define RCC_APB1ENR_TIM2EN                       RCC_APB1ENR_TIM2EN_Msk        /*!< Timer 2 clock enable */
N#define RCC_APB1ENR_TIM3EN_Pos                   (1U)                          
N#define RCC_APB1ENR_TIM3EN_Msk                   (0x1U << RCC_APB1ENR_TIM3EN_Pos) /*!< 0x00000002 */
N#define RCC_APB1ENR_TIM3EN                       RCC_APB1ENR_TIM3EN_Msk        /*!< Timer 3 clock enable */
N#define RCC_APB1ENR_TIM6EN_Pos                   (4U)                          
N#define RCC_APB1ENR_TIM6EN_Msk                   (0x1U << RCC_APB1ENR_TIM6EN_Pos) /*!< 0x00000010 */
N#define RCC_APB1ENR_TIM6EN                       RCC_APB1ENR_TIM6EN_Msk        /*!< Timer 6 clock enable */
N#define RCC_APB1ENR_TIM7EN_Pos                   (5U)                          
N#define RCC_APB1ENR_TIM7EN_Msk                   (0x1U << RCC_APB1ENR_TIM7EN_Pos) /*!< 0x00000020 */
N#define RCC_APB1ENR_TIM7EN                       RCC_APB1ENR_TIM7EN_Msk        /*!< Timer 7 clock enable */
N#define RCC_APB1ENR_TIM14EN_Pos                  (8U)                          
N#define RCC_APB1ENR_TIM14EN_Msk                  (0x1U << RCC_APB1ENR_TIM14EN_Pos) /*!< 0x00000100 */
N#define RCC_APB1ENR_TIM14EN                      RCC_APB1ENR_TIM14EN_Msk       /*!< Timer 14 clock enable */
N#define RCC_APB1ENR_WWDGEN_Pos                   (11U)                         
N#define RCC_APB1ENR_WWDGEN_Msk                   (0x1U << RCC_APB1ENR_WWDGEN_Pos) /*!< 0x00000800 */
N#define RCC_APB1ENR_WWDGEN                       RCC_APB1ENR_WWDGEN_Msk        /*!< Window Watchdog clock enable */
N#define RCC_APB1ENR_SPI2EN_Pos                   (14U)                         
N#define RCC_APB1ENR_SPI2EN_Msk                   (0x1U << RCC_APB1ENR_SPI2EN_Pos) /*!< 0x00004000 */
N#define RCC_APB1ENR_SPI2EN                       RCC_APB1ENR_SPI2EN_Msk        /*!< SPI2 clock enable */
N#define RCC_APB1ENR_USART2EN_Pos                 (17U)                         
N#define RCC_APB1ENR_USART2EN_Msk                 (0x1U << RCC_APB1ENR_USART2EN_Pos) /*!< 0x00020000 */
N#define RCC_APB1ENR_USART2EN                     RCC_APB1ENR_USART2EN_Msk      /*!< USART2 clock enable */
N#define RCC_APB1ENR_USART3EN_Pos                 (18U)                         
N#define RCC_APB1ENR_USART3EN_Msk                 (0x1U << RCC_APB1ENR_USART3EN_Pos) /*!< 0x00040000 */
N#define RCC_APB1ENR_USART3EN                     RCC_APB1ENR_USART3EN_Msk      /*!< USART3 clock enable */
N#define RCC_APB1ENR_USART4EN_Pos                 (19U)                         
N#define RCC_APB1ENR_USART4EN_Msk                 (0x1U << RCC_APB1ENR_USART4EN_Pos) /*!< 0x00080000 */
N#define RCC_APB1ENR_USART4EN                     RCC_APB1ENR_USART4EN_Msk      /*!< USART4 clock enable */
N#define RCC_APB1ENR_USART5EN_Pos                 (20U)                         
N#define RCC_APB1ENR_USART5EN_Msk                 (0x1U << RCC_APB1ENR_USART5EN_Pos) /*!< 0x00100000 */
N#define RCC_APB1ENR_USART5EN                     RCC_APB1ENR_USART5EN_Msk      /*!< USART5 clock enable */
N#define RCC_APB1ENR_I2C1EN_Pos                   (21U)                         
N#define RCC_APB1ENR_I2C1EN_Msk                   (0x1U << RCC_APB1ENR_I2C1EN_Pos) /*!< 0x00200000 */
N#define RCC_APB1ENR_I2C1EN                       RCC_APB1ENR_I2C1EN_Msk        /*!< I2C1 clock enable */
N#define RCC_APB1ENR_I2C2EN_Pos                   (22U)                         
N#define RCC_APB1ENR_I2C2EN_Msk                   (0x1U << RCC_APB1ENR_I2C2EN_Pos) /*!< 0x00400000 */
N#define RCC_APB1ENR_I2C2EN                       RCC_APB1ENR_I2C2EN_Msk        /*!< I2C2 clock enable */
N#define RCC_APB1ENR_CANEN_Pos                    (25U)                         
N#define RCC_APB1ENR_CANEN_Msk                    (0x1U << RCC_APB1ENR_CANEN_Pos) /*!< 0x02000000 */
N#define RCC_APB1ENR_CANEN                        RCC_APB1ENR_CANEN_Msk         /*!< CAN clock enable */
N#define RCC_APB1ENR_CRSEN_Pos                    (27U)                         
N#define RCC_APB1ENR_CRSEN_Msk                    (0x1U << RCC_APB1ENR_CRSEN_Pos) /*!< 0x08000000 */
N#define RCC_APB1ENR_CRSEN                        RCC_APB1ENR_CRSEN_Msk         /*!< CRS clock enable */
N#define RCC_APB1ENR_PWREN_Pos                    (28U)                         
N#define RCC_APB1ENR_PWREN_Msk                    (0x1U << RCC_APB1ENR_PWREN_Pos) /*!< 0x10000000 */
N#define RCC_APB1ENR_PWREN                        RCC_APB1ENR_PWREN_Msk         /*!< PWR clock enable */
N#define RCC_APB1ENR_DACEN_Pos                    (29U)                         
N#define RCC_APB1ENR_DACEN_Msk                    (0x1U << RCC_APB1ENR_DACEN_Pos) /*!< 0x20000000 */
N#define RCC_APB1ENR_DACEN                        RCC_APB1ENR_DACEN_Msk         /*!< DAC clock enable */
N#define RCC_APB1ENR_CECEN_Pos                    (30U)                         
N#define RCC_APB1ENR_CECEN_Msk                    (0x1U << RCC_APB1ENR_CECEN_Pos) /*!< 0x40000000 */
N#define RCC_APB1ENR_CECEN                        RCC_APB1ENR_CECEN_Msk         /*!< CEC clock enable */
N
N/*******************  Bit definition for RCC_BDCR register  ******************/
N#define RCC_BDCR_LSEON_Pos                       (0U)                          
N#define RCC_BDCR_LSEON_Msk                       (0x1U << RCC_BDCR_LSEON_Pos)  /*!< 0x00000001 */
N#define RCC_BDCR_LSEON                           RCC_BDCR_LSEON_Msk            /*!< External Low Speed oscillator enable */
N#define RCC_BDCR_LSERDY_Pos                      (1U)                          
N#define RCC_BDCR_LSERDY_Msk                      (0x1U << RCC_BDCR_LSERDY_Pos) /*!< 0x00000002 */
N#define RCC_BDCR_LSERDY                          RCC_BDCR_LSERDY_Msk           /*!< External Low Speed oscillator Ready */
N#define RCC_BDCR_LSEBYP_Pos                      (2U)                          
N#define RCC_BDCR_LSEBYP_Msk                      (0x1U << RCC_BDCR_LSEBYP_Pos) /*!< 0x00000004 */
N#define RCC_BDCR_LSEBYP                          RCC_BDCR_LSEBYP_Msk           /*!< External Low Speed oscillator Bypass */
N
N#define RCC_BDCR_LSEDRV_Pos                      (3U)                          
N#define RCC_BDCR_LSEDRV_Msk                      (0x3U << RCC_BDCR_LSEDRV_Pos) /*!< 0x00000018 */
N#define RCC_BDCR_LSEDRV                          RCC_BDCR_LSEDRV_Msk           /*!< LSEDRV[1:0] bits (LSE Osc. drive capability) */
N#define RCC_BDCR_LSEDRV_0                        (0x1U << RCC_BDCR_LSEDRV_Pos) /*!< 0x00000008 */
N#define RCC_BDCR_LSEDRV_1                        (0x2U << RCC_BDCR_LSEDRV_Pos) /*!< 0x00000010 */
N
N#define RCC_BDCR_RTCSEL_Pos                      (8U)                          
N#define RCC_BDCR_RTCSEL_Msk                      (0x3U << RCC_BDCR_RTCSEL_Pos) /*!< 0x00000300 */
N#define RCC_BDCR_RTCSEL                          RCC_BDCR_RTCSEL_Msk           /*!< RTCSEL[1:0] bits (RTC clock source selection) */
N#define RCC_BDCR_RTCSEL_0                        (0x1U << RCC_BDCR_RTCSEL_Pos) /*!< 0x00000100 */
N#define RCC_BDCR_RTCSEL_1                        (0x2U << RCC_BDCR_RTCSEL_Pos) /*!< 0x00000200 */
N
N/*!< RTC configuration */
N#define RCC_BDCR_RTCSEL_NOCLOCK                  (0x00000000U)                 /*!< No clock */
N#define RCC_BDCR_RTCSEL_LSE                      (0x00000100U)                 /*!< LSE oscillator clock used as RTC clock */
N#define RCC_BDCR_RTCSEL_LSI                      (0x00000200U)                 /*!< LSI oscillator clock used as RTC clock */
N#define RCC_BDCR_RTCSEL_HSE                      (0x00000300U)                 /*!< HSE oscillator clock divided by 128 used as RTC clock */
N
N#define RCC_BDCR_RTCEN_Pos                       (15U)                         
N#define RCC_BDCR_RTCEN_Msk                       (0x1U << RCC_BDCR_RTCEN_Pos)  /*!< 0x00008000 */
N#define RCC_BDCR_RTCEN                           RCC_BDCR_RTCEN_Msk            /*!< RTC clock enable */
N#define RCC_BDCR_BDRST_Pos                       (16U)                         
N#define RCC_BDCR_BDRST_Msk                       (0x1U << RCC_BDCR_BDRST_Pos)  /*!< 0x00010000 */
N#define RCC_BDCR_BDRST                           RCC_BDCR_BDRST_Msk            /*!< Backup domain software reset  */
N
N/*******************  Bit definition for RCC_CSR register  *******************/
N#define RCC_CSR_LSION_Pos                        (0U)                          
N#define RCC_CSR_LSION_Msk                        (0x1U << RCC_CSR_LSION_Pos)   /*!< 0x00000001 */
N#define RCC_CSR_LSION                            RCC_CSR_LSION_Msk             /*!< Internal Low Speed oscillator enable */
N#define RCC_CSR_LSIRDY_Pos                       (1U)                          
N#define RCC_CSR_LSIRDY_Msk                       (0x1U << RCC_CSR_LSIRDY_Pos)  /*!< 0x00000002 */
N#define RCC_CSR_LSIRDY                           RCC_CSR_LSIRDY_Msk            /*!< Internal Low Speed oscillator Ready */
N#define RCC_CSR_V18PWRRSTF_Pos                   (23U)                         
N#define RCC_CSR_V18PWRRSTF_Msk                   (0x1U << RCC_CSR_V18PWRRSTF_Pos) /*!< 0x00800000 */
N#define RCC_CSR_V18PWRRSTF                       RCC_CSR_V18PWRRSTF_Msk        /*!< V1.8 power domain reset flag */
N#define RCC_CSR_RMVF_Pos                         (24U)                         
N#define RCC_CSR_RMVF_Msk                         (0x1U << RCC_CSR_RMVF_Pos)    /*!< 0x01000000 */
N#define RCC_CSR_RMVF                             RCC_CSR_RMVF_Msk              /*!< Remove reset flag */
N#define RCC_CSR_OBLRSTF_Pos                      (25U)                         
N#define RCC_CSR_OBLRSTF_Msk                      (0x1U << RCC_CSR_OBLRSTF_Pos) /*!< 0x02000000 */
N#define RCC_CSR_OBLRSTF                          RCC_CSR_OBLRSTF_Msk           /*!< OBL reset flag */
N#define RCC_CSR_PINRSTF_Pos                      (26U)                         
N#define RCC_CSR_PINRSTF_Msk                      (0x1U << RCC_CSR_PINRSTF_Pos) /*!< 0x04000000 */
N#define RCC_CSR_PINRSTF                          RCC_CSR_PINRSTF_Msk           /*!< PIN reset flag */
N#define RCC_CSR_PORRSTF_Pos                      (27U)                         
N#define RCC_CSR_PORRSTF_Msk                      (0x1U << RCC_CSR_PORRSTF_Pos) /*!< 0x08000000 */
N#define RCC_CSR_PORRSTF                          RCC_CSR_PORRSTF_Msk           /*!< POR/PDR reset flag */
N#define RCC_CSR_SFTRSTF_Pos                      (28U)                         
N#define RCC_CSR_SFTRSTF_Msk                      (0x1U << RCC_CSR_SFTRSTF_Pos) /*!< 0x10000000 */
N#define RCC_CSR_SFTRSTF                          RCC_CSR_SFTRSTF_Msk           /*!< Software Reset flag */
N#define RCC_CSR_IWDGRSTF_Pos                     (29U)                         
N#define RCC_CSR_IWDGRSTF_Msk                     (0x1U << RCC_CSR_IWDGRSTF_Pos) /*!< 0x20000000 */
N#define RCC_CSR_IWDGRSTF                         RCC_CSR_IWDGRSTF_Msk          /*!< Independent Watchdog reset flag */
N#define RCC_CSR_WWDGRSTF_Pos                     (30U)                         
N#define RCC_CSR_WWDGRSTF_Msk                     (0x1U << RCC_CSR_WWDGRSTF_Pos) /*!< 0x40000000 */
N#define RCC_CSR_WWDGRSTF                         RCC_CSR_WWDGRSTF_Msk          /*!< Window watchdog reset flag */
N#define RCC_CSR_LPWRRSTF_Pos                     (31U)                         
N#define RCC_CSR_LPWRRSTF_Msk                     (0x1U << RCC_CSR_LPWRRSTF_Pos) /*!< 0x80000000 */
N#define RCC_CSR_LPWRRSTF                         RCC_CSR_LPWRRSTF_Msk          /*!< Low-Power reset flag */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_CSR_OBL                         RCC_CSR_OBLRSTF        /*!< OBL reset flag */
N
N/*******************  Bit definition for RCC_AHBRSTR register  ***************/
N#define RCC_AHBRSTR_GPIOARST_Pos                 (17U)                         
N#define RCC_AHBRSTR_GPIOARST_Msk                 (0x1U << RCC_AHBRSTR_GPIOARST_Pos) /*!< 0x00020000 */
N#define RCC_AHBRSTR_GPIOARST                     RCC_AHBRSTR_GPIOARST_Msk      /*!< GPIOA reset */
N#define RCC_AHBRSTR_GPIOBRST_Pos                 (18U)                         
N#define RCC_AHBRSTR_GPIOBRST_Msk                 (0x1U << RCC_AHBRSTR_GPIOBRST_Pos) /*!< 0x00040000 */
N#define RCC_AHBRSTR_GPIOBRST                     RCC_AHBRSTR_GPIOBRST_Msk      /*!< GPIOB reset */
N#define RCC_AHBRSTR_GPIOCRST_Pos                 (19U)                         
N#define RCC_AHBRSTR_GPIOCRST_Msk                 (0x1U << RCC_AHBRSTR_GPIOCRST_Pos) /*!< 0x00080000 */
N#define RCC_AHBRSTR_GPIOCRST                     RCC_AHBRSTR_GPIOCRST_Msk      /*!< GPIOC reset */
N#define RCC_AHBRSTR_GPIODRST_Pos                 (20U)                         
N#define RCC_AHBRSTR_GPIODRST_Msk                 (0x1U << RCC_AHBRSTR_GPIODRST_Pos) /*!< 0x00100000 */
N#define RCC_AHBRSTR_GPIODRST                     RCC_AHBRSTR_GPIODRST_Msk      /*!< GPIOD reset */
N#define RCC_AHBRSTR_GPIOERST_Pos                 (21U)                         
N#define RCC_AHBRSTR_GPIOERST_Msk                 (0x1U << RCC_AHBRSTR_GPIOERST_Pos) /*!< 0x00200000 */
N#define RCC_AHBRSTR_GPIOERST                     RCC_AHBRSTR_GPIOERST_Msk      /*!< GPIOE reset */
N#define RCC_AHBRSTR_GPIOFRST_Pos                 (22U)                         
N#define RCC_AHBRSTR_GPIOFRST_Msk                 (0x1U << RCC_AHBRSTR_GPIOFRST_Pos) /*!< 0x00400000 */
N#define RCC_AHBRSTR_GPIOFRST                     RCC_AHBRSTR_GPIOFRST_Msk      /*!< GPIOF reset */
N#define RCC_AHBRSTR_TSCRST_Pos                   (24U)                         
N#define RCC_AHBRSTR_TSCRST_Msk                   (0x1U << RCC_AHBRSTR_TSCRST_Pos) /*!< 0x01000000 */
N#define RCC_AHBRSTR_TSCRST                       RCC_AHBRSTR_TSCRST_Msk        /*!< TS reset */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_AHBRSTR_TSRST                   RCC_AHBRSTR_TSCRST         /*!< TS reset */
N
N/*******************  Bit definition for RCC_CFGR2 register  *****************/
N/*!< PREDIV configuration */
N#define RCC_CFGR2_PREDIV_Pos                     (0U)                          
N#define RCC_CFGR2_PREDIV_Msk                     (0xFU << RCC_CFGR2_PREDIV_Pos) /*!< 0x0000000F */
N#define RCC_CFGR2_PREDIV                         RCC_CFGR2_PREDIV_Msk          /*!< PREDIV[3:0] bits */
N#define RCC_CFGR2_PREDIV_0                       (0x1U << RCC_CFGR2_PREDIV_Pos) /*!< 0x00000001 */
N#define RCC_CFGR2_PREDIV_1                       (0x2U << RCC_CFGR2_PREDIV_Pos) /*!< 0x00000002 */
N#define RCC_CFGR2_PREDIV_2                       (0x4U << RCC_CFGR2_PREDIV_Pos) /*!< 0x00000004 */
N#define RCC_CFGR2_PREDIV_3                       (0x8U << RCC_CFGR2_PREDIV_Pos) /*!< 0x00000008 */
N
N#define RCC_CFGR2_PREDIV_DIV1                    (0x00000000U)                 /*!< PREDIV input clock not divided */
N#define RCC_CFGR2_PREDIV_DIV2                    (0x00000001U)                 /*!< PREDIV input clock divided by 2 */
N#define RCC_CFGR2_PREDIV_DIV3                    (0x00000002U)                 /*!< PREDIV input clock divided by 3 */
N#define RCC_CFGR2_PREDIV_DIV4                    (0x00000003U)                 /*!< PREDIV input clock divided by 4 */
N#define RCC_CFGR2_PREDIV_DIV5                    (0x00000004U)                 /*!< PREDIV input clock divided by 5 */
N#define RCC_CFGR2_PREDIV_DIV6                    (0x00000005U)                 /*!< PREDIV input clock divided by 6 */
N#define RCC_CFGR2_PREDIV_DIV7                    (0x00000006U)                 /*!< PREDIV input clock divided by 7 */
N#define RCC_CFGR2_PREDIV_DIV8                    (0x00000007U)                 /*!< PREDIV input clock divided by 8 */
N#define RCC_CFGR2_PREDIV_DIV9                    (0x00000008U)                 /*!< PREDIV input clock divided by 9 */
N#define RCC_CFGR2_PREDIV_DIV10                   (0x00000009U)                 /*!< PREDIV input clock divided by 10 */
N#define RCC_CFGR2_PREDIV_DIV11                   (0x0000000AU)                 /*!< PREDIV input clock divided by 11 */
N#define RCC_CFGR2_PREDIV_DIV12                   (0x0000000BU)                 /*!< PREDIV input clock divided by 12 */
N#define RCC_CFGR2_PREDIV_DIV13                   (0x0000000CU)                 /*!< PREDIV input clock divided by 13 */
N#define RCC_CFGR2_PREDIV_DIV14                   (0x0000000DU)                 /*!< PREDIV input clock divided by 14 */
N#define RCC_CFGR2_PREDIV_DIV15                   (0x0000000EU)                 /*!< PREDIV input clock divided by 15 */
N#define RCC_CFGR2_PREDIV_DIV16                   (0x0000000FU)                 /*!< PREDIV input clock divided by 16 */
N
N/*******************  Bit definition for RCC_CFGR3 register  *****************/
N/*!< USART1 Clock source selection */
N#define RCC_CFGR3_USART1SW_Pos                   (0U)                          
N#define RCC_CFGR3_USART1SW_Msk                   (0x3U << RCC_CFGR3_USART1SW_Pos) /*!< 0x00000003 */
N#define RCC_CFGR3_USART1SW                       RCC_CFGR3_USART1SW_Msk        /*!< USART1SW[1:0] bits */
N#define RCC_CFGR3_USART1SW_0                     (0x1U << RCC_CFGR3_USART1SW_Pos) /*!< 0x00000001 */
N#define RCC_CFGR3_USART1SW_1                     (0x2U << RCC_CFGR3_USART1SW_Pos) /*!< 0x00000002 */
N
N#define RCC_CFGR3_USART1SW_PCLK                  (0x00000000U)                 /*!< PCLK clock used as USART1 clock source */
N#define RCC_CFGR3_USART1SW_SYSCLK                (0x00000001U)                 /*!< System clock selected as USART1 clock source */
N#define RCC_CFGR3_USART1SW_LSE                   (0x00000002U)                 /*!< LSE oscillator clock used as USART1 clock source */
N#define RCC_CFGR3_USART1SW_HSI                   (0x00000003U)                 /*!< HSI oscillator clock used as USART1 clock source */
N
N/*!< I2C1 Clock source selection */
N#define RCC_CFGR3_I2C1SW_Pos                     (4U)                          
N#define RCC_CFGR3_I2C1SW_Msk                     (0x1U << RCC_CFGR3_I2C1SW_Pos) /*!< 0x00000010 */
N#define RCC_CFGR3_I2C1SW                         RCC_CFGR3_I2C1SW_Msk          /*!< I2C1SW bits */ 
N
N#define RCC_CFGR3_I2C1SW_HSI                     (0x00000000U)                 /*!< HSI oscillator clock used as I2C1 clock source */
N#define RCC_CFGR3_I2C1SW_SYSCLK_Pos              (4U)                          
N#define RCC_CFGR3_I2C1SW_SYSCLK_Msk              (0x1U << RCC_CFGR3_I2C1SW_SYSCLK_Pos) /*!< 0x00000010 */
N#define RCC_CFGR3_I2C1SW_SYSCLK                  RCC_CFGR3_I2C1SW_SYSCLK_Msk   /*!< System clock selected as I2C1 clock source */
N
N/*!< CEC Clock source selection */
N#define RCC_CFGR3_CECSW_Pos                      (6U)                          
N#define RCC_CFGR3_CECSW_Msk                      (0x1U << RCC_CFGR3_CECSW_Pos) /*!< 0x00000040 */
N#define RCC_CFGR3_CECSW                          RCC_CFGR3_CECSW_Msk           /*!< CECSW bits */ 
N
N#define RCC_CFGR3_CECSW_HSI_DIV244               (0x00000000U)                 /*!< HSI clock divided by 244 selected as HDMI CEC entry clock source */
N#define RCC_CFGR3_CECSW_LSE_Pos                  (6U)                          
N#define RCC_CFGR3_CECSW_LSE_Msk                  (0x1U << RCC_CFGR3_CECSW_LSE_Pos) /*!< 0x00000040 */
N#define RCC_CFGR3_CECSW_LSE                      RCC_CFGR3_CECSW_LSE_Msk       /*!< LSE clock selected as HDMI CEC entry clock source */
N
N/*!< USART2 Clock source selection */
N#define RCC_CFGR3_USART2SW_Pos                   (16U)                         
N#define RCC_CFGR3_USART2SW_Msk                   (0x3U << RCC_CFGR3_USART2SW_Pos) /*!< 0x00030000 */
N#define RCC_CFGR3_USART2SW                       RCC_CFGR3_USART2SW_Msk        /*!< USART2SW[1:0] bits */
N#define RCC_CFGR3_USART2SW_0                     (0x1U << RCC_CFGR3_USART2SW_Pos) /*!< 0x00010000 */
N#define RCC_CFGR3_USART2SW_1                     (0x2U << RCC_CFGR3_USART2SW_Pos) /*!< 0x00020000 */
N
N#define RCC_CFGR3_USART2SW_PCLK                  (0x00000000U)                 /*!< PCLK clock used as USART2 clock source */
N#define RCC_CFGR3_USART2SW_SYSCLK                (0x00010000U)                 /*!< System clock selected as USART2 clock source */
N#define RCC_CFGR3_USART2SW_LSE                   (0x00020000U)                 /*!< LSE oscillator clock used as USART2 clock source */
N#define RCC_CFGR3_USART2SW_HSI                   (0x00030000U)                 /*!< HSI oscillator clock used as USART2 clock source */
N
N/*!< USART3 Clock source selection */
N#define RCC_CFGR3_USART3SW_Pos                   (18U)                         
N#define RCC_CFGR3_USART3SW_Msk                   (0x3U << RCC_CFGR3_USART3SW_Pos) /*!< 0x000C0000 */
N#define RCC_CFGR3_USART3SW                       RCC_CFGR3_USART3SW_Msk        /*!< USART3SW[1:0] bits */
N#define RCC_CFGR3_USART3SW_0                     (0x1U << RCC_CFGR3_USART3SW_Pos) /*!< 0x00040000 */
N#define RCC_CFGR3_USART3SW_1                     (0x2U << RCC_CFGR3_USART3SW_Pos) /*!< 0x00080000 */
N
N#define RCC_CFGR3_USART3SW_PCLK                  (0x00000000U)                 /*!< PCLK clock used as USART3 clock source */
N#define RCC_CFGR3_USART3SW_SYSCLK                (0x00040000U)                 /*!< System clock selected as USART3 clock source */
N#define RCC_CFGR3_USART3SW_LSE                   (0x00080000U)                 /*!< LSE oscillator clock used as USART3 clock source */
N#define RCC_CFGR3_USART3SW_HSI                   (0x000C0000U)                 /*!< HSI oscillator clock used as USART3 clock source */
N
N/*******************  Bit definition for RCC_CR2 register  *******************/
N#define RCC_CR2_HSI14ON_Pos                      (0U)                          
N#define RCC_CR2_HSI14ON_Msk                      (0x1U << RCC_CR2_HSI14ON_Pos) /*!< 0x00000001 */
N#define RCC_CR2_HSI14ON                          RCC_CR2_HSI14ON_Msk           /*!< Internal High Speed 14MHz clock enable */
N#define RCC_CR2_HSI14RDY_Pos                     (1U)                          
N#define RCC_CR2_HSI14RDY_Msk                     (0x1U << RCC_CR2_HSI14RDY_Pos) /*!< 0x00000002 */
N#define RCC_CR2_HSI14RDY                         RCC_CR2_HSI14RDY_Msk          /*!< Internal High Speed 14MHz clock ready flag */
N#define RCC_CR2_HSI14DIS_Pos                     (2U)                          
N#define RCC_CR2_HSI14DIS_Msk                     (0x1U << RCC_CR2_HSI14DIS_Pos) /*!< 0x00000004 */
N#define RCC_CR2_HSI14DIS                         RCC_CR2_HSI14DIS_Msk          /*!< Internal High Speed 14MHz clock disable */
N#define RCC_CR2_HSI14TRIM_Pos                    (3U)                          
N#define RCC_CR2_HSI14TRIM_Msk                    (0x1FU << RCC_CR2_HSI14TRIM_Pos) /*!< 0x000000F8 */
N#define RCC_CR2_HSI14TRIM                        RCC_CR2_HSI14TRIM_Msk         /*!< Internal High Speed 14MHz clock trimming */
N#define RCC_CR2_HSI14CAL_Pos                     (8U)                          
N#define RCC_CR2_HSI14CAL_Msk                     (0xFFU << RCC_CR2_HSI14CAL_Pos) /*!< 0x0000FF00 */
N#define RCC_CR2_HSI14CAL                         RCC_CR2_HSI14CAL_Msk          /*!< Internal High Speed 14MHz clock Calibration */
N#define RCC_CR2_HSI48ON_Pos                      (16U)                         
N#define RCC_CR2_HSI48ON_Msk                      (0x1U << RCC_CR2_HSI48ON_Pos) /*!< 0x00010000 */
N#define RCC_CR2_HSI48ON                          RCC_CR2_HSI48ON_Msk           /*!< Internal High Speed 48MHz clock enable */
N#define RCC_CR2_HSI48RDY_Pos                     (17U)                         
N#define RCC_CR2_HSI48RDY_Msk                     (0x1U << RCC_CR2_HSI48RDY_Pos) /*!< 0x00020000 */
N#define RCC_CR2_HSI48RDY                         RCC_CR2_HSI48RDY_Msk          /*!< Internal High Speed 48MHz clock ready flag */
N#define RCC_CR2_HSI48CAL_Pos                     (24U)                         
N#define RCC_CR2_HSI48CAL_Msk                     (0xFFU << RCC_CR2_HSI48CAL_Pos) /*!< 0xFF000000 */
N#define RCC_CR2_HSI48CAL                         RCC_CR2_HSI48CAL_Msk          /*!< Internal High Speed 48MHz clock Calibration */
N
N/*****************************************************************************/
N/*                                                                           */
N/*                           Real-Time Clock (RTC)                           */
N/*                                                                           */
N/*****************************************************************************/
N/*
N* @brief Specific device feature definitions  (not present on all devices in the STM32F0 serie)
N*/
N#define RTC_TAMPER1_SUPPORT  /*!< TAMPER 1 feature support */
N#define RTC_TAMPER2_SUPPORT  /*!< TAMPER 2 feature support */
N#define RTC_TAMPER3_SUPPORT  /*!< TAMPER 3 feature support */
N#define RTC_BACKUP_SUPPORT   /*!< BACKUP register feature support */
N#define RTC_WAKEUP_SUPPORT   /*!< WAKEUP feature support */
N
N/********************  Bits definition for RTC_TR register  ******************/
N#define RTC_TR_PM_Pos                (22U)                                     
N#define RTC_TR_PM_Msk                (0x1U << RTC_TR_PM_Pos)                   /*!< 0x00400000 */
N#define RTC_TR_PM                    RTC_TR_PM_Msk                             
N#define RTC_TR_HT_Pos                (20U)                                     
N#define RTC_TR_HT_Msk                (0x3U << RTC_TR_HT_Pos)                   /*!< 0x00300000 */
N#define RTC_TR_HT                    RTC_TR_HT_Msk                             
N#define RTC_TR_HT_0                  (0x1U << RTC_TR_HT_Pos)                   /*!< 0x00100000 */
N#define RTC_TR_HT_1                  (0x2U << RTC_TR_HT_Pos)                   /*!< 0x00200000 */
N#define RTC_TR_HU_Pos                (16U)                                     
N#define RTC_TR_HU_Msk                (0xFU << RTC_TR_HU_Pos)                   /*!< 0x000F0000 */
N#define RTC_TR_HU                    RTC_TR_HU_Msk                             
N#define RTC_TR_HU_0                  (0x1U << RTC_TR_HU_Pos)                   /*!< 0x00010000 */
N#define RTC_TR_HU_1                  (0x2U << RTC_TR_HU_Pos)                   /*!< 0x00020000 */
N#define RTC_TR_HU_2                  (0x4U << RTC_TR_HU_Pos)                   /*!< 0x00040000 */
N#define RTC_TR_HU_3                  (0x8U << RTC_TR_HU_Pos)                   /*!< 0x00080000 */
N#define RTC_TR_MNT_Pos               (12U)                                     
N#define RTC_TR_MNT_Msk               (0x7U << RTC_TR_MNT_Pos)                  /*!< 0x00007000 */
N#define RTC_TR_MNT                   RTC_TR_MNT_Msk                            
N#define RTC_TR_MNT_0                 (0x1U << RTC_TR_MNT_Pos)                  /*!< 0x00001000 */
N#define RTC_TR_MNT_1                 (0x2U << RTC_TR_MNT_Pos)                  /*!< 0x00002000 */
N#define RTC_TR_MNT_2                 (0x4U << RTC_TR_MNT_Pos)                  /*!< 0x00004000 */
N#define RTC_TR_MNU_Pos               (8U)                                      
N#define RTC_TR_MNU_Msk               (0xFU << RTC_TR_MNU_Pos)                  /*!< 0x00000F00 */
N#define RTC_TR_MNU                   RTC_TR_MNU_Msk                            
N#define RTC_TR_MNU_0                 (0x1U << RTC_TR_MNU_Pos)                  /*!< 0x00000100 */
N#define RTC_TR_MNU_1                 (0x2U << RTC_TR_MNU_Pos)                  /*!< 0x00000200 */
N#define RTC_TR_MNU_2                 (0x4U << RTC_TR_MNU_Pos)                  /*!< 0x00000400 */
N#define RTC_TR_MNU_3                 (0x8U << RTC_TR_MNU_Pos)                  /*!< 0x00000800 */
N#define RTC_TR_ST_Pos                (4U)                                      
N#define RTC_TR_ST_Msk                (0x7U << RTC_TR_ST_Pos)                   /*!< 0x00000070 */
N#define RTC_TR_ST                    RTC_TR_ST_Msk                             
N#define RTC_TR_ST_0                  (0x1U << RTC_TR_ST_Pos)                   /*!< 0x00000010 */
N#define RTC_TR_ST_1                  (0x2U << RTC_TR_ST_Pos)                   /*!< 0x00000020 */
N#define RTC_TR_ST_2                  (0x4U << RTC_TR_ST_Pos)                   /*!< 0x00000040 */
N#define RTC_TR_SU_Pos                (0U)                                      
N#define RTC_TR_SU_Msk                (0xFU << RTC_TR_SU_Pos)                   /*!< 0x0000000F */
N#define RTC_TR_SU                    RTC_TR_SU_Msk                             
N#define RTC_TR_SU_0                  (0x1U << RTC_TR_SU_Pos)                   /*!< 0x00000001 */
N#define RTC_TR_SU_1                  (0x2U << RTC_TR_SU_Pos)                   /*!< 0x00000002 */
N#define RTC_TR_SU_2                  (0x4U << RTC_TR_SU_Pos)                   /*!< 0x00000004 */
N#define RTC_TR_SU_3                  (0x8U << RTC_TR_SU_Pos)                   /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_DR register  ******************/
N#define RTC_DR_YT_Pos                (20U)                                     
N#define RTC_DR_YT_Msk                (0xFU << RTC_DR_YT_Pos)                   /*!< 0x00F00000 */
N#define RTC_DR_YT                    RTC_DR_YT_Msk                             
N#define RTC_DR_YT_0                  (0x1U << RTC_DR_YT_Pos)                   /*!< 0x00100000 */
N#define RTC_DR_YT_1                  (0x2U << RTC_DR_YT_Pos)                   /*!< 0x00200000 */
N#define RTC_DR_YT_2                  (0x4U << RTC_DR_YT_Pos)                   /*!< 0x00400000 */
N#define RTC_DR_YT_3                  (0x8U << RTC_DR_YT_Pos)                   /*!< 0x00800000 */
N#define RTC_DR_YU_Pos                (16U)                                     
N#define RTC_DR_YU_Msk                (0xFU << RTC_DR_YU_Pos)                   /*!< 0x000F0000 */
N#define RTC_DR_YU                    RTC_DR_YU_Msk                             
N#define RTC_DR_YU_0                  (0x1U << RTC_DR_YU_Pos)                   /*!< 0x00010000 */
N#define RTC_DR_YU_1                  (0x2U << RTC_DR_YU_Pos)                   /*!< 0x00020000 */
N#define RTC_DR_YU_2                  (0x4U << RTC_DR_YU_Pos)                   /*!< 0x00040000 */
N#define RTC_DR_YU_3                  (0x8U << RTC_DR_YU_Pos)                   /*!< 0x00080000 */
N#define RTC_DR_WDU_Pos               (13U)                                     
N#define RTC_DR_WDU_Msk               (0x7U << RTC_DR_WDU_Pos)                  /*!< 0x0000E000 */
N#define RTC_DR_WDU                   RTC_DR_WDU_Msk                            
N#define RTC_DR_WDU_0                 (0x1U << RTC_DR_WDU_Pos)                  /*!< 0x00002000 */
N#define RTC_DR_WDU_1                 (0x2U << RTC_DR_WDU_Pos)                  /*!< 0x00004000 */
N#define RTC_DR_WDU_2                 (0x4U << RTC_DR_WDU_Pos)                  /*!< 0x00008000 */
N#define RTC_DR_MT_Pos                (12U)                                     
N#define RTC_DR_MT_Msk                (0x1U << RTC_DR_MT_Pos)                   /*!< 0x00001000 */
N#define RTC_DR_MT                    RTC_DR_MT_Msk                             
N#define RTC_DR_MU_Pos                (8U)                                      
N#define RTC_DR_MU_Msk                (0xFU << RTC_DR_MU_Pos)                   /*!< 0x00000F00 */
N#define RTC_DR_MU                    RTC_DR_MU_Msk                             
N#define RTC_DR_MU_0                  (0x1U << RTC_DR_MU_Pos)                   /*!< 0x00000100 */
N#define RTC_DR_MU_1                  (0x2U << RTC_DR_MU_Pos)                   /*!< 0x00000200 */
N#define RTC_DR_MU_2                  (0x4U << RTC_DR_MU_Pos)                   /*!< 0x00000400 */
N#define RTC_DR_MU_3                  (0x8U << RTC_DR_MU_Pos)                   /*!< 0x00000800 */
N#define RTC_DR_DT_Pos                (4U)                                      
N#define RTC_DR_DT_Msk                (0x3U << RTC_DR_DT_Pos)                   /*!< 0x00000030 */
N#define RTC_DR_DT                    RTC_DR_DT_Msk                             
N#define RTC_DR_DT_0                  (0x1U << RTC_DR_DT_Pos)                   /*!< 0x00000010 */
N#define RTC_DR_DT_1                  (0x2U << RTC_DR_DT_Pos)                   /*!< 0x00000020 */
N#define RTC_DR_DU_Pos                (0U)                                      
N#define RTC_DR_DU_Msk                (0xFU << RTC_DR_DU_Pos)                   /*!< 0x0000000F */
N#define RTC_DR_DU                    RTC_DR_DU_Msk                             
N#define RTC_DR_DU_0                  (0x1U << RTC_DR_DU_Pos)                   /*!< 0x00000001 */
N#define RTC_DR_DU_1                  (0x2U << RTC_DR_DU_Pos)                   /*!< 0x00000002 */
N#define RTC_DR_DU_2                  (0x4U << RTC_DR_DU_Pos)                   /*!< 0x00000004 */
N#define RTC_DR_DU_3                  (0x8U << RTC_DR_DU_Pos)                   /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_CR register  ******************/
N#define RTC_CR_COE_Pos               (23U)                                     
N#define RTC_CR_COE_Msk               (0x1U << RTC_CR_COE_Pos)                  /*!< 0x00800000 */
N#define RTC_CR_COE                   RTC_CR_COE_Msk                            
N#define RTC_CR_OSEL_Pos              (21U)                                     
N#define RTC_CR_OSEL_Msk              (0x3U << RTC_CR_OSEL_Pos)                 /*!< 0x00600000 */
N#define RTC_CR_OSEL                  RTC_CR_OSEL_Msk                           
N#define RTC_CR_OSEL_0                (0x1U << RTC_CR_OSEL_Pos)                 /*!< 0x00200000 */
N#define RTC_CR_OSEL_1                (0x2U << RTC_CR_OSEL_Pos)                 /*!< 0x00400000 */
N#define RTC_CR_POL_Pos               (20U)                                     
N#define RTC_CR_POL_Msk               (0x1U << RTC_CR_POL_Pos)                  /*!< 0x00100000 */
N#define RTC_CR_POL                   RTC_CR_POL_Msk                            
N#define RTC_CR_COSEL_Pos             (19U)                                     
N#define RTC_CR_COSEL_Msk             (0x1U << RTC_CR_COSEL_Pos)                /*!< 0x00080000 */
N#define RTC_CR_COSEL                 RTC_CR_COSEL_Msk                          
N#define RTC_CR_BKP_Pos               (18U)                                     
N#define RTC_CR_BKP_Msk               (0x1U << RTC_CR_BKP_Pos)                  /*!< 0x00040000 */
N#define RTC_CR_BKP                   RTC_CR_BKP_Msk                            
N#define RTC_CR_SUB1H_Pos             (17U)                                     
N#define RTC_CR_SUB1H_Msk             (0x1U << RTC_CR_SUB1H_Pos)                /*!< 0x00020000 */
N#define RTC_CR_SUB1H                 RTC_CR_SUB1H_Msk                          
N#define RTC_CR_ADD1H_Pos             (16U)                                     
N#define RTC_CR_ADD1H_Msk             (0x1U << RTC_CR_ADD1H_Pos)                /*!< 0x00010000 */
N#define RTC_CR_ADD1H                 RTC_CR_ADD1H_Msk                          
N#define RTC_CR_TSIE_Pos              (15U)                                     
N#define RTC_CR_TSIE_Msk              (0x1U << RTC_CR_TSIE_Pos)                 /*!< 0x00008000 */
N#define RTC_CR_TSIE                  RTC_CR_TSIE_Msk                           
N#define RTC_CR_WUTIE_Pos             (14U)                                     
N#define RTC_CR_WUTIE_Msk             (0x1U << RTC_CR_WUTIE_Pos)                /*!< 0x00004000 */
N#define RTC_CR_WUTIE                 RTC_CR_WUTIE_Msk                          
N#define RTC_CR_ALRAIE_Pos            (12U)                                     
N#define RTC_CR_ALRAIE_Msk            (0x1U << RTC_CR_ALRAIE_Pos)               /*!< 0x00001000 */
N#define RTC_CR_ALRAIE                RTC_CR_ALRAIE_Msk                         
N#define RTC_CR_TSE_Pos               (11U)                                     
N#define RTC_CR_TSE_Msk               (0x1U << RTC_CR_TSE_Pos)                  /*!< 0x00000800 */
N#define RTC_CR_TSE                   RTC_CR_TSE_Msk                            
N#define RTC_CR_WUTE_Pos              (10U)                                     
N#define RTC_CR_WUTE_Msk              (0x1U << RTC_CR_WUTE_Pos)                 /*!< 0x00000400 */
N#define RTC_CR_WUTE                  RTC_CR_WUTE_Msk                           
N#define RTC_CR_ALRAE_Pos             (8U)                                      
N#define RTC_CR_ALRAE_Msk             (0x1U << RTC_CR_ALRAE_Pos)                /*!< 0x00000100 */
N#define RTC_CR_ALRAE                 RTC_CR_ALRAE_Msk                          
N#define RTC_CR_FMT_Pos               (6U)                                      
N#define RTC_CR_FMT_Msk               (0x1U << RTC_CR_FMT_Pos)                  /*!< 0x00000040 */
N#define RTC_CR_FMT                   RTC_CR_FMT_Msk                            
N#define RTC_CR_BYPSHAD_Pos           (5U)                                      
N#define RTC_CR_BYPSHAD_Msk           (0x1U << RTC_CR_BYPSHAD_Pos)              /*!< 0x00000020 */
N#define RTC_CR_BYPSHAD               RTC_CR_BYPSHAD_Msk                        
N#define RTC_CR_REFCKON_Pos           (4U)                                      
N#define RTC_CR_REFCKON_Msk           (0x1U << RTC_CR_REFCKON_Pos)              /*!< 0x00000010 */
N#define RTC_CR_REFCKON               RTC_CR_REFCKON_Msk                        
N#define RTC_CR_TSEDGE_Pos            (3U)                                      
N#define RTC_CR_TSEDGE_Msk            (0x1U << RTC_CR_TSEDGE_Pos)               /*!< 0x00000008 */
N#define RTC_CR_TSEDGE                RTC_CR_TSEDGE_Msk                         
N#define RTC_CR_WUCKSEL_Pos           (0U)                                      
N#define RTC_CR_WUCKSEL_Msk           (0x7U << RTC_CR_WUCKSEL_Pos)              /*!< 0x00000007 */
N#define RTC_CR_WUCKSEL               RTC_CR_WUCKSEL_Msk                        
N#define RTC_CR_WUCKSEL_0             (0x1U << RTC_CR_WUCKSEL_Pos)              /*!< 0x00000001 */
N#define RTC_CR_WUCKSEL_1             (0x2U << RTC_CR_WUCKSEL_Pos)              /*!< 0x00000002 */
N#define RTC_CR_WUCKSEL_2             (0x4U << RTC_CR_WUCKSEL_Pos)              /*!< 0x00000004 */
N
N/* Legacy defines */
N#define RTC_CR_BCK_Pos               RTC_CR_BKP_Pos
N#define RTC_CR_BCK_Msk               RTC_CR_BKP_Msk
N#define RTC_CR_BCK                   RTC_CR_BKP
N
N/********************  Bits definition for RTC_ISR register  *****************/
N#define RTC_ISR_RECALPF_Pos          (16U)                                     
N#define RTC_ISR_RECALPF_Msk          (0x1U << RTC_ISR_RECALPF_Pos)             /*!< 0x00010000 */
N#define RTC_ISR_RECALPF              RTC_ISR_RECALPF_Msk                       
N#define RTC_ISR_TAMP3F_Pos           (15U)                                     
N#define RTC_ISR_TAMP3F_Msk           (0x1U << RTC_ISR_TAMP3F_Pos)              /*!< 0x00008000 */
N#define RTC_ISR_TAMP3F               RTC_ISR_TAMP3F_Msk                        
N#define RTC_ISR_TAMP2F_Pos           (14U)                                     
N#define RTC_ISR_TAMP2F_Msk           (0x1U << RTC_ISR_TAMP2F_Pos)              /*!< 0x00004000 */
N#define RTC_ISR_TAMP2F               RTC_ISR_TAMP2F_Msk                        
N#define RTC_ISR_TAMP1F_Pos           (13U)                                     
N#define RTC_ISR_TAMP1F_Msk           (0x1U << RTC_ISR_TAMP1F_Pos)              /*!< 0x00002000 */
N#define RTC_ISR_TAMP1F               RTC_ISR_TAMP1F_Msk                        
N#define RTC_ISR_TSOVF_Pos            (12U)                                     
N#define RTC_ISR_TSOVF_Msk            (0x1U << RTC_ISR_TSOVF_Pos)               /*!< 0x00001000 */
N#define RTC_ISR_TSOVF                RTC_ISR_TSOVF_Msk                         
N#define RTC_ISR_TSF_Pos              (11U)                                     
N#define RTC_ISR_TSF_Msk              (0x1U << RTC_ISR_TSF_Pos)                 /*!< 0x00000800 */
N#define RTC_ISR_TSF                  RTC_ISR_TSF_Msk                           
N#define RTC_ISR_WUTF_Pos             (10U)                                     
N#define RTC_ISR_WUTF_Msk             (0x1U << RTC_ISR_WUTF_Pos)                /*!< 0x00000400 */
N#define RTC_ISR_WUTF                 RTC_ISR_WUTF_Msk                          
N#define RTC_ISR_ALRAF_Pos            (8U)                                      
N#define RTC_ISR_ALRAF_Msk            (0x1U << RTC_ISR_ALRAF_Pos)               /*!< 0x00000100 */
N#define RTC_ISR_ALRAF                RTC_ISR_ALRAF_Msk                         
N#define RTC_ISR_INIT_Pos             (7U)                                      
N#define RTC_ISR_INIT_Msk             (0x1U << RTC_ISR_INIT_Pos)                /*!< 0x00000080 */
N#define RTC_ISR_INIT                 RTC_ISR_INIT_Msk                          
N#define RTC_ISR_INITF_Pos            (6U)                                      
N#define RTC_ISR_INITF_Msk            (0x1U << RTC_ISR_INITF_Pos)               /*!< 0x00000040 */
N#define RTC_ISR_INITF                RTC_ISR_INITF_Msk                         
N#define RTC_ISR_RSF_Pos              (5U)                                      
N#define RTC_ISR_RSF_Msk              (0x1U << RTC_ISR_RSF_Pos)                 /*!< 0x00000020 */
N#define RTC_ISR_RSF                  RTC_ISR_RSF_Msk                           
N#define RTC_ISR_INITS_Pos            (4U)                                      
N#define RTC_ISR_INITS_Msk            (0x1U << RTC_ISR_INITS_Pos)               /*!< 0x00000010 */
N#define RTC_ISR_INITS                RTC_ISR_INITS_Msk                         
N#define RTC_ISR_SHPF_Pos             (3U)                                      
N#define RTC_ISR_SHPF_Msk             (0x1U << RTC_ISR_SHPF_Pos)                /*!< 0x00000008 */
N#define RTC_ISR_SHPF                 RTC_ISR_SHPF_Msk                          
N#define RTC_ISR_WUTWF_Pos            (2U)                                      
N#define RTC_ISR_WUTWF_Msk            (0x1U << RTC_ISR_WUTWF_Pos)               /*!< 0x00000004 */
N#define RTC_ISR_WUTWF                RTC_ISR_WUTWF_Msk                         
N#define RTC_ISR_ALRAWF_Pos           (0U)                                      
N#define RTC_ISR_ALRAWF_Msk           (0x1U << RTC_ISR_ALRAWF_Pos)              /*!< 0x00000001 */
N#define RTC_ISR_ALRAWF               RTC_ISR_ALRAWF_Msk                        
N
N/********************  Bits definition for RTC_PRER register  ****************/
N#define RTC_PRER_PREDIV_A_Pos        (16U)                                     
N#define RTC_PRER_PREDIV_A_Msk        (0x7FU << RTC_PRER_PREDIV_A_Pos)          /*!< 0x007F0000 */
N#define RTC_PRER_PREDIV_A            RTC_PRER_PREDIV_A_Msk                     
N#define RTC_PRER_PREDIV_S_Pos        (0U)                                      
N#define RTC_PRER_PREDIV_S_Msk        (0x7FFFU << RTC_PRER_PREDIV_S_Pos)        /*!< 0x00007FFF */
N#define RTC_PRER_PREDIV_S            RTC_PRER_PREDIV_S_Msk                     
N
N/********************  Bits definition for RTC_WUTR register  ****************/
N#define RTC_WUTR_WUT_Pos             (0U)                                      
N#define RTC_WUTR_WUT_Msk             (0xFFFFU << RTC_WUTR_WUT_Pos)             /*!< 0x0000FFFF */
N#define RTC_WUTR_WUT                 RTC_WUTR_WUT_Msk                          
N
N/********************  Bits definition for RTC_ALRMAR register  **************/
N#define RTC_ALRMAR_MSK4_Pos          (31U)                                     
N#define RTC_ALRMAR_MSK4_Msk          (0x1U << RTC_ALRMAR_MSK4_Pos)             /*!< 0x80000000 */
N#define RTC_ALRMAR_MSK4              RTC_ALRMAR_MSK4_Msk                       
N#define RTC_ALRMAR_WDSEL_Pos         (30U)                                     
N#define RTC_ALRMAR_WDSEL_Msk         (0x1U << RTC_ALRMAR_WDSEL_Pos)            /*!< 0x40000000 */
N#define RTC_ALRMAR_WDSEL             RTC_ALRMAR_WDSEL_Msk                      
N#define RTC_ALRMAR_DT_Pos            (28U)                                     
N#define RTC_ALRMAR_DT_Msk            (0x3U << RTC_ALRMAR_DT_Pos)               /*!< 0x30000000 */
N#define RTC_ALRMAR_DT                RTC_ALRMAR_DT_Msk                         
N#define RTC_ALRMAR_DT_0              (0x1U << RTC_ALRMAR_DT_Pos)               /*!< 0x10000000 */
N#define RTC_ALRMAR_DT_1              (0x2U << RTC_ALRMAR_DT_Pos)               /*!< 0x20000000 */
N#define RTC_ALRMAR_DU_Pos            (24U)                                     
N#define RTC_ALRMAR_DU_Msk            (0xFU << RTC_ALRMAR_DU_Pos)               /*!< 0x0F000000 */
N#define RTC_ALRMAR_DU                RTC_ALRMAR_DU_Msk                         
N#define RTC_ALRMAR_DU_0              (0x1U << RTC_ALRMAR_DU_Pos)               /*!< 0x01000000 */
N#define RTC_ALRMAR_DU_1              (0x2U << RTC_ALRMAR_DU_Pos)               /*!< 0x02000000 */
N#define RTC_ALRMAR_DU_2              (0x4U << RTC_ALRMAR_DU_Pos)               /*!< 0x04000000 */
N#define RTC_ALRMAR_DU_3              (0x8U << RTC_ALRMAR_DU_Pos)               /*!< 0x08000000 */
N#define RTC_ALRMAR_MSK3_Pos          (23U)                                     
N#define RTC_ALRMAR_MSK3_Msk          (0x1U << RTC_ALRMAR_MSK3_Pos)             /*!< 0x00800000 */
N#define RTC_ALRMAR_MSK3              RTC_ALRMAR_MSK3_Msk                       
N#define RTC_ALRMAR_PM_Pos            (22U)                                     
N#define RTC_ALRMAR_PM_Msk            (0x1U << RTC_ALRMAR_PM_Pos)               /*!< 0x00400000 */
N#define RTC_ALRMAR_PM                RTC_ALRMAR_PM_Msk                         
N#define RTC_ALRMAR_HT_Pos            (20U)                                     
N#define RTC_ALRMAR_HT_Msk            (0x3U << RTC_ALRMAR_HT_Pos)               /*!< 0x00300000 */
N#define RTC_ALRMAR_HT                RTC_ALRMAR_HT_Msk                         
N#define RTC_ALRMAR_HT_0              (0x1U << RTC_ALRMAR_HT_Pos)               /*!< 0x00100000 */
N#define RTC_ALRMAR_HT_1              (0x2U << RTC_ALRMAR_HT_Pos)               /*!< 0x00200000 */
N#define RTC_ALRMAR_HU_Pos            (16U)                                     
N#define RTC_ALRMAR_HU_Msk            (0xFU << RTC_ALRMAR_HU_Pos)               /*!< 0x000F0000 */
N#define RTC_ALRMAR_HU                RTC_ALRMAR_HU_Msk                         
N#define RTC_ALRMAR_HU_0              (0x1U << RTC_ALRMAR_HU_Pos)               /*!< 0x00010000 */
N#define RTC_ALRMAR_HU_1              (0x2U << RTC_ALRMAR_HU_Pos)               /*!< 0x00020000 */
N#define RTC_ALRMAR_HU_2              (0x4U << RTC_ALRMAR_HU_Pos)               /*!< 0x00040000 */
N#define RTC_ALRMAR_HU_3              (0x8U << RTC_ALRMAR_HU_Pos)               /*!< 0x00080000 */
N#define RTC_ALRMAR_MSK2_Pos          (15U)                                     
N#define RTC_ALRMAR_MSK2_Msk          (0x1U << RTC_ALRMAR_MSK2_Pos)             /*!< 0x00008000 */
N#define RTC_ALRMAR_MSK2              RTC_ALRMAR_MSK2_Msk                       
N#define RTC_ALRMAR_MNT_Pos           (12U)                                     
N#define RTC_ALRMAR_MNT_Msk           (0x7U << RTC_ALRMAR_MNT_Pos)              /*!< 0x00007000 */
N#define RTC_ALRMAR_MNT               RTC_ALRMAR_MNT_Msk                        
N#define RTC_ALRMAR_MNT_0             (0x1U << RTC_ALRMAR_MNT_Pos)              /*!< 0x00001000 */
N#define RTC_ALRMAR_MNT_1             (0x2U << RTC_ALRMAR_MNT_Pos)              /*!< 0x00002000 */
N#define RTC_ALRMAR_MNT_2             (0x4U << RTC_ALRMAR_MNT_Pos)              /*!< 0x00004000 */
N#define RTC_ALRMAR_MNU_Pos           (8U)                                      
N#define RTC_ALRMAR_MNU_Msk           (0xFU << RTC_ALRMAR_MNU_Pos)              /*!< 0x00000F00 */
N#define RTC_ALRMAR_MNU               RTC_ALRMAR_MNU_Msk                        
N#define RTC_ALRMAR_MNU_0             (0x1U << RTC_ALRMAR_MNU_Pos)              /*!< 0x00000100 */
N#define RTC_ALRMAR_MNU_1             (0x2U << RTC_ALRMAR_MNU_Pos)              /*!< 0x00000200 */
N#define RTC_ALRMAR_MNU_2             (0x4U << RTC_ALRMAR_MNU_Pos)              /*!< 0x00000400 */
N#define RTC_ALRMAR_MNU_3             (0x8U << RTC_ALRMAR_MNU_Pos)              /*!< 0x00000800 */
N#define RTC_ALRMAR_MSK1_Pos          (7U)                                      
N#define RTC_ALRMAR_MSK1_Msk          (0x1U << RTC_ALRMAR_MSK1_Pos)             /*!< 0x00000080 */
N#define RTC_ALRMAR_MSK1              RTC_ALRMAR_MSK1_Msk                       
N#define RTC_ALRMAR_ST_Pos            (4U)                                      
N#define RTC_ALRMAR_ST_Msk            (0x7U << RTC_ALRMAR_ST_Pos)               /*!< 0x00000070 */
N#define RTC_ALRMAR_ST                RTC_ALRMAR_ST_Msk                         
N#define RTC_ALRMAR_ST_0              (0x1U << RTC_ALRMAR_ST_Pos)               /*!< 0x00000010 */
N#define RTC_ALRMAR_ST_1              (0x2U << RTC_ALRMAR_ST_Pos)               /*!< 0x00000020 */
N#define RTC_ALRMAR_ST_2              (0x4U << RTC_ALRMAR_ST_Pos)               /*!< 0x00000040 */
N#define RTC_ALRMAR_SU_Pos            (0U)                                      
N#define RTC_ALRMAR_SU_Msk            (0xFU << RTC_ALRMAR_SU_Pos)               /*!< 0x0000000F */
N#define RTC_ALRMAR_SU                RTC_ALRMAR_SU_Msk                         
N#define RTC_ALRMAR_SU_0              (0x1U << RTC_ALRMAR_SU_Pos)               /*!< 0x00000001 */
N#define RTC_ALRMAR_SU_1              (0x2U << RTC_ALRMAR_SU_Pos)               /*!< 0x00000002 */
N#define RTC_ALRMAR_SU_2              (0x4U << RTC_ALRMAR_SU_Pos)               /*!< 0x00000004 */
N#define RTC_ALRMAR_SU_3              (0x8U << RTC_ALRMAR_SU_Pos)               /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_WPR register  *****************/
N#define RTC_WPR_KEY_Pos              (0U)                                      
N#define RTC_WPR_KEY_Msk              (0xFFU << RTC_WPR_KEY_Pos)                /*!< 0x000000FF */
N#define RTC_WPR_KEY                  RTC_WPR_KEY_Msk                           
N
N/********************  Bits definition for RTC_SSR register  *****************/
N#define RTC_SSR_SS_Pos               (0U)                                      
N#define RTC_SSR_SS_Msk               (0xFFFFU << RTC_SSR_SS_Pos)               /*!< 0x0000FFFF */
N#define RTC_SSR_SS                   RTC_SSR_SS_Msk                            
N
N/********************  Bits definition for RTC_SHIFTR register  **************/
N#define RTC_SHIFTR_SUBFS_Pos         (0U)                                      
N#define RTC_SHIFTR_SUBFS_Msk         (0x7FFFU << RTC_SHIFTR_SUBFS_Pos)         /*!< 0x00007FFF */
N#define RTC_SHIFTR_SUBFS             RTC_SHIFTR_SUBFS_Msk                      
N#define RTC_SHIFTR_ADD1S_Pos         (31U)                                     
N#define RTC_SHIFTR_ADD1S_Msk         (0x1U << RTC_SHIFTR_ADD1S_Pos)            /*!< 0x80000000 */
N#define RTC_SHIFTR_ADD1S             RTC_SHIFTR_ADD1S_Msk                      
N
N/********************  Bits definition for RTC_TSTR register  ****************/
N#define RTC_TSTR_PM_Pos              (22U)                                     
N#define RTC_TSTR_PM_Msk              (0x1U << RTC_TSTR_PM_Pos)                 /*!< 0x00400000 */
N#define RTC_TSTR_PM                  RTC_TSTR_PM_Msk                           
N#define RTC_TSTR_HT_Pos              (20U)                                     
N#define RTC_TSTR_HT_Msk              (0x3U << RTC_TSTR_HT_Pos)                 /*!< 0x00300000 */
N#define RTC_TSTR_HT                  RTC_TSTR_HT_Msk                           
N#define RTC_TSTR_HT_0                (0x1U << RTC_TSTR_HT_Pos)                 /*!< 0x00100000 */
N#define RTC_TSTR_HT_1                (0x2U << RTC_TSTR_HT_Pos)                 /*!< 0x00200000 */
N#define RTC_TSTR_HU_Pos              (16U)                                     
N#define RTC_TSTR_HU_Msk              (0xFU << RTC_TSTR_HU_Pos)                 /*!< 0x000F0000 */
N#define RTC_TSTR_HU                  RTC_TSTR_HU_Msk                           
N#define RTC_TSTR_HU_0                (0x1U << RTC_TSTR_HU_Pos)                 /*!< 0x00010000 */
N#define RTC_TSTR_HU_1                (0x2U << RTC_TSTR_HU_Pos)                 /*!< 0x00020000 */
N#define RTC_TSTR_HU_2                (0x4U << RTC_TSTR_HU_Pos)                 /*!< 0x00040000 */
N#define RTC_TSTR_HU_3                (0x8U << RTC_TSTR_HU_Pos)                 /*!< 0x00080000 */
N#define RTC_TSTR_MNT_Pos             (12U)                                     
N#define RTC_TSTR_MNT_Msk             (0x7U << RTC_TSTR_MNT_Pos)                /*!< 0x00007000 */
N#define RTC_TSTR_MNT                 RTC_TSTR_MNT_Msk                          
N#define RTC_TSTR_MNT_0               (0x1U << RTC_TSTR_MNT_Pos)                /*!< 0x00001000 */
N#define RTC_TSTR_MNT_1               (0x2U << RTC_TSTR_MNT_Pos)                /*!< 0x00002000 */
N#define RTC_TSTR_MNT_2               (0x4U << RTC_TSTR_MNT_Pos)                /*!< 0x00004000 */
N#define RTC_TSTR_MNU_Pos             (8U)                                      
N#define RTC_TSTR_MNU_Msk             (0xFU << RTC_TSTR_MNU_Pos)                /*!< 0x00000F00 */
N#define RTC_TSTR_MNU                 RTC_TSTR_MNU_Msk                          
N#define RTC_TSTR_MNU_0               (0x1U << RTC_TSTR_MNU_Pos)                /*!< 0x00000100 */
N#define RTC_TSTR_MNU_1               (0x2U << RTC_TSTR_MNU_Pos)                /*!< 0x00000200 */
N#define RTC_TSTR_MNU_2               (0x4U << RTC_TSTR_MNU_Pos)                /*!< 0x00000400 */
N#define RTC_TSTR_MNU_3               (0x8U << RTC_TSTR_MNU_Pos)                /*!< 0x00000800 */
N#define RTC_TSTR_ST_Pos              (4U)                                      
N#define RTC_TSTR_ST_Msk              (0x7U << RTC_TSTR_ST_Pos)                 /*!< 0x00000070 */
N#define RTC_TSTR_ST                  RTC_TSTR_ST_Msk                           
N#define RTC_TSTR_ST_0                (0x1U << RTC_TSTR_ST_Pos)                 /*!< 0x00000010 */
N#define RTC_TSTR_ST_1                (0x2U << RTC_TSTR_ST_Pos)                 /*!< 0x00000020 */
N#define RTC_TSTR_ST_2                (0x4U << RTC_TSTR_ST_Pos)                 /*!< 0x00000040 */
N#define RTC_TSTR_SU_Pos              (0U)                                      
N#define RTC_TSTR_SU_Msk              (0xFU << RTC_TSTR_SU_Pos)                 /*!< 0x0000000F */
N#define RTC_TSTR_SU                  RTC_TSTR_SU_Msk                           
N#define RTC_TSTR_SU_0                (0x1U << RTC_TSTR_SU_Pos)                 /*!< 0x00000001 */
N#define RTC_TSTR_SU_1                (0x2U << RTC_TSTR_SU_Pos)                 /*!< 0x00000002 */
N#define RTC_TSTR_SU_2                (0x4U << RTC_TSTR_SU_Pos)                 /*!< 0x00000004 */
N#define RTC_TSTR_SU_3                (0x8U << RTC_TSTR_SU_Pos)                 /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_TSDR register  ****************/
N#define RTC_TSDR_WDU_Pos             (13U)                                     
N#define RTC_TSDR_WDU_Msk             (0x7U << RTC_TSDR_WDU_Pos)                /*!< 0x0000E000 */
N#define RTC_TSDR_WDU                 RTC_TSDR_WDU_Msk                          
N#define RTC_TSDR_WDU_0               (0x1U << RTC_TSDR_WDU_Pos)                /*!< 0x00002000 */
N#define RTC_TSDR_WDU_1               (0x2U << RTC_TSDR_WDU_Pos)                /*!< 0x00004000 */
N#define RTC_TSDR_WDU_2               (0x4U << RTC_TSDR_WDU_Pos)                /*!< 0x00008000 */
N#define RTC_TSDR_MT_Pos              (12U)                                     
N#define RTC_TSDR_MT_Msk              (0x1U << RTC_TSDR_MT_Pos)                 /*!< 0x00001000 */
N#define RTC_TSDR_MT                  RTC_TSDR_MT_Msk                           
N#define RTC_TSDR_MU_Pos              (8U)                                      
N#define RTC_TSDR_MU_Msk              (0xFU << RTC_TSDR_MU_Pos)                 /*!< 0x00000F00 */
N#define RTC_TSDR_MU                  RTC_TSDR_MU_Msk                           
N#define RTC_TSDR_MU_0                (0x1U << RTC_TSDR_MU_Pos)                 /*!< 0x00000100 */
N#define RTC_TSDR_MU_1                (0x2U << RTC_TSDR_MU_Pos)                 /*!< 0x00000200 */
N#define RTC_TSDR_MU_2                (0x4U << RTC_TSDR_MU_Pos)                 /*!< 0x00000400 */
N#define RTC_TSDR_MU_3                (0x8U << RTC_TSDR_MU_Pos)                 /*!< 0x00000800 */
N#define RTC_TSDR_DT_Pos              (4U)                                      
N#define RTC_TSDR_DT_Msk              (0x3U << RTC_TSDR_DT_Pos)                 /*!< 0x00000030 */
N#define RTC_TSDR_DT                  RTC_TSDR_DT_Msk                           
N#define RTC_TSDR_DT_0                (0x1U << RTC_TSDR_DT_Pos)                 /*!< 0x00000010 */
N#define RTC_TSDR_DT_1                (0x2U << RTC_TSDR_DT_Pos)                 /*!< 0x00000020 */
N#define RTC_TSDR_DU_Pos              (0U)                                      
N#define RTC_TSDR_DU_Msk              (0xFU << RTC_TSDR_DU_Pos)                 /*!< 0x0000000F */
N#define RTC_TSDR_DU                  RTC_TSDR_DU_Msk                           
N#define RTC_TSDR_DU_0                (0x1U << RTC_TSDR_DU_Pos)                 /*!< 0x00000001 */
N#define RTC_TSDR_DU_1                (0x2U << RTC_TSDR_DU_Pos)                 /*!< 0x00000002 */
N#define RTC_TSDR_DU_2                (0x4U << RTC_TSDR_DU_Pos)                 /*!< 0x00000004 */
N#define RTC_TSDR_DU_3                (0x8U << RTC_TSDR_DU_Pos)                 /*!< 0x00000008 */
N
N/********************  Bits definition for RTC_TSSSR register  ***************/
N#define RTC_TSSSR_SS_Pos             (0U)                                      
N#define RTC_TSSSR_SS_Msk             (0xFFFFU << RTC_TSSSR_SS_Pos)             /*!< 0x0000FFFF */
N#define RTC_TSSSR_SS                 RTC_TSSSR_SS_Msk                          
N
N/********************  Bits definition for RTC_CALR register  ****************/
N#define RTC_CALR_CALP_Pos            (15U)                                     
N#define RTC_CALR_CALP_Msk            (0x1U << RTC_CALR_CALP_Pos)               /*!< 0x00008000 */
N#define RTC_CALR_CALP                RTC_CALR_CALP_Msk                         
N#define RTC_CALR_CALW8_Pos           (14U)                                     
N#define RTC_CALR_CALW8_Msk           (0x1U << RTC_CALR_CALW8_Pos)              /*!< 0x00004000 */
N#define RTC_CALR_CALW8               RTC_CALR_CALW8_Msk                        
N#define RTC_CALR_CALW16_Pos          (13U)                                     
N#define RTC_CALR_CALW16_Msk          (0x1U << RTC_CALR_CALW16_Pos)             /*!< 0x00002000 */
N#define RTC_CALR_CALW16              RTC_CALR_CALW16_Msk                       
N#define RTC_CALR_CALM_Pos            (0U)                                      
N#define RTC_CALR_CALM_Msk            (0x1FFU << RTC_CALR_CALM_Pos)             /*!< 0x000001FF */
N#define RTC_CALR_CALM                RTC_CALR_CALM_Msk                         
N#define RTC_CALR_CALM_0              (0x001U << RTC_CALR_CALM_Pos)             /*!< 0x00000001 */
N#define RTC_CALR_CALM_1              (0x002U << RTC_CALR_CALM_Pos)             /*!< 0x00000002 */
N#define RTC_CALR_CALM_2              (0x004U << RTC_CALR_CALM_Pos)             /*!< 0x00000004 */
N#define RTC_CALR_CALM_3              (0x008U << RTC_CALR_CALM_Pos)             /*!< 0x00000008 */
N#define RTC_CALR_CALM_4              (0x010U << RTC_CALR_CALM_Pos)             /*!< 0x00000010 */
N#define RTC_CALR_CALM_5              (0x020U << RTC_CALR_CALM_Pos)             /*!< 0x00000020 */
N#define RTC_CALR_CALM_6              (0x040U << RTC_CALR_CALM_Pos)             /*!< 0x00000040 */
N#define RTC_CALR_CALM_7              (0x080U << RTC_CALR_CALM_Pos)             /*!< 0x00000080 */
N#define RTC_CALR_CALM_8              (0x100U << RTC_CALR_CALM_Pos)             /*!< 0x00000100 */
N
N/********************  Bits definition for RTC_TAFCR register  ***************/
N#define RTC_TAFCR_PC15MODE_Pos       (23U)                                     
N#define RTC_TAFCR_PC15MODE_Msk       (0x1U << RTC_TAFCR_PC15MODE_Pos)          /*!< 0x00800000 */
N#define RTC_TAFCR_PC15MODE           RTC_TAFCR_PC15MODE_Msk                    
N#define RTC_TAFCR_PC15VALUE_Pos      (22U)                                     
N#define RTC_TAFCR_PC15VALUE_Msk      (0x1U << RTC_TAFCR_PC15VALUE_Pos)         /*!< 0x00400000 */
N#define RTC_TAFCR_PC15VALUE          RTC_TAFCR_PC15VALUE_Msk                   
N#define RTC_TAFCR_PC14MODE_Pos       (21U)                                     
N#define RTC_TAFCR_PC14MODE_Msk       (0x1U << RTC_TAFCR_PC14MODE_Pos)          /*!< 0x00200000 */
N#define RTC_TAFCR_PC14MODE           RTC_TAFCR_PC14MODE_Msk                    
N#define RTC_TAFCR_PC14VALUE_Pos      (20U)                                     
N#define RTC_TAFCR_PC14VALUE_Msk      (0x1U << RTC_TAFCR_PC14VALUE_Pos)         /*!< 0x00100000 */
N#define RTC_TAFCR_PC14VALUE          RTC_TAFCR_PC14VALUE_Msk                   
N#define RTC_TAFCR_PC13MODE_Pos       (19U)                                     
N#define RTC_TAFCR_PC13MODE_Msk       (0x1U << RTC_TAFCR_PC13MODE_Pos)          /*!< 0x00080000 */
N#define RTC_TAFCR_PC13MODE           RTC_TAFCR_PC13MODE_Msk                    
N#define RTC_TAFCR_PC13VALUE_Pos      (18U)                                     
N#define RTC_TAFCR_PC13VALUE_Msk      (0x1U << RTC_TAFCR_PC13VALUE_Pos)         /*!< 0x00040000 */
N#define RTC_TAFCR_PC13VALUE          RTC_TAFCR_PC13VALUE_Msk                   
N#define RTC_TAFCR_TAMPPUDIS_Pos      (15U)                                     
N#define RTC_TAFCR_TAMPPUDIS_Msk      (0x1U << RTC_TAFCR_TAMPPUDIS_Pos)         /*!< 0x00008000 */
N#define RTC_TAFCR_TAMPPUDIS          RTC_TAFCR_TAMPPUDIS_Msk                   
N#define RTC_TAFCR_TAMPPRCH_Pos       (13U)                                     
N#define RTC_TAFCR_TAMPPRCH_Msk       (0x3U << RTC_TAFCR_TAMPPRCH_Pos)          /*!< 0x00006000 */
N#define RTC_TAFCR_TAMPPRCH           RTC_TAFCR_TAMPPRCH_Msk                    
N#define RTC_TAFCR_TAMPPRCH_0         (0x1U << RTC_TAFCR_TAMPPRCH_Pos)          /*!< 0x00002000 */
N#define RTC_TAFCR_TAMPPRCH_1         (0x2U << RTC_TAFCR_TAMPPRCH_Pos)          /*!< 0x00004000 */
N#define RTC_TAFCR_TAMPFLT_Pos        (11U)                                     
N#define RTC_TAFCR_TAMPFLT_Msk        (0x3U << RTC_TAFCR_TAMPFLT_Pos)           /*!< 0x00001800 */
N#define RTC_TAFCR_TAMPFLT            RTC_TAFCR_TAMPFLT_Msk                     
N#define RTC_TAFCR_TAMPFLT_0          (0x1U << RTC_TAFCR_TAMPFLT_Pos)           /*!< 0x00000800 */
N#define RTC_TAFCR_TAMPFLT_1          (0x2U << RTC_TAFCR_TAMPFLT_Pos)           /*!< 0x00001000 */
N#define RTC_TAFCR_TAMPFREQ_Pos       (8U)                                      
N#define RTC_TAFCR_TAMPFREQ_Msk       (0x7U << RTC_TAFCR_TAMPFREQ_Pos)          /*!< 0x00000700 */
N#define RTC_TAFCR_TAMPFREQ           RTC_TAFCR_TAMPFREQ_Msk                    
N#define RTC_TAFCR_TAMPFREQ_0         (0x1U << RTC_TAFCR_TAMPFREQ_Pos)          /*!< 0x00000100 */
N#define RTC_TAFCR_TAMPFREQ_1         (0x2U << RTC_TAFCR_TAMPFREQ_Pos)          /*!< 0x00000200 */
N#define RTC_TAFCR_TAMPFREQ_2         (0x4U << RTC_TAFCR_TAMPFREQ_Pos)          /*!< 0x00000400 */
N#define RTC_TAFCR_TAMPTS_Pos         (7U)                                      
N#define RTC_TAFCR_TAMPTS_Msk         (0x1U << RTC_TAFCR_TAMPTS_Pos)            /*!< 0x00000080 */
N#define RTC_TAFCR_TAMPTS             RTC_TAFCR_TAMPTS_Msk                      
N#define RTC_TAFCR_TAMP3TRG_Pos       (6U)                                      
N#define RTC_TAFCR_TAMP3TRG_Msk       (0x1U << RTC_TAFCR_TAMP3TRG_Pos)          /*!< 0x00000040 */
N#define RTC_TAFCR_TAMP3TRG           RTC_TAFCR_TAMP3TRG_Msk                    
N#define RTC_TAFCR_TAMP3E_Pos         (5U)                                      
N#define RTC_TAFCR_TAMP3E_Msk         (0x1U << RTC_TAFCR_TAMP3E_Pos)            /*!< 0x00000020 */
N#define RTC_TAFCR_TAMP3E             RTC_TAFCR_TAMP3E_Msk                      
N#define RTC_TAFCR_TAMP2TRG_Pos       (4U)                                      
N#define RTC_TAFCR_TAMP2TRG_Msk       (0x1U << RTC_TAFCR_TAMP2TRG_Pos)          /*!< 0x00000010 */
N#define RTC_TAFCR_TAMP2TRG           RTC_TAFCR_TAMP2TRG_Msk                    
N#define RTC_TAFCR_TAMP2E_Pos         (3U)                                      
N#define RTC_TAFCR_TAMP2E_Msk         (0x1U << RTC_TAFCR_TAMP2E_Pos)            /*!< 0x00000008 */
N#define RTC_TAFCR_TAMP2E             RTC_TAFCR_TAMP2E_Msk                      
N#define RTC_TAFCR_TAMPIE_Pos         (2U)                                      
N#define RTC_TAFCR_TAMPIE_Msk         (0x1U << RTC_TAFCR_TAMPIE_Pos)            /*!< 0x00000004 */
N#define RTC_TAFCR_TAMPIE             RTC_TAFCR_TAMPIE_Msk                      
N#define RTC_TAFCR_TAMP1TRG_Pos       (1U)                                      
N#define RTC_TAFCR_TAMP1TRG_Msk       (0x1U << RTC_TAFCR_TAMP1TRG_Pos)          /*!< 0x00000002 */
N#define RTC_TAFCR_TAMP1TRG           RTC_TAFCR_TAMP1TRG_Msk                    
N#define RTC_TAFCR_TAMP1E_Pos         (0U)                                      
N#define RTC_TAFCR_TAMP1E_Msk         (0x1U << RTC_TAFCR_TAMP1E_Pos)            /*!< 0x00000001 */
N#define RTC_TAFCR_TAMP1E             RTC_TAFCR_TAMP1E_Msk                      
N
N/* Reference defines */
N#define RTC_TAFCR_ALARMOUTTYPE               RTC_TAFCR_PC13VALUE
N
N/********************  Bits definition for RTC_ALRMASSR register  ************/
N#define RTC_ALRMASSR_MASKSS_Pos      (24U)                                     
N#define RTC_ALRMASSR_MASKSS_Msk      (0xFU << RTC_ALRMASSR_MASKSS_Pos)         /*!< 0x0F000000 */
N#define RTC_ALRMASSR_MASKSS          RTC_ALRMASSR_MASKSS_Msk                   
N#define RTC_ALRMASSR_MASKSS_0        (0x1U << RTC_ALRMASSR_MASKSS_Pos)         /*!< 0x01000000 */
N#define RTC_ALRMASSR_MASKSS_1        (0x2U << RTC_ALRMASSR_MASKSS_Pos)         /*!< 0x02000000 */
N#define RTC_ALRMASSR_MASKSS_2        (0x4U << RTC_ALRMASSR_MASKSS_Pos)         /*!< 0x04000000 */
N#define RTC_ALRMASSR_MASKSS_3        (0x8U << RTC_ALRMASSR_MASKSS_Pos)         /*!< 0x08000000 */
N#define RTC_ALRMASSR_SS_Pos          (0U)                                      
N#define RTC_ALRMASSR_SS_Msk          (0x7FFFU << RTC_ALRMASSR_SS_Pos)          /*!< 0x00007FFF */
N#define RTC_ALRMASSR_SS              RTC_ALRMASSR_SS_Msk                       
N
N/********************  Bits definition for RTC_BKP0R register  ***************/
N#define RTC_BKP0R_Pos                (0U)                                      
N#define RTC_BKP0R_Msk                (0xFFFFFFFFU << RTC_BKP0R_Pos)            /*!< 0xFFFFFFFF */
N#define RTC_BKP0R                    RTC_BKP0R_Msk                             
N
N/********************  Bits definition for RTC_BKP1R register  ***************/
N#define RTC_BKP1R_Pos                (0U)                                      
N#define RTC_BKP1R_Msk                (0xFFFFFFFFU << RTC_BKP1R_Pos)            /*!< 0xFFFFFFFF */
N#define RTC_BKP1R                    RTC_BKP1R_Msk                             
N
N/********************  Bits definition for RTC_BKP2R register  ***************/
N#define RTC_BKP2R_Pos                (0U)                                      
N#define RTC_BKP2R_Msk                (0xFFFFFFFFU << RTC_BKP2R_Pos)            /*!< 0xFFFFFFFF */
N#define RTC_BKP2R                    RTC_BKP2R_Msk                             
N
N/********************  Bits definition for RTC_BKP3R register  ***************/
N#define RTC_BKP3R_Pos                (0U)                                      
N#define RTC_BKP3R_Msk                (0xFFFFFFFFU << RTC_BKP3R_Pos)            /*!< 0xFFFFFFFF */
N#define RTC_BKP3R                    RTC_BKP3R_Msk                             
N
N/********************  Bits definition for RTC_BKP4R register  ***************/
N#define RTC_BKP4R_Pos                (0U)                                      
N#define RTC_BKP4R_Msk                (0xFFFFFFFFU << RTC_BKP4R_Pos)            /*!< 0xFFFFFFFF */
N#define RTC_BKP4R                    RTC_BKP4R_Msk                             
N
N/******************** Number of backup registers ******************************/
N#define RTC_BKP_NUMBER                       0x00000005U
N
N/*****************************************************************************/
N/*                                                                           */
N/*                        Serial Peripheral Interface (SPI)                  */
N/*                                                                           */
N/*****************************************************************************/
N
N/*
N * @brief Specific device feature definitions (not present on all devices in the STM32F0 serie)
N */
N#define SPI_I2S_SUPPORT                       /*!< I2S support */
N
N/*******************  Bit definition for SPI_CR1 register  *******************/
N#define SPI_CR1_CPHA_Pos            (0U)                                       
N#define SPI_CR1_CPHA_Msk            (0x1U << SPI_CR1_CPHA_Pos)                 /*!< 0x00000001 */
N#define SPI_CR1_CPHA                SPI_CR1_CPHA_Msk                           /*!< Clock Phase */
N#define SPI_CR1_CPOL_Pos            (1U)                                       
N#define SPI_CR1_CPOL_Msk            (0x1U << SPI_CR1_CPOL_Pos)                 /*!< 0x00000002 */
N#define SPI_CR1_CPOL                SPI_CR1_CPOL_Msk                           /*!< Clock Polarity */
N#define SPI_CR1_MSTR_Pos            (2U)                                       
N#define SPI_CR1_MSTR_Msk            (0x1U << SPI_CR1_MSTR_Pos)                 /*!< 0x00000004 */
N#define SPI_CR1_MSTR                SPI_CR1_MSTR_Msk                           /*!< Master Selection */
N#define SPI_CR1_BR_Pos              (3U)                                       
N#define SPI_CR1_BR_Msk              (0x7U << SPI_CR1_BR_Pos)                   /*!< 0x00000038 */
N#define SPI_CR1_BR                  SPI_CR1_BR_Msk                             /*!< BR[2:0] bits (Baud Rate Control) */
N#define SPI_CR1_BR_0                (0x1U << SPI_CR1_BR_Pos)                   /*!< 0x00000008 */
N#define SPI_CR1_BR_1                (0x2U << SPI_CR1_BR_Pos)                   /*!< 0x00000010 */
N#define SPI_CR1_BR_2                (0x4U << SPI_CR1_BR_Pos)                   /*!< 0x00000020 */
N#define SPI_CR1_SPE_Pos             (6U)                                       
N#define SPI_CR1_SPE_Msk             (0x1U << SPI_CR1_SPE_Pos)                  /*!< 0x00000040 */
N#define SPI_CR1_SPE                 SPI_CR1_SPE_Msk                            /*!< SPI Enable */
N#define SPI_CR1_LSBFIRST_Pos        (7U)                                       
N#define SPI_CR1_LSBFIRST_Msk        (0x1U << SPI_CR1_LSBFIRST_Pos)             /*!< 0x00000080 */
N#define SPI_CR1_LSBFIRST            SPI_CR1_LSBFIRST_Msk                       /*!< Frame Format */
N#define SPI_CR1_SSI_Pos             (8U)                                       
N#define SPI_CR1_SSI_Msk             (0x1U << SPI_CR1_SSI_Pos)                  /*!< 0x00000100 */
N#define SPI_CR1_SSI                 SPI_CR1_SSI_Msk                            /*!< Internal slave select */
N#define SPI_CR1_SSM_Pos             (9U)                                       
N#define SPI_CR1_SSM_Msk             (0x1U << SPI_CR1_SSM_Pos)                  /*!< 0x00000200 */
N#define SPI_CR1_SSM                 SPI_CR1_SSM_Msk                            /*!< Software slave management */
N#define SPI_CR1_RXONLY_Pos          (10U)                                      
N#define SPI_CR1_RXONLY_Msk          (0x1U << SPI_CR1_RXONLY_Pos)               /*!< 0x00000400 */
N#define SPI_CR1_RXONLY              SPI_CR1_RXONLY_Msk                         /*!< Receive only */
N#define SPI_CR1_CRCL_Pos            (11U)                                      
N#define SPI_CR1_CRCL_Msk            (0x1U << SPI_CR1_CRCL_Pos)                 /*!< 0x00000800 */
N#define SPI_CR1_CRCL                SPI_CR1_CRCL_Msk                           /*!< CRC Length */
N#define SPI_CR1_CRCNEXT_Pos         (12U)                                      
N#define SPI_CR1_CRCNEXT_Msk         (0x1U << SPI_CR1_CRCNEXT_Pos)              /*!< 0x00001000 */
N#define SPI_CR1_CRCNEXT             SPI_CR1_CRCNEXT_Msk                        /*!< Transmit CRC next */
N#define SPI_CR1_CRCEN_Pos           (13U)                                      
N#define SPI_CR1_CRCEN_Msk           (0x1U << SPI_CR1_CRCEN_Pos)                /*!< 0x00002000 */
N#define SPI_CR1_CRCEN               SPI_CR1_CRCEN_Msk                          /*!< Hardware CRC calculation enable */
N#define SPI_CR1_BIDIOE_Pos          (14U)                                      
N#define SPI_CR1_BIDIOE_Msk          (0x1U << SPI_CR1_BIDIOE_Pos)               /*!< 0x00004000 */
N#define SPI_CR1_BIDIOE              SPI_CR1_BIDIOE_Msk                         /*!< Output enable in bidirectional mode */
N#define SPI_CR1_BIDIMODE_Pos        (15U)                                      
N#define SPI_CR1_BIDIMODE_Msk        (0x1U << SPI_CR1_BIDIMODE_Pos)             /*!< 0x00008000 */
N#define SPI_CR1_BIDIMODE            SPI_CR1_BIDIMODE_Msk                       /*!< Bidirectional data mode enable */
N
N/*******************  Bit definition for SPI_CR2 register  *******************/
N#define SPI_CR2_RXDMAEN_Pos         (0U)                                       
N#define SPI_CR2_RXDMAEN_Msk         (0x1U << SPI_CR2_RXDMAEN_Pos)              /*!< 0x00000001 */
N#define SPI_CR2_RXDMAEN             SPI_CR2_RXDMAEN_Msk                        /*!< Rx Buffer DMA Enable */
N#define SPI_CR2_TXDMAEN_Pos         (1U)                                       
N#define SPI_CR2_TXDMAEN_Msk         (0x1U << SPI_CR2_TXDMAEN_Pos)              /*!< 0x00000002 */
N#define SPI_CR2_TXDMAEN             SPI_CR2_TXDMAEN_Msk                        /*!< Tx Buffer DMA Enable */
N#define SPI_CR2_SSOE_Pos            (2U)                                       
N#define SPI_CR2_SSOE_Msk            (0x1U << SPI_CR2_SSOE_Pos)                 /*!< 0x00000004 */
N#define SPI_CR2_SSOE                SPI_CR2_SSOE_Msk                           /*!< SS Output Enable */
N#define SPI_CR2_NSSP_Pos            (3U)                                       
N#define SPI_CR2_NSSP_Msk            (0x1U << SPI_CR2_NSSP_Pos)                 /*!< 0x00000008 */
N#define SPI_CR2_NSSP                SPI_CR2_NSSP_Msk                           /*!< NSS pulse management Enable */
N#define SPI_CR2_FRF_Pos             (4U)                                       
N#define SPI_CR2_FRF_Msk             (0x1U << SPI_CR2_FRF_Pos)                  /*!< 0x00000010 */
N#define SPI_CR2_FRF                 SPI_CR2_FRF_Msk                            /*!< Frame Format Enable */
N#define SPI_CR2_ERRIE_Pos           (5U)                                       
N#define SPI_CR2_ERRIE_Msk           (0x1U << SPI_CR2_ERRIE_Pos)                /*!< 0x00000020 */
N#define SPI_CR2_ERRIE               SPI_CR2_ERRIE_Msk                          /*!< Error Interrupt Enable */
N#define SPI_CR2_RXNEIE_Pos          (6U)                                       
N#define SPI_CR2_RXNEIE_Msk          (0x1U << SPI_CR2_RXNEIE_Pos)               /*!< 0x00000040 */
N#define SPI_CR2_RXNEIE              SPI_CR2_RXNEIE_Msk                         /*!< RX buffer Not Empty Interrupt Enable */
N#define SPI_CR2_TXEIE_Pos           (7U)                                       
N#define SPI_CR2_TXEIE_Msk           (0x1U << SPI_CR2_TXEIE_Pos)                /*!< 0x00000080 */
N#define SPI_CR2_TXEIE               SPI_CR2_TXEIE_Msk                          /*!< Tx buffer Empty Interrupt Enable */
N#define SPI_CR2_DS_Pos              (8U)                                       
N#define SPI_CR2_DS_Msk              (0xFU << SPI_CR2_DS_Pos)                   /*!< 0x00000F00 */
N#define SPI_CR2_DS                  SPI_CR2_DS_Msk                             /*!< DS[3:0] Data Size */
N#define SPI_CR2_DS_0                (0x1U << SPI_CR2_DS_Pos)                   /*!< 0x00000100 */
N#define SPI_CR2_DS_1                (0x2U << SPI_CR2_DS_Pos)                   /*!< 0x00000200 */
N#define SPI_CR2_DS_2                (0x4U << SPI_CR2_DS_Pos)                   /*!< 0x00000400 */
N#define SPI_CR2_DS_3                (0x8U << SPI_CR2_DS_Pos)                   /*!< 0x00000800 */
N#define SPI_CR2_FRXTH_Pos           (12U)                                      
N#define SPI_CR2_FRXTH_Msk           (0x1U << SPI_CR2_FRXTH_Pos)                /*!< 0x00001000 */
N#define SPI_CR2_FRXTH               SPI_CR2_FRXTH_Msk                          /*!< FIFO reception Threshold */
N#define SPI_CR2_LDMARX_Pos          (13U)                                      
N#define SPI_CR2_LDMARX_Msk          (0x1U << SPI_CR2_LDMARX_Pos)               /*!< 0x00002000 */
N#define SPI_CR2_LDMARX              SPI_CR2_LDMARX_Msk                         /*!< Last DMA transfer for reception */
N#define SPI_CR2_LDMATX_Pos          (14U)                                      
N#define SPI_CR2_LDMATX_Msk          (0x1U << SPI_CR2_LDMATX_Pos)               /*!< 0x00004000 */
N#define SPI_CR2_LDMATX              SPI_CR2_LDMATX_Msk                         /*!< Last DMA transfer for transmission */
N
N/********************  Bit definition for SPI_SR register  *******************/
N#define SPI_SR_RXNE_Pos             (0U)                                       
N#define SPI_SR_RXNE_Msk             (0x1U << SPI_SR_RXNE_Pos)                  /*!< 0x00000001 */
N#define SPI_SR_RXNE                 SPI_SR_RXNE_Msk                            /*!< Receive buffer Not Empty */
N#define SPI_SR_TXE_Pos              (1U)                                       
N#define SPI_SR_TXE_Msk              (0x1U << SPI_SR_TXE_Pos)                   /*!< 0x00000002 */
N#define SPI_SR_TXE                  SPI_SR_TXE_Msk                             /*!< Transmit buffer Empty */
N#define SPI_SR_CHSIDE_Pos           (2U)                                       
N#define SPI_SR_CHSIDE_Msk           (0x1U << SPI_SR_CHSIDE_Pos)                /*!< 0x00000004 */
N#define SPI_SR_CHSIDE               SPI_SR_CHSIDE_Msk                          /*!< Channel side */
N#define SPI_SR_UDR_Pos              (3U)                                       
N#define SPI_SR_UDR_Msk              (0x1U << SPI_SR_UDR_Pos)                   /*!< 0x00000008 */
N#define SPI_SR_UDR                  SPI_SR_UDR_Msk                             /*!< Underrun flag */
N#define SPI_SR_CRCERR_Pos           (4U)                                       
N#define SPI_SR_CRCERR_Msk           (0x1U << SPI_SR_CRCERR_Pos)                /*!< 0x00000010 */
N#define SPI_SR_CRCERR               SPI_SR_CRCERR_Msk                          /*!< CRC Error flag */
N#define SPI_SR_MODF_Pos             (5U)                                       
N#define SPI_SR_MODF_Msk             (0x1U << SPI_SR_MODF_Pos)                  /*!< 0x00000020 */
N#define SPI_SR_MODF                 SPI_SR_MODF_Msk                            /*!< Mode fault */
N#define SPI_SR_OVR_Pos              (6U)                                       
N#define SPI_SR_OVR_Msk              (0x1U << SPI_SR_OVR_Pos)                   /*!< 0x00000040 */
N#define SPI_SR_OVR                  SPI_SR_OVR_Msk                             /*!< Overrun flag */
N#define SPI_SR_BSY_Pos              (7U)                                       
N#define SPI_SR_BSY_Msk              (0x1U << SPI_SR_BSY_Pos)                   /*!< 0x00000080 */
N#define SPI_SR_BSY                  SPI_SR_BSY_Msk                             /*!< Busy flag */
N#define SPI_SR_FRE_Pos              (8U)                                       
N#define SPI_SR_FRE_Msk              (0x1U << SPI_SR_FRE_Pos)                   /*!< 0x00000100 */
N#define SPI_SR_FRE                  SPI_SR_FRE_Msk                             /*!< TI frame format error */
N#define SPI_SR_FRLVL_Pos            (9U)                                       
N#define SPI_SR_FRLVL_Msk            (0x3U << SPI_SR_FRLVL_Pos)                 /*!< 0x00000600 */
N#define SPI_SR_FRLVL                SPI_SR_FRLVL_Msk                           /*!< FIFO Reception Level */
N#define SPI_SR_FRLVL_0              (0x1U << SPI_SR_FRLVL_Pos)                 /*!< 0x00000200 */
N#define SPI_SR_FRLVL_1              (0x2U << SPI_SR_FRLVL_Pos)                 /*!< 0x00000400 */
N#define SPI_SR_FTLVL_Pos            (11U)                                      
N#define SPI_SR_FTLVL_Msk            (0x3U << SPI_SR_FTLVL_Pos)                 /*!< 0x00001800 */
N#define SPI_SR_FTLVL                SPI_SR_FTLVL_Msk                           /*!< FIFO Transmission Level */
N#define SPI_SR_FTLVL_0              (0x1U << SPI_SR_FTLVL_Pos)                 /*!< 0x00000800 */
N#define SPI_SR_FTLVL_1              (0x2U << SPI_SR_FTLVL_Pos)                 /*!< 0x00001000 */
N
N/********************  Bit definition for SPI_DR register  *******************/
N#define SPI_DR_DR_Pos               (0U)                                       
N#define SPI_DR_DR_Msk               (0xFFFFFFFFU << SPI_DR_DR_Pos)             /*!< 0xFFFFFFFF */
N#define SPI_DR_DR                   SPI_DR_DR_Msk                              /*!< Data Register */
N
N/*******************  Bit definition for SPI_CRCPR register  *****************/
N#define SPI_CRCPR_CRCPOLY_Pos       (0U)                                       
N#define SPI_CRCPR_CRCPOLY_Msk       (0xFFFFFFFFU << SPI_CRCPR_CRCPOLY_Pos)     /*!< 0xFFFFFFFF */
N#define SPI_CRCPR_CRCPOLY           SPI_CRCPR_CRCPOLY_Msk                      /*!< CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  *****************/
N#define SPI_RXCRCR_RXCRC_Pos        (0U)                                       
N#define SPI_RXCRCR_RXCRC_Msk        (0xFFFFFFFFU << SPI_RXCRCR_RXCRC_Pos)      /*!< 0xFFFFFFFF */
N#define SPI_RXCRCR_RXCRC            SPI_RXCRCR_RXCRC_Msk                       /*!< Rx CRC Register */
N
N/******************  Bit definition for SPI_TXCRCR register  *****************/
N#define SPI_TXCRCR_TXCRC_Pos        (0U)                                       
N#define SPI_TXCRCR_TXCRC_Msk        (0xFFFFFFFFU << SPI_TXCRCR_TXCRC_Pos)      /*!< 0xFFFFFFFF */
N#define SPI_TXCRCR_TXCRC            SPI_TXCRCR_TXCRC_Msk                       /*!< Tx CRC Register */
N
N/******************  Bit definition for SPI_I2SCFGR register  ****************/
N#define SPI_I2SCFGR_CHLEN_Pos       (0U)                                       
N#define SPI_I2SCFGR_CHLEN_Msk       (0x1U << SPI_I2SCFGR_CHLEN_Pos)            /*!< 0x00000001 */
N#define SPI_I2SCFGR_CHLEN           SPI_I2SCFGR_CHLEN_Msk                      /*!<Channel length (number of bits per audio channel) */
N#define SPI_I2SCFGR_DATLEN_Pos      (1U)                                       
N#define SPI_I2SCFGR_DATLEN_Msk      (0x3U << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000006 */
N#define SPI_I2SCFGR_DATLEN          SPI_I2SCFGR_DATLEN_Msk                     /*!<DATLEN[1:0] bits (Data length to be transferred) */
N#define SPI_I2SCFGR_DATLEN_0        (0x1U << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000002 */
N#define SPI_I2SCFGR_DATLEN_1        (0x2U << SPI_I2SCFGR_DATLEN_Pos)           /*!< 0x00000004 */
N#define SPI_I2SCFGR_CKPOL_Pos       (3U)                                       
N#define SPI_I2SCFGR_CKPOL_Msk       (0x1U << SPI_I2SCFGR_CKPOL_Pos)            /*!< 0x00000008 */
N#define SPI_I2SCFGR_CKPOL           SPI_I2SCFGR_CKPOL_Msk                      /*!<steady state clock polarity */
N#define SPI_I2SCFGR_I2SSTD_Pos      (4U)                                       
N#define SPI_I2SCFGR_I2SSTD_Msk      (0x3U << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000030 */
N#define SPI_I2SCFGR_I2SSTD          SPI_I2SCFGR_I2SSTD_Msk                     /*!<I2SSTD[1:0] bits (I2S standard selection) */
N#define SPI_I2SCFGR_I2SSTD_0        (0x1U << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000010 */
N#define SPI_I2SCFGR_I2SSTD_1        (0x2U << SPI_I2SCFGR_I2SSTD_Pos)           /*!< 0x00000020 */
N#define SPI_I2SCFGR_PCMSYNC_Pos     (7U)                                       
N#define SPI_I2SCFGR_PCMSYNC_Msk     (0x1U << SPI_I2SCFGR_PCMSYNC_Pos)          /*!< 0x00000080 */
N#define SPI_I2SCFGR_PCMSYNC         SPI_I2SCFGR_PCMSYNC_Msk                    /*!<PCM frame synchronization */
N#define SPI_I2SCFGR_I2SCFG_Pos      (8U)                                       
N#define SPI_I2SCFGR_I2SCFG_Msk      (0x3U << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000300 */
N#define SPI_I2SCFGR_I2SCFG          SPI_I2SCFGR_I2SCFG_Msk                     /*!<I2SCFG[1:0] bits (I2S configuration mode) */
N#define SPI_I2SCFGR_I2SCFG_0        (0x1U << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000100 */
N#define SPI_I2SCFGR_I2SCFG_1        (0x2U << SPI_I2SCFGR_I2SCFG_Pos)           /*!< 0x00000200 */
N#define SPI_I2SCFGR_I2SE_Pos        (10U)                                      
N#define SPI_I2SCFGR_I2SE_Msk        (0x1U << SPI_I2SCFGR_I2SE_Pos)             /*!< 0x00000400 */
N#define SPI_I2SCFGR_I2SE            SPI_I2SCFGR_I2SE_Msk                       /*!<I2S Enable */
N#define SPI_I2SCFGR_I2SMOD_Pos      (11U)                                      
N#define SPI_I2SCFGR_I2SMOD_Msk      (0x1U << SPI_I2SCFGR_I2SMOD_Pos)           /*!< 0x00000800 */
N#define SPI_I2SCFGR_I2SMOD          SPI_I2SCFGR_I2SMOD_Msk                     /*!<I2S mode selection */
N
N/******************  Bit definition for SPI_I2SPR register  ******************/
N#define SPI_I2SPR_I2SDIV_Pos        (0U)                                       
N#define SPI_I2SPR_I2SDIV_Msk        (0xFFU << SPI_I2SPR_I2SDIV_Pos)            /*!< 0x000000FF */
N#define SPI_I2SPR_I2SDIV            SPI_I2SPR_I2SDIV_Msk                       /*!<I2S Linear prescaler */
N#define SPI_I2SPR_ODD_Pos           (8U)                                       
N#define SPI_I2SPR_ODD_Msk           (0x1U << SPI_I2SPR_ODD_Pos)                /*!< 0x00000100 */
N#define SPI_I2SPR_ODD               SPI_I2SPR_ODD_Msk                          /*!<Odd factor for the prescaler */
N#define SPI_I2SPR_MCKOE_Pos         (9U)                                       
N#define SPI_I2SPR_MCKOE_Msk         (0x1U << SPI_I2SPR_MCKOE_Pos)              /*!< 0x00000200 */
N#define SPI_I2SPR_MCKOE             SPI_I2SPR_MCKOE_Msk                        /*!<Master Clock Output Enable */
N
N/*****************************************************************************/
N/*                                                                           */
N/*                       System Configuration (SYSCFG)                       */
N/*                                                                           */
N/*****************************************************************************/
N/*****************  Bit definition for SYSCFG_CFGR1 register  ****************/
N#define SYSCFG_CFGR1_MEM_MODE_Pos            (0U)                              
N#define SYSCFG_CFGR1_MEM_MODE_Msk            (0x3U << SYSCFG_CFGR1_MEM_MODE_Pos) /*!< 0x00000003 */
N#define SYSCFG_CFGR1_MEM_MODE                SYSCFG_CFGR1_MEM_MODE_Msk           /*!< SYSCFG_Memory Remap Config */
N#define SYSCFG_CFGR1_MEM_MODE_0              (0x1U << SYSCFG_CFGR1_MEM_MODE_Pos) /*!< 0x00000001 */
N#define SYSCFG_CFGR1_MEM_MODE_1              (0x2U << SYSCFG_CFGR1_MEM_MODE_Pos) /*!< 0x00000002 */
N#define SYSCFG_CFGR1_IR_MOD_Pos              (6U)                              
N#define SYSCFG_CFGR1_IR_MOD_Msk              (0x3U << SYSCFG_CFGR1_IR_MOD_Pos) /*!< 0x000000C0 */
N#define SYSCFG_CFGR1_IR_MOD                  SYSCFG_CFGR1_IR_MOD_Msk           /*!< IR_MOD config */
N#define SYSCFG_CFGR1_IR_MOD_0                (0x1U << SYSCFG_CFGR1_IR_MOD_Pos) /*!< 0x00000040 */
N#define SYSCFG_CFGR1_IR_MOD_1                (0x2U << SYSCFG_CFGR1_IR_MOD_Pos) /*!< 0x00000080 */
N
N/* Alias for legacy purposes */
N#define SYSCFG_CFGR1_IRDA_ENV_SEL            SYSCFG_CFGR1_IR_MOD 
N#define SYSCFG_CFGR1_IRDA_ENV_SEL_0          SYSCFG_CFGR1_IR_MOD_0
N#define SYSCFG_CFGR1_IRDA_ENV_SEL_1          SYSCFG_CFGR1_IR_MOD_1
N
N
N
N#define SYSCFG_CFGR1_I2C_FMP_PB6_Pos         (16U)                             
N#define SYSCFG_CFGR1_I2C_FMP_PB6_Msk         (0x1U << SYSCFG_CFGR1_I2C_FMP_PB6_Pos) /*!< 0x00010000 */
N#define SYSCFG_CFGR1_I2C_FMP_PB6             SYSCFG_CFGR1_I2C_FMP_PB6_Msk      /*!< I2C PB6 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_FMP_PB7_Pos         (17U)                             
N#define SYSCFG_CFGR1_I2C_FMP_PB7_Msk         (0x1U << SYSCFG_CFGR1_I2C_FMP_PB7_Pos) /*!< 0x00020000 */
N#define SYSCFG_CFGR1_I2C_FMP_PB7             SYSCFG_CFGR1_I2C_FMP_PB7_Msk      /*!< I2C PB7 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_FMP_PB8_Pos         (18U)                             
N#define SYSCFG_CFGR1_I2C_FMP_PB8_Msk         (0x1U << SYSCFG_CFGR1_I2C_FMP_PB8_Pos) /*!< 0x00040000 */
N#define SYSCFG_CFGR1_I2C_FMP_PB8             SYSCFG_CFGR1_I2C_FMP_PB8_Msk      /*!< I2C PB8 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_FMP_PB9_Pos         (19U)                             
N#define SYSCFG_CFGR1_I2C_FMP_PB9_Msk         (0x1U << SYSCFG_CFGR1_I2C_FMP_PB9_Pos) /*!< 0x00080000 */
N#define SYSCFG_CFGR1_I2C_FMP_PB9             SYSCFG_CFGR1_I2C_FMP_PB9_Msk      /*!< I2C PB9 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_FMP_I2C1_Pos        (20U)                             
N#define SYSCFG_CFGR1_I2C_FMP_I2C1_Msk        (0x1U << SYSCFG_CFGR1_I2C_FMP_I2C1_Pos) /*!< 0x00100000 */
N#define SYSCFG_CFGR1_I2C_FMP_I2C1            SYSCFG_CFGR1_I2C_FMP_I2C1_Msk     /*!< Enable Fast Mode Plus on PB10, PB11, PF6 and PF7  */
N#define SYSCFG_CFGR1_I2C_FMP_I2C2_Pos        (21U)                             
N#define SYSCFG_CFGR1_I2C_FMP_I2C2_Msk        (0x1U << SYSCFG_CFGR1_I2C_FMP_I2C2_Pos) /*!< 0x00200000 */
N#define SYSCFG_CFGR1_I2C_FMP_I2C2            SYSCFG_CFGR1_I2C_FMP_I2C2_Msk     /*!< Enable I2C2 Fast mode plus  */
N#define SYSCFG_CFGR1_I2C_FMP_PA9_Pos         (22U)                             
N#define SYSCFG_CFGR1_I2C_FMP_PA9_Msk         (0x1U << SYSCFG_CFGR1_I2C_FMP_PA9_Pos) /*!< 0x00400000 */
N#define SYSCFG_CFGR1_I2C_FMP_PA9             SYSCFG_CFGR1_I2C_FMP_PA9_Msk      /*!< Enable Fast Mode Plus on PA9  */
N#define SYSCFG_CFGR1_I2C_FMP_PA10_Pos        (23U)                             
N#define SYSCFG_CFGR1_I2C_FMP_PA10_Msk        (0x1U << SYSCFG_CFGR1_I2C_FMP_PA10_Pos) /*!< 0x00800000 */
N#define SYSCFG_CFGR1_I2C_FMP_PA10            SYSCFG_CFGR1_I2C_FMP_PA10_Msk     /*!< Enable Fast Mode Plus on PA10 */
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  **************/
N#define SYSCFG_EXTICR1_EXTI0_Pos             (0U)                              
N#define SYSCFG_EXTICR1_EXTI0_Msk             (0xFU << SYSCFG_EXTICR1_EXTI0_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR1_EXTI0                 SYSCFG_EXTICR1_EXTI0_Msk          /*!< EXTI 0 configuration */
N#define SYSCFG_EXTICR1_EXTI1_Pos             (4U)                              
N#define SYSCFG_EXTICR1_EXTI1_Msk             (0xFU << SYSCFG_EXTICR1_EXTI1_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR1_EXTI1                 SYSCFG_EXTICR1_EXTI1_Msk          /*!< EXTI 1 configuration */
N#define SYSCFG_EXTICR1_EXTI2_Pos             (8U)                              
N#define SYSCFG_EXTICR1_EXTI2_Msk             (0xFU << SYSCFG_EXTICR1_EXTI2_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR1_EXTI2                 SYSCFG_EXTICR1_EXTI2_Msk          /*!< EXTI 2 configuration */
N#define SYSCFG_EXTICR1_EXTI3_Pos             (12U)                             
N#define SYSCFG_EXTICR1_EXTI3_Msk             (0xFU << SYSCFG_EXTICR1_EXTI3_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR1_EXTI3                 SYSCFG_EXTICR1_EXTI3_Msk          /*!< EXTI 3 configuration */
N
N/** 
N  * @brief  EXTI0 configuration
N  */
N#define SYSCFG_EXTICR1_EXTI0_PA              (0x00000000U)                     /*!< PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB              (0x00000001U)                     /*!< PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC              (0x00000002U)                     /*!< PC[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PD              (0x00000003U)                     /*!< PD[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PE              (0x00000004U)                     /*!< PE[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PF              (0x00000005U)                     /*!< PF[0] pin */
N
N/** 
N  * @brief  EXTI1 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI1_PA              (0x00000000U)                     /*!< PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB              (0x00000010U)                     /*!< PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC              (0x00000020U)                     /*!< PC[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PD              (0x00000030U)                     /*!< PD[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PE              (0x00000040U)                     /*!< PE[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PF              (0x00000050U)                     /*!< PF[1] pin */
N
N/** 
N  * @brief  EXTI2 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI2_PA              (0x00000000U)                     /*!< PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB              (0x00000100U)                     /*!< PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC              (0x00000200U)                     /*!< PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD              (0x00000300U)                     /*!< PD[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PE              (0x00000400U)                     /*!< PE[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PF              (0x00000500U)                     /*!< PF[2] pin */
N
N/** 
N  * @brief  EXTI3 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI3_PA              (0x00000000U)                     /*!< PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB              (0x00001000U)                     /*!< PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC              (0x00002000U)                     /*!< PC[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PD              (0x00003000U)                     /*!< PD[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PE              (0x00004000U)                     /*!< PE[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PF              (0x00005000U)                     /*!< PF[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  **************/
N#define SYSCFG_EXTICR2_EXTI4_Pos             (0U)                              
N#define SYSCFG_EXTICR2_EXTI4_Msk             (0xFU << SYSCFG_EXTICR2_EXTI4_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR2_EXTI4                 SYSCFG_EXTICR2_EXTI4_Msk          /*!< EXTI 4 configuration */
N#define SYSCFG_EXTICR2_EXTI5_Pos             (4U)                              
N#define SYSCFG_EXTICR2_EXTI5_Msk             (0xFU << SYSCFG_EXTICR2_EXTI5_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR2_EXTI5                 SYSCFG_EXTICR2_EXTI5_Msk          /*!< EXTI 5 configuration */
N#define SYSCFG_EXTICR2_EXTI6_Pos             (8U)                              
N#define SYSCFG_EXTICR2_EXTI6_Msk             (0xFU << SYSCFG_EXTICR2_EXTI6_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR2_EXTI6                 SYSCFG_EXTICR2_EXTI6_Msk          /*!< EXTI 6 configuration */
N#define SYSCFG_EXTICR2_EXTI7_Pos             (12U)                             
N#define SYSCFG_EXTICR2_EXTI7_Msk             (0xFU << SYSCFG_EXTICR2_EXTI7_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR2_EXTI7                 SYSCFG_EXTICR2_EXTI7_Msk          /*!< EXTI 7 configuration */
N
N/** 
N  * @brief  EXTI4 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI4_PA              (0x00000000U)                     /*!< PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB              (0x00000001U)                     /*!< PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC              (0x00000002U)                     /*!< PC[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PD              (0x00000003U)                     /*!< PD[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PE              (0x00000004U)                     /*!< PE[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PF              (0x00000005U)                     /*!< PF[4] pin */
N
N/** 
N  * @brief  EXTI5 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI5_PA              (0x00000000U)                     /*!< PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB              (0x00000010U)                     /*!< PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC              (0x00000020U)                     /*!< PC[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PD              (0x00000030U)                     /*!< PD[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PE              (0x00000040U)                     /*!< PE[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PF              (0x00000050U)                     /*!< PF[5] pin */
N
N/** 
N  * @brief  EXTI6 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI6_PA              (0x00000000U)                     /*!< PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB              (0x00000100U)                     /*!< PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC              (0x00000200U)                     /*!< PC[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PD              (0x00000300U)                     /*!< PD[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PE              (0x00000400U)                     /*!< PE[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PF              (0x00000500U)                     /*!< PF[6] pin */
N
N/** 
N  * @brief  EXTI7 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI7_PA              (0x00000000U)                     /*!< PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB              (0x00001000U)                     /*!< PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC              (0x00002000U)                     /*!< PC[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PD              (0x00003000U)                     /*!< PD[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PE              (0x00004000U)                     /*!< PE[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PF              (0x00005000U)                     /*!< PF[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  **************/
N#define SYSCFG_EXTICR3_EXTI8_Pos             (0U)                              
N#define SYSCFG_EXTICR3_EXTI8_Msk             (0xFU << SYSCFG_EXTICR3_EXTI8_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR3_EXTI8                 SYSCFG_EXTICR3_EXTI8_Msk          /*!< EXTI 8 configuration */
N#define SYSCFG_EXTICR3_EXTI9_Pos             (4U)                              
N#define SYSCFG_EXTICR3_EXTI9_Msk             (0xFU << SYSCFG_EXTICR3_EXTI9_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR3_EXTI9                 SYSCFG_EXTICR3_EXTI9_Msk          /*!< EXTI 9 configuration */
N#define SYSCFG_EXTICR3_EXTI10_Pos            (8U)                              
N#define SYSCFG_EXTICR3_EXTI10_Msk            (0xFU << SYSCFG_EXTICR3_EXTI10_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR3_EXTI10                SYSCFG_EXTICR3_EXTI10_Msk         /*!< EXTI 10 configuration */
N#define SYSCFG_EXTICR3_EXTI11_Pos            (12U)                             
N#define SYSCFG_EXTICR3_EXTI11_Msk            (0xFU << SYSCFG_EXTICR3_EXTI11_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR3_EXTI11                SYSCFG_EXTICR3_EXTI11_Msk         /*!< EXTI 11 configuration */
N
N/** 
N  * @brief  EXTI8 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI8_PA              (0x00000000U)                     /*!< PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB              (0x00000001U)                     /*!< PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC              (0x00000002U)                     /*!< PC[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PD              (0x00000003U)                     /*!< PD[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PE              (0x00000004U)                     /*!< PE[8] pin */
N
N
N/** 
N  * @brief  EXTI9 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI9_PA              (0x00000000U)                     /*!< PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB              (0x00000010U)                     /*!< PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC              (0x00000020U)                     /*!< PC[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PD              (0x00000030U)                     /*!< PD[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PE              (0x00000040U)                     /*!< PE[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PF              (0x00000050U)                     /*!< PF[9] pin */
N
N/** 
N  * @brief  EXTI10 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI10_PA             (0x00000000U)                     /*!< PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB             (0x00000100U)                     /*!< PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC             (0x00000200U)                     /*!< PC[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PD             (0x00000300U)                     /*!< PD[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PE             (0x00000400U)                     /*!< PE[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PF             (0x00000500U)                     /*!< PF[10] pin */
N
N/** 
N  * @brief  EXTI11 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI11_PA             (0x00000000U)                     /*!< PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PB             (0x00001000U)                     /*!< PB[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC             (0x00002000U)                     /*!< PC[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PD             (0x00003000U)                     /*!< PD[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PE             (0x00004000U)                     /*!< PE[11] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  **************/
N#define SYSCFG_EXTICR4_EXTI12_Pos            (0U)                              
N#define SYSCFG_EXTICR4_EXTI12_Msk            (0xFU << SYSCFG_EXTICR4_EXTI12_Pos) /*!< 0x0000000F */
N#define SYSCFG_EXTICR4_EXTI12                SYSCFG_EXTICR4_EXTI12_Msk         /*!< EXTI 12 configuration */
N#define SYSCFG_EXTICR4_EXTI13_Pos            (4U)                              
N#define SYSCFG_EXTICR4_EXTI13_Msk            (0xFU << SYSCFG_EXTICR4_EXTI13_Pos) /*!< 0x000000F0 */
N#define SYSCFG_EXTICR4_EXTI13                SYSCFG_EXTICR4_EXTI13_Msk         /*!< EXTI 13 configuration */
N#define SYSCFG_EXTICR4_EXTI14_Pos            (8U)                              
N#define SYSCFG_EXTICR4_EXTI14_Msk            (0xFU << SYSCFG_EXTICR4_EXTI14_Pos) /*!< 0x00000F00 */
N#define SYSCFG_EXTICR4_EXTI14                SYSCFG_EXTICR4_EXTI14_Msk         /*!< EXTI 14 configuration */
N#define SYSCFG_EXTICR4_EXTI15_Pos            (12U)                             
N#define SYSCFG_EXTICR4_EXTI15_Msk            (0xFU << SYSCFG_EXTICR4_EXTI15_Pos) /*!< 0x0000F000 */
N#define SYSCFG_EXTICR4_EXTI15                SYSCFG_EXTICR4_EXTI15_Msk         /*!< EXTI 15 configuration */
N
N/** 
N  * @brief  EXTI12 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI12_PA             (0x00000000U)                     /*!< PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PB             (0x00000001U)                     /*!< PB[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC             (0x00000002U)                     /*!< PC[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PD             (0x00000003U)                     /*!< PD[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PE             (0x00000004U)                     /*!< PE[12] pin */
N
N/** 
N  * @brief  EXTI13 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI13_PA             (0x00000000U)                     /*!< PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PB             (0x00000010U)                     /*!< PB[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC             (0x00000020U)                     /*!< PC[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PD             (0x00000030U)                     /*!< PD[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PE             (0x00000040U)                     /*!< PE[13] pin */
N
N/** 
N  * @brief  EXTI14 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI14_PA             (0x00000000U)                     /*!< PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB             (0x00000100U)                     /*!< PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC             (0x00000200U)                     /*!< PC[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PD             (0x00000300U)                     /*!< PD[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PE             (0x00000400U)                     /*!< PE[14] pin */
N
N/** 
N  * @brief  EXTI15 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI15_PA             (0x00000000U)                     /*!< PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB             (0x00001000U)                     /*!< PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC             (0x00002000U)                     /*!< PC[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PD             (0x00003000U)                     /*!< PD[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PE             (0x00004000U)                     /*!< PE[15] pin */
N
N/*****************  Bit definition for SYSCFG_CFGR2 register  ****************/
N#define SYSCFG_CFGR2_LOCKUP_LOCK_Pos         (0U)                              
N#define SYSCFG_CFGR2_LOCKUP_LOCK_Msk         (0x1U << SYSCFG_CFGR2_LOCKUP_LOCK_Pos) /*!< 0x00000001 */
N#define SYSCFG_CFGR2_LOCKUP_LOCK             SYSCFG_CFGR2_LOCKUP_LOCK_Msk      /*!< Enables and locks the LOCKUP (Hardfault) output of CortexM0 with Break Input of TIMER1 */
N#define SYSCFG_CFGR2_SRAM_PARITY_LOCK_Pos    (1U)                              
N#define SYSCFG_CFGR2_SRAM_PARITY_LOCK_Msk    (0x1U << SYSCFG_CFGR2_SRAM_PARITY_LOCK_Pos) /*!< 0x00000002 */
N#define SYSCFG_CFGR2_SRAM_PARITY_LOCK        SYSCFG_CFGR2_SRAM_PARITY_LOCK_Msk /*!< Enables and locks the SRAM_PARITY error signal with Break Input of TIMER1 */
N#define SYSCFG_CFGR2_PVD_LOCK_Pos            (2U)                              
N#define SYSCFG_CFGR2_PVD_LOCK_Msk            (0x1U << SYSCFG_CFGR2_PVD_LOCK_Pos) /*!< 0x00000004 */
N#define SYSCFG_CFGR2_PVD_LOCK                SYSCFG_CFGR2_PVD_LOCK_Msk         /*!< Enables and locks the PVD connection with Timer1 Break Input and also the PVD_EN and PVDSEL[2:0] bits of the Power Control Interface */
N#define SYSCFG_CFGR2_SRAM_PEF_Pos            (8U)                              
N#define SYSCFG_CFGR2_SRAM_PEF_Msk            (0x1U << SYSCFG_CFGR2_SRAM_PEF_Pos) /*!< 0x00000100 */
N#define SYSCFG_CFGR2_SRAM_PEF                SYSCFG_CFGR2_SRAM_PEF_Msk         /*!< SRAM Parity error flag */
N#define SYSCFG_CFGR2_SRAM_PE                 SYSCFG_CFGR2_SRAM_PEF  /*!< SRAM Parity error flag (define maintained for legacy purpose) */
N
N/*****************  Bit definition for SYSCFG_xxx ISR Wrapper register  ****************/
N#define SYSCFG_ITLINE0_SR_EWDG_Pos           (0U)                              
N#define SYSCFG_ITLINE0_SR_EWDG_Msk           (0x1U << SYSCFG_ITLINE0_SR_EWDG_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE0_SR_EWDG               SYSCFG_ITLINE0_SR_EWDG_Msk        /*!< EWDG interrupt */
N#define SYSCFG_ITLINE1_SR_PVDOUT_Pos         (0U)                              
N#define SYSCFG_ITLINE1_SR_PVDOUT_Msk         (0x1U << SYSCFG_ITLINE1_SR_PVDOUT_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE1_SR_PVDOUT             SYSCFG_ITLINE1_SR_PVDOUT_Msk      /*!< Power voltage detection -> exti[31] Interrupt */
N#define SYSCFG_ITLINE1_SR_VDDIO2_Pos         (1U)                              
N#define SYSCFG_ITLINE1_SR_VDDIO2_Msk         (0x1U << SYSCFG_ITLINE1_SR_VDDIO2_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE1_SR_VDDIO2             SYSCFG_ITLINE1_SR_VDDIO2_Msk      /*!< VDDIO2 -> exti[16] Interrupt */
N#define SYSCFG_ITLINE2_SR_RTC_ALRA_Pos       (0U)                              
N#define SYSCFG_ITLINE2_SR_RTC_ALRA_Msk       (0x1U << SYSCFG_ITLINE2_SR_RTC_ALRA_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE2_SR_RTC_ALRA           SYSCFG_ITLINE2_SR_RTC_ALRA_Msk    /*!< RTC Alarm -> exti[17] interrupt .... */
N#define SYSCFG_ITLINE2_SR_RTC_TSTAMP_Pos     (1U)                              
N#define SYSCFG_ITLINE2_SR_RTC_TSTAMP_Msk     (0x1U << SYSCFG_ITLINE2_SR_RTC_TSTAMP_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE2_SR_RTC_TSTAMP         SYSCFG_ITLINE2_SR_RTC_TSTAMP_Msk  /*!< RTC Time Stamp -> exti[19] interrupt */
N#define SYSCFG_ITLINE2_SR_RTC_WAKEUP_Pos     (2U)                              
N#define SYSCFG_ITLINE2_SR_RTC_WAKEUP_Msk     (0x1U << SYSCFG_ITLINE2_SR_RTC_WAKEUP_Pos) /*!< 0x00000004 */
N#define SYSCFG_ITLINE2_SR_RTC_WAKEUP         SYSCFG_ITLINE2_SR_RTC_WAKEUP_Msk  /*!< RTC WAKEUP -> exti[20] Interrupt */
N#define SYSCFG_ITLINE3_SR_FLASH_ITF_Pos      (0U)                              
N#define SYSCFG_ITLINE3_SR_FLASH_ITF_Msk      (0x1U << SYSCFG_ITLINE3_SR_FLASH_ITF_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE3_SR_FLASH_ITF          SYSCFG_ITLINE3_SR_FLASH_ITF_Msk   /*!< Flash ITF Interrupt */
N#define SYSCFG_ITLINE4_SR_CRS_Pos            (0U)                              
N#define SYSCFG_ITLINE4_SR_CRS_Msk            (0x1U << SYSCFG_ITLINE4_SR_CRS_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE4_SR_CRS                SYSCFG_ITLINE4_SR_CRS_Msk         /*!< CRS interrupt */
N#define SYSCFG_ITLINE4_SR_CLK_CTRL_Pos       (1U)                              
N#define SYSCFG_ITLINE4_SR_CLK_CTRL_Msk       (0x1U << SYSCFG_ITLINE4_SR_CLK_CTRL_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE4_SR_CLK_CTRL           SYSCFG_ITLINE4_SR_CLK_CTRL_Msk    /*!< CLK CTRL interrupt */
N#define SYSCFG_ITLINE5_SR_EXTI0_Pos          (0U)                              
N#define SYSCFG_ITLINE5_SR_EXTI0_Msk          (0x1U << SYSCFG_ITLINE5_SR_EXTI0_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE5_SR_EXTI0              SYSCFG_ITLINE5_SR_EXTI0_Msk       /*!< External Interrupt 0 */
N#define SYSCFG_ITLINE5_SR_EXTI1_Pos          (1U)                              
N#define SYSCFG_ITLINE5_SR_EXTI1_Msk          (0x1U << SYSCFG_ITLINE5_SR_EXTI1_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE5_SR_EXTI1              SYSCFG_ITLINE5_SR_EXTI1_Msk       /*!< External Interrupt 1 */
N#define SYSCFG_ITLINE6_SR_EXTI2_Pos          (0U)                              
N#define SYSCFG_ITLINE6_SR_EXTI2_Msk          (0x1U << SYSCFG_ITLINE6_SR_EXTI2_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE6_SR_EXTI2              SYSCFG_ITLINE6_SR_EXTI2_Msk       /*!< External Interrupt 2 */
N#define SYSCFG_ITLINE6_SR_EXTI3_Pos          (1U)                              
N#define SYSCFG_ITLINE6_SR_EXTI3_Msk          (0x1U << SYSCFG_ITLINE6_SR_EXTI3_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE6_SR_EXTI3              SYSCFG_ITLINE6_SR_EXTI3_Msk       /*!< External Interrupt 3 */
N#define SYSCFG_ITLINE7_SR_EXTI4_Pos          (0U)                              
N#define SYSCFG_ITLINE7_SR_EXTI4_Msk          (0x1U << SYSCFG_ITLINE7_SR_EXTI4_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE7_SR_EXTI4              SYSCFG_ITLINE7_SR_EXTI4_Msk       /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI5_Pos          (1U)                              
N#define SYSCFG_ITLINE7_SR_EXTI5_Msk          (0x1U << SYSCFG_ITLINE7_SR_EXTI5_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE7_SR_EXTI5              SYSCFG_ITLINE7_SR_EXTI5_Msk       /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI6_Pos          (2U)                              
N#define SYSCFG_ITLINE7_SR_EXTI6_Msk          (0x1U << SYSCFG_ITLINE7_SR_EXTI6_Pos) /*!< 0x00000004 */
N#define SYSCFG_ITLINE7_SR_EXTI6              SYSCFG_ITLINE7_SR_EXTI6_Msk       /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI7_Pos          (3U)                              
N#define SYSCFG_ITLINE7_SR_EXTI7_Msk          (0x1U << SYSCFG_ITLINE7_SR_EXTI7_Pos) /*!< 0x00000008 */
N#define SYSCFG_ITLINE7_SR_EXTI7              SYSCFG_ITLINE7_SR_EXTI7_Msk       /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI8_Pos          (4U)                              
N#define SYSCFG_ITLINE7_SR_EXTI8_Msk          (0x1U << SYSCFG_ITLINE7_SR_EXTI8_Pos) /*!< 0x00000010 */
N#define SYSCFG_ITLINE7_SR_EXTI8              SYSCFG_ITLINE7_SR_EXTI8_Msk       /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI9_Pos          (5U)                              
N#define SYSCFG_ITLINE7_SR_EXTI9_Msk          (0x1U << SYSCFG_ITLINE7_SR_EXTI9_Pos) /*!< 0x00000020 */
N#define SYSCFG_ITLINE7_SR_EXTI9              SYSCFG_ITLINE7_SR_EXTI9_Msk       /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI10_Pos         (6U)                              
N#define SYSCFG_ITLINE7_SR_EXTI10_Msk         (0x1U << SYSCFG_ITLINE7_SR_EXTI10_Pos) /*!< 0x00000040 */
N#define SYSCFG_ITLINE7_SR_EXTI10             SYSCFG_ITLINE7_SR_EXTI10_Msk      /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI11_Pos         (7U)                              
N#define SYSCFG_ITLINE7_SR_EXTI11_Msk         (0x1U << SYSCFG_ITLINE7_SR_EXTI11_Pos) /*!< 0x00000080 */
N#define SYSCFG_ITLINE7_SR_EXTI11             SYSCFG_ITLINE7_SR_EXTI11_Msk      /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI12_Pos         (8U)                              
N#define SYSCFG_ITLINE7_SR_EXTI12_Msk         (0x1U << SYSCFG_ITLINE7_SR_EXTI12_Pos) /*!< 0x00000100 */
N#define SYSCFG_ITLINE7_SR_EXTI12             SYSCFG_ITLINE7_SR_EXTI12_Msk      /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI13_Pos         (9U)                              
N#define SYSCFG_ITLINE7_SR_EXTI13_Msk         (0x1U << SYSCFG_ITLINE7_SR_EXTI13_Pos) /*!< 0x00000200 */
N#define SYSCFG_ITLINE7_SR_EXTI13             SYSCFG_ITLINE7_SR_EXTI13_Msk      /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI14_Pos         (10U)                             
N#define SYSCFG_ITLINE7_SR_EXTI14_Msk         (0x1U << SYSCFG_ITLINE7_SR_EXTI14_Pos) /*!< 0x00000400 */
N#define SYSCFG_ITLINE7_SR_EXTI14             SYSCFG_ITLINE7_SR_EXTI14_Msk      /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE7_SR_EXTI15_Pos         (11U)                             
N#define SYSCFG_ITLINE7_SR_EXTI15_Msk         (0x1U << SYSCFG_ITLINE7_SR_EXTI15_Pos) /*!< 0x00000800 */
N#define SYSCFG_ITLINE7_SR_EXTI15             SYSCFG_ITLINE7_SR_EXTI15_Msk      /*!< External Interrupt 15 to 4 */
N#define SYSCFG_ITLINE8_SR_TSC_EOA_Pos        (0U)                              
N#define SYSCFG_ITLINE8_SR_TSC_EOA_Msk        (0x1U << SYSCFG_ITLINE8_SR_TSC_EOA_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE8_SR_TSC_EOA            SYSCFG_ITLINE8_SR_TSC_EOA_Msk     /*!< Touch control EOA Interrupt */
N#define SYSCFG_ITLINE8_SR_TSC_MCE_Pos        (1U)                              
N#define SYSCFG_ITLINE8_SR_TSC_MCE_Msk        (0x1U << SYSCFG_ITLINE8_SR_TSC_MCE_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE8_SR_TSC_MCE            SYSCFG_ITLINE8_SR_TSC_MCE_Msk     /*!< Touch control MCE Interrupt */
N#define SYSCFG_ITLINE9_SR_DMA1_CH1_Pos       (0U)                              
N#define SYSCFG_ITLINE9_SR_DMA1_CH1_Msk       (0x1U << SYSCFG_ITLINE9_SR_DMA1_CH1_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE9_SR_DMA1_CH1           SYSCFG_ITLINE9_SR_DMA1_CH1_Msk    /*!< DMA1 Channel 1 Interrupt */
N#define SYSCFG_ITLINE10_SR_DMA1_CH2_Pos      (0U)                              
N#define SYSCFG_ITLINE10_SR_DMA1_CH2_Msk      (0x1U << SYSCFG_ITLINE10_SR_DMA1_CH2_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE10_SR_DMA1_CH2          SYSCFG_ITLINE10_SR_DMA1_CH2_Msk   /*!< DMA1 Channel 2 Interrupt */
N#define SYSCFG_ITLINE10_SR_DMA1_CH3_Pos      (1U)                              
N#define SYSCFG_ITLINE10_SR_DMA1_CH3_Msk      (0x1U << SYSCFG_ITLINE10_SR_DMA1_CH3_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE10_SR_DMA1_CH3          SYSCFG_ITLINE10_SR_DMA1_CH3_Msk   /*!< DMA2 Channel 3 Interrupt */
N#define SYSCFG_ITLINE10_SR_DMA2_CH1_Pos      (2U)                              
N#define SYSCFG_ITLINE10_SR_DMA2_CH1_Msk      (0x1U << SYSCFG_ITLINE10_SR_DMA2_CH1_Pos) /*!< 0x00000004 */
N#define SYSCFG_ITLINE10_SR_DMA2_CH1          SYSCFG_ITLINE10_SR_DMA2_CH1_Msk   /*!< DMA2 Channel 1 Interrupt */
N#define SYSCFG_ITLINE10_SR_DMA2_CH2_Pos      (3U)                              
N#define SYSCFG_ITLINE10_SR_DMA2_CH2_Msk      (0x1U << SYSCFG_ITLINE10_SR_DMA2_CH2_Pos) /*!< 0x00000008 */
N#define SYSCFG_ITLINE10_SR_DMA2_CH2          SYSCFG_ITLINE10_SR_DMA2_CH2_Msk   /*!< DMA2 Channel 2 Interrupt */
N#define SYSCFG_ITLINE11_SR_DMA1_CH4_Pos      (0U)                              
N#define SYSCFG_ITLINE11_SR_DMA1_CH4_Msk      (0x1U << SYSCFG_ITLINE11_SR_DMA1_CH4_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE11_SR_DMA1_CH4          SYSCFG_ITLINE11_SR_DMA1_CH4_Msk   /*!< DMA1 Channel 4 Interrupt */
N#define SYSCFG_ITLINE11_SR_DMA1_CH5_Pos      (1U)                              
N#define SYSCFG_ITLINE11_SR_DMA1_CH5_Msk      (0x1U << SYSCFG_ITLINE11_SR_DMA1_CH5_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE11_SR_DMA1_CH5          SYSCFG_ITLINE11_SR_DMA1_CH5_Msk   /*!< DMA1 Channel 5 Interrupt */
N#define SYSCFG_ITLINE11_SR_DMA1_CH6_Pos      (2U)                              
N#define SYSCFG_ITLINE11_SR_DMA1_CH6_Msk      (0x1U << SYSCFG_ITLINE11_SR_DMA1_CH6_Pos) /*!< 0x00000004 */
N#define SYSCFG_ITLINE11_SR_DMA1_CH6          SYSCFG_ITLINE11_SR_DMA1_CH6_Msk   /*!< DMA1 Channel 6 Interrupt */
N#define SYSCFG_ITLINE11_SR_DMA1_CH7_Pos      (3U)                              
N#define SYSCFG_ITLINE11_SR_DMA1_CH7_Msk      (0x1U << SYSCFG_ITLINE11_SR_DMA1_CH7_Pos) /*!< 0x00000008 */
N#define SYSCFG_ITLINE11_SR_DMA1_CH7          SYSCFG_ITLINE11_SR_DMA1_CH7_Msk   /*!< DMA1 Channel 7 Interrupt */
N#define SYSCFG_ITLINE11_SR_DMA2_CH3_Pos      (4U)                              
N#define SYSCFG_ITLINE11_SR_DMA2_CH3_Msk      (0x1U << SYSCFG_ITLINE11_SR_DMA2_CH3_Pos) /*!< 0x00000010 */
N#define SYSCFG_ITLINE11_SR_DMA2_CH3          SYSCFG_ITLINE11_SR_DMA2_CH3_Msk   /*!< DMA2 Channel 3 Interrupt */
N#define SYSCFG_ITLINE11_SR_DMA2_CH4_Pos      (5U)                              
N#define SYSCFG_ITLINE11_SR_DMA2_CH4_Msk      (0x1U << SYSCFG_ITLINE11_SR_DMA2_CH4_Pos) /*!< 0x00000020 */
N#define SYSCFG_ITLINE11_SR_DMA2_CH4          SYSCFG_ITLINE11_SR_DMA2_CH4_Msk   /*!< DMA2 Channel 4 Interrupt */
N#define SYSCFG_ITLINE11_SR_DMA2_CH5_Pos      (6U)                              
N#define SYSCFG_ITLINE11_SR_DMA2_CH5_Msk      (0x1U << SYSCFG_ITLINE11_SR_DMA2_CH5_Pos) /*!< 0x00000040 */
N#define SYSCFG_ITLINE11_SR_DMA2_CH5          SYSCFG_ITLINE11_SR_DMA2_CH5_Msk   /*!< DMA2 Channel 5 Interrupt */
N#define SYSCFG_ITLINE12_SR_ADC_Pos           (0U)                              
N#define SYSCFG_ITLINE12_SR_ADC_Msk           (0x1U << SYSCFG_ITLINE12_SR_ADC_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE12_SR_ADC               SYSCFG_ITLINE12_SR_ADC_Msk        /*!< ADC Interrupt */
N#define SYSCFG_ITLINE12_SR_COMP1_Pos         (1U)                              
N#define SYSCFG_ITLINE12_SR_COMP1_Msk         (0x1U << SYSCFG_ITLINE12_SR_COMP1_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE12_SR_COMP1             SYSCFG_ITLINE12_SR_COMP1_Msk      /*!< COMP1 Interrupt -> exti[21] */
N#define SYSCFG_ITLINE12_SR_COMP2_Pos         (2U)                              
N#define SYSCFG_ITLINE12_SR_COMP2_Msk         (0x1U << SYSCFG_ITLINE12_SR_COMP2_Pos) /*!< 0x00000004 */
N#define SYSCFG_ITLINE12_SR_COMP2             SYSCFG_ITLINE12_SR_COMP2_Msk      /*!< COMP2 Interrupt -> exti[22] */
N#define SYSCFG_ITLINE13_SR_TIM1_BRK_Pos      (0U)                              
N#define SYSCFG_ITLINE13_SR_TIM1_BRK_Msk      (0x1U << SYSCFG_ITLINE13_SR_TIM1_BRK_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE13_SR_TIM1_BRK          SYSCFG_ITLINE13_SR_TIM1_BRK_Msk   /*!< TIM1 BRK Interrupt */
N#define SYSCFG_ITLINE13_SR_TIM1_UPD_Pos      (1U)                              
N#define SYSCFG_ITLINE13_SR_TIM1_UPD_Msk      (0x1U << SYSCFG_ITLINE13_SR_TIM1_UPD_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE13_SR_TIM1_UPD          SYSCFG_ITLINE13_SR_TIM1_UPD_Msk   /*!< TIM1 UPD Interrupt */
N#define SYSCFG_ITLINE13_SR_TIM1_TRG_Pos      (2U)                              
N#define SYSCFG_ITLINE13_SR_TIM1_TRG_Msk      (0x1U << SYSCFG_ITLINE13_SR_TIM1_TRG_Pos) /*!< 0x00000004 */
N#define SYSCFG_ITLINE13_SR_TIM1_TRG          SYSCFG_ITLINE13_SR_TIM1_TRG_Msk   /*!< TIM1 TRG Interrupt */
N#define SYSCFG_ITLINE13_SR_TIM1_CCU_Pos      (3U)                              
N#define SYSCFG_ITLINE13_SR_TIM1_CCU_Msk      (0x1U << SYSCFG_ITLINE13_SR_TIM1_CCU_Pos) /*!< 0x00000008 */
N#define SYSCFG_ITLINE13_SR_TIM1_CCU          SYSCFG_ITLINE13_SR_TIM1_CCU_Msk   /*!< TIM1 CCU Interrupt */
N#define SYSCFG_ITLINE14_SR_TIM1_CC_Pos       (0U)                              
N#define SYSCFG_ITLINE14_SR_TIM1_CC_Msk       (0x1U << SYSCFG_ITLINE14_SR_TIM1_CC_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE14_SR_TIM1_CC           SYSCFG_ITLINE14_SR_TIM1_CC_Msk    /*!< TIM1 CC Interrupt */
N#define SYSCFG_ITLINE15_SR_TIM2_GLB_Pos      (0U)                              
N#define SYSCFG_ITLINE15_SR_TIM2_GLB_Msk      (0x1U << SYSCFG_ITLINE15_SR_TIM2_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE15_SR_TIM2_GLB          SYSCFG_ITLINE15_SR_TIM2_GLB_Msk   /*!< TIM2 GLB Interrupt */
N#define SYSCFG_ITLINE16_SR_TIM3_GLB_Pos      (0U)                              
N#define SYSCFG_ITLINE16_SR_TIM3_GLB_Msk      (0x1U << SYSCFG_ITLINE16_SR_TIM3_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE16_SR_TIM3_GLB          SYSCFG_ITLINE16_SR_TIM3_GLB_Msk   /*!< TIM3 GLB Interrupt */
N#define SYSCFG_ITLINE17_SR_DAC_Pos           (0U)                              
N#define SYSCFG_ITLINE17_SR_DAC_Msk           (0x1U << SYSCFG_ITLINE17_SR_DAC_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE17_SR_DAC               SYSCFG_ITLINE17_SR_DAC_Msk        /*!< DAC Interrupt */
N#define SYSCFG_ITLINE17_SR_TIM6_GLB_Pos      (1U)                              
N#define SYSCFG_ITLINE17_SR_TIM6_GLB_Msk      (0x1U << SYSCFG_ITLINE17_SR_TIM6_GLB_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE17_SR_TIM6_GLB          SYSCFG_ITLINE17_SR_TIM6_GLB_Msk   /*!< TIM6 GLB Interrupt */
N#define SYSCFG_ITLINE18_SR_TIM7_GLB_Pos      (0U)                              
N#define SYSCFG_ITLINE18_SR_TIM7_GLB_Msk      (0x1U << SYSCFG_ITLINE18_SR_TIM7_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE18_SR_TIM7_GLB          SYSCFG_ITLINE18_SR_TIM7_GLB_Msk   /*!< TIM7 GLB Interrupt */
N#define SYSCFG_ITLINE19_SR_TIM14_GLB_Pos     (0U)                              
N#define SYSCFG_ITLINE19_SR_TIM14_GLB_Msk     (0x1U << SYSCFG_ITLINE19_SR_TIM14_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE19_SR_TIM14_GLB         SYSCFG_ITLINE19_SR_TIM14_GLB_Msk  /*!< TIM14 GLB Interrupt */
N#define SYSCFG_ITLINE20_SR_TIM15_GLB_Pos     (0U)                              
N#define SYSCFG_ITLINE20_SR_TIM15_GLB_Msk     (0x1U << SYSCFG_ITLINE20_SR_TIM15_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE20_SR_TIM15_GLB         SYSCFG_ITLINE20_SR_TIM15_GLB_Msk  /*!< TIM15 GLB Interrupt */
N#define SYSCFG_ITLINE21_SR_TIM16_GLB_Pos     (0U)                              
N#define SYSCFG_ITLINE21_SR_TIM16_GLB_Msk     (0x1U << SYSCFG_ITLINE21_SR_TIM16_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE21_SR_TIM16_GLB         SYSCFG_ITLINE21_SR_TIM16_GLB_Msk  /*!< TIM16 GLB Interrupt */
N#define SYSCFG_ITLINE22_SR_TIM17_GLB_Pos     (0U)                              
N#define SYSCFG_ITLINE22_SR_TIM17_GLB_Msk     (0x1U << SYSCFG_ITLINE22_SR_TIM17_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE22_SR_TIM17_GLB         SYSCFG_ITLINE22_SR_TIM17_GLB_Msk  /*!< TIM17 GLB Interrupt */
N#define SYSCFG_ITLINE23_SR_I2C1_GLB_Pos      (0U)                              
N#define SYSCFG_ITLINE23_SR_I2C1_GLB_Msk      (0x1U << SYSCFG_ITLINE23_SR_I2C1_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE23_SR_I2C1_GLB          SYSCFG_ITLINE23_SR_I2C1_GLB_Msk   /*!< I2C1 GLB Interrupt -> exti[23] */
N#define SYSCFG_ITLINE24_SR_I2C2_GLB_Pos      (0U)                              
N#define SYSCFG_ITLINE24_SR_I2C2_GLB_Msk      (0x1U << SYSCFG_ITLINE24_SR_I2C2_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE24_SR_I2C2_GLB          SYSCFG_ITLINE24_SR_I2C2_GLB_Msk   /*!< I2C2 GLB Interrupt */
N#define SYSCFG_ITLINE25_SR_SPI1_Pos          (0U)                              
N#define SYSCFG_ITLINE25_SR_SPI1_Msk          (0x1U << SYSCFG_ITLINE25_SR_SPI1_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE25_SR_SPI1              SYSCFG_ITLINE25_SR_SPI1_Msk       /*!< SPI1 Interrupt */
N#define SYSCFG_ITLINE26_SR_SPI2_Pos          (0U)                              
N#define SYSCFG_ITLINE26_SR_SPI2_Msk          (0x1U << SYSCFG_ITLINE26_SR_SPI2_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE26_SR_SPI2              SYSCFG_ITLINE26_SR_SPI2_Msk       /*!< SPI2  Interrupt */
N#define SYSCFG_ITLINE27_SR_USART1_GLB_Pos    (0U)                              
N#define SYSCFG_ITLINE27_SR_USART1_GLB_Msk    (0x1U << SYSCFG_ITLINE27_SR_USART1_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE27_SR_USART1_GLB        SYSCFG_ITLINE27_SR_USART1_GLB_Msk /*!< USART1 GLB Interrupt -> exti[25] */
N#define SYSCFG_ITLINE28_SR_USART2_GLB_Pos    (0U)                              
N#define SYSCFG_ITLINE28_SR_USART2_GLB_Msk    (0x1U << SYSCFG_ITLINE28_SR_USART2_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE28_SR_USART2_GLB        SYSCFG_ITLINE28_SR_USART2_GLB_Msk /*!< USART2 GLB Interrupt -> exti[26] */
N#define SYSCFG_ITLINE29_SR_USART3_GLB_Pos    (0U)                              
N#define SYSCFG_ITLINE29_SR_USART3_GLB_Msk    (0x1U << SYSCFG_ITLINE29_SR_USART3_GLB_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE29_SR_USART3_GLB        SYSCFG_ITLINE29_SR_USART3_GLB_Msk /*!< USART3 GLB Interrupt -> exti[28] */
N#define SYSCFG_ITLINE29_SR_USART4_GLB_Pos    (1U)                              
N#define SYSCFG_ITLINE29_SR_USART4_GLB_Msk    (0x1U << SYSCFG_ITLINE29_SR_USART4_GLB_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE29_SR_USART4_GLB        SYSCFG_ITLINE29_SR_USART4_GLB_Msk /*!< USART4 GLB Interrupt */
N#define SYSCFG_ITLINE29_SR_USART5_GLB_Pos    (2U)                              
N#define SYSCFG_ITLINE29_SR_USART5_GLB_Msk    (0x1U << SYSCFG_ITLINE29_SR_USART5_GLB_Pos) /*!< 0x00000004 */
N#define SYSCFG_ITLINE29_SR_USART5_GLB        SYSCFG_ITLINE29_SR_USART5_GLB_Msk /*!< USART5 GLB Interrupt */
N#define SYSCFG_ITLINE29_SR_USART6_GLB_Pos    (3U)                              
N#define SYSCFG_ITLINE29_SR_USART6_GLB_Msk    (0x1U << SYSCFG_ITLINE29_SR_USART6_GLB_Pos) /*!< 0x00000008 */
N#define SYSCFG_ITLINE29_SR_USART6_GLB        SYSCFG_ITLINE29_SR_USART6_GLB_Msk /*!< USART6 GLB Interrupt */
N#define SYSCFG_ITLINE29_SR_USART7_GLB_Pos    (4U)                              
N#define SYSCFG_ITLINE29_SR_USART7_GLB_Msk    (0x1U << SYSCFG_ITLINE29_SR_USART7_GLB_Pos) /*!< 0x00000010 */
N#define SYSCFG_ITLINE29_SR_USART7_GLB        SYSCFG_ITLINE29_SR_USART7_GLB_Msk /*!< USART7 GLB Interrupt */
N#define SYSCFG_ITLINE29_SR_USART8_GLB_Pos    (5U)                              
N#define SYSCFG_ITLINE29_SR_USART8_GLB_Msk    (0x1U << SYSCFG_ITLINE29_SR_USART8_GLB_Pos) /*!< 0x00000020 */
N#define SYSCFG_ITLINE29_SR_USART8_GLB        SYSCFG_ITLINE29_SR_USART8_GLB_Msk /*!< USART8 GLB Interrupt */
N#define SYSCFG_ITLINE30_SR_CAN_Pos           (0U)                              
N#define SYSCFG_ITLINE30_SR_CAN_Msk           (0x1U << SYSCFG_ITLINE30_SR_CAN_Pos) /*!< 0x00000001 */
N#define SYSCFG_ITLINE30_SR_CAN               SYSCFG_ITLINE30_SR_CAN_Msk        /*!< CAN Interrupt */
N#define SYSCFG_ITLINE30_SR_CEC_Pos           (1U)                              
N#define SYSCFG_ITLINE30_SR_CEC_Msk           (0x1U << SYSCFG_ITLINE30_SR_CEC_Pos) /*!< 0x00000002 */
N#define SYSCFG_ITLINE30_SR_CEC               SYSCFG_ITLINE30_SR_CEC_Msk        /*!< CEC Interrupt */
N  
N/*****************************************************************************/
N/*                                                                           */
N/*                               Timers (TIM)                                */
N/*                                                                           */
N/*****************************************************************************/
N/*******************  Bit definition for TIM_CR1 register  *******************/
N#define TIM_CR1_CEN_Pos           (0U)                                         
N#define TIM_CR1_CEN_Msk           (0x1U << TIM_CR1_CEN_Pos)                    /*!< 0x00000001 */
N#define TIM_CR1_CEN               TIM_CR1_CEN_Msk                              /*!<Counter enable */
N#define TIM_CR1_UDIS_Pos          (1U)                                         
N#define TIM_CR1_UDIS_Msk          (0x1U << TIM_CR1_UDIS_Pos)                   /*!< 0x00000002 */
N#define TIM_CR1_UDIS              TIM_CR1_UDIS_Msk                             /*!<Update disable */
N#define TIM_CR1_URS_Pos           (2U)                                         
N#define TIM_CR1_URS_Msk           (0x1U << TIM_CR1_URS_Pos)                    /*!< 0x00000004 */
N#define TIM_CR1_URS               TIM_CR1_URS_Msk                              /*!<Update request source */
N#define TIM_CR1_OPM_Pos           (3U)                                         
N#define TIM_CR1_OPM_Msk           (0x1U << TIM_CR1_OPM_Pos)                    /*!< 0x00000008 */
N#define TIM_CR1_OPM               TIM_CR1_OPM_Msk                              /*!<One pulse mode */
N#define TIM_CR1_DIR_Pos           (4U)                                         
N#define TIM_CR1_DIR_Msk           (0x1U << TIM_CR1_DIR_Pos)                    /*!< 0x00000010 */
N#define TIM_CR1_DIR               TIM_CR1_DIR_Msk                              /*!<Direction */
N
N#define TIM_CR1_CMS_Pos           (5U)                                         
N#define TIM_CR1_CMS_Msk           (0x3U << TIM_CR1_CMS_Pos)                    /*!< 0x00000060 */
N#define TIM_CR1_CMS               TIM_CR1_CMS_Msk                              /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define TIM_CR1_CMS_0             (0x1U << TIM_CR1_CMS_Pos)                    /*!< 0x00000020 */
N#define TIM_CR1_CMS_1             (0x2U << TIM_CR1_CMS_Pos)                    /*!< 0x00000040 */
N
N#define TIM_CR1_ARPE_Pos          (7U)                                         
N#define TIM_CR1_ARPE_Msk          (0x1U << TIM_CR1_ARPE_Pos)                   /*!< 0x00000080 */
N#define TIM_CR1_ARPE              TIM_CR1_ARPE_Msk                             /*!<Auto-reload preload enable */
N
N#define TIM_CR1_CKD_Pos           (8U)                                         
N#define TIM_CR1_CKD_Msk           (0x3U << TIM_CR1_CKD_Pos)                    /*!< 0x00000300 */
N#define TIM_CR1_CKD               TIM_CR1_CKD_Msk                              /*!<CKD[1:0] bits (clock division) */
N#define TIM_CR1_CKD_0             (0x1U << TIM_CR1_CKD_Pos)                    /*!< 0x00000100 */
N#define TIM_CR1_CKD_1             (0x2U << TIM_CR1_CKD_Pos)                    /*!< 0x00000200 */
N
N/*******************  Bit definition for TIM_CR2 register  *******************/
N#define TIM_CR2_CCPC_Pos          (0U)                                         
N#define TIM_CR2_CCPC_Msk          (0x1U << TIM_CR2_CCPC_Pos)                   /*!< 0x00000001 */
N#define TIM_CR2_CCPC              TIM_CR2_CCPC_Msk                             /*!<Capture/Compare Preloaded Control */
N#define TIM_CR2_CCUS_Pos          (2U)                                         
N#define TIM_CR2_CCUS_Msk          (0x1U << TIM_CR2_CCUS_Pos)                   /*!< 0x00000004 */
N#define TIM_CR2_CCUS              TIM_CR2_CCUS_Msk                             /*!<Capture/Compare Control Update Selection */
N#define TIM_CR2_CCDS_Pos          (3U)                                         
N#define TIM_CR2_CCDS_Msk          (0x1U << TIM_CR2_CCDS_Pos)                   /*!< 0x00000008 */
N#define TIM_CR2_CCDS              TIM_CR2_CCDS_Msk                             /*!<Capture/Compare DMA Selection */
N
N#define TIM_CR2_MMS_Pos           (4U)                                         
N#define TIM_CR2_MMS_Msk           (0x7U << TIM_CR2_MMS_Pos)                    /*!< 0x00000070 */
N#define TIM_CR2_MMS               TIM_CR2_MMS_Msk                              /*!<MMS[2:0] bits (Master Mode Selection) */
N#define TIM_CR2_MMS_0             (0x1U << TIM_CR2_MMS_Pos)                    /*!< 0x00000010 */
N#define TIM_CR2_MMS_1             (0x2U << TIM_CR2_MMS_Pos)                    /*!< 0x00000020 */
N#define TIM_CR2_MMS_2             (0x4U << TIM_CR2_MMS_Pos)                    /*!< 0x00000040 */
N
N#define TIM_CR2_TI1S_Pos          (7U)                                         
N#define TIM_CR2_TI1S_Msk          (0x1U << TIM_CR2_TI1S_Pos)                   /*!< 0x00000080 */
N#define TIM_CR2_TI1S              TIM_CR2_TI1S_Msk                             /*!<TI1 Selection */
N#define TIM_CR2_OIS1_Pos          (8U)                                         
N#define TIM_CR2_OIS1_Msk          (0x1U << TIM_CR2_OIS1_Pos)                   /*!< 0x00000100 */
N#define TIM_CR2_OIS1              TIM_CR2_OIS1_Msk                             /*!<Output Idle state 1 (OC1 output) */
N#define TIM_CR2_OIS1N_Pos         (9U)                                         
N#define TIM_CR2_OIS1N_Msk         (0x1U << TIM_CR2_OIS1N_Pos)                  /*!< 0x00000200 */
N#define TIM_CR2_OIS1N             TIM_CR2_OIS1N_Msk                            /*!<Output Idle state 1 (OC1N output) */
N#define TIM_CR2_OIS2_Pos          (10U)                                        
N#define TIM_CR2_OIS2_Msk          (0x1U << TIM_CR2_OIS2_Pos)                   /*!< 0x00000400 */
N#define TIM_CR2_OIS2              TIM_CR2_OIS2_Msk                             /*!<Output Idle state 2 (OC2 output) */
N#define TIM_CR2_OIS2N_Pos         (11U)                                        
N#define TIM_CR2_OIS2N_Msk         (0x1U << TIM_CR2_OIS2N_Pos)                  /*!< 0x00000800 */
N#define TIM_CR2_OIS2N             TIM_CR2_OIS2N_Msk                            /*!<Output Idle state 2 (OC2N output) */
N#define TIM_CR2_OIS3_Pos          (12U)                                        
N#define TIM_CR2_OIS3_Msk          (0x1U << TIM_CR2_OIS3_Pos)                   /*!< 0x00001000 */
N#define TIM_CR2_OIS3              TIM_CR2_OIS3_Msk                             /*!<Output Idle state 3 (OC3 output) */
N#define TIM_CR2_OIS3N_Pos         (13U)                                        
N#define TIM_CR2_OIS3N_Msk         (0x1U << TIM_CR2_OIS3N_Pos)                  /*!< 0x00002000 */
N#define TIM_CR2_OIS3N             TIM_CR2_OIS3N_Msk                            /*!<Output Idle state 3 (OC3N output) */
N#define TIM_CR2_OIS4_Pos          (14U)                                        
N#define TIM_CR2_OIS4_Msk          (0x1U << TIM_CR2_OIS4_Pos)                   /*!< 0x00004000 */
N#define TIM_CR2_OIS4              TIM_CR2_OIS4_Msk                             /*!<Output Idle state 4 (OC4 output) */
N
N/*******************  Bit definition for TIM_SMCR register  ******************/
N#define TIM_SMCR_SMS_Pos          (0U)                                         
N#define TIM_SMCR_SMS_Msk          (0x7U << TIM_SMCR_SMS_Pos)                   /*!< 0x00000007 */
N#define TIM_SMCR_SMS              TIM_SMCR_SMS_Msk                             /*!<SMS[2:0] bits (Slave mode selection) */
N#define TIM_SMCR_SMS_0            (0x1U << TIM_SMCR_SMS_Pos)                   /*!< 0x00000001 */
N#define TIM_SMCR_SMS_1            (0x2U << TIM_SMCR_SMS_Pos)                   /*!< 0x00000002 */
N#define TIM_SMCR_SMS_2            (0x4U << TIM_SMCR_SMS_Pos)                   /*!< 0x00000004 */
N
N#define TIM_SMCR_OCCS_Pos         (3U)                                         
N#define TIM_SMCR_OCCS_Msk         (0x1U << TIM_SMCR_OCCS_Pos)                  /*!< 0x00000008 */
N#define TIM_SMCR_OCCS             TIM_SMCR_OCCS_Msk                            /*!< OCREF clear selection */
N
N#define TIM_SMCR_TS_Pos           (4U)                                         
N#define TIM_SMCR_TS_Msk           (0x7U << TIM_SMCR_TS_Pos)                    /*!< 0x00000070 */
N#define TIM_SMCR_TS               TIM_SMCR_TS_Msk                              /*!<TS[2:0] bits (Trigger selection) */
N#define TIM_SMCR_TS_0             (0x1U << TIM_SMCR_TS_Pos)                    /*!< 0x00000010 */
N#define TIM_SMCR_TS_1             (0x2U << TIM_SMCR_TS_Pos)                    /*!< 0x00000020 */
N#define TIM_SMCR_TS_2             (0x4U << TIM_SMCR_TS_Pos)                    /*!< 0x00000040 */
N
N#define TIM_SMCR_MSM_Pos          (7U)                                         
N#define TIM_SMCR_MSM_Msk          (0x1U << TIM_SMCR_MSM_Pos)                   /*!< 0x00000080 */
N#define TIM_SMCR_MSM              TIM_SMCR_MSM_Msk                             /*!<Master/slave mode */
N
N#define TIM_SMCR_ETF_Pos          (8U)                                         
N#define TIM_SMCR_ETF_Msk          (0xFU << TIM_SMCR_ETF_Pos)                   /*!< 0x00000F00 */
N#define TIM_SMCR_ETF              TIM_SMCR_ETF_Msk                             /*!<ETF[3:0] bits (External trigger filter) */
N#define TIM_SMCR_ETF_0            (0x1U << TIM_SMCR_ETF_Pos)                   /*!< 0x00000100 */
N#define TIM_SMCR_ETF_1            (0x2U << TIM_SMCR_ETF_Pos)                   /*!< 0x00000200 */
N#define TIM_SMCR_ETF_2            (0x4U << TIM_SMCR_ETF_Pos)                   /*!< 0x00000400 */
N#define TIM_SMCR_ETF_3            (0x8U << TIM_SMCR_ETF_Pos)                   /*!< 0x00000800 */
N
N#define TIM_SMCR_ETPS_Pos         (12U)                                        
N#define TIM_SMCR_ETPS_Msk         (0x3U << TIM_SMCR_ETPS_Pos)                  /*!< 0x00003000 */
N#define TIM_SMCR_ETPS             TIM_SMCR_ETPS_Msk                            /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define TIM_SMCR_ETPS_0           (0x1U << TIM_SMCR_ETPS_Pos)                  /*!< 0x00001000 */
N#define TIM_SMCR_ETPS_1           (0x2U << TIM_SMCR_ETPS_Pos)                  /*!< 0x00002000 */
N
N#define TIM_SMCR_ECE_Pos          (14U)                                        
N#define TIM_SMCR_ECE_Msk          (0x1U << TIM_SMCR_ECE_Pos)                   /*!< 0x00004000 */
N#define TIM_SMCR_ECE              TIM_SMCR_ECE_Msk                             /*!<External clock enable */
N#define TIM_SMCR_ETP_Pos          (15U)                                        
N#define TIM_SMCR_ETP_Msk          (0x1U << TIM_SMCR_ETP_Pos)                   /*!< 0x00008000 */
N#define TIM_SMCR_ETP              TIM_SMCR_ETP_Msk                             /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  ******************/
N#define TIM_DIER_UIE_Pos          (0U)                                         
N#define TIM_DIER_UIE_Msk          (0x1U << TIM_DIER_UIE_Pos)                   /*!< 0x00000001 */
N#define TIM_DIER_UIE              TIM_DIER_UIE_Msk                             /*!<Update interrupt enable */
N#define TIM_DIER_CC1IE_Pos        (1U)                                         
N#define TIM_DIER_CC1IE_Msk        (0x1U << TIM_DIER_CC1IE_Pos)                 /*!< 0x00000002 */
N#define TIM_DIER_CC1IE            TIM_DIER_CC1IE_Msk                           /*!<Capture/Compare 1 interrupt enable */
N#define TIM_DIER_CC2IE_Pos        (2U)                                         
N#define TIM_DIER_CC2IE_Msk        (0x1U << TIM_DIER_CC2IE_Pos)                 /*!< 0x00000004 */
N#define TIM_DIER_CC2IE            TIM_DIER_CC2IE_Msk                           /*!<Capture/Compare 2 interrupt enable */
N#define TIM_DIER_CC3IE_Pos        (3U)                                         
N#define TIM_DIER_CC3IE_Msk        (0x1U << TIM_DIER_CC3IE_Pos)                 /*!< 0x00000008 */
N#define TIM_DIER_CC3IE            TIM_DIER_CC3IE_Msk                           /*!<Capture/Compare 3 interrupt enable */
N#define TIM_DIER_CC4IE_Pos        (4U)                                         
N#define TIM_DIER_CC4IE_Msk        (0x1U << TIM_DIER_CC4IE_Pos)                 /*!< 0x00000010 */
N#define TIM_DIER_CC4IE            TIM_DIER_CC4IE_Msk                           /*!<Capture/Compare 4 interrupt enable */
N#define TIM_DIER_COMIE_Pos        (5U)                                         
N#define TIM_DIER_COMIE_Msk        (0x1U << TIM_DIER_COMIE_Pos)                 /*!< 0x00000020 */
N#define TIM_DIER_COMIE            TIM_DIER_COMIE_Msk                           /*!<COM interrupt enable */
N#define TIM_DIER_TIE_Pos          (6U)                                         
N#define TIM_DIER_TIE_Msk          (0x1U << TIM_DIER_TIE_Pos)                   /*!< 0x00000040 */
N#define TIM_DIER_TIE              TIM_DIER_TIE_Msk                             /*!<Trigger interrupt enable */
N#define TIM_DIER_BIE_Pos          (7U)                                         
N#define TIM_DIER_BIE_Msk          (0x1U << TIM_DIER_BIE_Pos)                   /*!< 0x00000080 */
N#define TIM_DIER_BIE              TIM_DIER_BIE_Msk                             /*!<Break interrupt enable */
N#define TIM_DIER_UDE_Pos          (8U)                                         
N#define TIM_DIER_UDE_Msk          (0x1U << TIM_DIER_UDE_Pos)                   /*!< 0x00000100 */
N#define TIM_DIER_UDE              TIM_DIER_UDE_Msk                             /*!<Update DMA request enable */
N#define TIM_DIER_CC1DE_Pos        (9U)                                         
N#define TIM_DIER_CC1DE_Msk        (0x1U << TIM_DIER_CC1DE_Pos)                 /*!< 0x00000200 */
N#define TIM_DIER_CC1DE            TIM_DIER_CC1DE_Msk                           /*!<Capture/Compare 1 DMA request enable */
N#define TIM_DIER_CC2DE_Pos        (10U)                                        
N#define TIM_DIER_CC2DE_Msk        (0x1U << TIM_DIER_CC2DE_Pos)                 /*!< 0x00000400 */
N#define TIM_DIER_CC2DE            TIM_DIER_CC2DE_Msk                           /*!<Capture/Compare 2 DMA request enable */
N#define TIM_DIER_CC3DE_Pos        (11U)                                        
N#define TIM_DIER_CC3DE_Msk        (0x1U << TIM_DIER_CC3DE_Pos)                 /*!< 0x00000800 */
N#define TIM_DIER_CC3DE            TIM_DIER_CC3DE_Msk                           /*!<Capture/Compare 3 DMA request enable */
N#define TIM_DIER_CC4DE_Pos        (12U)                                        
N#define TIM_DIER_CC4DE_Msk        (0x1U << TIM_DIER_CC4DE_Pos)                 /*!< 0x00001000 */
N#define TIM_DIER_CC4DE            TIM_DIER_CC4DE_Msk                           /*!<Capture/Compare 4 DMA request enable */
N#define TIM_DIER_COMDE_Pos        (13U)                                        
N#define TIM_DIER_COMDE_Msk        (0x1U << TIM_DIER_COMDE_Pos)                 /*!< 0x00002000 */
N#define TIM_DIER_COMDE            TIM_DIER_COMDE_Msk                           /*!<COM DMA request enable */
N#define TIM_DIER_TDE_Pos          (14U)                                        
N#define TIM_DIER_TDE_Msk          (0x1U << TIM_DIER_TDE_Pos)                   /*!< 0x00004000 */
N#define TIM_DIER_TDE              TIM_DIER_TDE_Msk                             /*!<Trigger DMA request enable */
N
N/********************  Bit definition for TIM_SR register  *******************/
N#define TIM_SR_UIF_Pos            (0U)                                         
N#define TIM_SR_UIF_Msk            (0x1U << TIM_SR_UIF_Pos)                     /*!< 0x00000001 */
N#define TIM_SR_UIF                TIM_SR_UIF_Msk                               /*!<Update interrupt Flag */
N#define TIM_SR_CC1IF_Pos          (1U)                                         
N#define TIM_SR_CC1IF_Msk          (0x1U << TIM_SR_CC1IF_Pos)                   /*!< 0x00000002 */
N#define TIM_SR_CC1IF              TIM_SR_CC1IF_Msk                             /*!<Capture/Compare 1 interrupt Flag */
N#define TIM_SR_CC2IF_Pos          (2U)                                         
N#define TIM_SR_CC2IF_Msk          (0x1U << TIM_SR_CC2IF_Pos)                   /*!< 0x00000004 */
N#define TIM_SR_CC2IF              TIM_SR_CC2IF_Msk                             /*!<Capture/Compare 2 interrupt Flag */
N#define TIM_SR_CC3IF_Pos          (3U)                                         
N#define TIM_SR_CC3IF_Msk          (0x1U << TIM_SR_CC3IF_Pos)                   /*!< 0x00000008 */
N#define TIM_SR_CC3IF              TIM_SR_CC3IF_Msk                             /*!<Capture/Compare 3 interrupt Flag */
N#define TIM_SR_CC4IF_Pos          (4U)                                         
N#define TIM_SR_CC4IF_Msk          (0x1U << TIM_SR_CC4IF_Pos)                   /*!< 0x00000010 */
N#define TIM_SR_CC4IF              TIM_SR_CC4IF_Msk                             /*!<Capture/Compare 4 interrupt Flag */
N#define TIM_SR_COMIF_Pos          (5U)                                         
N#define TIM_SR_COMIF_Msk          (0x1U << TIM_SR_COMIF_Pos)                   /*!< 0x00000020 */
N#define TIM_SR_COMIF              TIM_SR_COMIF_Msk                             /*!<COM interrupt Flag */
N#define TIM_SR_TIF_Pos            (6U)                                         
N#define TIM_SR_TIF_Msk            (0x1U << TIM_SR_TIF_Pos)                     /*!< 0x00000040 */
N#define TIM_SR_TIF                TIM_SR_TIF_Msk                               /*!<Trigger interrupt Flag */
N#define TIM_SR_BIF_Pos            (7U)                                         
N#define TIM_SR_BIF_Msk            (0x1U << TIM_SR_BIF_Pos)                     /*!< 0x00000080 */
N#define TIM_SR_BIF                TIM_SR_BIF_Msk                               /*!<Break interrupt Flag */
N#define TIM_SR_CC1OF_Pos          (9U)                                         
N#define TIM_SR_CC1OF_Msk          (0x1U << TIM_SR_CC1OF_Pos)                   /*!< 0x00000200 */
N#define TIM_SR_CC1OF              TIM_SR_CC1OF_Msk                             /*!<Capture/Compare 1 Overcapture Flag */
N#define TIM_SR_CC2OF_Pos          (10U)                                        
N#define TIM_SR_CC2OF_Msk          (0x1U << TIM_SR_CC2OF_Pos)                   /*!< 0x00000400 */
N#define TIM_SR_CC2OF              TIM_SR_CC2OF_Msk                             /*!<Capture/Compare 2 Overcapture Flag */
N#define TIM_SR_CC3OF_Pos          (11U)                                        
N#define TIM_SR_CC3OF_Msk          (0x1U << TIM_SR_CC3OF_Pos)                   /*!< 0x00000800 */
N#define TIM_SR_CC3OF              TIM_SR_CC3OF_Msk                             /*!<Capture/Compare 3 Overcapture Flag */
N#define TIM_SR_CC4OF_Pos          (12U)                                        
N#define TIM_SR_CC4OF_Msk          (0x1U << TIM_SR_CC4OF_Pos)                   /*!< 0x00001000 */
N#define TIM_SR_CC4OF              TIM_SR_CC4OF_Msk                             /*!<Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  *******************/
N#define TIM_EGR_UG_Pos            (0U)                                         
N#define TIM_EGR_UG_Msk            (0x1U << TIM_EGR_UG_Pos)                     /*!< 0x00000001 */
N#define TIM_EGR_UG                TIM_EGR_UG_Msk                               /*!<Update Generation */
N#define TIM_EGR_CC1G_Pos          (1U)                                         
N#define TIM_EGR_CC1G_Msk          (0x1U << TIM_EGR_CC1G_Pos)                   /*!< 0x00000002 */
N#define TIM_EGR_CC1G              TIM_EGR_CC1G_Msk                             /*!<Capture/Compare 1 Generation */
N#define TIM_EGR_CC2G_Pos          (2U)                                         
N#define TIM_EGR_CC2G_Msk          (0x1U << TIM_EGR_CC2G_Pos)                   /*!< 0x00000004 */
N#define TIM_EGR_CC2G              TIM_EGR_CC2G_Msk                             /*!<Capture/Compare 2 Generation */
N#define TIM_EGR_CC3G_Pos          (3U)                                         
N#define TIM_EGR_CC3G_Msk          (0x1U << TIM_EGR_CC3G_Pos)                   /*!< 0x00000008 */
N#define TIM_EGR_CC3G              TIM_EGR_CC3G_Msk                             /*!<Capture/Compare 3 Generation */
N#define TIM_EGR_CC4G_Pos          (4U)                                         
N#define TIM_EGR_CC4G_Msk          (0x1U << TIM_EGR_CC4G_Pos)                   /*!< 0x00000010 */
N#define TIM_EGR_CC4G              TIM_EGR_CC4G_Msk                             /*!<Capture/Compare 4 Generation */
N#define TIM_EGR_COMG_Pos          (5U)                                         
N#define TIM_EGR_COMG_Msk          (0x1U << TIM_EGR_COMG_Pos)                   /*!< 0x00000020 */
N#define TIM_EGR_COMG              TIM_EGR_COMG_Msk                             /*!<Capture/Compare Control Update Generation */
N#define TIM_EGR_TG_Pos            (6U)                                         
N#define TIM_EGR_TG_Msk            (0x1U << TIM_EGR_TG_Pos)                     /*!< 0x00000040 */
N#define TIM_EGR_TG                TIM_EGR_TG_Msk                               /*!<Trigger Generation */
N#define TIM_EGR_BG_Pos            (7U)                                         
N#define TIM_EGR_BG_Msk            (0x1U << TIM_EGR_BG_Pos)                     /*!< 0x00000080 */
N#define TIM_EGR_BG                TIM_EGR_BG_Msk                               /*!<Break Generation */
N
N/******************  Bit definition for TIM_CCMR1 register  ******************/
N#define TIM_CCMR1_CC1S_Pos        (0U)                                         
N#define TIM_CCMR1_CC1S_Msk        (0x3U << TIM_CCMR1_CC1S_Pos)                 /*!< 0x00000003 */
N#define TIM_CCMR1_CC1S            TIM_CCMR1_CC1S_Msk                           /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define TIM_CCMR1_CC1S_0          (0x1U << TIM_CCMR1_CC1S_Pos)                 /*!< 0x00000001 */
N#define TIM_CCMR1_CC1S_1          (0x2U << TIM_CCMR1_CC1S_Pos)                 /*!< 0x00000002 */
N
N#define TIM_CCMR1_OC1FE_Pos       (2U)                                         
N#define TIM_CCMR1_OC1FE_Msk       (0x1U << TIM_CCMR1_OC1FE_Pos)                /*!< 0x00000004 */
N#define TIM_CCMR1_OC1FE           TIM_CCMR1_OC1FE_Msk                          /*!<Output Compare 1 Fast enable */
N#define TIM_CCMR1_OC1PE_Pos       (3U)                                         
N#define TIM_CCMR1_OC1PE_Msk       (0x1U << TIM_CCMR1_OC1PE_Pos)                /*!< 0x00000008 */
N#define TIM_CCMR1_OC1PE           TIM_CCMR1_OC1PE_Msk                          /*!<Output Compare 1 Preload enable */
N
N#define TIM_CCMR1_OC1M_Pos        (4U)                                         
N#define TIM_CCMR1_OC1M_Msk        (0x7U << TIM_CCMR1_OC1M_Pos)                 /*!< 0x00000070 */
N#define TIM_CCMR1_OC1M            TIM_CCMR1_OC1M_Msk                           /*!<OC1M[2:0] bits (Output Compare 1 Mode) */
N#define TIM_CCMR1_OC1M_0          (0x1U << TIM_CCMR1_OC1M_Pos)                 /*!< 0x00000010 */
N#define TIM_CCMR1_OC1M_1          (0x2U << TIM_CCMR1_OC1M_Pos)                 /*!< 0x00000020 */
N#define TIM_CCMR1_OC1M_2          (0x4U << TIM_CCMR1_OC1M_Pos)                 /*!< 0x00000040 */
N
N#define TIM_CCMR1_OC1CE_Pos       (7U)                                         
N#define TIM_CCMR1_OC1CE_Msk       (0x1U << TIM_CCMR1_OC1CE_Pos)                /*!< 0x00000080 */
N#define TIM_CCMR1_OC1CE           TIM_CCMR1_OC1CE_Msk                          /*!<Output Compare 1Clear Enable */
N
N#define TIM_CCMR1_CC2S_Pos        (8U)                                         
N#define TIM_CCMR1_CC2S_Msk        (0x3U << TIM_CCMR1_CC2S_Pos)                 /*!< 0x00000300 */
N#define TIM_CCMR1_CC2S            TIM_CCMR1_CC2S_Msk                           /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define TIM_CCMR1_CC2S_0          (0x1U << TIM_CCMR1_CC2S_Pos)                 /*!< 0x00000100 */
N#define TIM_CCMR1_CC2S_1          (0x2U << TIM_CCMR1_CC2S_Pos)                 /*!< 0x00000200 */
N
N#define TIM_CCMR1_OC2FE_Pos       (10U)                                        
N#define TIM_CCMR1_OC2FE_Msk       (0x1U << TIM_CCMR1_OC2FE_Pos)                /*!< 0x00000400 */
N#define TIM_CCMR1_OC2FE           TIM_CCMR1_OC2FE_Msk                          /*!<Output Compare 2 Fast enable */
N#define TIM_CCMR1_OC2PE_Pos       (11U)                                        
N#define TIM_CCMR1_OC2PE_Msk       (0x1U << TIM_CCMR1_OC2PE_Pos)                /*!< 0x00000800 */
N#define TIM_CCMR1_OC2PE           TIM_CCMR1_OC2PE_Msk                          /*!<Output Compare 2 Preload enable */
N
N#define TIM_CCMR1_OC2M_Pos        (12U)                                        
N#define TIM_CCMR1_OC2M_Msk        (0x7U << TIM_CCMR1_OC2M_Pos)                 /*!< 0x00007000 */
N#define TIM_CCMR1_OC2M            TIM_CCMR1_OC2M_Msk                           /*!<OC2M[2:0] bits (Output Compare 2 Mode) */
N#define TIM_CCMR1_OC2M_0          (0x1U << TIM_CCMR1_OC2M_Pos)                 /*!< 0x00001000 */
N#define TIM_CCMR1_OC2M_1          (0x2U << TIM_CCMR1_OC2M_Pos)                 /*!< 0x00002000 */
N#define TIM_CCMR1_OC2M_2          (0x4U << TIM_CCMR1_OC2M_Pos)                 /*!< 0x00004000 */
N
N#define TIM_CCMR1_OC2CE_Pos       (15U)                                        
N#define TIM_CCMR1_OC2CE_Msk       (0x1U << TIM_CCMR1_OC2CE_Pos)                /*!< 0x00008000 */
N#define TIM_CCMR1_OC2CE           TIM_CCMR1_OC2CE_Msk                          /*!<Output Compare 2 Clear Enable */
N
N/*---------------------------------------------------------------------------*/
N
N#define TIM_CCMR1_IC1PSC_Pos      (2U)                                         
N#define TIM_CCMR1_IC1PSC_Msk      (0x3U << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x0000000C */
N#define TIM_CCMR1_IC1PSC          TIM_CCMR1_IC1PSC_Msk                         /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define TIM_CCMR1_IC1PSC_0        (0x1U << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x00000004 */
N#define TIM_CCMR1_IC1PSC_1        (0x2U << TIM_CCMR1_IC1PSC_Pos)               /*!< 0x00000008 */
N
N#define TIM_CCMR1_IC1F_Pos        (4U)                                         
N#define TIM_CCMR1_IC1F_Msk        (0xFU << TIM_CCMR1_IC1F_Pos)                 /*!< 0x000000F0 */
N#define TIM_CCMR1_IC1F            TIM_CCMR1_IC1F_Msk                           /*!<IC1F[3:0] bits (Input Capture 1 Filter) */
N#define TIM_CCMR1_IC1F_0          (0x1U << TIM_CCMR1_IC1F_Pos)                 /*!< 0x00000010 */
N#define TIM_CCMR1_IC1F_1          (0x2U << TIM_CCMR1_IC1F_Pos)                 /*!< 0x00000020 */
N#define TIM_CCMR1_IC1F_2          (0x4U << TIM_CCMR1_IC1F_Pos)                 /*!< 0x00000040 */
N#define TIM_CCMR1_IC1F_3          (0x8U << TIM_CCMR1_IC1F_Pos)                 /*!< 0x00000080 */
N
N#define TIM_CCMR1_IC2PSC_Pos      (10U)                                        
N#define TIM_CCMR1_IC2PSC_Msk      (0x3U << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x00000C00 */
N#define TIM_CCMR1_IC2PSC          TIM_CCMR1_IC2PSC_Msk                         /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
N#define TIM_CCMR1_IC2PSC_0        (0x1U << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x00000400 */
N#define TIM_CCMR1_IC2PSC_1        (0x2U << TIM_CCMR1_IC2PSC_Pos)               /*!< 0x00000800 */
N
N#define TIM_CCMR1_IC2F_Pos        (12U)                                        
N#define TIM_CCMR1_IC2F_Msk        (0xFU << TIM_CCMR1_IC2F_Pos)                 /*!< 0x0000F000 */
N#define TIM_CCMR1_IC2F            TIM_CCMR1_IC2F_Msk                           /*!<IC2F[3:0] bits (Input Capture 2 Filter) */
N#define TIM_CCMR1_IC2F_0          (0x1U << TIM_CCMR1_IC2F_Pos)                 /*!< 0x00001000 */
N#define TIM_CCMR1_IC2F_1          (0x2U << TIM_CCMR1_IC2F_Pos)                 /*!< 0x00002000 */
N#define TIM_CCMR1_IC2F_2          (0x4U << TIM_CCMR1_IC2F_Pos)                 /*!< 0x00004000 */
N#define TIM_CCMR1_IC2F_3          (0x8U << TIM_CCMR1_IC2F_Pos)                 /*!< 0x00008000 */
N
N/******************  Bit definition for TIM_CCMR2 register  ******************/
N#define TIM_CCMR2_CC3S_Pos        (0U)                                         
N#define TIM_CCMR2_CC3S_Msk        (0x3U << TIM_CCMR2_CC3S_Pos)                 /*!< 0x00000003 */
N#define TIM_CCMR2_CC3S            TIM_CCMR2_CC3S_Msk                           /*!<CC3S[1:0] bits (Capture/Compare 3 Selection) */
N#define TIM_CCMR2_CC3S_0          (0x1U << TIM_CCMR2_CC3S_Pos)                 /*!< 0x00000001 */
N#define TIM_CCMR2_CC3S_1          (0x2U << TIM_CCMR2_CC3S_Pos)                 /*!< 0x00000002 */
N
N#define TIM_CCMR2_OC3FE_Pos       (2U)                                         
N#define TIM_CCMR2_OC3FE_Msk       (0x1U << TIM_CCMR2_OC3FE_Pos)                /*!< 0x00000004 */
N#define TIM_CCMR2_OC3FE           TIM_CCMR2_OC3FE_Msk                          /*!<Output Compare 3 Fast enable */
N#define TIM_CCMR2_OC3PE_Pos       (3U)                                         
N#define TIM_CCMR2_OC3PE_Msk       (0x1U << TIM_CCMR2_OC3PE_Pos)                /*!< 0x00000008 */
N#define TIM_CCMR2_OC3PE           TIM_CCMR2_OC3PE_Msk                          /*!<Output Compare 3 Preload enable */
N
N#define TIM_CCMR2_OC3M_Pos        (4U)                                         
N#define TIM_CCMR2_OC3M_Msk        (0x7U << TIM_CCMR2_OC3M_Pos)                 /*!< 0x00000070 */
N#define TIM_CCMR2_OC3M            TIM_CCMR2_OC3M_Msk                           /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define TIM_CCMR2_OC3M_0          (0x1U << TIM_CCMR2_OC3M_Pos)                 /*!< 0x00000010 */
N#define TIM_CCMR2_OC3M_1          (0x2U << TIM_CCMR2_OC3M_Pos)                 /*!< 0x00000020 */
N#define TIM_CCMR2_OC3M_2          (0x4U << TIM_CCMR2_OC3M_Pos)                 /*!< 0x00000040 */
N
N#define TIM_CCMR2_OC3CE_Pos       (7U)                                         
N#define TIM_CCMR2_OC3CE_Msk       (0x1U << TIM_CCMR2_OC3CE_Pos)                /*!< 0x00000080 */
N#define TIM_CCMR2_OC3CE           TIM_CCMR2_OC3CE_Msk                          /*!<Output Compare 3 Clear Enable */
N
N#define TIM_CCMR2_CC4S_Pos        (8U)                                         
N#define TIM_CCMR2_CC4S_Msk        (0x3U << TIM_CCMR2_CC4S_Pos)                 /*!< 0x00000300 */
N#define TIM_CCMR2_CC4S            TIM_CCMR2_CC4S_Msk                           /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define TIM_CCMR2_CC4S_0          (0x1U << TIM_CCMR2_CC4S_Pos)                 /*!< 0x00000100 */
N#define TIM_CCMR2_CC4S_1          (0x2U << TIM_CCMR2_CC4S_Pos)                 /*!< 0x00000200 */
N
N#define TIM_CCMR2_OC4FE_Pos       (10U)                                        
N#define TIM_CCMR2_OC4FE_Msk       (0x1U << TIM_CCMR2_OC4FE_Pos)                /*!< 0x00000400 */
N#define TIM_CCMR2_OC4FE           TIM_CCMR2_OC4FE_Msk                          /*!<Output Compare 4 Fast enable */
N#define TIM_CCMR2_OC4PE_Pos       (11U)                                        
N#define TIM_CCMR2_OC4PE_Msk       (0x1U << TIM_CCMR2_OC4PE_Pos)                /*!< 0x00000800 */
N#define TIM_CCMR2_OC4PE           TIM_CCMR2_OC4PE_Msk                          /*!<Output Compare 4 Preload enable */
N
N#define TIM_CCMR2_OC4M_Pos        (12U)                                        
N#define TIM_CCMR2_OC4M_Msk        (0x7U << TIM_CCMR2_OC4M_Pos)                 /*!< 0x00007000 */
N#define TIM_CCMR2_OC4M            TIM_CCMR2_OC4M_Msk                           /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define TIM_CCMR2_OC4M_0          (0x1U << TIM_CCMR2_OC4M_Pos)                 /*!< 0x00001000 */
N#define TIM_CCMR2_OC4M_1          (0x2U << TIM_CCMR2_OC4M_Pos)                 /*!< 0x00002000 */
N#define TIM_CCMR2_OC4M_2          (0x4U << TIM_CCMR2_OC4M_Pos)                 /*!< 0x00004000 */
N
N#define TIM_CCMR2_OC4CE_Pos       (15U)                                        
N#define TIM_CCMR2_OC4CE_Msk       (0x1U << TIM_CCMR2_OC4CE_Pos)                /*!< 0x00008000 */
N#define TIM_CCMR2_OC4CE           TIM_CCMR2_OC4CE_Msk                          /*!<Output Compare 4 Clear Enable */
N
N/*---------------------------------------------------------------------------*/
N
N#define TIM_CCMR2_IC3PSC_Pos      (2U)                                         
N#define TIM_CCMR2_IC3PSC_Msk      (0x3U << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x0000000C */
N#define TIM_CCMR2_IC3PSC          TIM_CCMR2_IC3PSC_Msk                         /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define TIM_CCMR2_IC3PSC_0        (0x1U << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x00000004 */
N#define TIM_CCMR2_IC3PSC_1        (0x2U << TIM_CCMR2_IC3PSC_Pos)               /*!< 0x00000008 */
N
N#define TIM_CCMR2_IC3F_Pos        (4U)                                         
N#define TIM_CCMR2_IC3F_Msk        (0xFU << TIM_CCMR2_IC3F_Pos)                 /*!< 0x000000F0 */
N#define TIM_CCMR2_IC3F            TIM_CCMR2_IC3F_Msk                           /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define TIM_CCMR2_IC3F_0          (0x1U << TIM_CCMR2_IC3F_Pos)                 /*!< 0x00000010 */
N#define TIM_CCMR2_IC3F_1          (0x2U << TIM_CCMR2_IC3F_Pos)                 /*!< 0x00000020 */
N#define TIM_CCMR2_IC3F_2          (0x4U << TIM_CCMR2_IC3F_Pos)                 /*!< 0x00000040 */
N#define TIM_CCMR2_IC3F_3          (0x8U << TIM_CCMR2_IC3F_Pos)                 /*!< 0x00000080 */
N
N#define TIM_CCMR2_IC4PSC_Pos      (10U)                                        
N#define TIM_CCMR2_IC4PSC_Msk      (0x3U << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x00000C00 */
N#define TIM_CCMR2_IC4PSC          TIM_CCMR2_IC4PSC_Msk                         /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define TIM_CCMR2_IC4PSC_0        (0x1U << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x00000400 */
N#define TIM_CCMR2_IC4PSC_1        (0x2U << TIM_CCMR2_IC4PSC_Pos)               /*!< 0x00000800 */
N
N#define TIM_CCMR2_IC4F_Pos        (12U)                                        
N#define TIM_CCMR2_IC4F_Msk        (0xFU << TIM_CCMR2_IC4F_Pos)                 /*!< 0x0000F000 */
N#define TIM_CCMR2_IC4F            TIM_CCMR2_IC4F_Msk                           /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define TIM_CCMR2_IC4F_0          (0x1U << TIM_CCMR2_IC4F_Pos)                 /*!< 0x00001000 */
N#define TIM_CCMR2_IC4F_1          (0x2U << TIM_CCMR2_IC4F_Pos)                 /*!< 0x00002000 */
N#define TIM_CCMR2_IC4F_2          (0x4U << TIM_CCMR2_IC4F_Pos)                 /*!< 0x00004000 */
N#define TIM_CCMR2_IC4F_3          (0x8U << TIM_CCMR2_IC4F_Pos)                 /*!< 0x00008000 */
N
N/*******************  Bit definition for TIM_CCER register  ******************/
N#define TIM_CCER_CC1E_Pos         (0U)                                         
N#define TIM_CCER_CC1E_Msk         (0x1U << TIM_CCER_CC1E_Pos)                  /*!< 0x00000001 */
N#define TIM_CCER_CC1E             TIM_CCER_CC1E_Msk                            /*!<Capture/Compare 1 output enable */
N#define TIM_CCER_CC1P_Pos         (1U)                                         
N#define TIM_CCER_CC1P_Msk         (0x1U << TIM_CCER_CC1P_Pos)                  /*!< 0x00000002 */
N#define TIM_CCER_CC1P             TIM_CCER_CC1P_Msk                            /*!<Capture/Compare 1 output Polarity */
N#define TIM_CCER_CC1NE_Pos        (2U)                                         
N#define TIM_CCER_CC1NE_Msk        (0x1U << TIM_CCER_CC1NE_Pos)                 /*!< 0x00000004 */
N#define TIM_CCER_CC1NE            TIM_CCER_CC1NE_Msk                           /*!<Capture/Compare 1 Complementary output enable */
N#define TIM_CCER_CC1NP_Pos        (3U)                                         
N#define TIM_CCER_CC1NP_Msk        (0x1U << TIM_CCER_CC1NP_Pos)                 /*!< 0x00000008 */
N#define TIM_CCER_CC1NP            TIM_CCER_CC1NP_Msk                           /*!<Capture/Compare 1 Complementary output Polarity */
N#define TIM_CCER_CC2E_Pos         (4U)                                         
N#define TIM_CCER_CC2E_Msk         (0x1U << TIM_CCER_CC2E_Pos)                  /*!< 0x00000010 */
N#define TIM_CCER_CC2E             TIM_CCER_CC2E_Msk                            /*!<Capture/Compare 2 output enable */
N#define TIM_CCER_CC2P_Pos         (5U)                                         
N#define TIM_CCER_CC2P_Msk         (0x1U << TIM_CCER_CC2P_Pos)                  /*!< 0x00000020 */
N#define TIM_CCER_CC2P             TIM_CCER_CC2P_Msk                            /*!<Capture/Compare 2 output Polarity */
N#define TIM_CCER_CC2NE_Pos        (6U)                                         
N#define TIM_CCER_CC2NE_Msk        (0x1U << TIM_CCER_CC2NE_Pos)                 /*!< 0x00000040 */
N#define TIM_CCER_CC2NE            TIM_CCER_CC2NE_Msk                           /*!<Capture/Compare 2 Complementary output enable */
N#define TIM_CCER_CC2NP_Pos        (7U)                                         
N#define TIM_CCER_CC2NP_Msk        (0x1U << TIM_CCER_CC2NP_Pos)                 /*!< 0x00000080 */
N#define TIM_CCER_CC2NP            TIM_CCER_CC2NP_Msk                           /*!<Capture/Compare 2 Complementary output Polarity */
N#define TIM_CCER_CC3E_Pos         (8U)                                         
N#define TIM_CCER_CC3E_Msk         (0x1U << TIM_CCER_CC3E_Pos)                  /*!< 0x00000100 */
N#define TIM_CCER_CC3E             TIM_CCER_CC3E_Msk                            /*!<Capture/Compare 3 output enable */
N#define TIM_CCER_CC3P_Pos         (9U)                                         
N#define TIM_CCER_CC3P_Msk         (0x1U << TIM_CCER_CC3P_Pos)                  /*!< 0x00000200 */
N#define TIM_CCER_CC3P             TIM_CCER_CC3P_Msk                            /*!<Capture/Compare 3 output Polarity */
N#define TIM_CCER_CC3NE_Pos        (10U)                                        
N#define TIM_CCER_CC3NE_Msk        (0x1U << TIM_CCER_CC3NE_Pos)                 /*!< 0x00000400 */
N#define TIM_CCER_CC3NE            TIM_CCER_CC3NE_Msk                           /*!<Capture/Compare 3 Complementary output enable */
N#define TIM_CCER_CC3NP_Pos        (11U)                                        
N#define TIM_CCER_CC3NP_Msk        (0x1U << TIM_CCER_CC3NP_Pos)                 /*!< 0x00000800 */
N#define TIM_CCER_CC3NP            TIM_CCER_CC3NP_Msk                           /*!<Capture/Compare 3 Complementary output Polarity */
N#define TIM_CCER_CC4E_Pos         (12U)                                        
N#define TIM_CCER_CC4E_Msk         (0x1U << TIM_CCER_CC4E_Pos)                  /*!< 0x00001000 */
N#define TIM_CCER_CC4E             TIM_CCER_CC4E_Msk                            /*!<Capture/Compare 4 output enable */
N#define TIM_CCER_CC4P_Pos         (13U)                                        
N#define TIM_CCER_CC4P_Msk         (0x1U << TIM_CCER_CC4P_Pos)                  /*!< 0x00002000 */
N#define TIM_CCER_CC4P             TIM_CCER_CC4P_Msk                            /*!<Capture/Compare 4 output Polarity */
N#define TIM_CCER_CC4NP_Pos        (15U)                                        
N#define TIM_CCER_CC4NP_Msk        (0x1U << TIM_CCER_CC4NP_Pos)                 /*!< 0x00008000 */
N#define TIM_CCER_CC4NP            TIM_CCER_CC4NP_Msk                           /*!<Capture/Compare 4 Complementary output Polarity */
N
N/*******************  Bit definition for TIM_CNT register  *******************/
N#define TIM_CNT_CNT_Pos           (0U)                                         
N#define TIM_CNT_CNT_Msk           (0xFFFFFFFFU << TIM_CNT_CNT_Pos)             /*!< 0xFFFFFFFF */
N#define TIM_CNT_CNT               TIM_CNT_CNT_Msk                              /*!<Counter Value */
N
N/*******************  Bit definition for TIM_PSC register  *******************/
N#define TIM_PSC_PSC_Pos           (0U)                                         
N#define TIM_PSC_PSC_Msk           (0xFFFFU << TIM_PSC_PSC_Pos)                 /*!< 0x0000FFFF */
N#define TIM_PSC_PSC               TIM_PSC_PSC_Msk                              /*!<Prescaler Value */
N
N/*******************  Bit definition for TIM_ARR register  *******************/
N#define TIM_ARR_ARR_Pos           (0U)                                         
N#define TIM_ARR_ARR_Msk           (0xFFFFFFFFU << TIM_ARR_ARR_Pos)             /*!< 0xFFFFFFFF */
N#define TIM_ARR_ARR               TIM_ARR_ARR_Msk                              /*!<actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  *******************/
N#define TIM_RCR_REP_Pos           (0U)                                         
N#define TIM_RCR_REP_Msk           (0xFFU << TIM_RCR_REP_Pos)                   /*!< 0x000000FF */
N#define TIM_RCR_REP               TIM_RCR_REP_Msk                              /*!<Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  ******************/
N#define TIM_CCR1_CCR1_Pos         (0U)                                         
N#define TIM_CCR1_CCR1_Msk         (0xFFFFU << TIM_CCR1_CCR1_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR1_CCR1             TIM_CCR1_CCR1_Msk                            /*!<Capture/Compare 1 Value */
N
N/*******************  Bit definition for TIM_CCR2 register  ******************/
N#define TIM_CCR2_CCR2_Pos         (0U)                                         
N#define TIM_CCR2_CCR2_Msk         (0xFFFFU << TIM_CCR2_CCR2_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR2_CCR2             TIM_CCR2_CCR2_Msk                            /*!<Capture/Compare 2 Value */
N
N/*******************  Bit definition for TIM_CCR3 register  ******************/
N#define TIM_CCR3_CCR3_Pos         (0U)                                         
N#define TIM_CCR3_CCR3_Msk         (0xFFFFU << TIM_CCR3_CCR3_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR3_CCR3             TIM_CCR3_CCR3_Msk                            /*!<Capture/Compare 3 Value */
N
N/*******************  Bit definition for TIM_CCR4 register  ******************/
N#define TIM_CCR4_CCR4_Pos         (0U)                                         
N#define TIM_CCR4_CCR4_Msk         (0xFFFFU << TIM_CCR4_CCR4_Pos)               /*!< 0x0000FFFF */
N#define TIM_CCR4_CCR4             TIM_CCR4_CCR4_Msk                            /*!<Capture/Compare 4 Value */
N
N/*******************  Bit definition for TIM_BDTR register  ******************/
N#define TIM_BDTR_DTG_Pos          (0U)                                         
N#define TIM_BDTR_DTG_Msk          (0xFFU << TIM_BDTR_DTG_Pos)                  /*!< 0x000000FF */
N#define TIM_BDTR_DTG              TIM_BDTR_DTG_Msk                             /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
N#define TIM_BDTR_DTG_0            (0x01U << TIM_BDTR_DTG_Pos)                  /*!< 0x00000001 */
N#define TIM_BDTR_DTG_1            (0x02U << TIM_BDTR_DTG_Pos)                  /*!< 0x00000002 */
N#define TIM_BDTR_DTG_2            (0x04U << TIM_BDTR_DTG_Pos)                  /*!< 0x00000004 */
N#define TIM_BDTR_DTG_3            (0x08U << TIM_BDTR_DTG_Pos)                  /*!< 0x00000008 */
N#define TIM_BDTR_DTG_4            (0x10U << TIM_BDTR_DTG_Pos)                  /*!< 0x00000010 */
N#define TIM_BDTR_DTG_5            (0x20U << TIM_BDTR_DTG_Pos)                  /*!< 0x00000020 */
N#define TIM_BDTR_DTG_6            (0x40U << TIM_BDTR_DTG_Pos)                  /*!< 0x00000040 */
N#define TIM_BDTR_DTG_7            (0x80U << TIM_BDTR_DTG_Pos)                  /*!< 0x00000080 */
N
N#define TIM_BDTR_LOCK_Pos         (8U)                                         
N#define TIM_BDTR_LOCK_Msk         (0x3U << TIM_BDTR_LOCK_Pos)                  /*!< 0x00000300 */
N#define TIM_BDTR_LOCK             TIM_BDTR_LOCK_Msk                            /*!<LOCK[1:0] bits (Lock Configuration) */
N#define TIM_BDTR_LOCK_0           (0x1U << TIM_BDTR_LOCK_Pos)                  /*!< 0x00000100 */
N#define TIM_BDTR_LOCK_1           (0x2U << TIM_BDTR_LOCK_Pos)                  /*!< 0x00000200 */
N
N#define TIM_BDTR_OSSI_Pos         (10U)                                        
N#define TIM_BDTR_OSSI_Msk         (0x1U << TIM_BDTR_OSSI_Pos)                  /*!< 0x00000400 */
N#define TIM_BDTR_OSSI             TIM_BDTR_OSSI_Msk                            /*!<Off-State Selection for Idle mode */
N#define TIM_BDTR_OSSR_Pos         (11U)                                        
N#define TIM_BDTR_OSSR_Msk         (0x1U << TIM_BDTR_OSSR_Pos)                  /*!< 0x00000800 */
N#define TIM_BDTR_OSSR             TIM_BDTR_OSSR_Msk                            /*!<Off-State Selection for Run mode */
N#define TIM_BDTR_BKE_Pos          (12U)                                        
N#define TIM_BDTR_BKE_Msk          (0x1U << TIM_BDTR_BKE_Pos)                   /*!< 0x00001000 */
N#define TIM_BDTR_BKE              TIM_BDTR_BKE_Msk                             /*!<Break enable */
N#define TIM_BDTR_BKP_Pos          (13U)                                        
N#define TIM_BDTR_BKP_Msk          (0x1U << TIM_BDTR_BKP_Pos)                   /*!< 0x00002000 */
N#define TIM_BDTR_BKP              TIM_BDTR_BKP_Msk                             /*!<Break Polarity */
N#define TIM_BDTR_AOE_Pos          (14U)                                        
N#define TIM_BDTR_AOE_Msk          (0x1U << TIM_BDTR_AOE_Pos)                   /*!< 0x00004000 */
N#define TIM_BDTR_AOE              TIM_BDTR_AOE_Msk                             /*!<Automatic Output enable */
N#define TIM_BDTR_MOE_Pos          (15U)                                        
N#define TIM_BDTR_MOE_Msk          (0x1U << TIM_BDTR_MOE_Pos)                   /*!< 0x00008000 */
N#define TIM_BDTR_MOE              TIM_BDTR_MOE_Msk                             /*!<Main Output enable */
N
N/*******************  Bit definition for TIM_DCR register  *******************/
N#define TIM_DCR_DBA_Pos           (0U)                                         
N#define TIM_DCR_DBA_Msk           (0x1FU << TIM_DCR_DBA_Pos)                   /*!< 0x0000001F */
N#define TIM_DCR_DBA               TIM_DCR_DBA_Msk                              /*!<DBA[4:0] bits (DMA Base Address) */
N#define TIM_DCR_DBA_0             (0x01U << TIM_DCR_DBA_Pos)                   /*!< 0x00000001 */
N#define TIM_DCR_DBA_1             (0x02U << TIM_DCR_DBA_Pos)                   /*!< 0x00000002 */
N#define TIM_DCR_DBA_2             (0x04U << TIM_DCR_DBA_Pos)                   /*!< 0x00000004 */
N#define TIM_DCR_DBA_3             (0x08U << TIM_DCR_DBA_Pos)                   /*!< 0x00000008 */
N#define TIM_DCR_DBA_4             (0x10U << TIM_DCR_DBA_Pos)                   /*!< 0x00000010 */
N
N#define TIM_DCR_DBL_Pos           (8U)                                         
N#define TIM_DCR_DBL_Msk           (0x1FU << TIM_DCR_DBL_Pos)                   /*!< 0x00001F00 */
N#define TIM_DCR_DBL               TIM_DCR_DBL_Msk                              /*!<DBL[4:0] bits (DMA Burst Length) */
N#define TIM_DCR_DBL_0             (0x01U << TIM_DCR_DBL_Pos)                   /*!< 0x00000100 */
N#define TIM_DCR_DBL_1             (0x02U << TIM_DCR_DBL_Pos)                   /*!< 0x00000200 */
N#define TIM_DCR_DBL_2             (0x04U << TIM_DCR_DBL_Pos)                   /*!< 0x00000400 */
N#define TIM_DCR_DBL_3             (0x08U << TIM_DCR_DBL_Pos)                   /*!< 0x00000800 */
N#define TIM_DCR_DBL_4             (0x10U << TIM_DCR_DBL_Pos)                   /*!< 0x00001000 */
N
N/*******************  Bit definition for TIM_DMAR register  ******************/
N#define TIM_DMAR_DMAB_Pos         (0U)                                         
N#define TIM_DMAR_DMAB_Msk         (0xFFFFU << TIM_DMAR_DMAB_Pos)               /*!< 0x0000FFFF */
N#define TIM_DMAR_DMAB             TIM_DMAR_DMAB_Msk                            /*!<DMA register for burst accesses */
N
N/*******************  Bit definition for TIM14_OR register  ********************/
N#define TIM14_OR_TI1_RMP_Pos      (0U)                                         
N#define TIM14_OR_TI1_RMP_Msk      (0x3U << TIM14_OR_TI1_RMP_Pos)               /*!< 0x00000003 */
N#define TIM14_OR_TI1_RMP          TIM14_OR_TI1_RMP_Msk                         /*!<TI1_RMP[1:0] bits (TIM14 Input 4 remap) */
N#define TIM14_OR_TI1_RMP_0        (0x1U << TIM14_OR_TI1_RMP_Pos)               /*!< 0x00000001 */
N#define TIM14_OR_TI1_RMP_1        (0x2U << TIM14_OR_TI1_RMP_Pos)               /*!< 0x00000002 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          Touch Sensing Controller (TSC)                    */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for TSC_CR register  *********************/
N#define TSC_CR_TSCE_Pos          (0U)                                          
N#define TSC_CR_TSCE_Msk          (0x1U << TSC_CR_TSCE_Pos)                     /*!< 0x00000001 */
N#define TSC_CR_TSCE              TSC_CR_TSCE_Msk                               /*!<Touch sensing controller enable */
N#define TSC_CR_START_Pos         (1U)                                          
N#define TSC_CR_START_Msk         (0x1U << TSC_CR_START_Pos)                    /*!< 0x00000002 */
N#define TSC_CR_START             TSC_CR_START_Msk                              /*!<Start acquisition */
N#define TSC_CR_AM_Pos            (2U)                                          
N#define TSC_CR_AM_Msk            (0x1U << TSC_CR_AM_Pos)                       /*!< 0x00000004 */
N#define TSC_CR_AM                TSC_CR_AM_Msk                                 /*!<Acquisition mode */
N#define TSC_CR_SYNCPOL_Pos       (3U)                                          
N#define TSC_CR_SYNCPOL_Msk       (0x1U << TSC_CR_SYNCPOL_Pos)                  /*!< 0x00000008 */
N#define TSC_CR_SYNCPOL           TSC_CR_SYNCPOL_Msk                            /*!<Synchronization pin polarity */
N#define TSC_CR_IODEF_Pos         (4U)                                          
N#define TSC_CR_IODEF_Msk         (0x1U << TSC_CR_IODEF_Pos)                    /*!< 0x00000010 */
N#define TSC_CR_IODEF             TSC_CR_IODEF_Msk                              /*!<IO default mode */
N
N#define TSC_CR_MCV_Pos           (5U)                                          
N#define TSC_CR_MCV_Msk           (0x7U << TSC_CR_MCV_Pos)                      /*!< 0x000000E0 */
N#define TSC_CR_MCV               TSC_CR_MCV_Msk                                /*!<MCV[2:0] bits (Max Count Value) */
N#define TSC_CR_MCV_0             (0x1U << TSC_CR_MCV_Pos)                      /*!< 0x00000020 */
N#define TSC_CR_MCV_1             (0x2U << TSC_CR_MCV_Pos)                      /*!< 0x00000040 */
N#define TSC_CR_MCV_2             (0x4U << TSC_CR_MCV_Pos)                      /*!< 0x00000080 */
N
N#define TSC_CR_PGPSC_Pos         (12U)                                         
N#define TSC_CR_PGPSC_Msk         (0x7U << TSC_CR_PGPSC_Pos)                    /*!< 0x00007000 */
N#define TSC_CR_PGPSC             TSC_CR_PGPSC_Msk                              /*!<PGPSC[2:0] bits (Pulse Generator Prescaler) */
N#define TSC_CR_PGPSC_0           (0x1U << TSC_CR_PGPSC_Pos)                    /*!< 0x00001000 */
N#define TSC_CR_PGPSC_1           (0x2U << TSC_CR_PGPSC_Pos)                    /*!< 0x00002000 */
N#define TSC_CR_PGPSC_2           (0x4U << TSC_CR_PGPSC_Pos)                    /*!< 0x00004000 */
N
N#define TSC_CR_SSPSC_Pos         (15U)                                         
N#define TSC_CR_SSPSC_Msk         (0x1U << TSC_CR_SSPSC_Pos)                    /*!< 0x00008000 */
N#define TSC_CR_SSPSC             TSC_CR_SSPSC_Msk                              /*!<Spread Spectrum Prescaler */
N#define TSC_CR_SSE_Pos           (16U)                                         
N#define TSC_CR_SSE_Msk           (0x1U << TSC_CR_SSE_Pos)                      /*!< 0x00010000 */
N#define TSC_CR_SSE               TSC_CR_SSE_Msk                                /*!<Spread Spectrum Enable */
N
N#define TSC_CR_SSD_Pos           (17U)                                         
N#define TSC_CR_SSD_Msk           (0x7FU << TSC_CR_SSD_Pos)                     /*!< 0x00FE0000 */
N#define TSC_CR_SSD               TSC_CR_SSD_Msk                                /*!<SSD[6:0] bits (Spread Spectrum Deviation) */
N#define TSC_CR_SSD_0             (0x01U << TSC_CR_SSD_Pos)                     /*!< 0x00020000 */
N#define TSC_CR_SSD_1             (0x02U << TSC_CR_SSD_Pos)                     /*!< 0x00040000 */
N#define TSC_CR_SSD_2             (0x04U << TSC_CR_SSD_Pos)                     /*!< 0x00080000 */
N#define TSC_CR_SSD_3             (0x08U << TSC_CR_SSD_Pos)                     /*!< 0x00100000 */
N#define TSC_CR_SSD_4             (0x10U << TSC_CR_SSD_Pos)                     /*!< 0x00200000 */
N#define TSC_CR_SSD_5             (0x20U << TSC_CR_SSD_Pos)                     /*!< 0x00400000 */
N#define TSC_CR_SSD_6             (0x40U << TSC_CR_SSD_Pos)                     /*!< 0x00800000 */
N
N#define TSC_CR_CTPL_Pos          (24U)                                         
N#define TSC_CR_CTPL_Msk          (0xFU << TSC_CR_CTPL_Pos)                     /*!< 0x0F000000 */
N#define TSC_CR_CTPL              TSC_CR_CTPL_Msk                               /*!<CTPL[3:0] bits (Charge Transfer pulse low) */
N#define TSC_CR_CTPL_0            (0x1U << TSC_CR_CTPL_Pos)                     /*!< 0x01000000 */
N#define TSC_CR_CTPL_1            (0x2U << TSC_CR_CTPL_Pos)                     /*!< 0x02000000 */
N#define TSC_CR_CTPL_2            (0x4U << TSC_CR_CTPL_Pos)                     /*!< 0x04000000 */
N#define TSC_CR_CTPL_3            (0x8U << TSC_CR_CTPL_Pos)                     /*!< 0x08000000 */
N
N#define TSC_CR_CTPH_Pos          (28U)                                         
N#define TSC_CR_CTPH_Msk          (0xFU << TSC_CR_CTPH_Pos)                     /*!< 0xF0000000 */
N#define TSC_CR_CTPH              TSC_CR_CTPH_Msk                               /*!<CTPH[3:0] bits (Charge Transfer pulse high) */
N#define TSC_CR_CTPH_0            (0x1U << TSC_CR_CTPH_Pos)                     /*!< 0x10000000 */
N#define TSC_CR_CTPH_1            (0x2U << TSC_CR_CTPH_Pos)                     /*!< 0x20000000 */
N#define TSC_CR_CTPH_2            (0x4U << TSC_CR_CTPH_Pos)                     /*!< 0x40000000 */
N#define TSC_CR_CTPH_3            (0x8U << TSC_CR_CTPH_Pos)                     /*!< 0x80000000 */
N
N/*******************  Bit definition for TSC_IER register  ********************/
N#define TSC_IER_EOAIE_Pos        (0U)                                          
N#define TSC_IER_EOAIE_Msk        (0x1U << TSC_IER_EOAIE_Pos)                   /*!< 0x00000001 */
N#define TSC_IER_EOAIE            TSC_IER_EOAIE_Msk                             /*!<End of acquisition interrupt enable */
N#define TSC_IER_MCEIE_Pos        (1U)                                          
N#define TSC_IER_MCEIE_Msk        (0x1U << TSC_IER_MCEIE_Pos)                   /*!< 0x00000002 */
N#define TSC_IER_MCEIE            TSC_IER_MCEIE_Msk                             /*!<Max count error interrupt enable */
N
N/*******************  Bit definition for TSC_ICR register  ********************/
N#define TSC_ICR_EOAIC_Pos        (0U)                                          
N#define TSC_ICR_EOAIC_Msk        (0x1U << TSC_ICR_EOAIC_Pos)                   /*!< 0x00000001 */
N#define TSC_ICR_EOAIC            TSC_ICR_EOAIC_Msk                             /*!<End of acquisition interrupt clear */
N#define TSC_ICR_MCEIC_Pos        (1U)                                          
N#define TSC_ICR_MCEIC_Msk        (0x1U << TSC_ICR_MCEIC_Pos)                   /*!< 0x00000002 */
N#define TSC_ICR_MCEIC            TSC_ICR_MCEIC_Msk                             /*!<Max count error interrupt clear */
N
N/*******************  Bit definition for TSC_ISR register  ********************/
N#define TSC_ISR_EOAF_Pos         (0U)                                          
N#define TSC_ISR_EOAF_Msk         (0x1U << TSC_ISR_EOAF_Pos)                    /*!< 0x00000001 */
N#define TSC_ISR_EOAF             TSC_ISR_EOAF_Msk                              /*!<End of acquisition flag */
N#define TSC_ISR_MCEF_Pos         (1U)                                          
N#define TSC_ISR_MCEF_Msk         (0x1U << TSC_ISR_MCEF_Pos)                    /*!< 0x00000002 */
N#define TSC_ISR_MCEF             TSC_ISR_MCEF_Msk                              /*!<Max count error flag */
N
N/*******************  Bit definition for TSC_IOHCR register  ******************/
N#define TSC_IOHCR_G1_IO1_Pos     (0U)                                          
N#define TSC_IOHCR_G1_IO1_Msk     (0x1U << TSC_IOHCR_G1_IO1_Pos)                /*!< 0x00000001 */
N#define TSC_IOHCR_G1_IO1         TSC_IOHCR_G1_IO1_Msk                          /*!<GROUP1_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G1_IO2_Pos     (1U)                                          
N#define TSC_IOHCR_G1_IO2_Msk     (0x1U << TSC_IOHCR_G1_IO2_Pos)                /*!< 0x00000002 */
N#define TSC_IOHCR_G1_IO2         TSC_IOHCR_G1_IO2_Msk                          /*!<GROUP1_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G1_IO3_Pos     (2U)                                          
N#define TSC_IOHCR_G1_IO3_Msk     (0x1U << TSC_IOHCR_G1_IO3_Pos)                /*!< 0x00000004 */
N#define TSC_IOHCR_G1_IO3         TSC_IOHCR_G1_IO3_Msk                          /*!<GROUP1_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G1_IO4_Pos     (3U)                                          
N#define TSC_IOHCR_G1_IO4_Msk     (0x1U << TSC_IOHCR_G1_IO4_Pos)                /*!< 0x00000008 */
N#define TSC_IOHCR_G1_IO4         TSC_IOHCR_G1_IO4_Msk                          /*!<GROUP1_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G2_IO1_Pos     (4U)                                          
N#define TSC_IOHCR_G2_IO1_Msk     (0x1U << TSC_IOHCR_G2_IO1_Pos)                /*!< 0x00000010 */
N#define TSC_IOHCR_G2_IO1         TSC_IOHCR_G2_IO1_Msk                          /*!<GROUP2_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G2_IO2_Pos     (5U)                                          
N#define TSC_IOHCR_G2_IO2_Msk     (0x1U << TSC_IOHCR_G2_IO2_Pos)                /*!< 0x00000020 */
N#define TSC_IOHCR_G2_IO2         TSC_IOHCR_G2_IO2_Msk                          /*!<GROUP2_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G2_IO3_Pos     (6U)                                          
N#define TSC_IOHCR_G2_IO3_Msk     (0x1U << TSC_IOHCR_G2_IO3_Pos)                /*!< 0x00000040 */
N#define TSC_IOHCR_G2_IO3         TSC_IOHCR_G2_IO3_Msk                          /*!<GROUP2_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G2_IO4_Pos     (7U)                                          
N#define TSC_IOHCR_G2_IO4_Msk     (0x1U << TSC_IOHCR_G2_IO4_Pos)                /*!< 0x00000080 */
N#define TSC_IOHCR_G2_IO4         TSC_IOHCR_G2_IO4_Msk                          /*!<GROUP2_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G3_IO1_Pos     (8U)                                          
N#define TSC_IOHCR_G3_IO1_Msk     (0x1U << TSC_IOHCR_G3_IO1_Pos)                /*!< 0x00000100 */
N#define TSC_IOHCR_G3_IO1         TSC_IOHCR_G3_IO1_Msk                          /*!<GROUP3_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G3_IO2_Pos     (9U)                                          
N#define TSC_IOHCR_G3_IO2_Msk     (0x1U << TSC_IOHCR_G3_IO2_Pos)                /*!< 0x00000200 */
N#define TSC_IOHCR_G3_IO2         TSC_IOHCR_G3_IO2_Msk                          /*!<GROUP3_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G3_IO3_Pos     (10U)                                         
N#define TSC_IOHCR_G3_IO3_Msk     (0x1U << TSC_IOHCR_G3_IO3_Pos)                /*!< 0x00000400 */
N#define TSC_IOHCR_G3_IO3         TSC_IOHCR_G3_IO3_Msk                          /*!<GROUP3_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G3_IO4_Pos     (11U)                                         
N#define TSC_IOHCR_G3_IO4_Msk     (0x1U << TSC_IOHCR_G3_IO4_Pos)                /*!< 0x00000800 */
N#define TSC_IOHCR_G3_IO4         TSC_IOHCR_G3_IO4_Msk                          /*!<GROUP3_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G4_IO1_Pos     (12U)                                         
N#define TSC_IOHCR_G4_IO1_Msk     (0x1U << TSC_IOHCR_G4_IO1_Pos)                /*!< 0x00001000 */
N#define TSC_IOHCR_G4_IO1         TSC_IOHCR_G4_IO1_Msk                          /*!<GROUP4_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G4_IO2_Pos     (13U)                                         
N#define TSC_IOHCR_G4_IO2_Msk     (0x1U << TSC_IOHCR_G4_IO2_Pos)                /*!< 0x00002000 */
N#define TSC_IOHCR_G4_IO2         TSC_IOHCR_G4_IO2_Msk                          /*!<GROUP4_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G4_IO3_Pos     (14U)                                         
N#define TSC_IOHCR_G4_IO3_Msk     (0x1U << TSC_IOHCR_G4_IO3_Pos)                /*!< 0x00004000 */
N#define TSC_IOHCR_G4_IO3         TSC_IOHCR_G4_IO3_Msk                          /*!<GROUP4_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G4_IO4_Pos     (15U)                                         
N#define TSC_IOHCR_G4_IO4_Msk     (0x1U << TSC_IOHCR_G4_IO4_Pos)                /*!< 0x00008000 */
N#define TSC_IOHCR_G4_IO4         TSC_IOHCR_G4_IO4_Msk                          /*!<GROUP4_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G5_IO1_Pos     (16U)                                         
N#define TSC_IOHCR_G5_IO1_Msk     (0x1U << TSC_IOHCR_G5_IO1_Pos)                /*!< 0x00010000 */
N#define TSC_IOHCR_G5_IO1         TSC_IOHCR_G5_IO1_Msk                          /*!<GROUP5_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G5_IO2_Pos     (17U)                                         
N#define TSC_IOHCR_G5_IO2_Msk     (0x1U << TSC_IOHCR_G5_IO2_Pos)                /*!< 0x00020000 */
N#define TSC_IOHCR_G5_IO2         TSC_IOHCR_G5_IO2_Msk                          /*!<GROUP5_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G5_IO3_Pos     (18U)                                         
N#define TSC_IOHCR_G5_IO3_Msk     (0x1U << TSC_IOHCR_G5_IO3_Pos)                /*!< 0x00040000 */
N#define TSC_IOHCR_G5_IO3         TSC_IOHCR_G5_IO3_Msk                          /*!<GROUP5_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G5_IO4_Pos     (19U)                                         
N#define TSC_IOHCR_G5_IO4_Msk     (0x1U << TSC_IOHCR_G5_IO4_Pos)                /*!< 0x00080000 */
N#define TSC_IOHCR_G5_IO4         TSC_IOHCR_G5_IO4_Msk                          /*!<GROUP5_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G6_IO1_Pos     (20U)                                         
N#define TSC_IOHCR_G6_IO1_Msk     (0x1U << TSC_IOHCR_G6_IO1_Pos)                /*!< 0x00100000 */
N#define TSC_IOHCR_G6_IO1         TSC_IOHCR_G6_IO1_Msk                          /*!<GROUP6_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G6_IO2_Pos     (21U)                                         
N#define TSC_IOHCR_G6_IO2_Msk     (0x1U << TSC_IOHCR_G6_IO2_Pos)                /*!< 0x00200000 */
N#define TSC_IOHCR_G6_IO2         TSC_IOHCR_G6_IO2_Msk                          /*!<GROUP6_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G6_IO3_Pos     (22U)                                         
N#define TSC_IOHCR_G6_IO3_Msk     (0x1U << TSC_IOHCR_G6_IO3_Pos)                /*!< 0x00400000 */
N#define TSC_IOHCR_G6_IO3         TSC_IOHCR_G6_IO3_Msk                          /*!<GROUP6_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G6_IO4_Pos     (23U)                                         
N#define TSC_IOHCR_G6_IO4_Msk     (0x1U << TSC_IOHCR_G6_IO4_Pos)                /*!< 0x00800000 */
N#define TSC_IOHCR_G6_IO4         TSC_IOHCR_G6_IO4_Msk                          /*!<GROUP6_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G7_IO1_Pos     (24U)                                         
N#define TSC_IOHCR_G7_IO1_Msk     (0x1U << TSC_IOHCR_G7_IO1_Pos)                /*!< 0x01000000 */
N#define TSC_IOHCR_G7_IO1         TSC_IOHCR_G7_IO1_Msk                          /*!<GROUP7_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G7_IO2_Pos     (25U)                                         
N#define TSC_IOHCR_G7_IO2_Msk     (0x1U << TSC_IOHCR_G7_IO2_Pos)                /*!< 0x02000000 */
N#define TSC_IOHCR_G7_IO2         TSC_IOHCR_G7_IO2_Msk                          /*!<GROUP7_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G7_IO3_Pos     (26U)                                         
N#define TSC_IOHCR_G7_IO3_Msk     (0x1U << TSC_IOHCR_G7_IO3_Pos)                /*!< 0x04000000 */
N#define TSC_IOHCR_G7_IO3         TSC_IOHCR_G7_IO3_Msk                          /*!<GROUP7_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G7_IO4_Pos     (27U)                                         
N#define TSC_IOHCR_G7_IO4_Msk     (0x1U << TSC_IOHCR_G7_IO4_Pos)                /*!< 0x08000000 */
N#define TSC_IOHCR_G7_IO4         TSC_IOHCR_G7_IO4_Msk                          /*!<GROUP7_IO4 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G8_IO1_Pos     (28U)                                         
N#define TSC_IOHCR_G8_IO1_Msk     (0x1U << TSC_IOHCR_G8_IO1_Pos)                /*!< 0x10000000 */
N#define TSC_IOHCR_G8_IO1         TSC_IOHCR_G8_IO1_Msk                          /*!<GROUP8_IO1 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G8_IO2_Pos     (29U)                                         
N#define TSC_IOHCR_G8_IO2_Msk     (0x1U << TSC_IOHCR_G8_IO2_Pos)                /*!< 0x20000000 */
N#define TSC_IOHCR_G8_IO2         TSC_IOHCR_G8_IO2_Msk                          /*!<GROUP8_IO2 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G8_IO3_Pos     (30U)                                         
N#define TSC_IOHCR_G8_IO3_Msk     (0x1U << TSC_IOHCR_G8_IO3_Pos)                /*!< 0x40000000 */
N#define TSC_IOHCR_G8_IO3         TSC_IOHCR_G8_IO3_Msk                          /*!<GROUP8_IO3 schmitt trigger hysteresis mode */
N#define TSC_IOHCR_G8_IO4_Pos     (31U)                                         
N#define TSC_IOHCR_G8_IO4_Msk     (0x1U << TSC_IOHCR_G8_IO4_Pos)                /*!< 0x80000000 */
N#define TSC_IOHCR_G8_IO4         TSC_IOHCR_G8_IO4_Msk                          /*!<GROUP8_IO4 schmitt trigger hysteresis mode */
N
N/*******************  Bit definition for TSC_IOASCR register  *****************/
N#define TSC_IOASCR_G1_IO1_Pos    (0U)                                          
N#define TSC_IOASCR_G1_IO1_Msk    (0x1U << TSC_IOASCR_G1_IO1_Pos)               /*!< 0x00000001 */
N#define TSC_IOASCR_G1_IO1        TSC_IOASCR_G1_IO1_Msk                         /*!<GROUP1_IO1 analog switch enable */
N#define TSC_IOASCR_G1_IO2_Pos    (1U)                                          
N#define TSC_IOASCR_G1_IO2_Msk    (0x1U << TSC_IOASCR_G1_IO2_Pos)               /*!< 0x00000002 */
N#define TSC_IOASCR_G1_IO2        TSC_IOASCR_G1_IO2_Msk                         /*!<GROUP1_IO2 analog switch enable */
N#define TSC_IOASCR_G1_IO3_Pos    (2U)                                          
N#define TSC_IOASCR_G1_IO3_Msk    (0x1U << TSC_IOASCR_G1_IO3_Pos)               /*!< 0x00000004 */
N#define TSC_IOASCR_G1_IO3        TSC_IOASCR_G1_IO3_Msk                         /*!<GROUP1_IO3 analog switch enable */
N#define TSC_IOASCR_G1_IO4_Pos    (3U)                                          
N#define TSC_IOASCR_G1_IO4_Msk    (0x1U << TSC_IOASCR_G1_IO4_Pos)               /*!< 0x00000008 */
N#define TSC_IOASCR_G1_IO4        TSC_IOASCR_G1_IO4_Msk                         /*!<GROUP1_IO4 analog switch enable */
N#define TSC_IOASCR_G2_IO1_Pos    (4U)                                          
N#define TSC_IOASCR_G2_IO1_Msk    (0x1U << TSC_IOASCR_G2_IO1_Pos)               /*!< 0x00000010 */
N#define TSC_IOASCR_G2_IO1        TSC_IOASCR_G2_IO1_Msk                         /*!<GROUP2_IO1 analog switch enable */
N#define TSC_IOASCR_G2_IO2_Pos    (5U)                                          
N#define TSC_IOASCR_G2_IO2_Msk    (0x1U << TSC_IOASCR_G2_IO2_Pos)               /*!< 0x00000020 */
N#define TSC_IOASCR_G2_IO2        TSC_IOASCR_G2_IO2_Msk                         /*!<GROUP2_IO2 analog switch enable */
N#define TSC_IOASCR_G2_IO3_Pos    (6U)                                          
N#define TSC_IOASCR_G2_IO3_Msk    (0x1U << TSC_IOASCR_G2_IO3_Pos)               /*!< 0x00000040 */
N#define TSC_IOASCR_G2_IO3        TSC_IOASCR_G2_IO3_Msk                         /*!<GROUP2_IO3 analog switch enable */
N#define TSC_IOASCR_G2_IO4_Pos    (7U)                                          
N#define TSC_IOASCR_G2_IO4_Msk    (0x1U << TSC_IOASCR_G2_IO4_Pos)               /*!< 0x00000080 */
N#define TSC_IOASCR_G2_IO4        TSC_IOASCR_G2_IO4_Msk                         /*!<GROUP2_IO4 analog switch enable */
N#define TSC_IOASCR_G3_IO1_Pos    (8U)                                          
N#define TSC_IOASCR_G3_IO1_Msk    (0x1U << TSC_IOASCR_G3_IO1_Pos)               /*!< 0x00000100 */
N#define TSC_IOASCR_G3_IO1        TSC_IOASCR_G3_IO1_Msk                         /*!<GROUP3_IO1 analog switch enable */
N#define TSC_IOASCR_G3_IO2_Pos    (9U)                                          
N#define TSC_IOASCR_G3_IO2_Msk    (0x1U << TSC_IOASCR_G3_IO2_Pos)               /*!< 0x00000200 */
N#define TSC_IOASCR_G3_IO2        TSC_IOASCR_G3_IO2_Msk                         /*!<GROUP3_IO2 analog switch enable */
N#define TSC_IOASCR_G3_IO3_Pos    (10U)                                         
N#define TSC_IOASCR_G3_IO3_Msk    (0x1U << TSC_IOASCR_G3_IO3_Pos)               /*!< 0x00000400 */
N#define TSC_IOASCR_G3_IO3        TSC_IOASCR_G3_IO3_Msk                         /*!<GROUP3_IO3 analog switch enable */
N#define TSC_IOASCR_G3_IO4_Pos    (11U)                                         
N#define TSC_IOASCR_G3_IO4_Msk    (0x1U << TSC_IOASCR_G3_IO4_Pos)               /*!< 0x00000800 */
N#define TSC_IOASCR_G3_IO4        TSC_IOASCR_G3_IO4_Msk                         /*!<GROUP3_IO4 analog switch enable */
N#define TSC_IOASCR_G4_IO1_Pos    (12U)                                         
N#define TSC_IOASCR_G4_IO1_Msk    (0x1U << TSC_IOASCR_G4_IO1_Pos)               /*!< 0x00001000 */
N#define TSC_IOASCR_G4_IO1        TSC_IOASCR_G4_IO1_Msk                         /*!<GROUP4_IO1 analog switch enable */
N#define TSC_IOASCR_G4_IO2_Pos    (13U)                                         
N#define TSC_IOASCR_G4_IO2_Msk    (0x1U << TSC_IOASCR_G4_IO2_Pos)               /*!< 0x00002000 */
N#define TSC_IOASCR_G4_IO2        TSC_IOASCR_G4_IO2_Msk                         /*!<GROUP4_IO2 analog switch enable */
N#define TSC_IOASCR_G4_IO3_Pos    (14U)                                         
N#define TSC_IOASCR_G4_IO3_Msk    (0x1U << TSC_IOASCR_G4_IO3_Pos)               /*!< 0x00004000 */
N#define TSC_IOASCR_G4_IO3        TSC_IOASCR_G4_IO3_Msk                         /*!<GROUP4_IO3 analog switch enable */
N#define TSC_IOASCR_G4_IO4_Pos    (15U)                                         
N#define TSC_IOASCR_G4_IO4_Msk    (0x1U << TSC_IOASCR_G4_IO4_Pos)               /*!< 0x00008000 */
N#define TSC_IOASCR_G4_IO4        TSC_IOASCR_G4_IO4_Msk                         /*!<GROUP4_IO4 analog switch enable */
N#define TSC_IOASCR_G5_IO1_Pos    (16U)                                         
N#define TSC_IOASCR_G5_IO1_Msk    (0x1U << TSC_IOASCR_G5_IO1_Pos)               /*!< 0x00010000 */
N#define TSC_IOASCR_G5_IO1        TSC_IOASCR_G5_IO1_Msk                         /*!<GROUP5_IO1 analog switch enable */
N#define TSC_IOASCR_G5_IO2_Pos    (17U)                                         
N#define TSC_IOASCR_G5_IO2_Msk    (0x1U << TSC_IOASCR_G5_IO2_Pos)               /*!< 0x00020000 */
N#define TSC_IOASCR_G5_IO2        TSC_IOASCR_G5_IO2_Msk                         /*!<GROUP5_IO2 analog switch enable */
N#define TSC_IOASCR_G5_IO3_Pos    (18U)                                         
N#define TSC_IOASCR_G5_IO3_Msk    (0x1U << TSC_IOASCR_G5_IO3_Pos)               /*!< 0x00040000 */
N#define TSC_IOASCR_G5_IO3        TSC_IOASCR_G5_IO3_Msk                         /*!<GROUP5_IO3 analog switch enable */
N#define TSC_IOASCR_G5_IO4_Pos    (19U)                                         
N#define TSC_IOASCR_G5_IO4_Msk    (0x1U << TSC_IOASCR_G5_IO4_Pos)               /*!< 0x00080000 */
N#define TSC_IOASCR_G5_IO4        TSC_IOASCR_G5_IO4_Msk                         /*!<GROUP5_IO4 analog switch enable */
N#define TSC_IOASCR_G6_IO1_Pos    (20U)                                         
N#define TSC_IOASCR_G6_IO1_Msk    (0x1U << TSC_IOASCR_G6_IO1_Pos)               /*!< 0x00100000 */
N#define TSC_IOASCR_G6_IO1        TSC_IOASCR_G6_IO1_Msk                         /*!<GROUP6_IO1 analog switch enable */
N#define TSC_IOASCR_G6_IO2_Pos    (21U)                                         
N#define TSC_IOASCR_G6_IO2_Msk    (0x1U << TSC_IOASCR_G6_IO2_Pos)               /*!< 0x00200000 */
N#define TSC_IOASCR_G6_IO2        TSC_IOASCR_G6_IO2_Msk                         /*!<GROUP6_IO2 analog switch enable */
N#define TSC_IOASCR_G6_IO3_Pos    (22U)                                         
N#define TSC_IOASCR_G6_IO3_Msk    (0x1U << TSC_IOASCR_G6_IO3_Pos)               /*!< 0x00400000 */
N#define TSC_IOASCR_G6_IO3        TSC_IOASCR_G6_IO3_Msk                         /*!<GROUP6_IO3 analog switch enable */
N#define TSC_IOASCR_G6_IO4_Pos    (23U)                                         
N#define TSC_IOASCR_G6_IO4_Msk    (0x1U << TSC_IOASCR_G6_IO4_Pos)               /*!< 0x00800000 */
N#define TSC_IOASCR_G6_IO4        TSC_IOASCR_G6_IO4_Msk                         /*!<GROUP6_IO4 analog switch enable */
N#define TSC_IOASCR_G7_IO1_Pos    (24U)                                         
N#define TSC_IOASCR_G7_IO1_Msk    (0x1U << TSC_IOASCR_G7_IO1_Pos)               /*!< 0x01000000 */
N#define TSC_IOASCR_G7_IO1        TSC_IOASCR_G7_IO1_Msk                         /*!<GROUP7_IO1 analog switch enable */
N#define TSC_IOASCR_G7_IO2_Pos    (25U)                                         
N#define TSC_IOASCR_G7_IO2_Msk    (0x1U << TSC_IOASCR_G7_IO2_Pos)               /*!< 0x02000000 */
N#define TSC_IOASCR_G7_IO2        TSC_IOASCR_G7_IO2_Msk                         /*!<GROUP7_IO2 analog switch enable */
N#define TSC_IOASCR_G7_IO3_Pos    (26U)                                         
N#define TSC_IOASCR_G7_IO3_Msk    (0x1U << TSC_IOASCR_G7_IO3_Pos)               /*!< 0x04000000 */
N#define TSC_IOASCR_G7_IO3        TSC_IOASCR_G7_IO3_Msk                         /*!<GROUP7_IO3 analog switch enable */
N#define TSC_IOASCR_G7_IO4_Pos    (27U)                                         
N#define TSC_IOASCR_G7_IO4_Msk    (0x1U << TSC_IOASCR_G7_IO4_Pos)               /*!< 0x08000000 */
N#define TSC_IOASCR_G7_IO4        TSC_IOASCR_G7_IO4_Msk                         /*!<GROUP7_IO4 analog switch enable */
N#define TSC_IOASCR_G8_IO1_Pos    (28U)                                         
N#define TSC_IOASCR_G8_IO1_Msk    (0x1U << TSC_IOASCR_G8_IO1_Pos)               /*!< 0x10000000 */
N#define TSC_IOASCR_G8_IO1        TSC_IOASCR_G8_IO1_Msk                         /*!<GROUP8_IO1 analog switch enable */
N#define TSC_IOASCR_G8_IO2_Pos    (29U)                                         
N#define TSC_IOASCR_G8_IO2_Msk    (0x1U << TSC_IOASCR_G8_IO2_Pos)               /*!< 0x20000000 */
N#define TSC_IOASCR_G8_IO2        TSC_IOASCR_G8_IO2_Msk                         /*!<GROUP8_IO2 analog switch enable */
N#define TSC_IOASCR_G8_IO3_Pos    (30U)                                         
N#define TSC_IOASCR_G8_IO3_Msk    (0x1U << TSC_IOASCR_G8_IO3_Pos)               /*!< 0x40000000 */
N#define TSC_IOASCR_G8_IO3        TSC_IOASCR_G8_IO3_Msk                         /*!<GROUP8_IO3 analog switch enable */
N#define TSC_IOASCR_G8_IO4_Pos    (31U)                                         
N#define TSC_IOASCR_G8_IO4_Msk    (0x1U << TSC_IOASCR_G8_IO4_Pos)               /*!< 0x80000000 */
N#define TSC_IOASCR_G8_IO4        TSC_IOASCR_G8_IO4_Msk                         /*!<GROUP8_IO4 analog switch enable */
N
N/*******************  Bit definition for TSC_IOSCR register  ******************/
N#define TSC_IOSCR_G1_IO1_Pos     (0U)                                          
N#define TSC_IOSCR_G1_IO1_Msk     (0x1U << TSC_IOSCR_G1_IO1_Pos)                /*!< 0x00000001 */
N#define TSC_IOSCR_G1_IO1         TSC_IOSCR_G1_IO1_Msk                          /*!<GROUP1_IO1 sampling mode */
N#define TSC_IOSCR_G1_IO2_Pos     (1U)                                          
N#define TSC_IOSCR_G1_IO2_Msk     (0x1U << TSC_IOSCR_G1_IO2_Pos)                /*!< 0x00000002 */
N#define TSC_IOSCR_G1_IO2         TSC_IOSCR_G1_IO2_Msk                          /*!<GROUP1_IO2 sampling mode */
N#define TSC_IOSCR_G1_IO3_Pos     (2U)                                          
N#define TSC_IOSCR_G1_IO3_Msk     (0x1U << TSC_IOSCR_G1_IO3_Pos)                /*!< 0x00000004 */
N#define TSC_IOSCR_G1_IO3         TSC_IOSCR_G1_IO3_Msk                          /*!<GROUP1_IO3 sampling mode */
N#define TSC_IOSCR_G1_IO4_Pos     (3U)                                          
N#define TSC_IOSCR_G1_IO4_Msk     (0x1U << TSC_IOSCR_G1_IO4_Pos)                /*!< 0x00000008 */
N#define TSC_IOSCR_G1_IO4         TSC_IOSCR_G1_IO4_Msk                          /*!<GROUP1_IO4 sampling mode */
N#define TSC_IOSCR_G2_IO1_Pos     (4U)                                          
N#define TSC_IOSCR_G2_IO1_Msk     (0x1U << TSC_IOSCR_G2_IO1_Pos)                /*!< 0x00000010 */
N#define TSC_IOSCR_G2_IO1         TSC_IOSCR_G2_IO1_Msk                          /*!<GROUP2_IO1 sampling mode */
N#define TSC_IOSCR_G2_IO2_Pos     (5U)                                          
N#define TSC_IOSCR_G2_IO2_Msk     (0x1U << TSC_IOSCR_G2_IO2_Pos)                /*!< 0x00000020 */
N#define TSC_IOSCR_G2_IO2         TSC_IOSCR_G2_IO2_Msk                          /*!<GROUP2_IO2 sampling mode */
N#define TSC_IOSCR_G2_IO3_Pos     (6U)                                          
N#define TSC_IOSCR_G2_IO3_Msk     (0x1U << TSC_IOSCR_G2_IO3_Pos)                /*!< 0x00000040 */
N#define TSC_IOSCR_G2_IO3         TSC_IOSCR_G2_IO3_Msk                          /*!<GROUP2_IO3 sampling mode */
N#define TSC_IOSCR_G2_IO4_Pos     (7U)                                          
N#define TSC_IOSCR_G2_IO4_Msk     (0x1U << TSC_IOSCR_G2_IO4_Pos)                /*!< 0x00000080 */
N#define TSC_IOSCR_G2_IO4         TSC_IOSCR_G2_IO4_Msk                          /*!<GROUP2_IO4 sampling mode */
N#define TSC_IOSCR_G3_IO1_Pos     (8U)                                          
N#define TSC_IOSCR_G3_IO1_Msk     (0x1U << TSC_IOSCR_G3_IO1_Pos)                /*!< 0x00000100 */
N#define TSC_IOSCR_G3_IO1         TSC_IOSCR_G3_IO1_Msk                          /*!<GROUP3_IO1 sampling mode */
N#define TSC_IOSCR_G3_IO2_Pos     (9U)                                          
N#define TSC_IOSCR_G3_IO2_Msk     (0x1U << TSC_IOSCR_G3_IO2_Pos)                /*!< 0x00000200 */
N#define TSC_IOSCR_G3_IO2         TSC_IOSCR_G3_IO2_Msk                          /*!<GROUP3_IO2 sampling mode */
N#define TSC_IOSCR_G3_IO3_Pos     (10U)                                         
N#define TSC_IOSCR_G3_IO3_Msk     (0x1U << TSC_IOSCR_G3_IO3_Pos)                /*!< 0x00000400 */
N#define TSC_IOSCR_G3_IO3         TSC_IOSCR_G3_IO3_Msk                          /*!<GROUP3_IO3 sampling mode */
N#define TSC_IOSCR_G3_IO4_Pos     (11U)                                         
N#define TSC_IOSCR_G3_IO4_Msk     (0x1U << TSC_IOSCR_G3_IO4_Pos)                /*!< 0x00000800 */
N#define TSC_IOSCR_G3_IO4         TSC_IOSCR_G3_IO4_Msk                          /*!<GROUP3_IO4 sampling mode */
N#define TSC_IOSCR_G4_IO1_Pos     (12U)                                         
N#define TSC_IOSCR_G4_IO1_Msk     (0x1U << TSC_IOSCR_G4_IO1_Pos)                /*!< 0x00001000 */
N#define TSC_IOSCR_G4_IO1         TSC_IOSCR_G4_IO1_Msk                          /*!<GROUP4_IO1 sampling mode */
N#define TSC_IOSCR_G4_IO2_Pos     (13U)                                         
N#define TSC_IOSCR_G4_IO2_Msk     (0x1U << TSC_IOSCR_G4_IO2_Pos)                /*!< 0x00002000 */
N#define TSC_IOSCR_G4_IO2         TSC_IOSCR_G4_IO2_Msk                          /*!<GROUP4_IO2 sampling mode */
N#define TSC_IOSCR_G4_IO3_Pos     (14U)                                         
N#define TSC_IOSCR_G4_IO3_Msk     (0x1U << TSC_IOSCR_G4_IO3_Pos)                /*!< 0x00004000 */
N#define TSC_IOSCR_G4_IO3         TSC_IOSCR_G4_IO3_Msk                          /*!<GROUP4_IO3 sampling mode */
N#define TSC_IOSCR_G4_IO4_Pos     (15U)                                         
N#define TSC_IOSCR_G4_IO4_Msk     (0x1U << TSC_IOSCR_G4_IO4_Pos)                /*!< 0x00008000 */
N#define TSC_IOSCR_G4_IO4         TSC_IOSCR_G4_IO4_Msk                          /*!<GROUP4_IO4 sampling mode */
N#define TSC_IOSCR_G5_IO1_Pos     (16U)                                         
N#define TSC_IOSCR_G5_IO1_Msk     (0x1U << TSC_IOSCR_G5_IO1_Pos)                /*!< 0x00010000 */
N#define TSC_IOSCR_G5_IO1         TSC_IOSCR_G5_IO1_Msk                          /*!<GROUP5_IO1 sampling mode */
N#define TSC_IOSCR_G5_IO2_Pos     (17U)                                         
N#define TSC_IOSCR_G5_IO2_Msk     (0x1U << TSC_IOSCR_G5_IO2_Pos)                /*!< 0x00020000 */
N#define TSC_IOSCR_G5_IO2         TSC_IOSCR_G5_IO2_Msk                          /*!<GROUP5_IO2 sampling mode */
N#define TSC_IOSCR_G5_IO3_Pos     (18U)                                         
N#define TSC_IOSCR_G5_IO3_Msk     (0x1U << TSC_IOSCR_G5_IO3_Pos)                /*!< 0x00040000 */
N#define TSC_IOSCR_G5_IO3         TSC_IOSCR_G5_IO3_Msk                          /*!<GROUP5_IO3 sampling mode */
N#define TSC_IOSCR_G5_IO4_Pos     (19U)                                         
N#define TSC_IOSCR_G5_IO4_Msk     (0x1U << TSC_IOSCR_G5_IO4_Pos)                /*!< 0x00080000 */
N#define TSC_IOSCR_G5_IO4         TSC_IOSCR_G5_IO4_Msk                          /*!<GROUP5_IO4 sampling mode */
N#define TSC_IOSCR_G6_IO1_Pos     (20U)                                         
N#define TSC_IOSCR_G6_IO1_Msk     (0x1U << TSC_IOSCR_G6_IO1_Pos)                /*!< 0x00100000 */
N#define TSC_IOSCR_G6_IO1         TSC_IOSCR_G6_IO1_Msk                          /*!<GROUP6_IO1 sampling mode */
N#define TSC_IOSCR_G6_IO2_Pos     (21U)                                         
N#define TSC_IOSCR_G6_IO2_Msk     (0x1U << TSC_IOSCR_G6_IO2_Pos)                /*!< 0x00200000 */
N#define TSC_IOSCR_G6_IO2         TSC_IOSCR_G6_IO2_Msk                          /*!<GROUP6_IO2 sampling mode */
N#define TSC_IOSCR_G6_IO3_Pos     (22U)                                         
N#define TSC_IOSCR_G6_IO3_Msk     (0x1U << TSC_IOSCR_G6_IO3_Pos)                /*!< 0x00400000 */
N#define TSC_IOSCR_G6_IO3         TSC_IOSCR_G6_IO3_Msk                          /*!<GROUP6_IO3 sampling mode */
N#define TSC_IOSCR_G6_IO4_Pos     (23U)                                         
N#define TSC_IOSCR_G6_IO4_Msk     (0x1U << TSC_IOSCR_G6_IO4_Pos)                /*!< 0x00800000 */
N#define TSC_IOSCR_G6_IO4         TSC_IOSCR_G6_IO4_Msk                          /*!<GROUP6_IO4 sampling mode */
N#define TSC_IOSCR_G7_IO1_Pos     (24U)                                         
N#define TSC_IOSCR_G7_IO1_Msk     (0x1U << TSC_IOSCR_G7_IO1_Pos)                /*!< 0x01000000 */
N#define TSC_IOSCR_G7_IO1         TSC_IOSCR_G7_IO1_Msk                          /*!<GROUP7_IO1 sampling mode */
N#define TSC_IOSCR_G7_IO2_Pos     (25U)                                         
N#define TSC_IOSCR_G7_IO2_Msk     (0x1U << TSC_IOSCR_G7_IO2_Pos)                /*!< 0x02000000 */
N#define TSC_IOSCR_G7_IO2         TSC_IOSCR_G7_IO2_Msk                          /*!<GROUP7_IO2 sampling mode */
N#define TSC_IOSCR_G7_IO3_Pos     (26U)                                         
N#define TSC_IOSCR_G7_IO3_Msk     (0x1U << TSC_IOSCR_G7_IO3_Pos)                /*!< 0x04000000 */
N#define TSC_IOSCR_G7_IO3         TSC_IOSCR_G7_IO3_Msk                          /*!<GROUP7_IO3 sampling mode */
N#define TSC_IOSCR_G7_IO4_Pos     (27U)                                         
N#define TSC_IOSCR_G7_IO4_Msk     (0x1U << TSC_IOSCR_G7_IO4_Pos)                /*!< 0x08000000 */
N#define TSC_IOSCR_G7_IO4         TSC_IOSCR_G7_IO4_Msk                          /*!<GROUP7_IO4 sampling mode */
N#define TSC_IOSCR_G8_IO1_Pos     (28U)                                         
N#define TSC_IOSCR_G8_IO1_Msk     (0x1U << TSC_IOSCR_G8_IO1_Pos)                /*!< 0x10000000 */
N#define TSC_IOSCR_G8_IO1         TSC_IOSCR_G8_IO1_Msk                          /*!<GROUP8_IO1 sampling mode */
N#define TSC_IOSCR_G8_IO2_Pos     (29U)                                         
N#define TSC_IOSCR_G8_IO2_Msk     (0x1U << TSC_IOSCR_G8_IO2_Pos)                /*!< 0x20000000 */
N#define TSC_IOSCR_G8_IO2         TSC_IOSCR_G8_IO2_Msk                          /*!<GROUP8_IO2 sampling mode */
N#define TSC_IOSCR_G8_IO3_Pos     (30U)                                         
N#define TSC_IOSCR_G8_IO3_Msk     (0x1U << TSC_IOSCR_G8_IO3_Pos)                /*!< 0x40000000 */
N#define TSC_IOSCR_G8_IO3         TSC_IOSCR_G8_IO3_Msk                          /*!<GROUP8_IO3 sampling mode */
N#define TSC_IOSCR_G8_IO4_Pos     (31U)                                         
N#define TSC_IOSCR_G8_IO4_Msk     (0x1U << TSC_IOSCR_G8_IO4_Pos)                /*!< 0x80000000 */
N#define TSC_IOSCR_G8_IO4         TSC_IOSCR_G8_IO4_Msk                          /*!<GROUP8_IO4 sampling mode */
N
N/*******************  Bit definition for TSC_IOCCR register  ******************/
N#define TSC_IOCCR_G1_IO1_Pos     (0U)                                          
N#define TSC_IOCCR_G1_IO1_Msk     (0x1U << TSC_IOCCR_G1_IO1_Pos)                /*!< 0x00000001 */
N#define TSC_IOCCR_G1_IO1         TSC_IOCCR_G1_IO1_Msk                          /*!<GROUP1_IO1 channel mode */
N#define TSC_IOCCR_G1_IO2_Pos     (1U)                                          
N#define TSC_IOCCR_G1_IO2_Msk     (0x1U << TSC_IOCCR_G1_IO2_Pos)                /*!< 0x00000002 */
N#define TSC_IOCCR_G1_IO2         TSC_IOCCR_G1_IO2_Msk                          /*!<GROUP1_IO2 channel mode */
N#define TSC_IOCCR_G1_IO3_Pos     (2U)                                          
N#define TSC_IOCCR_G1_IO3_Msk     (0x1U << TSC_IOCCR_G1_IO3_Pos)                /*!< 0x00000004 */
N#define TSC_IOCCR_G1_IO3         TSC_IOCCR_G1_IO3_Msk                          /*!<GROUP1_IO3 channel mode */
N#define TSC_IOCCR_G1_IO4_Pos     (3U)                                          
N#define TSC_IOCCR_G1_IO4_Msk     (0x1U << TSC_IOCCR_G1_IO4_Pos)                /*!< 0x00000008 */
N#define TSC_IOCCR_G1_IO4         TSC_IOCCR_G1_IO4_Msk                          /*!<GROUP1_IO4 channel mode */
N#define TSC_IOCCR_G2_IO1_Pos     (4U)                                          
N#define TSC_IOCCR_G2_IO1_Msk     (0x1U << TSC_IOCCR_G2_IO1_Pos)                /*!< 0x00000010 */
N#define TSC_IOCCR_G2_IO1         TSC_IOCCR_G2_IO1_Msk                          /*!<GROUP2_IO1 channel mode */
N#define TSC_IOCCR_G2_IO2_Pos     (5U)                                          
N#define TSC_IOCCR_G2_IO2_Msk     (0x1U << TSC_IOCCR_G2_IO2_Pos)                /*!< 0x00000020 */
N#define TSC_IOCCR_G2_IO2         TSC_IOCCR_G2_IO2_Msk                          /*!<GROUP2_IO2 channel mode */
N#define TSC_IOCCR_G2_IO3_Pos     (6U)                                          
N#define TSC_IOCCR_G2_IO3_Msk     (0x1U << TSC_IOCCR_G2_IO3_Pos)                /*!< 0x00000040 */
N#define TSC_IOCCR_G2_IO3         TSC_IOCCR_G2_IO3_Msk                          /*!<GROUP2_IO3 channel mode */
N#define TSC_IOCCR_G2_IO4_Pos     (7U)                                          
N#define TSC_IOCCR_G2_IO4_Msk     (0x1U << TSC_IOCCR_G2_IO4_Pos)                /*!< 0x00000080 */
N#define TSC_IOCCR_G2_IO4         TSC_IOCCR_G2_IO4_Msk                          /*!<GROUP2_IO4 channel mode */
N#define TSC_IOCCR_G3_IO1_Pos     (8U)                                          
N#define TSC_IOCCR_G3_IO1_Msk     (0x1U << TSC_IOCCR_G3_IO1_Pos)                /*!< 0x00000100 */
N#define TSC_IOCCR_G3_IO1         TSC_IOCCR_G3_IO1_Msk                          /*!<GROUP3_IO1 channel mode */
N#define TSC_IOCCR_G3_IO2_Pos     (9U)                                          
N#define TSC_IOCCR_G3_IO2_Msk     (0x1U << TSC_IOCCR_G3_IO2_Pos)                /*!< 0x00000200 */
N#define TSC_IOCCR_G3_IO2         TSC_IOCCR_G3_IO2_Msk                          /*!<GROUP3_IO2 channel mode */
N#define TSC_IOCCR_G3_IO3_Pos     (10U)                                         
N#define TSC_IOCCR_G3_IO3_Msk     (0x1U << TSC_IOCCR_G3_IO3_Pos)                /*!< 0x00000400 */
N#define TSC_IOCCR_G3_IO3         TSC_IOCCR_G3_IO3_Msk                          /*!<GROUP3_IO3 channel mode */
N#define TSC_IOCCR_G3_IO4_Pos     (11U)                                         
N#define TSC_IOCCR_G3_IO4_Msk     (0x1U << TSC_IOCCR_G3_IO4_Pos)                /*!< 0x00000800 */
N#define TSC_IOCCR_G3_IO4         TSC_IOCCR_G3_IO4_Msk                          /*!<GROUP3_IO4 channel mode */
N#define TSC_IOCCR_G4_IO1_Pos     (12U)                                         
N#define TSC_IOCCR_G4_IO1_Msk     (0x1U << TSC_IOCCR_G4_IO1_Pos)                /*!< 0x00001000 */
N#define TSC_IOCCR_G4_IO1         TSC_IOCCR_G4_IO1_Msk                          /*!<GROUP4_IO1 channel mode */
N#define TSC_IOCCR_G4_IO2_Pos     (13U)                                         
N#define TSC_IOCCR_G4_IO2_Msk     (0x1U << TSC_IOCCR_G4_IO2_Pos)                /*!< 0x00002000 */
N#define TSC_IOCCR_G4_IO2         TSC_IOCCR_G4_IO2_Msk                          /*!<GROUP4_IO2 channel mode */
N#define TSC_IOCCR_G4_IO3_Pos     (14U)                                         
N#define TSC_IOCCR_G4_IO3_Msk     (0x1U << TSC_IOCCR_G4_IO3_Pos)                /*!< 0x00004000 */
N#define TSC_IOCCR_G4_IO3         TSC_IOCCR_G4_IO3_Msk                          /*!<GROUP4_IO3 channel mode */
N#define TSC_IOCCR_G4_IO4_Pos     (15U)                                         
N#define TSC_IOCCR_G4_IO4_Msk     (0x1U << TSC_IOCCR_G4_IO4_Pos)                /*!< 0x00008000 */
N#define TSC_IOCCR_G4_IO4         TSC_IOCCR_G4_IO4_Msk                          /*!<GROUP4_IO4 channel mode */
N#define TSC_IOCCR_G5_IO1_Pos     (16U)                                         
N#define TSC_IOCCR_G5_IO1_Msk     (0x1U << TSC_IOCCR_G5_IO1_Pos)                /*!< 0x00010000 */
N#define TSC_IOCCR_G5_IO1         TSC_IOCCR_G5_IO1_Msk                          /*!<GROUP5_IO1 channel mode */
N#define TSC_IOCCR_G5_IO2_Pos     (17U)                                         
N#define TSC_IOCCR_G5_IO2_Msk     (0x1U << TSC_IOCCR_G5_IO2_Pos)                /*!< 0x00020000 */
N#define TSC_IOCCR_G5_IO2         TSC_IOCCR_G5_IO2_Msk                          /*!<GROUP5_IO2 channel mode */
N#define TSC_IOCCR_G5_IO3_Pos     (18U)                                         
N#define TSC_IOCCR_G5_IO3_Msk     (0x1U << TSC_IOCCR_G5_IO3_Pos)                /*!< 0x00040000 */
N#define TSC_IOCCR_G5_IO3         TSC_IOCCR_G5_IO3_Msk                          /*!<GROUP5_IO3 channel mode */
N#define TSC_IOCCR_G5_IO4_Pos     (19U)                                         
N#define TSC_IOCCR_G5_IO4_Msk     (0x1U << TSC_IOCCR_G5_IO4_Pos)                /*!< 0x00080000 */
N#define TSC_IOCCR_G5_IO4         TSC_IOCCR_G5_IO4_Msk                          /*!<GROUP5_IO4 channel mode */
N#define TSC_IOCCR_G6_IO1_Pos     (20U)                                         
N#define TSC_IOCCR_G6_IO1_Msk     (0x1U << TSC_IOCCR_G6_IO1_Pos)                /*!< 0x00100000 */
N#define TSC_IOCCR_G6_IO1         TSC_IOCCR_G6_IO1_Msk                          /*!<GROUP6_IO1 channel mode */
N#define TSC_IOCCR_G6_IO2_Pos     (21U)                                         
N#define TSC_IOCCR_G6_IO2_Msk     (0x1U << TSC_IOCCR_G6_IO2_Pos)                /*!< 0x00200000 */
N#define TSC_IOCCR_G6_IO2         TSC_IOCCR_G6_IO2_Msk                          /*!<GROUP6_IO2 channel mode */
N#define TSC_IOCCR_G6_IO3_Pos     (22U)                                         
N#define TSC_IOCCR_G6_IO3_Msk     (0x1U << TSC_IOCCR_G6_IO3_Pos)                /*!< 0x00400000 */
N#define TSC_IOCCR_G6_IO3         TSC_IOCCR_G6_IO3_Msk                          /*!<GROUP6_IO3 channel mode */
N#define TSC_IOCCR_G6_IO4_Pos     (23U)                                         
N#define TSC_IOCCR_G6_IO4_Msk     (0x1U << TSC_IOCCR_G6_IO4_Pos)                /*!< 0x00800000 */
N#define TSC_IOCCR_G6_IO4         TSC_IOCCR_G6_IO4_Msk                          /*!<GROUP6_IO4 channel mode */
N#define TSC_IOCCR_G7_IO1_Pos     (24U)                                         
N#define TSC_IOCCR_G7_IO1_Msk     (0x1U << TSC_IOCCR_G7_IO1_Pos)                /*!< 0x01000000 */
N#define TSC_IOCCR_G7_IO1         TSC_IOCCR_G7_IO1_Msk                          /*!<GROUP7_IO1 channel mode */
N#define TSC_IOCCR_G7_IO2_Pos     (25U)                                         
N#define TSC_IOCCR_G7_IO2_Msk     (0x1U << TSC_IOCCR_G7_IO2_Pos)                /*!< 0x02000000 */
N#define TSC_IOCCR_G7_IO2         TSC_IOCCR_G7_IO2_Msk                          /*!<GROUP7_IO2 channel mode */
N#define TSC_IOCCR_G7_IO3_Pos     (26U)                                         
N#define TSC_IOCCR_G7_IO3_Msk     (0x1U << TSC_IOCCR_G7_IO3_Pos)                /*!< 0x04000000 */
N#define TSC_IOCCR_G7_IO3         TSC_IOCCR_G7_IO3_Msk                          /*!<GROUP7_IO3 channel mode */
N#define TSC_IOCCR_G7_IO4_Pos     (27U)                                         
N#define TSC_IOCCR_G7_IO4_Msk     (0x1U << TSC_IOCCR_G7_IO4_Pos)                /*!< 0x08000000 */
N#define TSC_IOCCR_G7_IO4         TSC_IOCCR_G7_IO4_Msk                          /*!<GROUP7_IO4 channel mode */
N#define TSC_IOCCR_G8_IO1_Pos     (28U)                                         
N#define TSC_IOCCR_G8_IO1_Msk     (0x1U << TSC_IOCCR_G8_IO1_Pos)                /*!< 0x10000000 */
N#define TSC_IOCCR_G8_IO1         TSC_IOCCR_G8_IO1_Msk                          /*!<GROUP8_IO1 channel mode */
N#define TSC_IOCCR_G8_IO2_Pos     (29U)                                         
N#define TSC_IOCCR_G8_IO2_Msk     (0x1U << TSC_IOCCR_G8_IO2_Pos)                /*!< 0x20000000 */
N#define TSC_IOCCR_G8_IO2         TSC_IOCCR_G8_IO2_Msk                          /*!<GROUP8_IO2 channel mode */
N#define TSC_IOCCR_G8_IO3_Pos     (30U)                                         
N#define TSC_IOCCR_G8_IO3_Msk     (0x1U << TSC_IOCCR_G8_IO3_Pos)                /*!< 0x40000000 */
N#define TSC_IOCCR_G8_IO3         TSC_IOCCR_G8_IO3_Msk                          /*!<GROUP8_IO3 channel mode */
N#define TSC_IOCCR_G8_IO4_Pos     (31U)                                         
N#define TSC_IOCCR_G8_IO4_Msk     (0x1U << TSC_IOCCR_G8_IO4_Pos)                /*!< 0x80000000 */
N#define TSC_IOCCR_G8_IO4         TSC_IOCCR_G8_IO4_Msk                          /*!<GROUP8_IO4 channel mode */
N
N/*******************  Bit definition for TSC_IOGCSR register  *****************/
N#define TSC_IOGCSR_G1E_Pos       (0U)                                          
N#define TSC_IOGCSR_G1E_Msk       (0x1U << TSC_IOGCSR_G1E_Pos)                  /*!< 0x00000001 */
N#define TSC_IOGCSR_G1E           TSC_IOGCSR_G1E_Msk                            /*!<Analog IO GROUP1 enable */
N#define TSC_IOGCSR_G2E_Pos       (1U)                                          
N#define TSC_IOGCSR_G2E_Msk       (0x1U << TSC_IOGCSR_G2E_Pos)                  /*!< 0x00000002 */
N#define TSC_IOGCSR_G2E           TSC_IOGCSR_G2E_Msk                            /*!<Analog IO GROUP2 enable */
N#define TSC_IOGCSR_G3E_Pos       (2U)                                          
N#define TSC_IOGCSR_G3E_Msk       (0x1U << TSC_IOGCSR_G3E_Pos)                  /*!< 0x00000004 */
N#define TSC_IOGCSR_G3E           TSC_IOGCSR_G3E_Msk                            /*!<Analog IO GROUP3 enable */
N#define TSC_IOGCSR_G4E_Pos       (3U)                                          
N#define TSC_IOGCSR_G4E_Msk       (0x1U << TSC_IOGCSR_G4E_Pos)                  /*!< 0x00000008 */
N#define TSC_IOGCSR_G4E           TSC_IOGCSR_G4E_Msk                            /*!<Analog IO GROUP4 enable */
N#define TSC_IOGCSR_G5E_Pos       (4U)                                          
N#define TSC_IOGCSR_G5E_Msk       (0x1U << TSC_IOGCSR_G5E_Pos)                  /*!< 0x00000010 */
N#define TSC_IOGCSR_G5E           TSC_IOGCSR_G5E_Msk                            /*!<Analog IO GROUP5 enable */
N#define TSC_IOGCSR_G6E_Pos       (5U)                                          
N#define TSC_IOGCSR_G6E_Msk       (0x1U << TSC_IOGCSR_G6E_Pos)                  /*!< 0x00000020 */
N#define TSC_IOGCSR_G6E           TSC_IOGCSR_G6E_Msk                            /*!<Analog IO GROUP6 enable */
N#define TSC_IOGCSR_G7E_Pos       (6U)                                          
N#define TSC_IOGCSR_G7E_Msk       (0x1U << TSC_IOGCSR_G7E_Pos)                  /*!< 0x00000040 */
N#define TSC_IOGCSR_G7E           TSC_IOGCSR_G7E_Msk                            /*!<Analog IO GROUP7 enable */
N#define TSC_IOGCSR_G8E_Pos       (7U)                                          
N#define TSC_IOGCSR_G8E_Msk       (0x1U << TSC_IOGCSR_G8E_Pos)                  /*!< 0x00000080 */
N#define TSC_IOGCSR_G8E           TSC_IOGCSR_G8E_Msk                            /*!<Analog IO GROUP8 enable */
N#define TSC_IOGCSR_G1S_Pos       (16U)                                         
N#define TSC_IOGCSR_G1S_Msk       (0x1U << TSC_IOGCSR_G1S_Pos)                  /*!< 0x00010000 */
N#define TSC_IOGCSR_G1S           TSC_IOGCSR_G1S_Msk                            /*!<Analog IO GROUP1 status */
N#define TSC_IOGCSR_G2S_Pos       (17U)                                         
N#define TSC_IOGCSR_G2S_Msk       (0x1U << TSC_IOGCSR_G2S_Pos)                  /*!< 0x00020000 */
N#define TSC_IOGCSR_G2S           TSC_IOGCSR_G2S_Msk                            /*!<Analog IO GROUP2 status */
N#define TSC_IOGCSR_G3S_Pos       (18U)                                         
N#define TSC_IOGCSR_G3S_Msk       (0x1U << TSC_IOGCSR_G3S_Pos)                  /*!< 0x00040000 */
N#define TSC_IOGCSR_G3S           TSC_IOGCSR_G3S_Msk                            /*!<Analog IO GROUP3 status */
N#define TSC_IOGCSR_G4S_Pos       (19U)                                         
N#define TSC_IOGCSR_G4S_Msk       (0x1U << TSC_IOGCSR_G4S_Pos)                  /*!< 0x00080000 */
N#define TSC_IOGCSR_G4S           TSC_IOGCSR_G4S_Msk                            /*!<Analog IO GROUP4 status */
N#define TSC_IOGCSR_G5S_Pos       (20U)                                         
N#define TSC_IOGCSR_G5S_Msk       (0x1U << TSC_IOGCSR_G5S_Pos)                  /*!< 0x00100000 */
N#define TSC_IOGCSR_G5S           TSC_IOGCSR_G5S_Msk                            /*!<Analog IO GROUP5 status */
N#define TSC_IOGCSR_G6S_Pos       (21U)                                         
N#define TSC_IOGCSR_G6S_Msk       (0x1U << TSC_IOGCSR_G6S_Pos)                  /*!< 0x00200000 */
N#define TSC_IOGCSR_G6S           TSC_IOGCSR_G6S_Msk                            /*!<Analog IO GROUP6 status */
N#define TSC_IOGCSR_G7S_Pos       (22U)                                         
N#define TSC_IOGCSR_G7S_Msk       (0x1U << TSC_IOGCSR_G7S_Pos)                  /*!< 0x00400000 */
N#define TSC_IOGCSR_G7S           TSC_IOGCSR_G7S_Msk                            /*!<Analog IO GROUP7 status */
N#define TSC_IOGCSR_G8S_Pos       (23U)                                         
N#define TSC_IOGCSR_G8S_Msk       (0x1U << TSC_IOGCSR_G8S_Pos)                  /*!< 0x00800000 */
N#define TSC_IOGCSR_G8S           TSC_IOGCSR_G8S_Msk                            /*!<Analog IO GROUP8 status */
N
N/*******************  Bit definition for TSC_IOGXCR register  *****************/
N#define TSC_IOGXCR_CNT_Pos       (0U)                                          
N#define TSC_IOGXCR_CNT_Msk       (0x3FFFU << TSC_IOGXCR_CNT_Pos)               /*!< 0x00003FFF */
N#define TSC_IOGXCR_CNT           TSC_IOGXCR_CNT_Msk                            /*!<CNT[13:0] bits (Counter value) */
N
N/******************************************************************************/
N/*                                                                            */
N/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
N/*                                                                            */
N/******************************************************************************/
N
N/*
N* @brief Specific device feature definitions (not present on all devices in the STM32F0 serie)
N*/
N
N/* Support of 7 bits data length feature */
N#define USART_7BITS_SUPPORT
N
N/* Support of LIN feature */
N#define USART_LIN_SUPPORT
N
N/* Support of Smartcard feature */
N#define USART_SMARTCARD_SUPPORT
N
N/* Support of Irda feature */
N#define USART_IRDA_SUPPORT
N
N/* Support of Wake Up from Stop Mode feature */
N#define USART_WUSM_SUPPORT
N
N/* Support of Full Auto Baud rate feature (4 modes) activation */
N#define USART_FABR_SUPPORT
N
N/******************  Bit definition for USART_CR1 register  *******************/
N#define USART_CR1_UE_Pos              (0U)                                     
N#define USART_CR1_UE_Msk              (0x1U << USART_CR1_UE_Pos)               /*!< 0x00000001 */
N#define USART_CR1_UE                  USART_CR1_UE_Msk                         /*!< USART Enable */
N#define USART_CR1_UESM_Pos            (1U)                                     
N#define USART_CR1_UESM_Msk            (0x1U << USART_CR1_UESM_Pos)             /*!< 0x00000002 */
N#define USART_CR1_UESM                USART_CR1_UESM_Msk                       /*!< USART Enable in STOP Mode */
N#define USART_CR1_RE_Pos              (2U)                                     
N#define USART_CR1_RE_Msk              (0x1U << USART_CR1_RE_Pos)               /*!< 0x00000004 */
N#define USART_CR1_RE                  USART_CR1_RE_Msk                         /*!< Receiver Enable */
N#define USART_CR1_TE_Pos              (3U)                                     
N#define USART_CR1_TE_Msk              (0x1U << USART_CR1_TE_Pos)               /*!< 0x00000008 */
N#define USART_CR1_TE                  USART_CR1_TE_Msk                         /*!< Transmitter Enable */
N#define USART_CR1_IDLEIE_Pos          (4U)                                     
N#define USART_CR1_IDLEIE_Msk          (0x1U << USART_CR1_IDLEIE_Pos)           /*!< 0x00000010 */
N#define USART_CR1_IDLEIE              USART_CR1_IDLEIE_Msk                     /*!< IDLE Interrupt Enable */
N#define USART_CR1_RXNEIE_Pos          (5U)                                     
N#define USART_CR1_RXNEIE_Msk          (0x1U << USART_CR1_RXNEIE_Pos)           /*!< 0x00000020 */
N#define USART_CR1_RXNEIE              USART_CR1_RXNEIE_Msk                     /*!< RXNE Interrupt Enable */
N#define USART_CR1_TCIE_Pos            (6U)                                     
N#define USART_CR1_TCIE_Msk            (0x1U << USART_CR1_TCIE_Pos)             /*!< 0x00000040 */
N#define USART_CR1_TCIE                USART_CR1_TCIE_Msk                       /*!< Transmission Complete Interrupt Enable */
N#define USART_CR1_TXEIE_Pos           (7U)                                     
N#define USART_CR1_TXEIE_Msk           (0x1U << USART_CR1_TXEIE_Pos)            /*!< 0x00000080 */
N#define USART_CR1_TXEIE               USART_CR1_TXEIE_Msk                      /*!< TXE Interrupt Enable */
N#define USART_CR1_PEIE_Pos            (8U)                                     
N#define USART_CR1_PEIE_Msk            (0x1U << USART_CR1_PEIE_Pos)             /*!< 0x00000100 */
N#define USART_CR1_PEIE                USART_CR1_PEIE_Msk                       /*!< PE Interrupt Enable */
N#define USART_CR1_PS_Pos              (9U)                                     
N#define USART_CR1_PS_Msk              (0x1U << USART_CR1_PS_Pos)               /*!< 0x00000200 */
N#define USART_CR1_PS                  USART_CR1_PS_Msk                         /*!< Parity Selection */
N#define USART_CR1_PCE_Pos             (10U)                                    
N#define USART_CR1_PCE_Msk             (0x1U << USART_CR1_PCE_Pos)              /*!< 0x00000400 */
N#define USART_CR1_PCE                 USART_CR1_PCE_Msk                        /*!< Parity Control Enable */
N#define USART_CR1_WAKE_Pos            (11U)                                    
N#define USART_CR1_WAKE_Msk            (0x1U << USART_CR1_WAKE_Pos)             /*!< 0x00000800 */
N#define USART_CR1_WAKE                USART_CR1_WAKE_Msk                       /*!< Receiver Wakeup method */
N#define USART_CR1_M0_Pos              (12U)                                    
N#define USART_CR1_M0_Msk              (0x1U << USART_CR1_M0_Pos)               /*!< 0x00001000 */
N#define USART_CR1_M0                  USART_CR1_M0_Msk                         /*!< Word length bit 0 */
N#define USART_CR1_MME_Pos             (13U)                                    
N#define USART_CR1_MME_Msk             (0x1U << USART_CR1_MME_Pos)              /*!< 0x00002000 */
N#define USART_CR1_MME                 USART_CR1_MME_Msk                        /*!< Mute Mode Enable */
N#define USART_CR1_CMIE_Pos            (14U)                                    
N#define USART_CR1_CMIE_Msk            (0x1U << USART_CR1_CMIE_Pos)             /*!< 0x00004000 */
N#define USART_CR1_CMIE                USART_CR1_CMIE_Msk                       /*!< Character match interrupt enable */
N#define USART_CR1_OVER8_Pos           (15U)                                    
N#define USART_CR1_OVER8_Msk           (0x1U << USART_CR1_OVER8_Pos)            /*!< 0x00008000 */
N#define USART_CR1_OVER8               USART_CR1_OVER8_Msk                      /*!< Oversampling by 8-bit or 16-bit mode */
N#define USART_CR1_DEDT_Pos            (16U)                                    
N#define USART_CR1_DEDT_Msk            (0x1FU << USART_CR1_DEDT_Pos)            /*!< 0x001F0000 */
N#define USART_CR1_DEDT                USART_CR1_DEDT_Msk                       /*!< DEDT[4:0] bits (Driver Enable Deassertion Time) */
N#define USART_CR1_DEDT_0              (0x01U << USART_CR1_DEDT_Pos)            /*!< 0x00010000 */
N#define USART_CR1_DEDT_1              (0x02U << USART_CR1_DEDT_Pos)            /*!< 0x00020000 */
N#define USART_CR1_DEDT_2              (0x04U << USART_CR1_DEDT_Pos)            /*!< 0x00040000 */
N#define USART_CR1_DEDT_3              (0x08U << USART_CR1_DEDT_Pos)            /*!< 0x00080000 */
N#define USART_CR1_DEDT_4              (0x10U << USART_CR1_DEDT_Pos)            /*!< 0x00100000 */
N#define USART_CR1_DEAT_Pos            (21U)                                    
N#define USART_CR1_DEAT_Msk            (0x1FU << USART_CR1_DEAT_Pos)            /*!< 0x03E00000 */
N#define USART_CR1_DEAT                USART_CR1_DEAT_Msk                       /*!< DEAT[4:0] bits (Driver Enable Assertion Time) */
N#define USART_CR1_DEAT_0              (0x01U << USART_CR1_DEAT_Pos)            /*!< 0x00200000 */
N#define USART_CR1_DEAT_1              (0x02U << USART_CR1_DEAT_Pos)            /*!< 0x00400000 */
N#define USART_CR1_DEAT_2              (0x04U << USART_CR1_DEAT_Pos)            /*!< 0x00800000 */
N#define USART_CR1_DEAT_3              (0x08U << USART_CR1_DEAT_Pos)            /*!< 0x01000000 */
N#define USART_CR1_DEAT_4              (0x10U << USART_CR1_DEAT_Pos)            /*!< 0x02000000 */
N#define USART_CR1_RTOIE_Pos           (26U)                                    
N#define USART_CR1_RTOIE_Msk           (0x1U << USART_CR1_RTOIE_Pos)            /*!< 0x04000000 */
N#define USART_CR1_RTOIE               USART_CR1_RTOIE_Msk                      /*!< Receive Time Out interrupt enable */
N#define USART_CR1_EOBIE_Pos           (27U)                                    
N#define USART_CR1_EOBIE_Msk           (0x1U << USART_CR1_EOBIE_Pos)            /*!< 0x08000000 */
N#define USART_CR1_EOBIE               USART_CR1_EOBIE_Msk                      /*!< End of Block interrupt enable */
N#define USART_CR1_M1_Pos              (28U)                                    
N#define USART_CR1_M1_Msk              (0x1U << USART_CR1_M1_Pos)               /*!< 0x10000000 */
N#define USART_CR1_M1                  USART_CR1_M1_Msk                         /*!< Word length bit 1 */
N#define USART_CR1_M_Pos               (12U)                                    
N#define USART_CR1_M_Msk               (0x10001U << USART_CR1_M_Pos)            /*!< 0x10001000 */
N#define USART_CR1_M                   USART_CR1_M_Msk                          /*!< [M1:M0] Word length */
N
N/******************  Bit definition for USART_CR2 register  *******************/
N#define USART_CR2_ADDM7_Pos           (4U)                                     
N#define USART_CR2_ADDM7_Msk           (0x1U << USART_CR2_ADDM7_Pos)            /*!< 0x00000010 */
N#define USART_CR2_ADDM7               USART_CR2_ADDM7_Msk                      /*!< 7-bit or 4-bit Address Detection */
N#define USART_CR2_LBDL_Pos            (5U)                                     
N#define USART_CR2_LBDL_Msk            (0x1U << USART_CR2_LBDL_Pos)             /*!< 0x00000020 */
N#define USART_CR2_LBDL                USART_CR2_LBDL_Msk                       /*!< LIN Break Detection Length */
N#define USART_CR2_LBDIE_Pos           (6U)                                     
N#define USART_CR2_LBDIE_Msk           (0x1U << USART_CR2_LBDIE_Pos)            /*!< 0x00000040 */
N#define USART_CR2_LBDIE               USART_CR2_LBDIE_Msk                      /*!< LIN Break Detection Interrupt Enable */
N#define USART_CR2_LBCL_Pos            (8U)                                     
N#define USART_CR2_LBCL_Msk            (0x1U << USART_CR2_LBCL_Pos)             /*!< 0x00000100 */
N#define USART_CR2_LBCL                USART_CR2_LBCL_Msk                       /*!< Last Bit Clock pulse */
N#define USART_CR2_CPHA_Pos            (9U)                                     
N#define USART_CR2_CPHA_Msk            (0x1U << USART_CR2_CPHA_Pos)             /*!< 0x00000200 */
N#define USART_CR2_CPHA                USART_CR2_CPHA_Msk                       /*!< Clock Phase */
N#define USART_CR2_CPOL_Pos            (10U)                                    
N#define USART_CR2_CPOL_Msk            (0x1U << USART_CR2_CPOL_Pos)             /*!< 0x00000400 */
N#define USART_CR2_CPOL                USART_CR2_CPOL_Msk                       /*!< Clock Polarity */
N#define USART_CR2_CLKEN_Pos           (11U)                                    
N#define USART_CR2_CLKEN_Msk           (0x1U << USART_CR2_CLKEN_Pos)            /*!< 0x00000800 */
N#define USART_CR2_CLKEN               USART_CR2_CLKEN_Msk                      /*!< Clock Enable */
N#define USART_CR2_STOP_Pos            (12U)                                    
N#define USART_CR2_STOP_Msk            (0x3U << USART_CR2_STOP_Pos)             /*!< 0x00003000 */
N#define USART_CR2_STOP                USART_CR2_STOP_Msk                       /*!< STOP[1:0] bits (STOP bits) */
N#define USART_CR2_STOP_0              (0x1U << USART_CR2_STOP_Pos)             /*!< 0x00001000 */
N#define USART_CR2_STOP_1              (0x2U << USART_CR2_STOP_Pos)             /*!< 0x00002000 */
N#define USART_CR2_LINEN_Pos           (14U)                                    
N#define USART_CR2_LINEN_Msk           (0x1U << USART_CR2_LINEN_Pos)            /*!< 0x00004000 */
N#define USART_CR2_LINEN               USART_CR2_LINEN_Msk                      /*!< LIN mode enable */
N#define USART_CR2_SWAP_Pos            (15U)                                    
N#define USART_CR2_SWAP_Msk            (0x1U << USART_CR2_SWAP_Pos)             /*!< 0x00008000 */
N#define USART_CR2_SWAP                USART_CR2_SWAP_Msk                       /*!< SWAP TX/RX pins */
N#define USART_CR2_RXINV_Pos           (16U)                                    
N#define USART_CR2_RXINV_Msk           (0x1U << USART_CR2_RXINV_Pos)            /*!< 0x00010000 */
N#define USART_CR2_RXINV               USART_CR2_RXINV_Msk                      /*!< RX pin active level inversion */
N#define USART_CR2_TXINV_Pos           (17U)                                    
N#define USART_CR2_TXINV_Msk           (0x1U << USART_CR2_TXINV_Pos)            /*!< 0x00020000 */
N#define USART_CR2_TXINV               USART_CR2_TXINV_Msk                      /*!< TX pin active level inversion */
N#define USART_CR2_DATAINV_Pos         (18U)                                    
N#define USART_CR2_DATAINV_Msk         (0x1U << USART_CR2_DATAINV_Pos)          /*!< 0x00040000 */
N#define USART_CR2_DATAINV             USART_CR2_DATAINV_Msk                    /*!< Binary data inversion */
N#define USART_CR2_MSBFIRST_Pos        (19U)                                    
N#define USART_CR2_MSBFIRST_Msk        (0x1U << USART_CR2_MSBFIRST_Pos)         /*!< 0x00080000 */
N#define USART_CR2_MSBFIRST            USART_CR2_MSBFIRST_Msk                   /*!< Most Significant Bit First */
N#define USART_CR2_ABREN_Pos           (20U)                                    
N#define USART_CR2_ABREN_Msk           (0x1U << USART_CR2_ABREN_Pos)            /*!< 0x00100000 */
N#define USART_CR2_ABREN               USART_CR2_ABREN_Msk                      /*!< Auto Baud-Rate Enable*/
N#define USART_CR2_ABRMODE_Pos         (21U)                                    
N#define USART_CR2_ABRMODE_Msk         (0x3U << USART_CR2_ABRMODE_Pos)          /*!< 0x00600000 */
N#define USART_CR2_ABRMODE             USART_CR2_ABRMODE_Msk                    /*!< ABRMOD[1:0] bits (Auto Baud-Rate Mode) */
N#define USART_CR2_ABRMODE_0           (0x1U << USART_CR2_ABRMODE_Pos)          /*!< 0x00200000 */
N#define USART_CR2_ABRMODE_1           (0x2U << USART_CR2_ABRMODE_Pos)          /*!< 0x00400000 */
N#define USART_CR2_RTOEN_Pos           (23U)                                    
N#define USART_CR2_RTOEN_Msk           (0x1U << USART_CR2_RTOEN_Pos)            /*!< 0x00800000 */
N#define USART_CR2_RTOEN               USART_CR2_RTOEN_Msk                      /*!< Receiver Time-Out enable */
N#define USART_CR2_ADD_Pos             (24U)                                    
N#define USART_CR2_ADD_Msk             (0xFFU << USART_CR2_ADD_Pos)             /*!< 0xFF000000 */
N#define USART_CR2_ADD                 USART_CR2_ADD_Msk                        /*!< Address of the USART node */
N
N/******************  Bit definition for USART_CR3 register  *******************/
N#define USART_CR3_EIE_Pos             (0U)                                     
N#define USART_CR3_EIE_Msk             (0x1U << USART_CR3_EIE_Pos)              /*!< 0x00000001 */
N#define USART_CR3_EIE                 USART_CR3_EIE_Msk                        /*!< Error Interrupt Enable */
N#define USART_CR3_IREN_Pos            (1U)                                     
N#define USART_CR3_IREN_Msk            (0x1U << USART_CR3_IREN_Pos)             /*!< 0x00000002 */
N#define USART_CR3_IREN                USART_CR3_IREN_Msk                       /*!< IrDA mode Enable */
N#define USART_CR3_IRLP_Pos            (2U)                                     
N#define USART_CR3_IRLP_Msk            (0x1U << USART_CR3_IRLP_Pos)             /*!< 0x00000004 */
N#define USART_CR3_IRLP                USART_CR3_IRLP_Msk                       /*!< IrDA Low-Power */
N#define USART_CR3_HDSEL_Pos           (3U)                                     
N#define USART_CR3_HDSEL_Msk           (0x1U << USART_CR3_HDSEL_Pos)            /*!< 0x00000008 */
N#define USART_CR3_HDSEL               USART_CR3_HDSEL_Msk                      /*!< Half-Duplex Selection */
N#define USART_CR3_NACK_Pos            (4U)                                     
N#define USART_CR3_NACK_Msk            (0x1U << USART_CR3_NACK_Pos)             /*!< 0x00000010 */
N#define USART_CR3_NACK                USART_CR3_NACK_Msk                       /*!< SmartCard NACK enable */
N#define USART_CR3_SCEN_Pos            (5U)                                     
N#define USART_CR3_SCEN_Msk            (0x1U << USART_CR3_SCEN_Pos)             /*!< 0x00000020 */
N#define USART_CR3_SCEN                USART_CR3_SCEN_Msk                       /*!< SmartCard mode enable */
N#define USART_CR3_DMAR_Pos            (6U)                                     
N#define USART_CR3_DMAR_Msk            (0x1U << USART_CR3_DMAR_Pos)             /*!< 0x00000040 */
N#define USART_CR3_DMAR                USART_CR3_DMAR_Msk                       /*!< DMA Enable Receiver */
N#define USART_CR3_DMAT_Pos            (7U)                                     
N#define USART_CR3_DMAT_Msk            (0x1U << USART_CR3_DMAT_Pos)             /*!< 0x00000080 */
N#define USART_CR3_DMAT                USART_CR3_DMAT_Msk                       /*!< DMA Enable Transmitter */
N#define USART_CR3_RTSE_Pos            (8U)                                     
N#define USART_CR3_RTSE_Msk            (0x1U << USART_CR3_RTSE_Pos)             /*!< 0x00000100 */
N#define USART_CR3_RTSE                USART_CR3_RTSE_Msk                       /*!< RTS Enable */
N#define USART_CR3_CTSE_Pos            (9U)                                     
N#define USART_CR3_CTSE_Msk            (0x1U << USART_CR3_CTSE_Pos)             /*!< 0x00000200 */
N#define USART_CR3_CTSE                USART_CR3_CTSE_Msk                       /*!< CTS Enable */
N#define USART_CR3_CTSIE_Pos           (10U)                                    
N#define USART_CR3_CTSIE_Msk           (0x1U << USART_CR3_CTSIE_Pos)            /*!< 0x00000400 */
N#define USART_CR3_CTSIE               USART_CR3_CTSIE_Msk                      /*!< CTS Interrupt Enable */
N#define USART_CR3_ONEBIT_Pos          (11U)                                    
N#define USART_CR3_ONEBIT_Msk          (0x1U << USART_CR3_ONEBIT_Pos)           /*!< 0x00000800 */
N#define USART_CR3_ONEBIT              USART_CR3_ONEBIT_Msk                     /*!< One sample bit method enable */
N#define USART_CR3_OVRDIS_Pos          (12U)                                    
N#define USART_CR3_OVRDIS_Msk          (0x1U << USART_CR3_OVRDIS_Pos)           /*!< 0x00001000 */
N#define USART_CR3_OVRDIS              USART_CR3_OVRDIS_Msk                     /*!< Overrun Disable */
N#define USART_CR3_DDRE_Pos            (13U)                                    
N#define USART_CR3_DDRE_Msk            (0x1U << USART_CR3_DDRE_Pos)             /*!< 0x00002000 */
N#define USART_CR3_DDRE                USART_CR3_DDRE_Msk                       /*!< DMA Disable on Reception Error */
N#define USART_CR3_DEM_Pos             (14U)                                    
N#define USART_CR3_DEM_Msk             (0x1U << USART_CR3_DEM_Pos)              /*!< 0x00004000 */
N#define USART_CR3_DEM                 USART_CR3_DEM_Msk                        /*!< Driver Enable Mode */
N#define USART_CR3_DEP_Pos             (15U)                                    
N#define USART_CR3_DEP_Msk             (0x1U << USART_CR3_DEP_Pos)              /*!< 0x00008000 */
N#define USART_CR3_DEP                 USART_CR3_DEP_Msk                        /*!< Driver Enable Polarity Selection */
N#define USART_CR3_SCARCNT_Pos         (17U)                                    
N#define USART_CR3_SCARCNT_Msk         (0x7U << USART_CR3_SCARCNT_Pos)          /*!< 0x000E0000 */
N#define USART_CR3_SCARCNT             USART_CR3_SCARCNT_Msk                    /*!< SCARCNT[2:0] bits (SmartCard Auto-Retry Count) */
N#define USART_CR3_SCARCNT_0           (0x1U << USART_CR3_SCARCNT_Pos)          /*!< 0x00020000 */
N#define USART_CR3_SCARCNT_1           (0x2U << USART_CR3_SCARCNT_Pos)          /*!< 0x00040000 */
N#define USART_CR3_SCARCNT_2           (0x4U << USART_CR3_SCARCNT_Pos)          /*!< 0x00080000 */
N#define USART_CR3_WUS_Pos             (20U)                                    
N#define USART_CR3_WUS_Msk             (0x3U << USART_CR3_WUS_Pos)              /*!< 0x00300000 */
N#define USART_CR3_WUS                 USART_CR3_WUS_Msk                        /*!< WUS[1:0] bits (Wake UP Interrupt Flag Selection) */
N#define USART_CR3_WUS_0               (0x1U << USART_CR3_WUS_Pos)              /*!< 0x00100000 */
N#define USART_CR3_WUS_1               (0x2U << USART_CR3_WUS_Pos)              /*!< 0x00200000 */
N#define USART_CR3_WUFIE_Pos           (22U)                                    
N#define USART_CR3_WUFIE_Msk           (0x1U << USART_CR3_WUFIE_Pos)            /*!< 0x00400000 */
N#define USART_CR3_WUFIE               USART_CR3_WUFIE_Msk                      /*!< Wake Up Interrupt Enable */
N
N/******************  Bit definition for USART_BRR register  *******************/
N#define USART_BRR_DIV_FRACTION_Pos    (0U)                                     
N#define USART_BRR_DIV_FRACTION_Msk    (0xFU << USART_BRR_DIV_FRACTION_Pos)     /*!< 0x0000000F */
N#define USART_BRR_DIV_FRACTION        USART_BRR_DIV_FRACTION_Msk               /*!< Fraction of USARTDIV */
N#define USART_BRR_DIV_MANTISSA_Pos    (4U)                                     
N#define USART_BRR_DIV_MANTISSA_Msk    (0xFFFU << USART_BRR_DIV_MANTISSA_Pos)   /*!< 0x0000FFF0 */
N#define USART_BRR_DIV_MANTISSA        USART_BRR_DIV_MANTISSA_Msk               /*!< Mantissa of USARTDIV */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define USART_GTPR_PSC_Pos            (0U)                                     
N#define USART_GTPR_PSC_Msk            (0xFFU << USART_GTPR_PSC_Pos)            /*!< 0x000000FF */
N#define USART_GTPR_PSC                USART_GTPR_PSC_Msk                       /*!< PSC[7:0] bits (Prescaler value) */
N#define USART_GTPR_GT_Pos             (8U)                                     
N#define USART_GTPR_GT_Msk             (0xFFU << USART_GTPR_GT_Pos)             /*!< 0x0000FF00 */
N#define USART_GTPR_GT                 USART_GTPR_GT_Msk                        /*!< GT[7:0] bits (Guard time value) */
N
N
N/*******************  Bit definition for USART_RTOR register  *****************/
N#define USART_RTOR_RTO_Pos            (0U)                                     
N#define USART_RTOR_RTO_Msk            (0xFFFFFFU << USART_RTOR_RTO_Pos)        /*!< 0x00FFFFFF */
N#define USART_RTOR_RTO                USART_RTOR_RTO_Msk                       /*!< Receiver Time Out Value */
N#define USART_RTOR_BLEN_Pos           (24U)                                    
N#define USART_RTOR_BLEN_Msk           (0xFFU << USART_RTOR_BLEN_Pos)           /*!< 0xFF000000 */
N#define USART_RTOR_BLEN               USART_RTOR_BLEN_Msk                      /*!< Block Length */
N
N/*******************  Bit definition for USART_RQR register  ******************/
N#define USART_RQR_ABRRQ_Pos           (0U)                                     
N#define USART_RQR_ABRRQ_Msk           (0x1U << USART_RQR_ABRRQ_Pos)            /*!< 0x00000001 */
N#define USART_RQR_ABRRQ               USART_RQR_ABRRQ_Msk                      /*!< Auto-Baud Rate Request */
N#define USART_RQR_SBKRQ_Pos           (1U)                                     
N#define USART_RQR_SBKRQ_Msk           (0x1U << USART_RQR_SBKRQ_Pos)            /*!< 0x00000002 */
N#define USART_RQR_SBKRQ               USART_RQR_SBKRQ_Msk                      /*!< Send Break Request */
N#define USART_RQR_MMRQ_Pos            (2U)                                     
N#define USART_RQR_MMRQ_Msk            (0x1U << USART_RQR_MMRQ_Pos)             /*!< 0x00000004 */
N#define USART_RQR_MMRQ                USART_RQR_MMRQ_Msk                       /*!< Mute Mode Request */
N#define USART_RQR_RXFRQ_Pos           (3U)                                     
N#define USART_RQR_RXFRQ_Msk           (0x1U << USART_RQR_RXFRQ_Pos)            /*!< 0x00000008 */
N#define USART_RQR_RXFRQ               USART_RQR_RXFRQ_Msk                      /*!< Receive Data flush Request */
N#define USART_RQR_TXFRQ_Pos           (4U)                                     
N#define USART_RQR_TXFRQ_Msk           (0x1U << USART_RQR_TXFRQ_Pos)            /*!< 0x00000010 */
N#define USART_RQR_TXFRQ               USART_RQR_TXFRQ_Msk                      /*!< Transmit data flush Request */
N
N/*******************  Bit definition for USART_ISR register  ******************/
N#define USART_ISR_PE_Pos              (0U)                                     
N#define USART_ISR_PE_Msk              (0x1U << USART_ISR_PE_Pos)               /*!< 0x00000001 */
N#define USART_ISR_PE                  USART_ISR_PE_Msk                         /*!< Parity Error */
N#define USART_ISR_FE_Pos              (1U)                                     
N#define USART_ISR_FE_Msk              (0x1U << USART_ISR_FE_Pos)               /*!< 0x00000002 */
N#define USART_ISR_FE                  USART_ISR_FE_Msk                         /*!< Framing Error */
N#define USART_ISR_NE_Pos              (2U)                                     
N#define USART_ISR_NE_Msk              (0x1U << USART_ISR_NE_Pos)               /*!< 0x00000004 */
N#define USART_ISR_NE                  USART_ISR_NE_Msk                         /*!< Noise detected Flag */
N#define USART_ISR_ORE_Pos             (3U)                                     
N#define USART_ISR_ORE_Msk             (0x1U << USART_ISR_ORE_Pos)              /*!< 0x00000008 */
N#define USART_ISR_ORE                 USART_ISR_ORE_Msk                        /*!< OverRun Error */
N#define USART_ISR_IDLE_Pos            (4U)                                     
N#define USART_ISR_IDLE_Msk            (0x1U << USART_ISR_IDLE_Pos)             /*!< 0x00000010 */
N#define USART_ISR_IDLE                USART_ISR_IDLE_Msk                       /*!< IDLE line detected */
N#define USART_ISR_RXNE_Pos            (5U)                                     
N#define USART_ISR_RXNE_Msk            (0x1U << USART_ISR_RXNE_Pos)             /*!< 0x00000020 */
N#define USART_ISR_RXNE                USART_ISR_RXNE_Msk                       /*!< Read Data Register Not Empty */
N#define USART_ISR_TC_Pos              (6U)                                     
N#define USART_ISR_TC_Msk              (0x1U << USART_ISR_TC_Pos)               /*!< 0x00000040 */
N#define USART_ISR_TC                  USART_ISR_TC_Msk                         /*!< Transmission Complete */
N#define USART_ISR_TXE_Pos             (7U)                                     
N#define USART_ISR_TXE_Msk             (0x1U << USART_ISR_TXE_Pos)              /*!< 0x00000080 */
N#define USART_ISR_TXE                 USART_ISR_TXE_Msk                        /*!< Transmit Data Register Empty */
N#define USART_ISR_LBDF_Pos            (8U)                                     
N#define USART_ISR_LBDF_Msk            (0x1U << USART_ISR_LBDF_Pos)             /*!< 0x00000100 */
N#define USART_ISR_LBDF                USART_ISR_LBDF_Msk                       /*!< LIN Break Detection Flag */
N#define USART_ISR_CTSIF_Pos           (9U)                                     
N#define USART_ISR_CTSIF_Msk           (0x1U << USART_ISR_CTSIF_Pos)            /*!< 0x00000200 */
N#define USART_ISR_CTSIF               USART_ISR_CTSIF_Msk                      /*!< CTS interrupt flag */
N#define USART_ISR_CTS_Pos             (10U)                                    
N#define USART_ISR_CTS_Msk             (0x1U << USART_ISR_CTS_Pos)              /*!< 0x00000400 */
N#define USART_ISR_CTS                 USART_ISR_CTS_Msk                        /*!< CTS flag */
N#define USART_ISR_RTOF_Pos            (11U)                                    
N#define USART_ISR_RTOF_Msk            (0x1U << USART_ISR_RTOF_Pos)             /*!< 0x00000800 */
N#define USART_ISR_RTOF                USART_ISR_RTOF_Msk                       /*!< Receiver Time Out */
N#define USART_ISR_EOBF_Pos            (12U)                                    
N#define USART_ISR_EOBF_Msk            (0x1U << USART_ISR_EOBF_Pos)             /*!< 0x00001000 */
N#define USART_ISR_EOBF                USART_ISR_EOBF_Msk                       /*!< End Of Block Flag */
N#define USART_ISR_ABRE_Pos            (14U)                                    
N#define USART_ISR_ABRE_Msk            (0x1U << USART_ISR_ABRE_Pos)             /*!< 0x00004000 */
N#define USART_ISR_ABRE                USART_ISR_ABRE_Msk                       /*!< Auto-Baud Rate Error */
N#define USART_ISR_ABRF_Pos            (15U)                                    
N#define USART_ISR_ABRF_Msk            (0x1U << USART_ISR_ABRF_Pos)             /*!< 0x00008000 */
N#define USART_ISR_ABRF                USART_ISR_ABRF_Msk                       /*!< Auto-Baud Rate Flag */
N#define USART_ISR_BUSY_Pos            (16U)                                    
N#define USART_ISR_BUSY_Msk            (0x1U << USART_ISR_BUSY_Pos)             /*!< 0x00010000 */
N#define USART_ISR_BUSY                USART_ISR_BUSY_Msk                       /*!< Busy Flag */
N#define USART_ISR_CMF_Pos             (17U)                                    
N#define USART_ISR_CMF_Msk             (0x1U << USART_ISR_CMF_Pos)              /*!< 0x00020000 */
N#define USART_ISR_CMF                 USART_ISR_CMF_Msk                        /*!< Character Match Flag */
N#define USART_ISR_SBKF_Pos            (18U)                                    
N#define USART_ISR_SBKF_Msk            (0x1U << USART_ISR_SBKF_Pos)             /*!< 0x00040000 */
N#define USART_ISR_SBKF                USART_ISR_SBKF_Msk                       /*!< Send Break Flag */
N#define USART_ISR_RWU_Pos             (19U)                                    
N#define USART_ISR_RWU_Msk             (0x1U << USART_ISR_RWU_Pos)              /*!< 0x00080000 */
N#define USART_ISR_RWU                 USART_ISR_RWU_Msk                        /*!< Receive Wake Up from mute mode Flag */
N#define USART_ISR_WUF_Pos             (20U)                                    
N#define USART_ISR_WUF_Msk             (0x1U << USART_ISR_WUF_Pos)              /*!< 0x00100000 */
N#define USART_ISR_WUF                 USART_ISR_WUF_Msk                        /*!< Wake Up from stop mode Flag */
N#define USART_ISR_TEACK_Pos           (21U)                                    
N#define USART_ISR_TEACK_Msk           (0x1U << USART_ISR_TEACK_Pos)            /*!< 0x00200000 */
N#define USART_ISR_TEACK               USART_ISR_TEACK_Msk                      /*!< Transmit Enable Acknowledge Flag */
N#define USART_ISR_REACK_Pos           (22U)                                    
N#define USART_ISR_REACK_Msk           (0x1U << USART_ISR_REACK_Pos)            /*!< 0x00400000 */
N#define USART_ISR_REACK               USART_ISR_REACK_Msk                      /*!< Receive Enable Acknowledge Flag */
N
N/*******************  Bit definition for USART_ICR register  ******************/
N#define USART_ICR_PECF_Pos            (0U)                                     
N#define USART_ICR_PECF_Msk            (0x1U << USART_ICR_PECF_Pos)             /*!< 0x00000001 */
N#define USART_ICR_PECF                USART_ICR_PECF_Msk                       /*!< Parity Error Clear Flag */
N#define USART_ICR_FECF_Pos            (1U)                                     
N#define USART_ICR_FECF_Msk            (0x1U << USART_ICR_FECF_Pos)             /*!< 0x00000002 */
N#define USART_ICR_FECF                USART_ICR_FECF_Msk                       /*!< Framing Error Clear Flag */
N#define USART_ICR_NCF_Pos             (2U)                                     
N#define USART_ICR_NCF_Msk             (0x1U << USART_ICR_NCF_Pos)              /*!< 0x00000004 */
N#define USART_ICR_NCF                 USART_ICR_NCF_Msk                        /*!< Noise detected Clear Flag */
N#define USART_ICR_ORECF_Pos           (3U)                                     
N#define USART_ICR_ORECF_Msk           (0x1U << USART_ICR_ORECF_Pos)            /*!< 0x00000008 */
N#define USART_ICR_ORECF               USART_ICR_ORECF_Msk                      /*!< OverRun Error Clear Flag */
N#define USART_ICR_IDLECF_Pos          (4U)                                     
N#define USART_ICR_IDLECF_Msk          (0x1U << USART_ICR_IDLECF_Pos)           /*!< 0x00000010 */
N#define USART_ICR_IDLECF              USART_ICR_IDLECF_Msk                     /*!< IDLE line detected Clear Flag */
N#define USART_ICR_TCCF_Pos            (6U)                                     
N#define USART_ICR_TCCF_Msk            (0x1U << USART_ICR_TCCF_Pos)             /*!< 0x00000040 */
N#define USART_ICR_TCCF                USART_ICR_TCCF_Msk                       /*!< Transmission Complete Clear Flag */
N#define USART_ICR_LBDCF_Pos           (8U)                                     
N#define USART_ICR_LBDCF_Msk           (0x1U << USART_ICR_LBDCF_Pos)            /*!< 0x00000100 */
N#define USART_ICR_LBDCF               USART_ICR_LBDCF_Msk                      /*!< LIN Break Detection Clear Flag */
N#define USART_ICR_CTSCF_Pos           (9U)                                     
N#define USART_ICR_CTSCF_Msk           (0x1U << USART_ICR_CTSCF_Pos)            /*!< 0x00000200 */
N#define USART_ICR_CTSCF               USART_ICR_CTSCF_Msk                      /*!< CTS Interrupt Clear Flag */
N#define USART_ICR_RTOCF_Pos           (11U)                                    
N#define USART_ICR_RTOCF_Msk           (0x1U << USART_ICR_RTOCF_Pos)            /*!< 0x00000800 */
N#define USART_ICR_RTOCF               USART_ICR_RTOCF_Msk                      /*!< Receiver Time Out Clear Flag */
N#define USART_ICR_EOBCF_Pos           (12U)                                    
N#define USART_ICR_EOBCF_Msk           (0x1U << USART_ICR_EOBCF_Pos)            /*!< 0x00001000 */
N#define USART_ICR_EOBCF               USART_ICR_EOBCF_Msk                      /*!< End Of Block Clear Flag */
N#define USART_ICR_CMCF_Pos            (17U)                                    
N#define USART_ICR_CMCF_Msk            (0x1U << USART_ICR_CMCF_Pos)             /*!< 0x00020000 */
N#define USART_ICR_CMCF                USART_ICR_CMCF_Msk                       /*!< Character Match Clear Flag */
N#define USART_ICR_WUCF_Pos            (20U)                                    
N#define USART_ICR_WUCF_Msk            (0x1U << USART_ICR_WUCF_Pos)             /*!< 0x00100000 */
N#define USART_ICR_WUCF                USART_ICR_WUCF_Msk                       /*!< Wake Up from stop mode Clear Flag */
N
N/*******************  Bit definition for USART_RDR register  ******************/
N#define USART_RDR_RDR                 ((uint16_t)0x01FFU)                      /*!< RDR[8:0] bits (Receive Data value) */
N
N/*******************  Bit definition for USART_TDR register  ******************/
N#define USART_TDR_TDR                 ((uint16_t)0x01FFU)                      /*!< TDR[8:0] bits (Transmit Data value) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Window WATCHDOG (WWDG)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define WWDG_CR_T_Pos           (0U)                                           
N#define WWDG_CR_T_Msk           (0x7FU << WWDG_CR_T_Pos)                       /*!< 0x0000007F */
N#define WWDG_CR_T               WWDG_CR_T_Msk                                  /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define WWDG_CR_T_0             (0x01U << WWDG_CR_T_Pos)                       /*!< 0x00000001 */
N#define WWDG_CR_T_1             (0x02U << WWDG_CR_T_Pos)                       /*!< 0x00000002 */
N#define WWDG_CR_T_2             (0x04U << WWDG_CR_T_Pos)                       /*!< 0x00000004 */
N#define WWDG_CR_T_3             (0x08U << WWDG_CR_T_Pos)                       /*!< 0x00000008 */
N#define WWDG_CR_T_4             (0x10U << WWDG_CR_T_Pos)                       /*!< 0x00000010 */
N#define WWDG_CR_T_5             (0x20U << WWDG_CR_T_Pos)                       /*!< 0x00000020 */
N#define WWDG_CR_T_6             (0x40U << WWDG_CR_T_Pos)                       /*!< 0x00000040 */
N
N/* Legacy defines */
N#define  WWDG_CR_T0 WWDG_CR_T_0
N#define  WWDG_CR_T1 WWDG_CR_T_1
N#define  WWDG_CR_T2 WWDG_CR_T_2
N#define  WWDG_CR_T3 WWDG_CR_T_3
N#define  WWDG_CR_T4 WWDG_CR_T_4
N#define  WWDG_CR_T5 WWDG_CR_T_5
N#define  WWDG_CR_T6 WWDG_CR_T_6
N
N#define WWDG_CR_WDGA_Pos        (7U)                                           
N#define WWDG_CR_WDGA_Msk        (0x1U << WWDG_CR_WDGA_Pos)                     /*!< 0x00000080 */
N#define WWDG_CR_WDGA            WWDG_CR_WDGA_Msk                               /*!< Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define WWDG_CFR_W_Pos          (0U)                                           
N#define WWDG_CFR_W_Msk          (0x7FU << WWDG_CFR_W_Pos)                      /*!< 0x0000007F */
N#define WWDG_CFR_W              WWDG_CFR_W_Msk                                 /*!< W[6:0] bits (7-bit window value) */
N#define WWDG_CFR_W_0            (0x01U << WWDG_CFR_W_Pos)                      /*!< 0x00000001 */
N#define WWDG_CFR_W_1            (0x02U << WWDG_CFR_W_Pos)                      /*!< 0x00000002 */
N#define WWDG_CFR_W_2            (0x04U << WWDG_CFR_W_Pos)                      /*!< 0x00000004 */
N#define WWDG_CFR_W_3            (0x08U << WWDG_CFR_W_Pos)                      /*!< 0x00000008 */
N#define WWDG_CFR_W_4            (0x10U << WWDG_CFR_W_Pos)                      /*!< 0x00000010 */
N#define WWDG_CFR_W_5            (0x20U << WWDG_CFR_W_Pos)                      /*!< 0x00000020 */
N#define WWDG_CFR_W_6            (0x40U << WWDG_CFR_W_Pos)                      /*!< 0x00000040 */
N
N/* Legacy defines */
N#define  WWDG_CFR_W0 WWDG_CFR_W_0
N#define  WWDG_CFR_W1 WWDG_CFR_W_1
N#define  WWDG_CFR_W2 WWDG_CFR_W_2
N#define  WWDG_CFR_W3 WWDG_CFR_W_3
N#define  WWDG_CFR_W4 WWDG_CFR_W_4
N#define  WWDG_CFR_W5 WWDG_CFR_W_5
N#define  WWDG_CFR_W6 WWDG_CFR_W_6
N
N#define WWDG_CFR_WDGTB_Pos      (7U)                                           
N#define WWDG_CFR_WDGTB_Msk      (0x3U << WWDG_CFR_WDGTB_Pos)                   /*!< 0x00000180 */
N#define WWDG_CFR_WDGTB          WWDG_CFR_WDGTB_Msk                             /*!< WDGTB[1:0] bits (Timer Base) */
N#define WWDG_CFR_WDGTB_0        (0x1U << WWDG_CFR_WDGTB_Pos)                   /*!< 0x00000080 */
N#define WWDG_CFR_WDGTB_1        (0x2U << WWDG_CFR_WDGTB_Pos)                   /*!< 0x00000100 */
N
N/* Legacy defines */
N#define  WWDG_CFR_WDGTB0 WWDG_CFR_WDGTB_0
N#define  WWDG_CFR_WDGTB1 WWDG_CFR_WDGTB_1
N
N#define WWDG_CFR_EWI_Pos        (9U)                                           
N#define WWDG_CFR_EWI_Msk        (0x1U << WWDG_CFR_EWI_Pos)                     /*!< 0x00000200 */
N#define WWDG_CFR_EWI            WWDG_CFR_EWI_Msk                               /*!< Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define WWDG_SR_EWIF_Pos        (0U)                                           
N#define WWDG_SR_EWIF_Msk        (0x1U << WWDG_SR_EWIF_Pos)                     /*!< 0x00000001 */
N#define WWDG_SR_EWIF            WWDG_SR_EWIF_Msk                               /*!< Early Wakeup Interrupt Flag */
N
N/**
N  * @}
N  */
N
N /**
N  * @}
N  */
N
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N
N/****************************** ADC Instances *********************************/
N#define IS_ADC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == ADC1)
N
N#define IS_ADC_COMMON_INSTANCE(INSTANCE) ((INSTANCE) == ADC)
N
N/******************************* CAN Instances ********************************/
N#define IS_CAN_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CAN)
N
N/****************************** COMP Instances *********************************/
N#define IS_COMP_ALL_INSTANCE(INSTANCE) (((INSTANCE) == COMP1) || \
N                                        ((INSTANCE) == COMP2))
X#define IS_COMP_ALL_INSTANCE(INSTANCE) (((INSTANCE) == COMP1) ||                                         ((INSTANCE) == COMP2))
N
N#define IS_COMP_COMMON_INSTANCE(COMMON_INSTANCE) ((COMMON_INSTANCE) == COMP12_COMMON)
N
N#define IS_COMP_DAC1SWITCH_INSTANCE(INSTANCE) ((INSTANCE) == COMP1)
N
N#define IS_COMP_WINDOWMODE_INSTANCE(INSTANCE) ((INSTANCE) == COMP2)
N
N/****************************** CEC Instances *********************************/
N#define IS_CEC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CEC)
N
N/****************************** CRC Instances *********************************/
N#define IS_CRC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CRC)
N                                      
N/******************************* DAC Instances ********************************/
N#define IS_DAC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == DAC1)
N
N/******************************* DMA Instances ********************************/
N#define IS_DMA_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Channel1) || \
N                                       ((INSTANCE) == DMA1_Channel2) || \
N                                       ((INSTANCE) == DMA1_Channel3) || \
N                                       ((INSTANCE) == DMA1_Channel4) || \
N                                       ((INSTANCE) == DMA1_Channel5) || \
N                                       ((INSTANCE) == DMA1_Channel6) || \
N                                       ((INSTANCE) == DMA1_Channel7) || \
N                                       ((INSTANCE) == DMA2_Channel1) || \
N                                       ((INSTANCE) == DMA2_Channel2) || \
N                                       ((INSTANCE) == DMA2_Channel3) || \
N                                       ((INSTANCE) == DMA2_Channel4) || \
N                                       ((INSTANCE) == DMA2_Channel5))
X#define IS_DMA_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Channel1) ||                                        ((INSTANCE) == DMA1_Channel2) ||                                        ((INSTANCE) == DMA1_Channel3) ||                                        ((INSTANCE) == DMA1_Channel4) ||                                        ((INSTANCE) == DMA1_Channel5) ||                                        ((INSTANCE) == DMA1_Channel6) ||                                        ((INSTANCE) == DMA1_Channel7) ||                                        ((INSTANCE) == DMA2_Channel1) ||                                        ((INSTANCE) == DMA2_Channel2) ||                                        ((INSTANCE) == DMA2_Channel3) ||                                        ((INSTANCE) == DMA2_Channel4) ||                                        ((INSTANCE) == DMA2_Channel5))
N
N/****************************** GPIO Instances ********************************/
N#define IS_GPIO_ALL_INSTANCE(INSTANCE)  (((INSTANCE) == GPIOA) || \
N                                         ((INSTANCE) == GPIOB) || \
N                                         ((INSTANCE) == GPIOC) || \
N                                         ((INSTANCE) == GPIOD) || \
N                                         ((INSTANCE) == GPIOE) || \
N                                         ((INSTANCE) == GPIOF))
X#define IS_GPIO_ALL_INSTANCE(INSTANCE)  (((INSTANCE) == GPIOA) ||                                          ((INSTANCE) == GPIOB) ||                                          ((INSTANCE) == GPIOC) ||                                          ((INSTANCE) == GPIOD) ||                                          ((INSTANCE) == GPIOE) ||                                          ((INSTANCE) == GPIOF))
N                                         
N/**************************** GPIO Alternate Function Instances ***************/
N#define IS_GPIO_AF_INSTANCE(INSTANCE)   (((INSTANCE) == GPIOA) || \
N                                         ((INSTANCE) == GPIOB) || \
N                                         ((INSTANCE) == GPIOC) || \
N                                         ((INSTANCE) == GPIOD) || \
N                                         ((INSTANCE) == GPIOE) || \
N                                         ((INSTANCE) == GPIOF))
X#define IS_GPIO_AF_INSTANCE(INSTANCE)   (((INSTANCE) == GPIOA) ||                                          ((INSTANCE) == GPIOB) ||                                          ((INSTANCE) == GPIOC) ||                                          ((INSTANCE) == GPIOD) ||                                          ((INSTANCE) == GPIOE) ||                                          ((INSTANCE) == GPIOF))
N
N/****************************** GPIO Lock Instances ***************************/
N#define IS_GPIO_LOCK_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) || \
N                                         ((INSTANCE) == GPIOB))
X#define IS_GPIO_LOCK_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) ||                                          ((INSTANCE) == GPIOB))
N
N/****************************** I2C Instances *********************************/
N#define IS_I2C_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) || \
N                                       ((INSTANCE) == I2C2))
X#define IS_I2C_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) ||                                        ((INSTANCE) == I2C2))
N
N/****************** I2C Instances : wakeup capability from stop modes *********/
N#define IS_I2C_WAKEUP_FROMSTOP_INSTANCE(INSTANCE) ((INSTANCE) == I2C1)
N
N/****************************** I2S Instances *********************************/
N#define IS_I2S_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) || \
N                                       ((INSTANCE) == SPI2))
X#define IS_I2S_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) ||                                        ((INSTANCE) == SPI2))
N
N/****************************** IWDG Instances ********************************/
N#define IS_IWDG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == IWDG)
N
N/****************************** RTC Instances *********************************/
N#define IS_RTC_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == RTC)
N
N/****************************** SMBUS Instances *********************************/
N#define IS_SMBUS_ALL_INSTANCE(INSTANCE) ((INSTANCE) == I2C1)
N
N/****************************** SPI Instances *********************************/
N#define IS_SPI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) || \
N                                       ((INSTANCE) == SPI2))
X#define IS_SPI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) ||                                        ((INSTANCE) == SPI2))
N
N/****************************** TIM Instances *********************************/
N#define IS_TIM_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM6)    || \
N   ((INSTANCE) == TIM7)    || \
N   ((INSTANCE) == TIM14)   || \
N   ((INSTANCE) == TIM15)   || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM6)    ||    ((INSTANCE) == TIM7)    ||    ((INSTANCE) == TIM14)   ||    ((INSTANCE) == TIM15)   ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_CC1_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM14)   || \
N   ((INSTANCE) == TIM15)   || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_CC1_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM14)   ||    ((INSTANCE) == TIM15)   ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_CC2_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM15))
X#define IS_TIM_CC2_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM15))
N
N#define IS_TIM_CC3_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CC3_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_CC4_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CC4_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM15))
X#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM15))
N
N#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM15))
X#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM15))
N
N#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_HALL_INTERFACE_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1))
X#define IS_TIM_HALL_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1))
N  
N#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1))
X#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1))
N
N#define IS_TIM_ETR_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_ETR_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_XOR_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_XOR_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_MASTER_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM6)    || \
N   ((INSTANCE) == TIM7)    || \
N   ((INSTANCE) == TIM15))
X#define IS_TIM_MASTER_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM6)    ||    ((INSTANCE) == TIM7)    ||    ((INSTANCE) == TIM15))
N
N#define IS_TIM_SLAVE_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM15))
X#define IS_TIM_SLAVE_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM15))
N
N#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE)\
N    ((INSTANCE) == TIM2)
X#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE)    ((INSTANCE) == TIM2)
N
N#define IS_TIM_DMABURST_INSTANCE(INSTANCE)\
N    (((INSTANCE) == TIM1)    || \
N     ((INSTANCE) == TIM2)    || \
N     ((INSTANCE) == TIM3)    || \
N     ((INSTANCE) == TIM15)   || \
N     ((INSTANCE) == TIM16)   || \
N     ((INSTANCE) == TIM17))
X#define IS_TIM_DMABURST_INSTANCE(INSTANCE)    (((INSTANCE) == TIM1)    ||      ((INSTANCE) == TIM2)    ||      ((INSTANCE) == TIM3)    ||      ((INSTANCE) == TIM15)   ||      ((INSTANCE) == TIM16)   ||      ((INSTANCE) == TIM17))
N
N#define IS_TIM_BREAK_INSTANCE(INSTANCE)\
N      (((INSTANCE) == TIM1)    || \
N       ((INSTANCE) == TIM15)   || \
N       ((INSTANCE) == TIM16)   || \
N       ((INSTANCE) == TIM17))
X#define IS_TIM_BREAK_INSTANCE(INSTANCE)      (((INSTANCE) == TIM1)    ||        ((INSTANCE) == TIM15)   ||        ((INSTANCE) == TIM16)   ||        ((INSTANCE) == TIM17))
N
N#define IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL) \
N    ((((INSTANCE) == TIM1) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM2) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM3) &&                   \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2) ||          \
N      ((CHANNEL) == TIM_CHANNEL_3) ||          \
N      ((CHANNEL) == TIM_CHANNEL_4)))           \
N    ||                                         \
N    (((INSTANCE) == TIM14) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((INSTANCE) == TIM15) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1) ||          \
N      ((CHANNEL) == TIM_CHANNEL_2)))           \
N    ||                                         \
N    (((INSTANCE) == TIM16) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1)))           \
N    ||                                         \
N    (((INSTANCE) == TIM17) &&                  \
N     (((CHANNEL) == TIM_CHANNEL_1))))
X#define IS_TIM_CCX_INSTANCE(INSTANCE, CHANNEL)     ((((INSTANCE) == TIM1) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM2) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM3) &&                        (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2) ||                ((CHANNEL) == TIM_CHANNEL_3) ||                ((CHANNEL) == TIM_CHANNEL_4)))               ||                                             (((INSTANCE) == TIM14) &&                       (((CHANNEL) == TIM_CHANNEL_1)))               ||                                             (((INSTANCE) == TIM15) &&                       (((CHANNEL) == TIM_CHANNEL_1) ||                ((CHANNEL) == TIM_CHANNEL_2)))               ||                                             (((INSTANCE) == TIM16) &&                       (((CHANNEL) == TIM_CHANNEL_1)))               ||                                             (((INSTANCE) == TIM17) &&                       (((CHANNEL) == TIM_CHANNEL_1))))
N
N#define IS_TIM_CCXN_INSTANCE(INSTANCE, CHANNEL) \
N   ((((INSTANCE) == TIM1) &&                    \
N     (((CHANNEL) == TIM_CHANNEL_1) ||           \
N      ((CHANNEL) == TIM_CHANNEL_2) ||           \
N      ((CHANNEL) == TIM_CHANNEL_3)))            \
N    ||                                          \
N    (((INSTANCE) == TIM15) &&                   \
N      ((CHANNEL) == TIM_CHANNEL_1))             \
N    ||                                          \
N    (((INSTANCE) == TIM16) &&                   \
N     ((CHANNEL) == TIM_CHANNEL_1))              \
N    ||                                          \
N    (((INSTANCE) == TIM17) &&                   \
N     ((CHANNEL) == TIM_CHANNEL_1)))
X#define IS_TIM_CCXN_INSTANCE(INSTANCE, CHANNEL)    ((((INSTANCE) == TIM1) &&                         (((CHANNEL) == TIM_CHANNEL_1) ||                 ((CHANNEL) == TIM_CHANNEL_2) ||                 ((CHANNEL) == TIM_CHANNEL_3)))                ||                                              (((INSTANCE) == TIM15) &&                         ((CHANNEL) == TIM_CHANNEL_1))                 ||                                              (((INSTANCE) == TIM16) &&                        ((CHANNEL) == TIM_CHANNEL_1))                  ||                                              (((INSTANCE) == TIM17) &&                        ((CHANNEL) == TIM_CHANNEL_1)))
N
N#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3))
X#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3))
N
N#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM15)   || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM15)   ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM14)   || \
N   ((INSTANCE) == TIM15)   || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM14)   ||    ((INSTANCE) == TIM15)   ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_DMA_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM6)    || \
N   ((INSTANCE) == TIM7)    || \
N   ((INSTANCE) == TIM15)   || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_DMA_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM6)    ||    ((INSTANCE) == TIM7)    ||    ((INSTANCE) == TIM15)   ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N    
N#define IS_TIM_DMA_CC_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM2)    || \
N   ((INSTANCE) == TIM3)    || \
N   ((INSTANCE) == TIM15)   || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_DMA_CC_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM2)    ||    ((INSTANCE) == TIM3)    ||    ((INSTANCE) == TIM15)   ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N    
N#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE)\
N  (((INSTANCE) == TIM1)    || \
N   ((INSTANCE) == TIM15)   || \
N   ((INSTANCE) == TIM16)   || \
N   ((INSTANCE) == TIM17))
X#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE)  (((INSTANCE) == TIM1)    ||    ((INSTANCE) == TIM15)   ||    ((INSTANCE) == TIM16)   ||    ((INSTANCE) == TIM17))
N
N#define IS_TIM_REMAP_INSTANCE(INSTANCE)\
N  ((INSTANCE) == TIM14)
X#define IS_TIM_REMAP_INSTANCE(INSTANCE)  ((INSTANCE) == TIM14)
N
N#define IS_TIM_ADVANCED_INSTANCE(INSTANCE)\
N  ((INSTANCE) == TIM1)
X#define IS_TIM_ADVANCED_INSTANCE(INSTANCE)  ((INSTANCE) == TIM1)
N
N/****************************** TSC Instances *********************************/
N#define IS_TSC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == TSC)
N
N/*********************** UART Instances : IRDA mode ***************************/
N#define IS_IRDA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                    ((INSTANCE) == USART2) || \
N                                    ((INSTANCE) == USART3))
X#define IS_IRDA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                     ((INSTANCE) == USART2) ||                                     ((INSTANCE) == USART3))
N
N/********************* UART Instances : Smard card mode ***********************/
N#define IS_SMARTCARD_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                         ((INSTANCE) == USART2) || \
N                                         ((INSTANCE) == USART3))
X#define IS_SMARTCARD_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                          ((INSTANCE) == USART2) ||                                          ((INSTANCE) == USART3))
N
N/******************** USART Instances : Synchronous mode **********************/
N#define IS_USART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                     ((INSTANCE) == USART2) || \
N                                     ((INSTANCE) == USART3) || \
N                                     ((INSTANCE) == USART4) || \
N                                     ((INSTANCE) == USART5) || \
N                                     ((INSTANCE) == USART6) || \
N                                     ((INSTANCE) == USART7) || \
N                                     ((INSTANCE) == USART8))
X#define IS_USART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                      ((INSTANCE) == USART2) ||                                      ((INSTANCE) == USART3) ||                                      ((INSTANCE) == USART4) ||                                      ((INSTANCE) == USART5) ||                                      ((INSTANCE) == USART6) ||                                      ((INSTANCE) == USART7) ||                                      ((INSTANCE) == USART8))
N                                     
N/******************** USART Instances : auto Baud rate detection **************/                                     
N#define IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                                            ((INSTANCE) == USART2) || \
N                                                            ((INSTANCE) == USART3))
X#define IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                                             ((INSTANCE) == USART2) ||                                                             ((INSTANCE) == USART3))
N                                                                                              
N/******************** UART Instances : Asynchronous mode **********************/
N#define IS_UART_INSTANCE(INSTANCE)   (((INSTANCE) == USART1) || \
N                                      ((INSTANCE) == USART2) || \
N                                      ((INSTANCE) == USART3) || \
N                                      ((INSTANCE) == USART4) || \
N                                      ((INSTANCE) == USART5) || \
N                                      ((INSTANCE) == USART6) || \
N                                      ((INSTANCE) == USART7) || \
N                                      ((INSTANCE) == USART8))
X#define IS_UART_INSTANCE(INSTANCE)   (((INSTANCE) == USART1) ||                                       ((INSTANCE) == USART2) ||                                       ((INSTANCE) == USART3) ||                                       ((INSTANCE) == USART4) ||                                       ((INSTANCE) == USART5) ||                                       ((INSTANCE) == USART6) ||                                       ((INSTANCE) == USART7) ||                                       ((INSTANCE) == USART8))
N                                      
N/******************** UART Instances : Half-Duplex mode **********************/
N#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE)   (((INSTANCE) == USART1) || \
N                                                 ((INSTANCE) == USART2) || \
N                                                 ((INSTANCE) == USART3) || \
N                                                 ((INSTANCE) == USART4) || \
N                                                 ((INSTANCE) == USART5) || \
N                                                 ((INSTANCE) == USART6) || \
N                                                 ((INSTANCE) == USART7) || \
N                                                 ((INSTANCE) == USART8))
X#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE)   (((INSTANCE) == USART1) ||                                                  ((INSTANCE) == USART2) ||                                                  ((INSTANCE) == USART3) ||                                                  ((INSTANCE) == USART4) ||                                                  ((INSTANCE) == USART5) ||                                                  ((INSTANCE) == USART6) ||                                                  ((INSTANCE) == USART7) ||                                                  ((INSTANCE) == USART8))
N
N/****************** UART Instances : Hardware Flow control ********************/
N#define IS_UART_HWFLOW_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                           ((INSTANCE) == USART2) || \
N                                           ((INSTANCE) == USART3) || \
N                                           ((INSTANCE) == USART4))
X#define IS_UART_HWFLOW_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                            ((INSTANCE) == USART2) ||                                            ((INSTANCE) == USART3) ||                                            ((INSTANCE) == USART4))
N
N/****************** UART Instances : LIN mode ********************/
N#define IS_UART_LIN_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                        ((INSTANCE) == USART2) || \
N                                        ((INSTANCE) == USART3))
X#define IS_UART_LIN_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                         ((INSTANCE) == USART2) ||                                         ((INSTANCE) == USART3))
N
N/****************** UART Instances : wakeup from stop mode ********************/
N#define IS_UART_WAKEUP_FROMSTOP_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                                    ((INSTANCE) == USART2) || \
N                                                    ((INSTANCE) == USART3))
X#define IS_UART_WAKEUP_FROMSTOP_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                                     ((INSTANCE) == USART2) ||                                                     ((INSTANCE) == USART3))
N/* Old macro definition maintained for legacy purpose */
N#define IS_UART_WAKEUP_INSTANCE         IS_UART_WAKEUP_FROMSTOP_INSTANCE
N
N/****************** UART Instances : Driver enable detection ********************/
N#define IS_UART_DRIVER_ENABLE_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || \
N                                                  ((INSTANCE) == USART2) || \
N                                                  ((INSTANCE) == USART3) || \
N                                                  ((INSTANCE) == USART4) || \
N                                                  ((INSTANCE) == USART5) || \
N                                                  ((INSTANCE) == USART6) || \
N                                                  ((INSTANCE) == USART7) || \
N                                                  ((INSTANCE) == USART8))
X#define IS_UART_DRIVER_ENABLE_INSTANCE(INSTANCE) (((INSTANCE) == USART1) ||                                                   ((INSTANCE) == USART2) ||                                                   ((INSTANCE) == USART3) ||                                                   ((INSTANCE) == USART4) ||                                                   ((INSTANCE) == USART5) ||                                                   ((INSTANCE) == USART6) ||                                                   ((INSTANCE) == USART7) ||                                                   ((INSTANCE) == USART8))
N
N/****************************** WWDG Instances ********************************/
N#define IS_WWDG_ALL_INSTANCE(INSTANCE)  ((INSTANCE) == WWDG)
N
N/**
N  * @}
N  */
N
N
N/******************************************************************************/
N/*  For a painless codes migration between the STM32F0xx device product       */
N/*  lines, the aliases defined below are put in place to overcome the         */
N/*  differences in the interrupt handlers and IRQn definitions.               */
N/*  No need to update developed interrupt code when moving across             */
N/*  product lines within the same STM32F0 Family                              */
N/******************************************************************************/
N
N/* Aliases for __IRQn */
N#define ADC1_IRQn                ADC1_COMP_IRQn
N#define DMA1_Channel1_IRQn       DMA1_Ch1_IRQn
N#define DMA1_Channel2_3_IRQn     DMA1_Ch2_3_DMA2_Ch1_2_IRQn
N#define DMA1_Channel4_5_6_7_IRQn DMA1_Ch4_7_DMA2_Ch3_5_IRQn
N#define DMA1_Channel4_5_IRQn     DMA1_Ch4_7_DMA2_Ch3_5_IRQn
N#define PVD_IRQn                 PVD_VDDIO2_IRQn
N#define VDDIO2_IRQn              PVD_VDDIO2_IRQn
N#define RCC_IRQn                 RCC_CRS_IRQn
N#define TIM6_IRQn                TIM6_DAC_IRQn
N#define USART3_4_IRQn            USART3_8_IRQn
N#define USART3_6_IRQn            USART3_8_IRQn
N
N
N/* Aliases for __IRQHandler */
N#define ADC1_IRQHandler                ADC1_COMP_IRQHandler
N#define DMA1_Channel1_IRQHandler       DMA1_Ch1_IRQHandler
N#define DMA1_Channel2_3_IRQHandler     DMA1_Ch2_3_DMA2_Ch1_2_IRQHandler
N#define DMA1_Channel4_5_6_7_IRQHandler DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler
N#define DMA1_Channel4_5_IRQHandler     DMA1_Ch4_7_DMA2_Ch3_5_IRQHandler
N#define PVD_IRQHandler                 PVD_VDDIO2_IRQHandler
N#define VDDIO2_IRQHandler              PVD_VDDIO2_IRQHandler
N#define RCC_IRQHandler                 RCC_CRS_IRQHandler
N#define TIM6_IRQHandler                TIM6_DAC_IRQHandler
N#define USART3_4_IRQHandler            USART3_8_IRQHandler
N#define USART3_6_IRQHandler            USART3_8_IRQHandler
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __STM32F091xC_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 160 "../Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f0xx.h" 2
N#elif defined(STM32F098xx)
S  #include "stm32f098xx.h"
S#elif defined(STM32F030xC)
S  #include "stm32f030xc.h"    
S#else
S #error "Please select first the target STM32F0xx device used in your application (in stm32f0xx.h file)"
N#endif
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_types
N  * @{
N  */ 
Ntypedef enum 
N{
N  RESET = 0, 
N  SET = !RESET
N} FlagStatus, ITStatus;
N
Ntypedef enum 
N{
N  DISABLE = 0, 
N  ENABLE = !DISABLE
N} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum 
N{
N  ERROR = 0, 
N  SUCCESS = !ERROR
N} ErrorStatus;
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N
N/**
N  * @}
N  */
N
N#if defined (USE_HAL_DRIVER)
X#if 1L
N #include "stm32f0xx_hal.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal.h
N  * @author  MCD Application Team
N  * @brief   This file contains all the functions prototypes for the HAL 
N  *          module driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_H
S#define __STM32F0xx_HAL_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32f0xx_hal_conf.h"
S
S/** @addtogroup STM32F0xx_HAL_Driver
S  * @{
S  */
S
S/** @addtogroup HAL
S  * @{
S  */ 
S
S/* Private macros ------------------------------------------------------------*/
S/** @addtogroup HAL_Private_Macros
S  * @{
S  */
S#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F042x6) || defined(STM32F048xx) || \
S    defined(STM32F030x6) || defined(STM32F031x6) || defined(STM32F038xx) || defined(STM32F070x6) || \
S    defined(STM32F070xB) || defined(STM32F030x6)
X#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F042x6) || defined(STM32F048xx) ||     defined(STM32F030x6) || defined(STM32F031x6) || defined(STM32F038xx) || defined(STM32F070x6) ||     defined(STM32F070xB) || defined(STM32F030x6)
S#define IS_SYSCFG_FASTMODEPLUS(__PIN__) ((((__PIN__) & SYSCFG_FASTMODEPLUS_PA9)  == SYSCFG_FASTMODEPLUS_PA9)  || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PA10) == SYSCFG_FASTMODEPLUS_PA10) || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB6)  == SYSCFG_FASTMODEPLUS_PB6)  || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB7)  == SYSCFG_FASTMODEPLUS_PB7)  || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB8)  == SYSCFG_FASTMODEPLUS_PB8)  || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB9)  == SYSCFG_FASTMODEPLUS_PB9))
X#define IS_SYSCFG_FASTMODEPLUS(__PIN__) ((((__PIN__) & SYSCFG_FASTMODEPLUS_PA9)  == SYSCFG_FASTMODEPLUS_PA9)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PA10) == SYSCFG_FASTMODEPLUS_PA10) ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB6)  == SYSCFG_FASTMODEPLUS_PB6)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB7)  == SYSCFG_FASTMODEPLUS_PB7)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB8)  == SYSCFG_FASTMODEPLUS_PB8)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB9)  == SYSCFG_FASTMODEPLUS_PB9))
S#else
S#define IS_SYSCFG_FASTMODEPLUS(__PIN__) ((((__PIN__) & SYSCFG_FASTMODEPLUS_PB6)  == SYSCFG_FASTMODEPLUS_PB6)  || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB7)  == SYSCFG_FASTMODEPLUS_PB7)  || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB8)  == SYSCFG_FASTMODEPLUS_PB8)  || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB9)  == SYSCFG_FASTMODEPLUS_PB9))
X#define IS_SYSCFG_FASTMODEPLUS(__PIN__) ((((__PIN__) & SYSCFG_FASTMODEPLUS_PB6)  == SYSCFG_FASTMODEPLUS_PB6)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB7)  == SYSCFG_FASTMODEPLUS_PB7)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB8)  == SYSCFG_FASTMODEPLUS_PB8)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB9)  == SYSCFG_FASTMODEPLUS_PB9))
S#endif
S#if defined(SYSCFG_CFGR1_PA11_PA12_RMP)
S#define IS_HAL_REMAP_PIN(RMP) ((RMP) == HAL_REMAP_PA11_PA12)
S#endif /* SYSCFG_CFGR1_PA11_PA12_RMP */
S#if defined(STM32F091xC) || defined(STM32F098xx)
S#define IS_HAL_SYSCFG_IRDA_ENV_SEL(SEL)   (((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_TIM16)   || \
S                                           ((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_USART1)   || \
S                                           ((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_USART4))
X#define IS_HAL_SYSCFG_IRDA_ENV_SEL(SEL)   (((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_TIM16)   ||                                            ((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_USART1)   ||                                            ((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_USART4))
S#endif /* STM32F091xC || STM32F098xx */
S/**
S  * @}
S  */
S
S/* Exported types ------------------------------------------------------------*/
S/* Exported constants --------------------------------------------------------*/
S/** @defgroup HAL_Exported_Constants HAL Exported Constants
S  * @{
S  */
S   
S#if defined(SYSCFG_CFGR1_PA11_PA12_RMP)
S/** @defgroup HAL_Pin_remapping HAL Pin remapping
S  * @{
S  */
S#define HAL_REMAP_PA11_PA12                 (SYSCFG_CFGR1_PA11_PA12_RMP)  /*!< PA11 and PA12 remapping bit for small packages (28 and 20 pins).
S                                                                           0: No remap (pin pair PA9/10 mapped on the pins)
S                                                                           1: Remap (pin pair PA11/12 mapped instead of PA9/10) */
S
S/**
S  * @}
S  */
S#endif /* SYSCFG_CFGR1_PA11_PA12_RMP */
S
S#if defined(STM32F091xC) || defined(STM32F098xx)
S/** @defgroup HAL_IRDA_ENV_SEL HAL IRDA Enveloppe Selection
S  * @note Applicable on STM32F09x
S  * @{
S  */
S#define HAL_SYSCFG_IRDA_ENV_SEL_TIM16     (SYSCFG_CFGR1_IRDA_ENV_SEL_0 & SYSCFG_CFGR1_IRDA_ENV_SEL_1)    /* 00: Timer16 is selected as IRDA Modulation enveloppe source */
S#define HAL_SYSCFG_IRDA_ENV_SEL_USART1    (SYSCFG_CFGR1_IRDA_ENV_SEL_0)  /* 01: USART1 is selected as IRDA Modulation enveloppe source */
S#define HAL_SYSCFG_IRDA_ENV_SEL_USART4    (SYSCFG_CFGR1_IRDA_ENV_SEL_1)  /* 10: USART4 is selected as IRDA Modulation enveloppe source */
S
S/**
S  * @}
S  */
S#endif /* STM32F091xC || STM32F098xx */
S
S
S/** @defgroup SYSCFG_FastModePlus_GPIO Fast-mode Plus on GPIO
S  * @{
S  */
S
S/** @brief  Fast-mode Plus driving capability on a specific GPIO
S  */  
S#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F042x6) || defined(STM32F048xx) || \
S    defined(STM32F030x6) || defined(STM32F031x6) || defined(STM32F038xx) || defined(STM32F070x6) || \
S    defined(STM32F070xB) || defined(STM32F030x6)
X#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F042x6) || defined(STM32F048xx) ||     defined(STM32F030x6) || defined(STM32F031x6) || defined(STM32F038xx) || defined(STM32F070x6) ||     defined(STM32F070xB) || defined(STM32F030x6)
S#define SYSCFG_FASTMODEPLUS_PA9        SYSCFG_CFGR1_I2C_FMP_PA9  /*!< Enable Fast-mode Plus on PA9  */
S#define SYSCFG_FASTMODEPLUS_PA10       SYSCFG_CFGR1_I2C_FMP_PA10 /*!< Enable Fast-mode Plus on PA10 */
S#endif
S#define SYSCFG_FASTMODEPLUS_PB6        SYSCFG_CFGR1_I2C_FMP_PB6  /*!< Enable Fast-mode Plus on PB6  */
S#define SYSCFG_FASTMODEPLUS_PB7        SYSCFG_CFGR1_I2C_FMP_PB7  /*!< Enable Fast-mode Plus on PB7  */
S#define SYSCFG_FASTMODEPLUS_PB8        SYSCFG_CFGR1_I2C_FMP_PB8  /*!< Enable Fast-mode Plus on PB8  */
S#define SYSCFG_FASTMODEPLUS_PB9        SYSCFG_CFGR1_I2C_FMP_PB9  /*!< Enable Fast-mode Plus on PB9  */
S
S/**
S * @}
S */
S
S
S#if defined(STM32F091xC) || defined (STM32F098xx)
S/** @defgroup HAL_ISR_Wrapper HAL ISR Wrapper
S  * @brief ISR Wrapper
S  * @note applicable on STM32F09x
S  * @{
S  */
S#define HAL_SYSCFG_ITLINE0                           ( 0x00000000U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE1                           ( 0x00000001U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE2                           ( 0x00000002U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE3                           ( 0x00000003U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE4                           ( 0x00000004U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE5                           ( 0x00000005U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE6                           ( 0x00000006U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE7                           ( 0x00000007U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE8                           ( 0x00000008U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE9                           ( 0x00000009U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE10                          ( 0x0000000AU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE11                          ( 0x0000000BU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE12                          ( 0x0000000CU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE13                          ( 0x0000000DU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE14                          ( 0x0000000EU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE15                          ( 0x0000000FU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE16                          ( 0x00000010U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE17                          ( 0x00000011U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE18                          ( 0x00000012U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE19                          ( 0x00000013U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE20                          ( 0x00000014U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE21                          ( 0x00000015U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE22                          ( 0x00000016U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE23                          ( 0x00000017U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE24                          ( 0x00000018U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE25                          ( 0x00000019U) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE26                          ( 0x0000001AU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE27                          ( 0x0000001BU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE28                          ( 0x0000001CU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE29                          ( 0x0000001DU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE30                          ( 0x0000001EU) /*!< Internal define for macro handling */
S#define HAL_SYSCFG_ITLINE31                          ( 0x0000001FU) /*!< Internal define for macro handling */
S
S#define HAL_ITLINE_EWDG           ((uint32_t) ((HAL_SYSCFG_ITLINE0 << 0x18U) | SYSCFG_ITLINE0_SR_EWDG)) /*!< EWDG has expired .... */
S#if defined(STM32F091xC)
S#define HAL_ITLINE_PVDOUT         ((uint32_t) ((HAL_SYSCFG_ITLINE1 << 0x18U) | SYSCFG_ITLINE1_SR_PVDOUT)) /*!< Power voltage detection Interrupt .... */
S#endif
S#define HAL_ITLINE_VDDIO2         ((uint32_t) ((HAL_SYSCFG_ITLINE1 << 0x18U) | SYSCFG_ITLINE1_SR_VDDIO2)) /*!< VDDIO2 Interrupt .... */
S#define HAL_ITLINE_RTC_WAKEUP     ((uint32_t) ((HAL_SYSCFG_ITLINE2 << 0x18U) | SYSCFG_ITLINE2_SR_RTC_WAKEUP)) /*!< RTC WAKEUP -> exti[20] Interrupt */
S#define HAL_ITLINE_RTC_TSTAMP     ((uint32_t) ((HAL_SYSCFG_ITLINE2 << 0x18U) | SYSCFG_ITLINE2_SR_RTC_TSTAMP)) /*!< RTC Time Stamp -> exti[19] interrupt */
S#define HAL_ITLINE_RTC_ALRA       ((uint32_t) ((HAL_SYSCFG_ITLINE2 << 0x18U) | SYSCFG_ITLINE2_SR_RTC_ALRA)) /*!< RTC Alarm -> exti[17] interrupt .... */
S#define HAL_ITLINE_FLASH_ITF      ((uint32_t) ((HAL_SYSCFG_ITLINE3 << 0x18U) | SYSCFG_ITLINE3_SR_FLASH_ITF)) /*!< Flash ITF Interrupt */
S#define HAL_ITLINE_CRS            ((uint32_t) ((HAL_SYSCFG_ITLINE4 << 0x18U) | SYSCFG_ITLINE4_SR_CRS)) /*!< CRS Interrupt */
S#define HAL_ITLINE_CLK_CTRL       ((uint32_t) ((HAL_SYSCFG_ITLINE4 << 0x18U) | SYSCFG_ITLINE4_SR_CLK_CTRL)) /*!< CLK Control Interrupt */
S#define HAL_ITLINE_EXTI0          ((uint32_t) ((HAL_SYSCFG_ITLINE5 << 0x18U) | SYSCFG_ITLINE5_SR_EXTI0)) /*!< External Interrupt 0 */
S#define HAL_ITLINE_EXTI1          ((uint32_t) ((HAL_SYSCFG_ITLINE5 << 0x18U) | SYSCFG_ITLINE5_SR_EXTI1)) /*!< External Interrupt 1 */
S#define HAL_ITLINE_EXTI2          ((uint32_t) ((HAL_SYSCFG_ITLINE6 << 0x18U) | SYSCFG_ITLINE6_SR_EXTI2)) /*!< External Interrupt 2 */
S#define HAL_ITLINE_EXTI3          ((uint32_t) ((HAL_SYSCFG_ITLINE6 << 0x18U) | SYSCFG_ITLINE6_SR_EXTI3)) /*!< External Interrupt 3 */
S#define HAL_ITLINE_EXTI4          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI4)) /*!< EXTI4 Interrupt */
S#define HAL_ITLINE_EXTI5          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI5)) /*!< EXTI5 Interrupt */
S#define HAL_ITLINE_EXTI6          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI6)) /*!< EXTI6 Interrupt */
S#define HAL_ITLINE_EXTI7          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI7)) /*!< EXTI7 Interrupt */
S#define HAL_ITLINE_EXTI8          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI8)) /*!< EXTI8 Interrupt */
S#define HAL_ITLINE_EXTI9          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI9)) /*!< EXTI9 Interrupt */
S#define HAL_ITLINE_EXTI10         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI10)) /*!< EXTI10 Interrupt */
S#define HAL_ITLINE_EXTI11         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI11)) /*!< EXTI11 Interrupt */
S#define HAL_ITLINE_EXTI12         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI12)) /*!< EXTI12 Interrupt */
S#define HAL_ITLINE_EXTI13         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI13)) /*!< EXTI13 Interrupt */
S#define HAL_ITLINE_EXTI14         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI14)) /*!< EXTI14 Interrupt */
S#define HAL_ITLINE_EXTI15         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI15)) /*!< EXTI15 Interrupt */
S#define HAL_ITLINE_TSC_EOA        ((uint32_t) ((HAL_SYSCFG_ITLINE8 << 0x18U) | SYSCFG_ITLINE8_SR_TSC_EOA)) /*!< Touch control EOA Interrupt */
S#define HAL_ITLINE_TSC_MCE        ((uint32_t) ((HAL_SYSCFG_ITLINE8 << 0x18U) | SYSCFG_ITLINE8_SR_TSC_MCE)) /*!< Touch control MCE Interrupt */
S#define HAL_ITLINE_DMA1_CH1       ((uint32_t) ((HAL_SYSCFG_ITLINE9 << 0x18U) | SYSCFG_ITLINE9_SR_DMA1_CH1)) /*!< DMA1 Channel 1 Interrupt */
S#define HAL_ITLINE_DMA1_CH2       ((uint32_t) ((HAL_SYSCFG_ITLINE10 << 0x18U) | SYSCFG_ITLINE10_SR_DMA1_CH2)) /*!< DMA1 Channel 2 Interrupt */
S#define HAL_ITLINE_DMA1_CH3       ((uint32_t) ((HAL_SYSCFG_ITLINE10 << 0x18U) | SYSCFG_ITLINE10_SR_DMA1_CH3)) /*!< DMA1 Channel 3 Interrupt */
S#define HAL_ITLINE_DMA2_CH1       ((uint32_t) ((HAL_SYSCFG_ITLINE10 << 0x18U) | SYSCFG_ITLINE10_SR_DMA2_CH1)) /*!< DMA2 Channel 1 Interrupt */
S#define HAL_ITLINE_DMA2_CH2       ((uint32_t) ((HAL_SYSCFG_ITLINE10 << 0x18U) | SYSCFG_ITLINE10_SR_DMA2_CH2)) /*!< DMA2 Channel 2 Interrupt */
S#define HAL_ITLINE_DMA1_CH4       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA1_CH4)) /*!< DMA1 Channel 4 Interrupt */
S#define HAL_ITLINE_DMA1_CH5       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA1_CH5)) /*!< DMA1 Channel 5 Interrupt */
S#define HAL_ITLINE_DMA1_CH6       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA1_CH6)) /*!< DMA1 Channel 6 Interrupt */
S#define HAL_ITLINE_DMA1_CH7       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA1_CH7)) /*!< DMA1 Channel 7 Interrupt */
S#define HAL_ITLINE_DMA2_CH3       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA2_CH3)) /*!< DMA2 Channel 3 Interrupt */
S#define HAL_ITLINE_DMA2_CH4       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA2_CH4)) /*!< DMA2 Channel 4 Interrupt */
S#define HAL_ITLINE_DMA2_CH5       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA2_CH5)) /*!< DMA2 Channel 5 Interrupt */
S#define HAL_ITLINE_ADC            ((uint32_t) ((HAL_SYSCFG_ITLINE12 << 0x18U) | SYSCFG_ITLINE12_SR_ADC)) /*!< ADC Interrupt */
S#define HAL_ITLINE_COMP1          ((uint32_t) ((HAL_SYSCFG_ITLINE12 << 0x18U) | SYSCFG_ITLINE12_SR_COMP1)) /*!< COMP1 Interrupt -> exti[21] */
S#define HAL_ITLINE_COMP2          ((uint32_t) ((HAL_SYSCFG_ITLINE12 << 0x18U) | SYSCFG_ITLINE12_SR_COMP2)) /*!< COMP2 Interrupt -> exti[21] */
S#define HAL_ITLINE_TIM1_BRK       ((uint32_t) ((HAL_SYSCFG_ITLINE13 << 0x18U) | SYSCFG_ITLINE13_SR_TIM1_BRK)) /*!< TIM1 BRK Interrupt */
S#define HAL_ITLINE_TIM1_UPD       ((uint32_t) ((HAL_SYSCFG_ITLINE13 << 0x18U) | SYSCFG_ITLINE13_SR_TIM1_UPD)) /*!< TIM1 UPD Interrupt */
S#define HAL_ITLINE_TIM1_TRG       ((uint32_t) ((HAL_SYSCFG_ITLINE13 << 0x18U) | SYSCFG_ITLINE13_SR_TIM1_TRG)) /*!< TIM1 TRG Interrupt */
S#define HAL_ITLINE_TIM1_CCU       ((uint32_t) ((HAL_SYSCFG_ITLINE13 << 0x18U) | SYSCFG_ITLINE13_SR_TIM1_CCU)) /*!< TIM1 CCU Interrupt */
S#define HAL_ITLINE_TIM1_CC        ((uint32_t) ((HAL_SYSCFG_ITLINE14 << 0x18U) | SYSCFG_ITLINE14_SR_TIM1_CC)) /*!< TIM1 CC Interrupt */
S#define HAL_ITLINE_TIM2           ((uint32_t) ((HAL_SYSCFG_ITLINE15 << 0x18U) | SYSCFG_ITLINE15_SR_TIM2_GLB)) /*!< TIM2 Interrupt */
S#define HAL_ITLINE_TIM3           ((uint32_t) ((HAL_SYSCFG_ITLINE16 << 0x18U) | SYSCFG_ITLINE16_SR_TIM3_GLB)) /*!< TIM3 Interrupt */
S#define HAL_ITLINE_DAC            ((uint32_t) ((HAL_SYSCFG_ITLINE17 << 0x18U) | SYSCFG_ITLINE17_SR_DAC)) /*!< DAC Interrupt */
S#define HAL_ITLINE_TIM6           ((uint32_t) ((HAL_SYSCFG_ITLINE17 << 0x18U) | SYSCFG_ITLINE17_SR_TIM6_GLB)) /*!< TIM6 Interrupt */
S#define HAL_ITLINE_TIM7           ((uint32_t) ((HAL_SYSCFG_ITLINE18 << 0x18U) | SYSCFG_ITLINE18_SR_TIM7_GLB)) /*!< TIM7 Interrupt */
S#define HAL_ITLINE_TIM14          ((uint32_t) ((HAL_SYSCFG_ITLINE19 << 0x18U) | SYSCFG_ITLINE19_SR_TIM14_GLB)) /*!< TIM14 Interrupt */
S#define HAL_ITLINE_TIM15          ((uint32_t) ((HAL_SYSCFG_ITLINE20 << 0x18U) | SYSCFG_ITLINE20_SR_TIM15_GLB)) /*!< TIM15 Interrupt */
S#define HAL_ITLINE_TIM16          ((uint32_t) ((HAL_SYSCFG_ITLINE21 << 0x18U) | SYSCFG_ITLINE21_SR_TIM16_GLB)) /*!< TIM16 Interrupt */
S#define HAL_ITLINE_TIM17          ((uint32_t) ((HAL_SYSCFG_ITLINE22 << 0x18U) | SYSCFG_ITLINE22_SR_TIM17_GLB)) /*!< TIM17 Interrupt */
S#define HAL_ITLINE_I2C1           ((uint32_t) ((HAL_SYSCFG_ITLINE23 << 0x18U) | SYSCFG_ITLINE23_SR_I2C1_GLB)) /*!< I2C1 Interrupt -> exti[23] */
S#define HAL_ITLINE_I2C2           ((uint32_t) ((HAL_SYSCFG_ITLINE24 << 0x18U) | SYSCFG_ITLINE24_SR_I2C2_GLB)) /*!< I2C2 Interrupt */
S#define HAL_ITLINE_SPI1           ((uint32_t) ((HAL_SYSCFG_ITLINE25 << 0x18U) | SYSCFG_ITLINE25_SR_SPI1)) /*!< I2C1 Interrupt -> exti[23] */
S#define HAL_ITLINE_SPI2           ((uint32_t) ((HAL_SYSCFG_ITLINE26 << 0x18U) | SYSCFG_ITLINE26_SR_SPI2)) /*!< SPI1 Interrupt */
S#define HAL_ITLINE_USART1         ((uint32_t) ((HAL_SYSCFG_ITLINE27 << 0x18U) | SYSCFG_ITLINE27_SR_USART1_GLB)) /*!< USART1 GLB Interrupt -> exti[25] */
S#define HAL_ITLINE_USART2         ((uint32_t) ((HAL_SYSCFG_ITLINE28 << 0x18U) | SYSCFG_ITLINE28_SR_USART2_GLB)) /*!< USART2 GLB Interrupt -> exti[26] */
S#define HAL_ITLINE_USART3         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART3_GLB)) /*!< USART3 Interrupt .... */
S#define HAL_ITLINE_USART4         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART4_GLB)) /*!< USART4 Interrupt .... */
S#define HAL_ITLINE_USART5         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART5_GLB)) /*!< USART5 Interrupt .... */
S#define HAL_ITLINE_USART6         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART6_GLB)) /*!< USART6 Interrupt .... */
S#define HAL_ITLINE_USART7         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART7_GLB)) /*!< USART7 Interrupt .... */
S#define HAL_ITLINE_USART8         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART8_GLB)) /*!< USART8 Interrupt .... */
S#define HAL_ITLINE_CAN            ((uint32_t) ((HAL_SYSCFG_ITLINE30 << 0x18U) | SYSCFG_ITLINE30_SR_CAN)) /*!< CAN Interrupt */
S#define HAL_ITLINE_CEC            ((uint32_t) ((HAL_SYSCFG_ITLINE30 << 0x18U) | SYSCFG_ITLINE30_SR_CEC)) /*!< CEC Interrupt -> exti[27] */
S/**
S  * @}
S  */
S#endif /* STM32F091xC || STM32F098xx */
S
S/**
S  * @}
S  */  
S
S/* Exported macros -----------------------------------------------------------*/
S/** @defgroup HAL_Exported_Macros HAL Exported Macros
S  * @{  
S  */
S
S/** @defgroup HAL_Freeze_Unfreeze_Peripherals HAL Freeze Unfreeze Peripherals
S  * @brief  Freeze/Unfreeze Peripherals in Debug mode 
S  * @{  
S  */
S  
S#if defined(DBGMCU_APB1_FZ_DBG_CAN_STOP)
S#define __HAL_FREEZE_CAN_DBGMCU()            (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN_STOP))
S#define __HAL_UNFREEZE_CAN_DBGMCU()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN_STOP))
S#endif /* DBGMCU_APB1_FZ_DBG_CAN_STOP */
S
S#if defined(DBGMCU_APB1_FZ_DBG_RTC_STOP)
S#define __HAL_DBGMCU_FREEZE_RTC()            (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_RTC_STOP))
S#define __HAL_DBGMCU_UNFREEZE_RTC()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_RTC_STOP))
S#endif /* DBGMCU_APB1_FZ_DBG_RTC_STOP */
S
S#if defined(DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT)
S#define __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
S#define __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT() (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
S#endif /* DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT */
S
S#if defined(DBGMCU_APB1_FZ_DBG_IWDG_STOP)
S#define __HAL_DBGMCU_FREEZE_IWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_IWDG_STOP))
S#define __HAL_DBGMCU_UNFREEZE_IWDG()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_IWDG_STOP))
S#endif /* DBGMCU_APB1_FZ_DBG_IWDG_STOP */
S
S#if defined(DBGMCU_APB1_FZ_DBG_WWDG_STOP)
S#define __HAL_DBGMCU_FREEZE_WWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_WWDG_STOP))
S#define __HAL_DBGMCU_UNFREEZE_WWDG()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_WWDG_STOP))
S#endif /* DBGMCU_APB1_FZ_DBG_WWDG_STOP */
S
S#if defined(DBGMCU_APB1_FZ_DBG_TIM2_STOP)
S#define __HAL_DBGMCU_FREEZE_TIM2()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM2_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM2()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM2_STOP))
S#endif /* DBGMCU_APB1_FZ_DBG_TIM2_STOP */
S
S#if defined(DBGMCU_APB1_FZ_DBG_TIM3_STOP)
S#define __HAL_DBGMCU_FREEZE_TIM3()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM3_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM3()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM3_STOP))
S#endif /* DBGMCU_APB1_FZ_DBG_TIM3_STOP */
S
S#if defined(DBGMCU_APB1_FZ_DBG_TIM6_STOP)
S#define __HAL_DBGMCU_FREEZE_TIM6()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM6_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM6()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM6_STOP))
S#endif /* DBGMCU_APB1_FZ_DBG_TIM6_STOP */
S
S#if defined(DBGMCU_APB1_FZ_DBG_TIM7_STOP)
S#define __HAL_DBGMCU_FREEZE_TIM7()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM7_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM7()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM7_STOP))
S#endif /* DBGMCU_APB1_FZ_DBG_TIM7_STOP */
S
S#if defined(DBGMCU_APB1_FZ_DBG_TIM14_STOP)
S#define __HAL_DBGMCU_FREEZE_TIM14()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM14_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM14()        (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM14_STOP))
S#endif /* DBGMCU_APB1_FZ_DBG_TIM14_STOP */
S
S#if defined(DBGMCU_APB2_FZ_DBG_TIM1_STOP)
S#define __HAL_DBGMCU_FREEZE_TIM1()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM1_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM1()         (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM1_STOP))
S#endif /* DBGMCU_APB2_FZ_DBG_TIM1_STOP */
S
S#if defined(DBGMCU_APB2_FZ_DBG_TIM15_STOP)
S#define __HAL_DBGMCU_FREEZE_TIM15()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM15_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM15()        (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM15_STOP))
S#endif /* DBGMCU_APB2_FZ_DBG_TIM15_STOP */
S
S#if defined(DBGMCU_APB2_FZ_DBG_TIM16_STOP)
S#define __HAL_DBGMCU_FREEZE_TIM16()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM16_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM16()        (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM16_STOP))
S#endif /* DBGMCU_APB2_FZ_DBG_TIM16_STOP */
S
S#if defined(DBGMCU_APB2_FZ_DBG_TIM17_STOP)
S#define __HAL_DBGMCU_FREEZE_TIM17()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM17_STOP))
S#define __HAL_DBGMCU_UNFREEZE_TIM17()        (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM17_STOP))
S#endif /* DBGMCU_APB2_FZ_DBG_TIM17_STOP */
S
S/**
S  * @}
S  */  
S  
S/** @defgroup Memory_Mapping_Selection Memory Mapping Selection
S  * @{   
S  */
S#if defined(SYSCFG_CFGR1_MEM_MODE)
S/** @brief  Main Flash memory mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_FLASH()        (SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_MEM_MODE))
S#endif /* SYSCFG_CFGR1_MEM_MODE */
S
S#if defined(SYSCFG_CFGR1_MEM_MODE_0)
S/** @brief  System Flash memory mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH()  do {SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_MEM_MODE); \
S                                             SYSCFG->CFGR1 |= SYSCFG_CFGR1_MEM_MODE_0;  \
S                                            }while(0)
X#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH()  do {SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_MEM_MODE);                                              SYSCFG->CFGR1 |= SYSCFG_CFGR1_MEM_MODE_0;                                              }while(0)
S#endif /* SYSCFG_CFGR1_MEM_MODE_0 */
S
S#if defined(SYSCFG_CFGR1_MEM_MODE_0) && defined(SYSCFG_CFGR1_MEM_MODE_1)
S/** @brief  Embedded SRAM mapped at 0x00000000
S  */
S#define __HAL_SYSCFG_REMAPMEMORY_SRAM()         do {SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_MEM_MODE); \
S                                             SYSCFG->CFGR1 |= (SYSCFG_CFGR1_MEM_MODE_0 | SYSCFG_CFGR1_MEM_MODE_1); \
S                                            }while(0) 
X#define __HAL_SYSCFG_REMAPMEMORY_SRAM()         do {SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_MEM_MODE);                                              SYSCFG->CFGR1 |= (SYSCFG_CFGR1_MEM_MODE_0 | SYSCFG_CFGR1_MEM_MODE_1);                                             }while(0) 
S#endif /* SYSCFG_CFGR1_MEM_MODE_0 && SYSCFG_CFGR1_MEM_MODE_1 */
S/**
S  * @}
S  */ 
S
S
S#if defined(SYSCFG_CFGR1_PA11_PA12_RMP)
S/** @defgroup HAL_Pin_remap HAL Pin remap 
S  * @brief  Pin remapping enable/disable macros
S  * @param __PIN_REMAP__ This parameter can be a value of @ref HAL_Pin_remapping
S  * @{   
S  */
S#define __HAL_REMAP_PIN_ENABLE(__PIN_REMAP__)          do {assert_param(IS_HAL_REMAP_PIN((__PIN_REMAP__)));                 \
S                                                           SYSCFG->CFGR1 |= (__PIN_REMAP__);                                \
S                                                         }while(0)
X#define __HAL_REMAP_PIN_ENABLE(__PIN_REMAP__)          do {assert_param(IS_HAL_REMAP_PIN((__PIN_REMAP__)));                                                                            SYSCFG->CFGR1 |= (__PIN_REMAP__);                                                                                         }while(0)
S#define __HAL_REMAP_PIN_DISABLE(__PIN_REMAP__)         do {assert_param(IS_HAL_REMAP_PIN((__PIN_REMAP__)));                 \
S                                                           SYSCFG->CFGR1 &= ~(__PIN_REMAP__);                               \
S                                                         }while(0)
X#define __HAL_REMAP_PIN_DISABLE(__PIN_REMAP__)         do {assert_param(IS_HAL_REMAP_PIN((__PIN_REMAP__)));                                                                            SYSCFG->CFGR1 &= ~(__PIN_REMAP__);                                                                                        }while(0)
S/**
S  * @}
S  */  
S#endif /* SYSCFG_CFGR1_PA11_PA12_RMP */
S
S/** @brief  Fast-mode Plus driving capability enable/disable macros
S  * @param __FASTMODEPLUS__ This parameter can be a value of @ref SYSCFG_FastModePlus_GPIO values.
S  *                          That you can find above these macros.
S  */
S#define __HAL_SYSCFG_FASTMODEPLUS_ENABLE(__FASTMODEPLUS__)  do {assert_param(IS_SYSCFG_FASTMODEPLUS((__FASTMODEPLUS__)));\
S                                                                SET_BIT(SYSCFG->CFGR1, (__FASTMODEPLUS__));\
S                                                               }while(0)
X#define __HAL_SYSCFG_FASTMODEPLUS_ENABLE(__FASTMODEPLUS__)  do {assert_param(IS_SYSCFG_FASTMODEPLUS((__FASTMODEPLUS__)));                                                                SET_BIT(SYSCFG->CFGR1, (__FASTMODEPLUS__));                                                               }while(0)
S
S#define __HAL_SYSCFG_FASTMODEPLUS_DISABLE(__FASTMODEPLUS__) do {assert_param(IS_SYSCFG_FASTMODEPLUS((__FASTMODEPLUS__)));\
S                                                                CLEAR_BIT(SYSCFG->CFGR1, (__FASTMODEPLUS__));\
S                                                               }while(0)
X#define __HAL_SYSCFG_FASTMODEPLUS_DISABLE(__FASTMODEPLUS__) do {assert_param(IS_SYSCFG_FASTMODEPLUS((__FASTMODEPLUS__)));                                                                CLEAR_BIT(SYSCFG->CFGR1, (__FASTMODEPLUS__));                                                               }while(0)
S#if defined(SYSCFG_CFGR2_LOCKUP_LOCK)
S/** @defgroup Cortex_Lockup_Enable Cortex Lockup Enable
S  * @{   
S  */
S/** @brief  SYSCFG Break Lockup lock
S  *         Enables and locks the connection of Cortex-M0 LOCKUP (Hardfault) output to TIM1/15/16/17 Break input
S  * @note   The selected configuration is locked and can be unlocked by system reset
S  */
S#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()   do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_LOCKUP_LOCK); \
S                                               SYSCFG->CFGR2 |= SYSCFG_CFGR2_LOCKUP_LOCK;    \
S                                              }while(0)
X#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()   do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_LOCKUP_LOCK);                                                SYSCFG->CFGR2 |= SYSCFG_CFGR2_LOCKUP_LOCK;                                                  }while(0)
S/**
S  * @}
S  */  
S#endif /* SYSCFG_CFGR2_LOCKUP_LOCK */
S
S#if defined(SYSCFG_CFGR2_PVD_LOCK)
S/** @defgroup PVD_Lock_Enable PVD Lock
S  * @{  
S  */
S/** @brief  SYSCFG Break PVD lock
S  *         Enables and locks the PVD connection with Timer1/8/15/16/17 Break Input, , as well as the PVDE and PLS[2:0] in the PWR_CR register
S  * @note   The selected configuration is locked and can be unlocked by system reset
S  */
S#define __HAL_SYSCFG_BREAK_PVD_LOCK()      do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_PVD_LOCK); \
S                                               SYSCFG->CFGR2 |= SYSCFG_CFGR2_PVD_LOCK;    \
S                                              }while(0)
X#define __HAL_SYSCFG_BREAK_PVD_LOCK()      do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_PVD_LOCK);                                                SYSCFG->CFGR2 |= SYSCFG_CFGR2_PVD_LOCK;                                                  }while(0)
S/**
S  * @}
S  */
S#endif /* SYSCFG_CFGR2_PVD_LOCK */
S
S#if defined(SYSCFG_CFGR2_SRAM_PARITY_LOCK)
S/** @defgroup SRAM_Parity_Lock SRAM Parity Lock
S  * @{
S  */
S/** @brief  SYSCFG Break SRAM PARITY lock
S  *         Enables and locks the SRAM_PARITY error signal with Break Input of TIMER1/8/15/16/17
S  * @note   The selected configuration is locked and can be unlocked by system reset
S  */
S#define __HAL_SYSCFG_BREAK_SRAMPARITY_LOCK() do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_SRAM_PARITY_LOCK); \
S                                                 SYSCFG->CFGR2 |= SYSCFG_CFGR2_SRAM_PARITY_LOCK;    \
S                                                }while(0)
X#define __HAL_SYSCFG_BREAK_SRAMPARITY_LOCK() do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_SRAM_PARITY_LOCK);                                                  SYSCFG->CFGR2 |= SYSCFG_CFGR2_SRAM_PARITY_LOCK;                                                    }while(0)
S/**
S  * @}
S  */
S#endif /* SYSCFG_CFGR2_SRAM_PARITY_LOCK */
S
S#if defined(SYSCFG_CFGR2_SRAM_PEF)
S/** @defgroup HAL_SYSCFG_Parity_check_on_RAM HAL SYSCFG Parity check on RAM
S  * @brief  Parity check on RAM disable macro
S  * @note   Disabling the parity check on RAM locks the configuration bit.
S  *         To re-enable the parity check on RAM perform a system reset.
S  * @{  
S  */
S#define __HAL_SYSCFG_RAM_PARITYCHECK_DISABLE()   (SYSCFG->CFGR2 |= SYSCFG_CFGR2_SRAM_PEF)
S/**
S  * @}
S  */
S#endif /* SYSCFG_CFGR2_SRAM_PEF */
S
S
S#if defined(STM32F091xC) || defined (STM32F098xx)
S/** @defgroup HAL_ISR_wrapper_check HAL ISR wrapper check
S  * @brief  ISR wrapper check
S  * @note This feature is applicable on STM32F09x  
S  * @note Allow to determine interrupt source per line.
S  * @{  
S  */
S#define __HAL_GET_PENDING_IT(__SOURCE__)       (SYSCFG->IT_LINE_SR[((__SOURCE__) >> 0x18U)] & ((__SOURCE__) & 0x00FFFFFF))
S/**
S  * @}
S  */
S#endif /* (STM32F091xC) || defined (STM32F098xx)*/
S
S#if defined(STM32F091xC) || defined (STM32F098xx)
S/** @defgroup HAL_SYSCFG_IRDA_modulation_envelope_selection HAL SYSCFG IRDA modulation envelope selection
S  * @brief  selection of the modulation envelope signal macro, using bits [7:6] of SYS_CTRL(CFGR1) register
S  * @note This feature is applicable on STM32F09x
S  * @param __SOURCE__ This parameter can be a value of @ref HAL_IRDA_ENV_SEL
S  * @{  
S  */
S#define __HAL_SYSCFG_IRDA_ENV_SELECTION(__SOURCE__)  do {assert_param(IS_HAL_SYSCFG_IRDA_ENV_SEL((__SOURCE__))); \
S                                                         SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_IRDA_ENV_SEL); \
S                                                         SYSCFG->CFGR1 |= (__SOURCE__);    \
S                                                        }while(0)
X#define __HAL_SYSCFG_IRDA_ENV_SELECTION(__SOURCE__)  do {assert_param(IS_HAL_SYSCFG_IRDA_ENV_SEL((__SOURCE__)));                                                          SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_IRDA_ENV_SEL);                                                          SYSCFG->CFGR1 |= (__SOURCE__);                                                            }while(0)
S
S#define __HAL_SYSCFG_GET_IRDA_ENV_SELECTION()  ((SYSCFG->CFGR1) & 0x000000C0)
S/**
S  * @}
S  */
S#endif /* (STM32F091xC) || defined (STM32F098xx)*/
S
S/**
S  * @}
S  */  
S  
S/* Exported functions --------------------------------------------------------*/
S
S/** @addtogroup HAL_Exported_Functions
S  * @{
S  */
S
S/** @addtogroup HAL_Exported_Functions_Group1
S  * @{
S  */    
S/* Initialization and de-initialization functions  ******************************/
SHAL_StatusTypeDef HAL_Init(void);
SHAL_StatusTypeDef HAL_DeInit(void);
Svoid              HAL_MspInit(void);
Svoid              HAL_MspDeInit(void);
SHAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority);
S/**
S  * @}
S  */  
S
S/** @addtogroup HAL_Exported_Functions_Group2
S  * @{
S  */    
S
S/* Peripheral Control functions  ************************************************/
Svoid              HAL_IncTick(void);
Svoid              HAL_Delay(__IO uint32_t Delay);
Suint32_t          HAL_GetTick(void);
Svoid              HAL_SuspendTick(void);
Svoid              HAL_ResumeTick(void);
Suint32_t          HAL_GetHalVersion(void);
Suint32_t          HAL_GetREVID(void);
Suint32_t          HAL_GetDEVID(void);
Suint32_t          HAL_GetUIDw0(void);
Suint32_t          HAL_GetUIDw1(void);
Suint32_t          HAL_GetUIDw2(void);
Svoid              HAL_DBGMCU_EnableDBGStopMode(void);
Svoid              HAL_DBGMCU_DisableDBGStopMode(void);
Svoid              HAL_DBGMCU_EnableDBGStandbyMode(void);
Svoid              HAL_DBGMCU_DisableDBGStandbyMode(void);
S/**
S  * @}
S  */ 
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */ 
S
S/**
S  * @}
S  */
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __STM32F0xx_HAL_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 223 "../Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f0xx.h" 2
N#endif /* USE_HAL_DRIVER */
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __STM32F0xx_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 47 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_def.h" 2
N#if defined(USE_HAL_LEGACY)
X#if 0L
S  #include "Legacy/stm32_hal_legacy.h"
N#endif
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 185531 $
N * Checkin $Date: 2014-05-29 15:16:06 +0100 (Thu, 29 May 2014) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5050157
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 51 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_def.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  HAL Status structures definition  
N  */  
Ntypedef enum 
N{
N  HAL_OK       = 0x00U,
N  HAL_ERROR    = 0x01U,
N  HAL_BUSY     = 0x02U,
N  HAL_TIMEOUT  = 0x03U
N} HAL_StatusTypeDef;
N
N/** 
N  * @brief  HAL Lock structures definition  
N  */
Ntypedef enum 
N{
N  HAL_UNLOCKED = 0x00U,
N  HAL_LOCKED   = 0x01U  
N} HAL_LockTypeDef;
N
N/* Exported macro ------------------------------------------------------------*/
N
N#define HAL_MAX_DELAY      0xFFFFFFFFU
N
N#define HAL_IS_BIT_SET(REG, BIT)         (((REG) & (BIT)) != RESET)
N#define HAL_IS_BIT_CLR(REG, BIT)         (((REG) & (BIT)) == RESET)
N
N#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD_, __DMA_HANDLE_)                 \
N                        do{                                                        \
N                              (__HANDLE__)->__PPP_DMA_FIELD_ = &(__DMA_HANDLE_);   \
N                              (__DMA_HANDLE_).Parent = (__HANDLE__);               \
N                          } while(0)
X#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD_, __DMA_HANDLE_)                                         do{                                                                                      (__HANDLE__)->__PPP_DMA_FIELD_ = &(__DMA_HANDLE_);                                 (__DMA_HANDLE_).Parent = (__HANDLE__);                                         } while(0)
N
N#define UNUSED(x) ((void)(x))                            
N                            
N/** @brief Reset the Handle's State field.
N  * @param __HANDLE__ specifies the Peripheral Handle.
N  * @note  This macro can be used for the following purpose:
N  *          - When the Handle is declared as local variable; before passing it as parameter
N  *            to HAL_PPP_Init() for the first time, it is mandatory to use this macro
N  *            to set to 0 the Handle's "State" field.
N  *            Otherwise, "State" field may have any random value and the first time the function
N  *            HAL_PPP_Init() is called, the low level hardware initialization will be missed
N  *            (i.e. HAL_PPP_MspInit() will not be executed).
N  *          - When there is a need to reconfigure the low level hardware: instead of calling
N  *            HAL_PPP_DeInit() then HAL_PPP_Init(), user can make a call to this macro then HAL_PPP_Init().
N  *            In this later function, when the Handle's "State" field is set to 0, it will execute the function
N  *            HAL_PPP_MspInit() which will reconfigure the low level hardware.
N  * @retval None
N  */
N#define __HAL_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = 0)
N
N#if (USE_RTOS == 1)
X#if (0 == 1)
S  #error " USE_RTOS should be 0 in the current HAL release "
N#else
N  #define __HAL_LOCK(__HANDLE__)                                           \
N                                do{                                        \
N                                    if((__HANDLE__)->Lock == HAL_LOCKED)   \
N                                    {                                      \
N                                       return HAL_BUSY;                    \
N                                    }                                      \
N                                    else                                   \
N                                    {                                      \
N                                       (__HANDLE__)->Lock = HAL_LOCKED;    \
N                                    }                                      \
N       	                          }while (0)
X  #define __HAL_LOCK(__HANDLE__)                                                                           do{                                                                            if((__HANDLE__)->Lock == HAL_LOCKED)                                       {                                                                             return HAL_BUSY;                                                        }                                                                          else                                                                       {                                                                             (__HANDLE__)->Lock = HAL_LOCKED;                                        }                                             	                          }while (0)
N
N  #define __HAL_UNLOCK(__HANDLE__)                                          \
N                                  do{                                       \
N                                      (__HANDLE__)->Lock = HAL_UNLOCKED;    \
N                                    }while (0)
X  #define __HAL_UNLOCK(__HANDLE__)                                                                            do{                                                                             (__HANDLE__)->Lock = HAL_UNLOCKED;                                        }while (0)
N#endif /* USE_RTOS */
N
N#if  defined ( __GNUC__ )
X#if  0L
S  #ifndef __weak
S    #define __weak   __attribute__((weak))
S  #endif /* __weak */
S  #ifndef __packed
S    #define __packed __attribute__((__packed__))
S  #endif /* __packed */
N#endif /* __GNUC__ */
N
N
N/* Macro to get variable aligned on 4-bytes, for __ICCARM__ the directive "#pragma data_alignment=4" must be used instead */
N#if defined   (__GNUC__)        /* GNU Compiler */
X#if 0L         
S  #ifndef __ALIGN_END
S    #define __ALIGN_END    __attribute__ ((aligned (4)))
S  #endif /* __ALIGN_END */
S  #ifndef __ALIGN_BEGIN  
S    #define __ALIGN_BEGIN
S  #endif /* __ALIGN_BEGIN */
N#else
N  #ifndef __ALIGN_END
N    #define __ALIGN_END
N  #endif /* __ALIGN_END */
N  #ifndef __ALIGN_BEGIN      
N    #if defined   (__CC_ARM)      /* ARM Compiler */
X    #if 1L       
N      #define __ALIGN_BEGIN    __align(4)  
N    #elif defined (__ICCARM__)    /* IAR Compiler */
S      #define __ALIGN_BEGIN 
N    #endif /* __CC_ARM */
N  #endif /* __ALIGN_BEGIN */
N#endif /* __GNUC__ */
N
N/** 
N  * @brief  __NOINLINE definition
N  */ 
N#if defined ( __CC_ARM   ) || defined   (  __GNUC__  )
X#if 1L || 0L
N/* ARM & GNUCompiler 
N   ---------------- 
N*/
N#define __NOINLINE __attribute__ ( (noinline) )
N
N#elif defined ( __ICCARM__ )
S/* ICCARM Compiler
S   ---------------
S*/
S#define __NOINLINE _Pragma("optimize = no_inline")
S
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* ___STM32F0xx_HAL_DEF */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 46 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rcc.h" 2
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RCC
N  * @{
N  */
N
N/** @addtogroup RCC_Private_Constants
N  * @{
N  */
N
N/** @defgroup RCC_Timeout RCC Timeout
N  * @{
N  */ 
N  
N/* Disable Backup domain write protection state change timeout */
N#define RCC_DBP_TIMEOUT_VALUE      (100U)       /* 100 ms */
N/* LSE state change timeout */
N#define RCC_LSE_TIMEOUT_VALUE      LSE_STARTUP_TIMEOUT
N#define CLOCKSWITCH_TIMEOUT_VALUE  (5000U)  /* 5 s    */
N#define HSE_TIMEOUT_VALUE          HSE_STARTUP_TIMEOUT
N#define HSI_TIMEOUT_VALUE          (2U)      /* 2 ms (minimum Tick + 1U) */
N#define LSI_TIMEOUT_VALUE          (2U)      /* 2 ms (minimum Tick + 1U) */
N#define PLL_TIMEOUT_VALUE          (2U)      /* 2 ms (minimum Tick + 1U) */
N#define HSI14_TIMEOUT_VALUE        (2U)      /* 2 ms (minimum Tick + 1U) */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N#define HSI48_TIMEOUT_VALUE        (2U)      /* 2 ms (minimum Tick + 1U) */
N#endif /* RCC_HSI48_SUPPORT */
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_Register_Offset Register offsets
N  * @{
N  */
N#define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
N#define RCC_CR_OFFSET             0x00
N#define RCC_CFGR_OFFSET           0x04
N#define RCC_CIR_OFFSET            0x08
N#define RCC_BDCR_OFFSET           0x20
N#define RCC_CSR_OFFSET            0x24
N
N/**
N  * @}
N  */
N
N  
N/* CR register byte 2 (Bits[23:16]) base address */
N#define RCC_CR_BYTE2_ADDRESS          ((uint32_t)(RCC_BASE + RCC_CR_OFFSET + 0x02U))
N
N/* CIR register byte 1 (Bits[15:8]) base address */
N#define RCC_CIR_BYTE1_ADDRESS     ((uint32_t)(RCC_BASE + RCC_CIR_OFFSET + 0x01U))
N
N/* CIR register byte 2 (Bits[23:16]) base address */
N#define RCC_CIR_BYTE2_ADDRESS     ((uint32_t)(RCC_BASE + RCC_CIR_OFFSET + 0x02U))
N
N/* Defines used for Flags */
N#define CR_REG_INDEX                     ((uint8_t)1U)
N#define CR2_REG_INDEX                    ((uint8_t)2U)
N#define BDCR_REG_INDEX                   ((uint8_t)3U)
N#define CSR_REG_INDEX                    ((uint8_t)4U)
N
N/* Bits position in  in the CFGR register */
N#define RCC_CFGR_PLLMUL_BITNUMBER         18U
N#define RCC_CFGR_HPRE_BITNUMBER           4U
N#define RCC_CFGR_PPRE_BITNUMBER           8U
N/* Flags in the CFGR2 register */
N#define RCC_CFGR2_PREDIV_BITNUMBER        0
N/* Flags in the CR register */
N#define RCC_CR_HSIRDY_BitNumber           1
N#define RCC_CR_HSERDY_BitNumber           17
N#define RCC_CR_PLLRDY_BitNumber           25
N/* Flags in the CR2 register */
N#define RCC_CR2_HSI14RDY_BitNumber        1
N#define RCC_CR2_HSI48RDY_BitNumber       16
N/* Flags in the BDCR register */
N#define RCC_BDCR_LSERDY_BitNumber         1
N/* Flags in the CSR register */
N#define RCC_CSR_LSIRDY_BitNumber          1
N#define RCC_CSR_V18PWRRSTF_BitNumber      23
N#define RCC_CSR_RMVF_BitNumber            24
N#define RCC_CSR_OBLRSTF_BitNumber         25
N#define RCC_CSR_PINRSTF_BitNumber         26
N#define RCC_CSR_PORRSTF_BitNumber         27
N#define RCC_CSR_SFTRSTF_BitNumber         28
N#define RCC_CSR_IWDGRSTF_BitNumber        29
N#define RCC_CSR_WWDGRSTF_BitNumber        30
N#define RCC_CSR_LPWRRSTF_BitNumber        31
N/* Flags in the HSITRIM register */
N#define RCC_CR_HSITRIM_BitNumber          3
N#define RCC_HSI14TRIM_BIT_NUMBER          3
N#define RCC_FLAG_MASK                    ((uint8_t)0x1FU)
N
N/**
N  * @}
N  */
N
N/** @addtogroup RCC_Private_Macros
N  * @{
N  */
N#define IS_RCC_HSE(__HSE__) (((__HSE__) == RCC_HSE_OFF) || ((__HSE__) == RCC_HSE_ON) || \
N                             ((__HSE__) == RCC_HSE_BYPASS))
X#define IS_RCC_HSE(__HSE__) (((__HSE__) == RCC_HSE_OFF) || ((__HSE__) == RCC_HSE_ON) ||                              ((__HSE__) == RCC_HSE_BYPASS))
N#define IS_RCC_LSE(__LSE__) (((__LSE__) == RCC_LSE_OFF) || ((__LSE__) == RCC_LSE_ON) || \
N                             ((__LSE__) == RCC_LSE_BYPASS))
X#define IS_RCC_LSE(__LSE__) (((__LSE__) == RCC_LSE_OFF) || ((__LSE__) == RCC_LSE_ON) ||                              ((__LSE__) == RCC_LSE_BYPASS))
N#define IS_RCC_HSI(__HSI__) (((__HSI__) == RCC_HSI_OFF) || ((__HSI__) == RCC_HSI_ON))
N#define IS_RCC_HSI14(__HSI14__) (((__HSI14__) == RCC_HSI14_OFF) || ((__HSI14__) == RCC_HSI14_ON) || ((__HSI14__) == RCC_HSI14_ADC_CONTROL))
N#define IS_RCC_CALIBRATION_VALUE(__VALUE__) ((__VALUE__) <= 0x1FU)
N#define IS_RCC_LSI(__LSI__) (((__LSI__) == RCC_LSI_OFF) || ((__LSI__) == RCC_LSI_ON))
N#define IS_RCC_PLL(__PLL__) (((__PLL__) == RCC_PLL_NONE) || ((__PLL__) == RCC_PLL_OFF) || \
N                             ((__PLL__) == RCC_PLL_ON))
X#define IS_RCC_PLL(__PLL__) (((__PLL__) == RCC_PLL_NONE) || ((__PLL__) == RCC_PLL_OFF) ||                              ((__PLL__) == RCC_PLL_ON))
N#define IS_RCC_PREDIV(__PREDIV__) (((__PREDIV__) == RCC_PREDIV_DIV1)  || ((__PREDIV__) == RCC_PREDIV_DIV2)   || \
N                                  ((__PREDIV__) == RCC_PREDIV_DIV3)  || ((__PREDIV__) == RCC_PREDIV_DIV4)   || \
N                                  ((__PREDIV__) == RCC_PREDIV_DIV5)  || ((__PREDIV__) == RCC_PREDIV_DIV6)   || \
N                                  ((__PREDIV__) == RCC_PREDIV_DIV7)  || ((__PREDIV__) == RCC_PREDIV_DIV8)   || \
N                                  ((__PREDIV__) == RCC_PREDIV_DIV9)  || ((__PREDIV__) == RCC_PREDIV_DIV10)  || \
N                                  ((__PREDIV__) == RCC_PREDIV_DIV11) || ((__PREDIV__) == RCC_PREDIV_DIV12)  || \
N                                  ((__PREDIV__) == RCC_PREDIV_DIV13) || ((__PREDIV__) == RCC_PREDIV_DIV14)  || \
N                                  ((__PREDIV__) == RCC_PREDIV_DIV15) || ((__PREDIV__) == RCC_PREDIV_DIV16))
X#define IS_RCC_PREDIV(__PREDIV__) (((__PREDIV__) == RCC_PREDIV_DIV1)  || ((__PREDIV__) == RCC_PREDIV_DIV2)   ||                                   ((__PREDIV__) == RCC_PREDIV_DIV3)  || ((__PREDIV__) == RCC_PREDIV_DIV4)   ||                                   ((__PREDIV__) == RCC_PREDIV_DIV5)  || ((__PREDIV__) == RCC_PREDIV_DIV6)   ||                                   ((__PREDIV__) == RCC_PREDIV_DIV7)  || ((__PREDIV__) == RCC_PREDIV_DIV8)   ||                                   ((__PREDIV__) == RCC_PREDIV_DIV9)  || ((__PREDIV__) == RCC_PREDIV_DIV10)  ||                                   ((__PREDIV__) == RCC_PREDIV_DIV11) || ((__PREDIV__) == RCC_PREDIV_DIV12)  ||                                   ((__PREDIV__) == RCC_PREDIV_DIV13) || ((__PREDIV__) == RCC_PREDIV_DIV14)  ||                                   ((__PREDIV__) == RCC_PREDIV_DIV15) || ((__PREDIV__) == RCC_PREDIV_DIV16))
N
N#define IS_RCC_PLL_MUL(__MUL__) (((__MUL__) == RCC_PLL_MUL2)  || ((__MUL__) == RCC_PLL_MUL3)   || \
N                                 ((__MUL__) == RCC_PLL_MUL4)  || ((__MUL__) == RCC_PLL_MUL5)   || \
N                                 ((__MUL__) == RCC_PLL_MUL6)  || ((__MUL__) == RCC_PLL_MUL7)   || \
N                                 ((__MUL__) == RCC_PLL_MUL8)  || ((__MUL__) == RCC_PLL_MUL9)   || \
N                                 ((__MUL__) == RCC_PLL_MUL10) || ((__MUL__) == RCC_PLL_MUL11)  || \
N                                 ((__MUL__) == RCC_PLL_MUL12) || ((__MUL__) == RCC_PLL_MUL13)  || \
N                                 ((__MUL__) == RCC_PLL_MUL14) || ((__MUL__) == RCC_PLL_MUL15)  || \
N                                 ((__MUL__) == RCC_PLL_MUL16))
X#define IS_RCC_PLL_MUL(__MUL__) (((__MUL__) == RCC_PLL_MUL2)  || ((__MUL__) == RCC_PLL_MUL3)   ||                                  ((__MUL__) == RCC_PLL_MUL4)  || ((__MUL__) == RCC_PLL_MUL5)   ||                                  ((__MUL__) == RCC_PLL_MUL6)  || ((__MUL__) == RCC_PLL_MUL7)   ||                                  ((__MUL__) == RCC_PLL_MUL8)  || ((__MUL__) == RCC_PLL_MUL9)   ||                                  ((__MUL__) == RCC_PLL_MUL10) || ((__MUL__) == RCC_PLL_MUL11)  ||                                  ((__MUL__) == RCC_PLL_MUL12) || ((__MUL__) == RCC_PLL_MUL13)  ||                                  ((__MUL__) == RCC_PLL_MUL14) || ((__MUL__) == RCC_PLL_MUL15)  ||                                  ((__MUL__) == RCC_PLL_MUL16))
N#define IS_RCC_CLOCKTYPE(__CLK__) ((((__CLK__) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK) || \
N                                   (((__CLK__) & RCC_CLOCKTYPE_HCLK)   == RCC_CLOCKTYPE_HCLK)   || \
N                                   (((__CLK__) & RCC_CLOCKTYPE_PCLK1)  == RCC_CLOCKTYPE_PCLK1))
X#define IS_RCC_CLOCKTYPE(__CLK__) ((((__CLK__) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK) ||                                    (((__CLK__) & RCC_CLOCKTYPE_HCLK)   == RCC_CLOCKTYPE_HCLK)   ||                                    (((__CLK__) & RCC_CLOCKTYPE_PCLK1)  == RCC_CLOCKTYPE_PCLK1))
N#define IS_RCC_HCLK(__HCLK__) (((__HCLK__) == RCC_SYSCLK_DIV1) || ((__HCLK__) == RCC_SYSCLK_DIV2) || \
N                               ((__HCLK__) == RCC_SYSCLK_DIV4) || ((__HCLK__) == RCC_SYSCLK_DIV8) || \
N                               ((__HCLK__) == RCC_SYSCLK_DIV16) || ((__HCLK__) == RCC_SYSCLK_DIV64) || \
N                               ((__HCLK__) == RCC_SYSCLK_DIV128) || ((__HCLK__) == RCC_SYSCLK_DIV256) || \
N                               ((__HCLK__) == RCC_SYSCLK_DIV512))
X#define IS_RCC_HCLK(__HCLK__) (((__HCLK__) == RCC_SYSCLK_DIV1) || ((__HCLK__) == RCC_SYSCLK_DIV2) ||                                ((__HCLK__) == RCC_SYSCLK_DIV4) || ((__HCLK__) == RCC_SYSCLK_DIV8) ||                                ((__HCLK__) == RCC_SYSCLK_DIV16) || ((__HCLK__) == RCC_SYSCLK_DIV64) ||                                ((__HCLK__) == RCC_SYSCLK_DIV128) || ((__HCLK__) == RCC_SYSCLK_DIV256) ||                                ((__HCLK__) == RCC_SYSCLK_DIV512))
N#define IS_RCC_PCLK(__PCLK__) (((__PCLK__) == RCC_HCLK_DIV1) || ((__PCLK__) == RCC_HCLK_DIV2) || \
N                               ((__PCLK__) == RCC_HCLK_DIV4) || ((__PCLK__) == RCC_HCLK_DIV8) || \
N                               ((__PCLK__) == RCC_HCLK_DIV16))
X#define IS_RCC_PCLK(__PCLK__) (((__PCLK__) == RCC_HCLK_DIV1) || ((__PCLK__) == RCC_HCLK_DIV2) ||                                ((__PCLK__) == RCC_HCLK_DIV4) || ((__PCLK__) == RCC_HCLK_DIV8) ||                                ((__PCLK__) == RCC_HCLK_DIV16))
N#define IS_RCC_MCO(__MCO__)  ((__MCO__) == RCC_MCO)
N#define IS_RCC_RTCCLKSOURCE(__SOURCE__)  (((__SOURCE__) == RCC_RTCCLKSOURCE_NO_CLK) || \
N                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_LSE)  || \
N                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_LSI)  || \
N                                          ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV32))
X#define IS_RCC_RTCCLKSOURCE(__SOURCE__)  (((__SOURCE__) == RCC_RTCCLKSOURCE_NO_CLK) ||                                           ((__SOURCE__) == RCC_RTCCLKSOURCE_LSE)  ||                                           ((__SOURCE__) == RCC_RTCCLKSOURCE_LSI)  ||                                           ((__SOURCE__) == RCC_RTCCLKSOURCE_HSE_DIV32))
N#define IS_RCC_USART1CLKSOURCE(__SOURCE__)  (((__SOURCE__) == RCC_USART1CLKSOURCE_PCLK1)  || \
N                                             ((__SOURCE__) == RCC_USART1CLKSOURCE_SYSCLK) || \
N                                             ((__SOURCE__) == RCC_USART1CLKSOURCE_LSE)    || \
N                                             ((__SOURCE__) == RCC_USART1CLKSOURCE_HSI))
X#define IS_RCC_USART1CLKSOURCE(__SOURCE__)  (((__SOURCE__) == RCC_USART1CLKSOURCE_PCLK1)  ||                                              ((__SOURCE__) == RCC_USART1CLKSOURCE_SYSCLK) ||                                              ((__SOURCE__) == RCC_USART1CLKSOURCE_LSE)    ||                                              ((__SOURCE__) == RCC_USART1CLKSOURCE_HSI))
N#define IS_RCC_I2C1CLKSOURCE(__SOURCE__)  (((__SOURCE__) == RCC_I2C1CLKSOURCE_HSI) || \
N                                           ((__SOURCE__) == RCC_I2C1CLKSOURCE_SYSCLK))
X#define IS_RCC_I2C1CLKSOURCE(__SOURCE__)  (((__SOURCE__) == RCC_I2C1CLKSOURCE_HSI) ||                                            ((__SOURCE__) == RCC_I2C1CLKSOURCE_SYSCLK))
N
N/**
N  * @}
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** @defgroup RCC_Exported_Types RCC Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  RCC PLL configuration structure definition  
N  */
Ntypedef struct
N{
N  uint32_t PLLState;      /*!< PLLState: The new state of the PLL.
N                              This parameter can be a value of @ref RCC_PLL_Config */
N
N  uint32_t PLLSource;     /*!< PLLSource: PLL entry clock source.
N                              This parameter must be a value of @ref RCC_PLL_Clock_Source */          
N
N  uint32_t PLLMUL;        /*!< PLLMUL: Multiplication factor for PLL VCO input clock
N                              This parameter must be a value of @ref RCC_PLL_Multiplication_Factor*/
N
N  uint32_t PREDIV;        /*!< PREDIV: Predivision factor for PLL VCO input clock
N                              This parameter must be a value of @ref RCC_PLL_Prediv_Factor */
N
N} RCC_PLLInitTypeDef;
N   
N/**
N  * @brief  RCC Internal/External Oscillator (HSE, HSI, LSE and LSI) configuration structure definition  
N  */
Ntypedef struct
N{
N  uint32_t OscillatorType;        /*!< The oscillators to be configured.
N                                       This parameter can be a value of @ref RCC_Oscillator_Type */
N
N  uint32_t HSEState;              /*!< The new state of the HSE.
N                                       This parameter can be a value of @ref RCC_HSE_Config */
N
N  uint32_t LSEState;              /*!< The new state of the LSE.
N                                       This parameter can be a value of @ref RCC_LSE_Config */
N
N  uint32_t HSIState;              /*!< The new state of the HSI.
N                                       This parameter can be a value of @ref RCC_HSI_Config */
N
N  uint32_t HSICalibrationValue;   /*!< The HSI calibration trimming value (default is RCC_HSICALIBRATION_DEFAULT).
N                                       This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x1FU */
N
N  uint32_t HSI14State;             /*!< The new state of the HSI14.
N                                        This parameter can be a value of @ref RCC_HSI14_Config */
N
N  uint32_t HSI14CalibrationValue;  /*!< The HSI14 calibration trimming value (default is RCC_HSI14CALIBRATION_DEFAULT).
N                                        This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x1FU */
N
N  uint32_t LSIState;              /*!< The new state of the LSI.
N                                       This parameter can be a value of @ref RCC_LSI_Config */
N
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N  uint32_t HSI48State;            /*!< The new state of the HSI48.
N                                       This parameter can be a value of @ref RCC_HSI48_Config */
N
N#endif /* RCC_HSI48_SUPPORT */
N  RCC_PLLInitTypeDef PLL;         /*!< PLL structure parameters */     
N
N} RCC_OscInitTypeDef;
N
N/**
N  * @brief  RCC System, AHB and APB busses clock configuration structure definition  
N  */
Ntypedef struct
N{
N  uint32_t ClockType;             /*!< The clock to be configured.
N                                       This parameter can be a value of @ref RCC_System_Clock_Type */
N
N  uint32_t SYSCLKSource;          /*!< The clock source (SYSCLKS) used as system clock.
N                                       This parameter can be a value of @ref RCC_System_Clock_Source */
N
N  uint32_t AHBCLKDivider;         /*!< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK).
N                                       This parameter can be a value of @ref RCC_AHB_Clock_Source */
N
N  uint32_t APB1CLKDivider;        /*!< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK).
N                                       This parameter can be a value of @ref RCC_APB1_Clock_Source */
N
N} RCC_ClkInitTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RCC_Exported_Constants RCC Exported Constants
N  * @{
N  */
N
N/** @defgroup RCC_PLL_Clock_Source PLL Clock Source
N  * @{
N  */
N
N#define RCC_PLLSOURCE_HSE           RCC_CFGR_PLLSRC_HSE_PREDIV /*!< HSE clock selected as PLL entry clock source */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Oscillator_Type Oscillator Type
N  * @{
N  */
N#define RCC_OSCILLATORTYPE_NONE            (0x00000000U)
N#define RCC_OSCILLATORTYPE_HSE             (0x00000001U)
N#define RCC_OSCILLATORTYPE_HSI             (0x00000002U)
N#define RCC_OSCILLATORTYPE_LSE             (0x00000004U)
N#define RCC_OSCILLATORTYPE_LSI             (0x00000008U)
N#define RCC_OSCILLATORTYPE_HSI14           (0x00000010U)
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N#define RCC_OSCILLATORTYPE_HSI48           (0x00000020U)
N#endif /* RCC_HSI48_SUPPORT */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSE_Config HSE Config
N  * @{
N  */
N#define RCC_HSE_OFF                      (0x00000000U)                     /*!< HSE clock deactivation */
N#define RCC_HSE_ON                       (0x00000001U)                     /*!< HSE clock activation */
N#define RCC_HSE_BYPASS                   (0x00000005U)                     /*!< External clock source for HSE clock */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Config LSE Config
N  * @{
N  */
N#define RCC_LSE_OFF                      (0x00000000U)                       /*!< LSE clock deactivation */
N#define RCC_LSE_ON                       (0x00000001U)                       /*!< LSE clock activation */
N#define RCC_LSE_BYPASS                   (0x00000005U)                       /*!< External clock source for LSE clock */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSI_Config HSI Config
N  * @{
N  */
N#define RCC_HSI_OFF                      (0x00000000U)           /*!< HSI clock deactivation */
N#define RCC_HSI_ON                       RCC_CR_HSION                     /*!< HSI clock activation */
N
N#define RCC_HSICALIBRATION_DEFAULT       (0x10U)         /* Default HSI calibration trimming value */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSI14_Config RCC HSI14 Config
N  * @{
N  */
N#define RCC_HSI14_OFF                    (0x00000000U)
N#define RCC_HSI14_ON                     RCC_CR2_HSI14ON
N#define RCC_HSI14_ADC_CONTROL            (~RCC_CR2_HSI14DIS)
N
N#define RCC_HSI14CALIBRATION_DEFAULT     (0x10U)   /* Default HSI14 calibration trimming value */
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_LSI_Config LSI Config
N  * @{
N  */
N#define RCC_LSI_OFF                      (0x00000000U)   /*!< LSI clock deactivation */
N#define RCC_LSI_ON                       RCC_CSR_LSION            /*!< LSI clock activation */
N
N/**
N  * @}
N  */
N
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N/** @defgroup RCC_HSI48_Config HSI48 Config
N  * @{
N  */
N#define RCC_HSI48_OFF               ((uint8_t)0x00U)
N#define RCC_HSI48_ON                ((uint8_t)0x01U)
N
N/**
N  * @}
N  */
N#endif /* RCC_HSI48_SUPPORT */
N
N/** @defgroup RCC_PLL_Config PLL Config
N  * @{
N  */
N#define RCC_PLL_NONE                      (0x00000000U)  /*!< PLL is not configured */
N#define RCC_PLL_OFF                       (0x00000001U)  /*!< PLL deactivation */
N#define RCC_PLL_ON                        (0x00000002U)  /*!< PLL activation */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_System_Clock_Type System Clock Type
N  * @{
N  */
N#define RCC_CLOCKTYPE_SYSCLK             (0x00000001U) /*!< SYSCLK to configure */
N#define RCC_CLOCKTYPE_HCLK               (0x00000002U) /*!< HCLK to configure */
N#define RCC_CLOCKTYPE_PCLK1              (0x00000004U) /*!< PCLK1 to configure */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_System_Clock_Source System Clock Source
N  * @{
N  */
N#define RCC_SYSCLKSOURCE_HSI             RCC_CFGR_SW_HSI /*!< HSI selected as system clock */
N#define RCC_SYSCLKSOURCE_HSE             RCC_CFGR_SW_HSE /*!< HSE selected as system clock */
N#define RCC_SYSCLKSOURCE_PLLCLK          RCC_CFGR_SW_PLL /*!< PLL selected as system clock */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_System_Clock_Source_Status System Clock Source Status
N  * @{
N  */
N#define RCC_SYSCLKSOURCE_STATUS_HSI      RCC_CFGR_SWS_HSI            /*!< HSI used as system clock */
N#define RCC_SYSCLKSOURCE_STATUS_HSE      RCC_CFGR_SWS_HSE            /*!< HSE used as system clock */
N#define RCC_SYSCLKSOURCE_STATUS_PLLCLK   RCC_CFGR_SWS_PLL            /*!< PLL used as system clock */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB_Clock_Source AHB Clock Source
N  * @{
N  */
N#define RCC_SYSCLK_DIV1                  RCC_CFGR_HPRE_DIV1   /*!< SYSCLK not divided */
N#define RCC_SYSCLK_DIV2                  RCC_CFGR_HPRE_DIV2   /*!< SYSCLK divided by 2 */
N#define RCC_SYSCLK_DIV4                  RCC_CFGR_HPRE_DIV4   /*!< SYSCLK divided by 4 */
N#define RCC_SYSCLK_DIV8                  RCC_CFGR_HPRE_DIV8   /*!< SYSCLK divided by 8 */
N#define RCC_SYSCLK_DIV16                 RCC_CFGR_HPRE_DIV16  /*!< SYSCLK divided by 16 */
N#define RCC_SYSCLK_DIV64                 RCC_CFGR_HPRE_DIV64  /*!< SYSCLK divided by 64 */
N#define RCC_SYSCLK_DIV128                RCC_CFGR_HPRE_DIV128 /*!< SYSCLK divided by 128 */
N#define RCC_SYSCLK_DIV256                RCC_CFGR_HPRE_DIV256 /*!< SYSCLK divided by 256 */
N#define RCC_SYSCLK_DIV512                RCC_CFGR_HPRE_DIV512 /*!< SYSCLK divided by 512 */
N
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_APB1_Clock_Source RCC APB1 Clock Source
N  * @{
N  */
N#define RCC_HCLK_DIV1                    RCC_CFGR_PPRE_DIV1  /*!< HCLK not divided */
N#define RCC_HCLK_DIV2                    RCC_CFGR_PPRE_DIV2  /*!< HCLK divided by 2 */
N#define RCC_HCLK_DIV4                    RCC_CFGR_PPRE_DIV4  /*!< HCLK divided by 4 */
N#define RCC_HCLK_DIV8                    RCC_CFGR_PPRE_DIV8  /*!< HCLK divided by 8 */
N#define RCC_HCLK_DIV16                   RCC_CFGR_PPRE_DIV16 /*!< HCLK divided by 16 */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_RTC_Clock_Source RTC Clock Source
N  * @{
N  */
N#define RCC_RTCCLKSOURCE_NO_CLK          (0x00000000U)                 /*!< No clock */
N#define RCC_RTCCLKSOURCE_LSE             RCC_BDCR_RTCSEL_LSE                  /*!< LSE oscillator clock used as RTC clock */
N#define RCC_RTCCLKSOURCE_LSI             RCC_BDCR_RTCSEL_LSI                  /*!< LSI oscillator clock used as RTC clock */
N#define RCC_RTCCLKSOURCE_HSE_DIV32       RCC_BDCR_RTCSEL_HSE                    /*!< HSE oscillator clock divided by 32 used as RTC clock */
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Multiplication_Factor RCC PLL Multiplication Factor
N  * @{
N  */
N#define RCC_PLL_MUL2                     RCC_CFGR_PLLMUL2
N#define RCC_PLL_MUL3                     RCC_CFGR_PLLMUL3
N#define RCC_PLL_MUL4                     RCC_CFGR_PLLMUL4
N#define RCC_PLL_MUL5                     RCC_CFGR_PLLMUL5
N#define RCC_PLL_MUL6                     RCC_CFGR_PLLMUL6
N#define RCC_PLL_MUL7                     RCC_CFGR_PLLMUL7
N#define RCC_PLL_MUL8                     RCC_CFGR_PLLMUL8
N#define RCC_PLL_MUL9                     RCC_CFGR_PLLMUL9
N#define RCC_PLL_MUL10                    RCC_CFGR_PLLMUL10
N#define RCC_PLL_MUL11                    RCC_CFGR_PLLMUL11
N#define RCC_PLL_MUL12                    RCC_CFGR_PLLMUL12
N#define RCC_PLL_MUL13                    RCC_CFGR_PLLMUL13
N#define RCC_PLL_MUL14                    RCC_CFGR_PLLMUL14
N#define RCC_PLL_MUL15                    RCC_CFGR_PLLMUL15
N#define RCC_PLL_MUL16                    RCC_CFGR_PLLMUL16
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Prediv_Factor RCC PLL Prediv Factor
N  * @{
N  */
N
N#define RCC_PREDIV_DIV1                  RCC_CFGR2_PREDIV_DIV1
N#define RCC_PREDIV_DIV2                  RCC_CFGR2_PREDIV_DIV2
N#define RCC_PREDIV_DIV3                  RCC_CFGR2_PREDIV_DIV3
N#define RCC_PREDIV_DIV4                  RCC_CFGR2_PREDIV_DIV4
N#define RCC_PREDIV_DIV5                  RCC_CFGR2_PREDIV_DIV5
N#define RCC_PREDIV_DIV6                  RCC_CFGR2_PREDIV_DIV6
N#define RCC_PREDIV_DIV7                  RCC_CFGR2_PREDIV_DIV7
N#define RCC_PREDIV_DIV8                  RCC_CFGR2_PREDIV_DIV8
N#define RCC_PREDIV_DIV9                  RCC_CFGR2_PREDIV_DIV9
N#define RCC_PREDIV_DIV10                 RCC_CFGR2_PREDIV_DIV10
N#define RCC_PREDIV_DIV11                 RCC_CFGR2_PREDIV_DIV11
N#define RCC_PREDIV_DIV12                 RCC_CFGR2_PREDIV_DIV12
N#define RCC_PREDIV_DIV13                 RCC_CFGR2_PREDIV_DIV13
N#define RCC_PREDIV_DIV14                 RCC_CFGR2_PREDIV_DIV14
N#define RCC_PREDIV_DIV15                 RCC_CFGR2_PREDIV_DIV15
N#define RCC_PREDIV_DIV16                 RCC_CFGR2_PREDIV_DIV16
N
N/**
N  * @}
N  */
N  
N
N/** @defgroup RCC_USART1_Clock_Source RCC USART1 Clock Source
N  * @{
N  */
N#define RCC_USART1CLKSOURCE_PCLK1        RCC_CFGR3_USART1SW_PCLK
N#define RCC_USART1CLKSOURCE_SYSCLK       RCC_CFGR3_USART1SW_SYSCLK
N#define RCC_USART1CLKSOURCE_LSE          RCC_CFGR3_USART1SW_LSE
N#define RCC_USART1CLKSOURCE_HSI          RCC_CFGR3_USART1SW_HSI
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_I2C1_Clock_Source RCC I2C1 Clock Source
N  * @{
N  */
N#define RCC_I2C1CLKSOURCE_HSI            RCC_CFGR3_I2C1SW_HSI
N#define RCC_I2C1CLKSOURCE_SYSCLK         RCC_CFGR3_I2C1SW_SYSCLK
N
N/**
N  * @}
N  */
N/** @defgroup RCC_MCO_Index MCO Index
N  * @{
N  */
N#define RCC_MCO1                         (0x00000000U)
N#define RCC_MCO                          RCC_MCO1               /*!< MCO1 to be compliant with other families with 2 MCOs*/
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO_Clock_Source RCC MCO Clock Source
N  * @{
N  */
N#define RCC_MCO1SOURCE_NOCLOCK            RCC_CFGR_MCO_NOCLOCK
N#define RCC_MCO1SOURCE_LSI                RCC_CFGR_MCO_LSI
N#define RCC_MCO1SOURCE_LSE                RCC_CFGR_MCO_LSE
N#define RCC_MCO1SOURCE_SYSCLK             RCC_CFGR_MCO_SYSCLK
N#define RCC_MCO1SOURCE_HSI                RCC_CFGR_MCO_HSI
N#define RCC_MCO1SOURCE_HSE                RCC_CFGR_MCO_HSE
N#define RCC_MCO1SOURCE_PLLCLK_DIV2        RCC_CFGR_MCO_PLL
N#define RCC_MCO1SOURCE_HSI14              RCC_CFGR_MCO_HSI14
N
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_Interrupt Interrupts
N  * @{
N  */
N#define RCC_IT_LSIRDY                    ((uint8_t)RCC_CIR_LSIRDYF)   /*!< LSI Ready Interrupt flag */
N#define RCC_IT_LSERDY                    ((uint8_t)RCC_CIR_LSERDYF)   /*!< LSE Ready Interrupt flag */
N#define RCC_IT_HSIRDY                    ((uint8_t)RCC_CIR_HSIRDYF)   /*!< HSI Ready Interrupt flag */
N#define RCC_IT_HSERDY                    ((uint8_t)RCC_CIR_HSERDYF)   /*!< HSE Ready Interrupt flag */
N#define RCC_IT_PLLRDY                    ((uint8_t)RCC_CIR_PLLRDYF)   /*!< PLL Ready Interrupt flag */
N#define RCC_IT_HSI14RDY                  ((uint8_t)RCC_CIR_HSI14RDYF) /*!< HSI14 Ready Interrupt flag */
N#if defined(RCC_CIR_HSI48RDYF)
X#if 1L
N#define RCC_IT_HSI48RDY                  ((uint8_t)RCC_CIR_HSI48RDYF) /*!< HSI48 Ready Interrupt flag */
N#endif
N#define RCC_IT_CSS                       ((uint8_t)RCC_CIR_CSSF)      /*!< Clock Security System Interrupt flag */
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_Flag Flags
N  *        Elements values convention: XXXYYYYYb
N  *           - YYYYY  : Flag position in the register
N  *           - XXX  : Register index
N  *                 - 001: CR register
N  *                 - 010: CR2 register
N  *                 - 011: BDCR register
N  *                 - 0100: CSR register
N  * @{
N  */
N/* Flags in the CR register */
N#define RCC_FLAG_HSIRDY                  ((uint8_t)((CR_REG_INDEX << 5U) | RCC_CR_HSIRDY_BitNumber))
N#define RCC_FLAG_HSERDY                  ((uint8_t)((CR_REG_INDEX << 5U) | RCC_CR_HSERDY_BitNumber))
N#define RCC_FLAG_PLLRDY                  ((uint8_t)((CR_REG_INDEX << 5U) | RCC_CR_PLLRDY_BitNumber))
N/* Flags in the CR2 register */
N#define RCC_FLAG_HSI14RDY                ((uint8_t)((CR2_REG_INDEX << 5U) | RCC_CR2_HSI14RDY_BitNumber))
N
N/* Flags in the CSR register */
N#define RCC_FLAG_LSIRDY                  ((uint8_t)((CSR_REG_INDEX << 5U) | RCC_CSR_LSIRDY_BitNumber))
N#if   defined(RCC_CSR_V18PWRRSTF)
X#if   1L
N#define RCC_FLAG_V18PWRRST               ((uint8_t)((CSR_REG_INDEX << 5U) | RCC_CSR_V18PWRRSTF_BitNumber))
N#endif
N#define RCC_FLAG_OBLRST                  ((uint8_t)((CSR_REG_INDEX << 5U) | RCC_CSR_OBLRSTF_BitNumber))
N#define RCC_FLAG_PINRST                  ((uint8_t)((CSR_REG_INDEX << 5U) | RCC_CSR_PINRSTF_BitNumber))      /*!< PIN reset flag */
N#define RCC_FLAG_PORRST                  ((uint8_t)((CSR_REG_INDEX << 5U) | RCC_CSR_PORRSTF_BitNumber))      /*!< POR/PDR reset flag */
N#define RCC_FLAG_SFTRST                  ((uint8_t)((CSR_REG_INDEX << 5U) | RCC_CSR_SFTRSTF_BitNumber))      /*!< Software Reset flag */
N#define RCC_FLAG_IWDGRST                 ((uint8_t)((CSR_REG_INDEX << 5U) | RCC_CSR_IWDGRSTF_BitNumber))     /*!< Independent Watchdog reset flag */
N#define RCC_FLAG_WWDGRST                 ((uint8_t)((CSR_REG_INDEX << 5U) | RCC_CSR_WWDGRSTF_BitNumber))     /*!< Window watchdog reset flag */
N#define RCC_FLAG_LPWRRST                 ((uint8_t)((CSR_REG_INDEX << 5U) | RCC_CSR_LPWRRSTF_BitNumber))     /*!< Low-Power reset flag */
N
N/* Flags in the BDCR register */
N#define RCC_FLAG_LSERDY                  ((uint8_t)((BDCR_REG_INDEX << 5U) | RCC_BDCR_LSERDY_BitNumber))     /*!< External Low Speed oscillator Ready */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N
N/** @defgroup RCC_Exported_Macros RCC Exported Macros
N  * @{
N  */
N
N/** @defgroup RCC_AHB_Clock_Enable_Disable RCC AHB Clock Enable Disable
N  * @brief  Enable or disable the AHB peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{  
N  */
N#define __HAL_RCC_GPIOA_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_GPIOA_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);                                                                                 tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_GPIOB_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_GPIOB_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN);                                                                                 tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_GPIOC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOCEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_GPIOC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOCEN);                                                                                 tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOCEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_GPIOF_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOFEN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOFEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_GPIOF_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOFEN);                                                                                 tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOFEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_CRC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_CRCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_CRCEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_CRC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_CRCEN);                                                                                 tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_CRCEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_DMA1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_DMA1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_DMA1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_DMA1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_DMA1EN);                                                                                 tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_DMA1EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_SRAM_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_SRAMEN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_SRAMEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_SRAM_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_SRAMEN);                                                                                 tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_SRAMEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_FLITF_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_FLITFEN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_FLITFEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_FLITF_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_FLITFEN);                                                                                 tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_FLITFEN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_GPIOA_CLK_DISABLE()        (RCC->AHBENR &= ~(RCC_AHBENR_GPIOAEN))
N#define __HAL_RCC_GPIOB_CLK_DISABLE()        (RCC->AHBENR &= ~(RCC_AHBENR_GPIOBEN))
N#define __HAL_RCC_GPIOC_CLK_DISABLE()        (RCC->AHBENR &= ~(RCC_AHBENR_GPIOCEN))
N#define __HAL_RCC_GPIOF_CLK_DISABLE()        (RCC->AHBENR &= ~(RCC_AHBENR_GPIOFEN))
N#define __HAL_RCC_CRC_CLK_DISABLE()          (RCC->AHBENR &= ~(RCC_AHBENR_CRCEN))
N#define __HAL_RCC_DMA1_CLK_DISABLE()         (RCC->AHBENR &= ~(RCC_AHBENR_DMA1EN))
N#define __HAL_RCC_SRAM_CLK_DISABLE()         (RCC->AHBENR &= ~(RCC_AHBENR_SRAMEN))
N#define __HAL_RCC_FLITF_CLK_DISABLE()        (RCC->AHBENR &= ~(RCC_AHBENR_FLITFEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB_Peripheral_Clock_Enable_Disable_Status AHB Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the AHB peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_GPIOA_IS_CLK_ENABLED()     ((RCC->AHBENR & (RCC_AHBENR_GPIOAEN)) != RESET)
N#define __HAL_RCC_GPIOB_IS_CLK_ENABLED()     ((RCC->AHBENR & (RCC_AHBENR_GPIOBEN)) != RESET)
N#define __HAL_RCC_GPIOC_IS_CLK_ENABLED()     ((RCC->AHBENR & (RCC_AHBENR_GPIOCEN)) != RESET)
N#define __HAL_RCC_GPIOF_IS_CLK_ENABLED()     ((RCC->AHBENR & (RCC_AHBENR_GPIOFEN)) != RESET)
N#define __HAL_RCC_CRC_IS_CLK_ENABLED()       ((RCC->AHBENR & (RCC_AHBENR_CRCEN))   != RESET)
N#define __HAL_RCC_DMA1_IS_CLK_ENABLED()      ((RCC->AHBENR & (RCC_AHBENR_DMA1EN))  != RESET)
N#define __HAL_RCC_SRAM_IS_CLK_ENABLED()      ((RCC->AHBENR & (RCC_AHBENR_SRAMEN))  != RESET)
N#define __HAL_RCC_FLITF_IS_CLK_ENABLED()     ((RCC->AHBENR & (RCC_AHBENR_FLITFEN)) != RESET)
N#define __HAL_RCC_GPIOA_IS_CLK_DISABLED()    ((RCC->AHBENR & (RCC_AHBENR_GPIOAEN)) == RESET)
N#define __HAL_RCC_GPIOB_IS_CLK_DISABLED()    ((RCC->AHBENR & (RCC_AHBENR_GPIOBEN)) == RESET)
N#define __HAL_RCC_GPIOC_IS_CLK_DISABLED()    ((RCC->AHBENR & (RCC_AHBENR_GPIOCEN)) == RESET)
N#define __HAL_RCC_GPIOF_IS_CLK_DISABLED()    ((RCC->AHBENR & (RCC_AHBENR_GPIOFEN)) == RESET)
N#define __HAL_RCC_CRC_IS_CLK_DISABLED()      ((RCC->AHBENR & (RCC_AHBENR_CRCEN))   == RESET)
N#define __HAL_RCC_DMA1_IS_CLK_DISABLED()     ((RCC->AHBENR & (RCC_AHBENR_DMA1EN))  == RESET)
N#define __HAL_RCC_SRAM_IS_CLK_DISABLED()     ((RCC->AHBENR & (RCC_AHBENR_SRAMEN))  == RESET)
N#define __HAL_RCC_FLITF_IS_CLK_DISABLED()    ((RCC->AHBENR & (RCC_AHBENR_FLITFEN)) == RESET)
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_APB1_Clock_Enable_Disable RCC APB1 Clock Enable Disable
N  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{   
N  */
N#define __HAL_RCC_TIM3_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM3_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                                                                 tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM14_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM14_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                                                                 tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_WWDG_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_WWDG_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);                                                                                 tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_I2C1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_I2C1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);                                                                                 tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_PWR_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_PWR_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);                                                                                 tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_TIM3_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))
N#define __HAL_RCC_TIM14_CLK_DISABLE()  (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN))
N#define __HAL_RCC_WWDG_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_WWDGEN))
N#define __HAL_RCC_I2C1_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C1EN))
N#define __HAL_RCC_PWR_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_PWREN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Peripheral_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the APB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_TIM3_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN))  != RESET)
N#define __HAL_RCC_TIM14_IS_CLK_ENABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET)
N#define __HAL_RCC_WWDG_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_WWDGEN))  != RESET)
N#define __HAL_RCC_I2C1_IS_CLK_ENABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_I2C1EN))  != RESET)
N#define __HAL_RCC_PWR_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_PWREN))   != RESET)
N#define __HAL_RCC_TIM3_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN))  == RESET)
N#define __HAL_RCC_TIM14_IS_CLK_DISABLED() ((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET)
N#define __HAL_RCC_WWDG_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_WWDGEN))  == RESET)
N#define __HAL_RCC_I2C1_IS_CLK_DISABLED()  ((RCC->APB1ENR & (RCC_APB1ENR_I2C1EN))  == RESET)
N#define __HAL_RCC_PWR_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_PWREN))   == RESET)
N/**
N  * @}
N  */
N  
N  
N/** @defgroup RCC_APB2_Clock_Enable_Disable RCC APB2 Clock Enable Disable
N  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{   
N  */
N#define __HAL_RCC_SYSCFG_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_SYSCFG_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);                                                                                 tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_ADC1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_ADC1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);                                                                                 tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);                                                                                 tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_SPI1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_SPI1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);                                                                                 tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM16_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM16EN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM16EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM16_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM16EN);                                                                                 tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM16EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_TIM17_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM17EN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM17EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM17_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM17EN);                                                                                 tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM17EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_USART1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_USART1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);                                                                                 tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_DBGMCU_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DBGMCUEN);\
N                                        /* Delay after an RCC peripheral clock enabling */\
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DBGMCUEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_DBGMCU_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DBGMCUEN);                                                                                 tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DBGMCUEN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_SYSCFG_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_SYSCFGEN))
N#define __HAL_RCC_ADC1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_ADC1EN))
N#define __HAL_RCC_TIM1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM1EN))
N#define __HAL_RCC_SPI1_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_SPI1EN))
N#define __HAL_RCC_TIM16_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM16EN))
N#define __HAL_RCC_TIM17_CLK_DISABLE()  (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM17EN))
N#define __HAL_RCC_USART1_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_USART1EN))
N#define __HAL_RCC_DBGMCU_CLK_DISABLE() (RCC->APB2ENR &= ~(RCC_APB2ENR_DBGMCUEN))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Peripheral_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of the APB2 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#define __HAL_RCC_SYSCFG_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_SYSCFGEN)) != RESET)
N#define __HAL_RCC_ADC1_IS_CLK_ENABLED()       ((RCC->APB2ENR & (RCC_APB2ENR_ADC1EN))   != RESET)
N#define __HAL_RCC_TIM1_IS_CLK_ENABLED()       ((RCC->APB2ENR & (RCC_APB2ENR_TIM1EN))   != RESET)
N#define __HAL_RCC_SPI1_IS_CLK_ENABLED()       ((RCC->APB2ENR & (RCC_APB2ENR_SPI1EN))   != RESET)
N#define __HAL_RCC_TIM16_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_TIM16EN))  != RESET)
N#define __HAL_RCC_TIM17_IS_CLK_ENABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_TIM17EN))  != RESET)
N#define __HAL_RCC_USART1_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_USART1EN)) != RESET)
N#define __HAL_RCC_DBGMCU_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_DBGMCUEN)) != RESET)
N#define __HAL_RCC_SYSCFG_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_SYSCFGEN)) == RESET)
N#define __HAL_RCC_ADC1_IS_CLK_DISABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_ADC1EN))   == RESET)
N#define __HAL_RCC_TIM1_IS_CLK_DISABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_TIM1EN))   == RESET)
N#define __HAL_RCC_SPI1_IS_CLK_DISABLED()      ((RCC->APB2ENR & (RCC_APB2ENR_SPI1EN))   == RESET)
N#define __HAL_RCC_TIM16_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_TIM16EN))  == RESET)
N#define __HAL_RCC_TIM17_IS_CLK_DISABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_TIM17EN))  == RESET)
N#define __HAL_RCC_USART1_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_USART1EN)) == RESET)
N#define __HAL_RCC_DBGMCU_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_DBGMCUEN)) == RESET)
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_AHB_Force_Release_Reset RCC AHB Force Release Reset
N  * @brief  Force or release AHB peripheral reset.
N  * @{   
N  */ 
N#define __HAL_RCC_AHB_FORCE_RESET()     (RCC->AHBRSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_GPIOA_FORCE_RESET()   (RCC->AHBRSTR |= (RCC_AHBRSTR_GPIOARST))
N#define __HAL_RCC_GPIOB_FORCE_RESET()   (RCC->AHBRSTR |= (RCC_AHBRSTR_GPIOBRST))
N#define __HAL_RCC_GPIOC_FORCE_RESET()   (RCC->AHBRSTR |= (RCC_AHBRSTR_GPIOCRST))
N#define __HAL_RCC_GPIOF_FORCE_RESET()   (RCC->AHBRSTR |= (RCC_AHBRSTR_GPIOFRST))
N
N#define __HAL_RCC_AHB_RELEASE_RESET()   (RCC->AHBRSTR = 0x00000000U)
N#define __HAL_RCC_GPIOA_RELEASE_RESET() (RCC->AHBRSTR &= ~(RCC_AHBRSTR_GPIOARST))
N#define __HAL_RCC_GPIOB_RELEASE_RESET() (RCC->AHBRSTR &= ~(RCC_AHBRSTR_GPIOBRST))
N#define __HAL_RCC_GPIOC_RELEASE_RESET() (RCC->AHBRSTR &= ~(RCC_AHBRSTR_GPIOCRST))
N#define __HAL_RCC_GPIOF_RELEASE_RESET() (RCC->AHBRSTR &= ~(RCC_AHBRSTR_GPIOFRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB1_Force_Release_Reset RCC APB1 Force Release Reset
N  * @brief  Force or release APB1 peripheral reset.
N  * @{   
N  */  
N#define __HAL_RCC_APB1_FORCE_RESET()     (RCC->APB1RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_TIM3_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))
N#define __HAL_RCC_TIM14_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST))
N#define __HAL_RCC_WWDG_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_WWDGRST))
N#define __HAL_RCC_I2C1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C1RST))
N#define __HAL_RCC_PWR_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_PWRRST))
N
N#define __HAL_RCC_APB1_RELEASE_RESET()   (RCC->APB1RSTR = 0x00000000U)
N#define __HAL_RCC_TIM3_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))
N#define __HAL_RCC_TIM14_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST))
N#define __HAL_RCC_WWDG_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_WWDGRST))
N#define __HAL_RCC_I2C1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C1RST))
N#define __HAL_RCC_PWR_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_PWRRST))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Force_Release_Reset RCC APB2 Force Release Reset
N  * @brief  Force or release APB2 peripheral reset.
N  * @{   
N  */    
N#define __HAL_RCC_APB2_FORCE_RESET()     (RCC->APB2RSTR = 0xFFFFFFFFU)
N#define __HAL_RCC_SYSCFG_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_SYSCFGRST))
N#define __HAL_RCC_ADC1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_ADC1RST))
N#define __HAL_RCC_TIM1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM1RST))
N#define __HAL_RCC_SPI1_FORCE_RESET()     (RCC->APB2RSTR |= (RCC_APB2RSTR_SPI1RST))
N#define __HAL_RCC_USART1_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_USART1RST))
N#define __HAL_RCC_TIM16_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM16RST))
N#define __HAL_RCC_TIM17_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM17RST))
N#define __HAL_RCC_DBGMCU_FORCE_RESET()   (RCC->APB2RSTR |= (RCC_APB2RSTR_DBGMCURST))
N
N#define __HAL_RCC_APB2_RELEASE_RESET()   (RCC->APB2RSTR = 0x00000000U)
N#define __HAL_RCC_SYSCFG_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SYSCFGRST))
N#define __HAL_RCC_ADC1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_ADC1RST))
N#define __HAL_RCC_TIM1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM1RST))
N#define __HAL_RCC_SPI1_RELEASE_RESET()   (RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI1RST))
N#define __HAL_RCC_USART1_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART1RST))
N#define __HAL_RCC_TIM16_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM16RST))
N#define __HAL_RCC_TIM17_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM17RST))
N#define __HAL_RCC_DBGMCU_RELEASE_RESET() (RCC->APB2RSTR &= ~(RCC_APB2RSTR_DBGMCURST))
N/**
N  * @}
N  */
N/** @defgroup RCC_HSI_Configuration HSI Configuration
N  * @{   
N  */
N
N/** @brief  Macros to enable or disable the Internal High Speed oscillator (HSI).
N  * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
N  * @note   HSI can not be stopped if it is used as system clock source. In this case,
N  *         you have to select another source of the system clock then stop the HSI.  
N  * @note   After enabling the HSI, the application software should wait on HSIRDY
N  *         flag to be set indicating that HSI clock is stable and can be used as
N  *         system clock source.  
N  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
N  *         clock cycles.  
N  */
N#define __HAL_RCC_HSI_ENABLE()  SET_BIT(RCC->CR, RCC_CR_HSION)
N#define __HAL_RCC_HSI_DISABLE() CLEAR_BIT(RCC->CR, RCC_CR_HSION)
N
N/** @brief  Macro to adjust the Internal High Speed oscillator (HSI) calibration value.
N  * @note   The calibration is used to compensate for the variations in voltage
N  *         and temperature that influence the frequency of the internal HSI RC.
N  * @param  _HSICALIBRATIONVALUE_ specifies the calibration trimming value.
N  *         (default is RCC_HSICALIBRATION_DEFAULT).
N  *         This parameter must be a number between 0 and 0x1F.
N  */  
N#define __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(_HSICALIBRATIONVALUE_) \
N                  MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, (uint32_t)(_HSICALIBRATIONVALUE_) << RCC_CR_HSITRIM_BitNumber)
X#define __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(_HSICALIBRATIONVALUE_)                   MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, (uint32_t)(_HSICALIBRATIONVALUE_) << RCC_CR_HSITRIM_BitNumber)
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSI_Configuration  LSI Configuration
N  * @{   
N  */
N
N/** @brief Macro to enable the Internal Low Speed oscillator (LSI).
N  * @note   After enabling the LSI, the application software should wait on 
N  *         LSIRDY flag to be set indicating that LSI clock is stable and can
N  *         be used to clock the IWDG and/or the RTC.
N  */
N#define __HAL_RCC_LSI_ENABLE() SET_BIT(RCC->CSR, RCC_CSR_LSION)
N
N/** @brief Macro to disable the Internal Low Speed oscillator (LSI).
N  * @note   LSI can not be disabled if the IWDG is running.  
N  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
N  *         clock cycles. 
N  */
N#define __HAL_RCC_LSI_DISABLE() CLEAR_BIT(RCC->CSR, RCC_CSR_LSION)
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSE_Configuration HSE Configuration
N  * @{   
N  */
N
N/**
N  * @brief  Macro to configure the External High Speed oscillator (HSE).
N  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
N  *         supported by this macro. User should request a transition to HSE Off
N  *         first and then HSE On or HSE Bypass.
N  * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
N  *         software should wait on HSERDY flag to be set indicating that HSE clock
N  *         is stable and can be used to clock the PLL and/or system clock.
N  * @note   HSE state can not be changed if it is used directly or through the
N  *         PLL as system clock. In this case, you have to select another source
N  *         of the system clock then change the HSE state (ex. disable it).
N  * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.
N  * @note   This function reset the CSSON bit, so if the clock security system(CSS)
N  *         was previously enabled you have to enable it again after calling this
N  *         function.
N  * @param  __STATE__ specifies the new state of the HSE.
N  *          This parameter can be one of the following values:
N  *            @arg @ref RCC_HSE_OFF turn OFF the HSE oscillator, HSERDY flag goes low after
N  *                              6 HSE oscillator clock cycles.
N  *            @arg @ref RCC_HSE_ON turn ON the HSE oscillator
N  *            @arg @ref RCC_HSE_BYPASS HSE oscillator bypassed with external clock
N  */
N#define __HAL_RCC_HSE_CONFIG(__STATE__)                                     \
N                    do{                                                     \
N                      if ((__STATE__) == RCC_HSE_ON)                        \
N                      {                                                     \
N                        SET_BIT(RCC->CR, RCC_CR_HSEON);                     \
N                      }                                                     \
N                      else if ((__STATE__) == RCC_HSE_OFF)                  \
N                      {                                                     \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEON);                   \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);                  \
N                      }                                                     \
N                      else if ((__STATE__) == RCC_HSE_BYPASS)               \
N                      {                                                     \
N                        SET_BIT(RCC->CR, RCC_CR_HSEBYP);                    \
N                        SET_BIT(RCC->CR, RCC_CR_HSEON);                     \
N                      }                                                     \
N                      else                                                  \
N                      {                                                     \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEON);                   \
N                        CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);                  \
N                      }                                                     \
N                    }while(0U)
X#define __HAL_RCC_HSE_CONFIG(__STATE__)                                                         do{                                                                           if ((__STATE__) == RCC_HSE_ON)                                              {                                                                             SET_BIT(RCC->CR, RCC_CR_HSEON);                                           }                                                                           else if ((__STATE__) == RCC_HSE_OFF)                                        {                                                                             CLEAR_BIT(RCC->CR, RCC_CR_HSEON);                                           CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);                                        }                                                                           else if ((__STATE__) == RCC_HSE_BYPASS)                                     {                                                                             SET_BIT(RCC->CR, RCC_CR_HSEBYP);                                            SET_BIT(RCC->CR, RCC_CR_HSEON);                                           }                                                                           else                                                                        {                                                                             CLEAR_BIT(RCC->CR, RCC_CR_HSEON);                                           CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);                                        }                                                                         }while(0U)
N
N/**
N  * @brief  Macro to configure the External High Speed oscillator (HSE) Predivision factor for PLL.
N  * @note   Predivision factor can not be changed if PLL is used as system clock
N  *         In this case, you have to select another source of the system clock, disable the PLL and
N  *         then change the HSE predivision factor.
N  * @param  __HSE_PREDIV_VALUE__ specifies the division value applied to HSE.
N  *         This parameter must be a number between RCC_HSE_PREDIV_DIV1 and RCC_HSE_PREDIV_DIV16.
N  */
N#define __HAL_RCC_HSE_PREDIV_CONFIG(__HSE_PREDIV_VALUE__) \
N                  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, (uint32_t)(__HSE_PREDIV_VALUE__))
X#define __HAL_RCC_HSE_PREDIV_CONFIG(__HSE_PREDIV_VALUE__)                   MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, (uint32_t)(__HSE_PREDIV_VALUE__))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Configuration LSE Configuration
N  * @{   
N  */
N
N/**
N  * @brief  Macro to configure the External Low Speed oscillator (LSE).
N  * @note Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not supported by this macro. 
N  * @note   As the LSE is in the Backup domain and write access is denied to
N  *         this domain after reset, you have to enable write access using 
N  *         @ref HAL_PWR_EnableBkUpAccess() function before to configure the LSE
N  *         (to be done once after reset).  
N  * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_BYPASS), the application
N  *         software should wait on LSERDY flag to be set indicating that LSE clock
N  *         is stable and can be used to clock the RTC.
N  * @param  __STATE__ specifies the new state of the LSE.
N  *         This parameter can be one of the following values:
N  *            @arg @ref RCC_LSE_OFF turn OFF the LSE oscillator, LSERDY flag goes low after
N  *                              6 LSE oscillator clock cycles.
N  *            @arg @ref RCC_LSE_ON turn ON the LSE oscillator.
N  *            @arg @ref RCC_LSE_BYPASS LSE oscillator bypassed with external clock.
N  */
N#define __HAL_RCC_LSE_CONFIG(__STATE__)                                     \
N                    do{                                                     \
N                      if ((__STATE__) == RCC_LSE_ON)                        \
N                      {                                                     \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);                   \
N                      }                                                     \
N                      else if ((__STATE__) == RCC_LSE_OFF)                  \
N                      {                                                     \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);                 \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                \
N                      }                                                     \
N                      else if ((__STATE__) == RCC_LSE_BYPASS)               \
N                      {                                                     \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                  \
N                        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);                   \
N                      }                                                     \
N                      else                                                  \
N                      {                                                     \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);                 \
N                        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                \
N                      }                                                     \
N                    }while(0U)
X#define __HAL_RCC_LSE_CONFIG(__STATE__)                                                         do{                                                                           if ((__STATE__) == RCC_LSE_ON)                                              {                                                                             SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);                                         }                                                                           else if ((__STATE__) == RCC_LSE_OFF)                                        {                                                                             CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);                                         CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                                      }                                                                           else if ((__STATE__) == RCC_LSE_BYPASS)                                     {                                                                             SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                                          SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);                                         }                                                                           else                                                                        {                                                                             CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);                                         CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);                                      }                                                                         }while(0U)
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_HSI14_Configuration RCC_HSI14_Configuration
N  * @{   
N  */
N    
N/** @brief  Macro to enable the Internal 14Mhz High Speed oscillator (HSI14).
N  * @note   After enabling the HSI14 with @ref __HAL_RCC_HSI14_ENABLE(), the application software 
N  *         should wait on HSI14RDY flag to be set indicating that HSI clock is stable and can be 
N  *         used as system clock source. This is not necessary if @ref HAL_RCC_OscConfig() is used.
N  *         clock cycles.
N  */
N#define __HAL_RCC_HSI14_ENABLE()  SET_BIT(RCC->CR2, RCC_CR2_HSI14ON)
N
N/** @brief  Macro to disable the Internal 14Mhz High Speed oscillator (HSI14).
N  * @note   The HSI14 is stopped by hardware when entering STOP and STANDBY modes.
N  * @note   HSI14 can not be stopped if it is used as system clock source. In this case,
N  *         you have to select another source of the system clock then stop the HSI14.
N  * @note   When the HSI14 is stopped, HSI14RDY flag goes low after 6 HSI14 oscillator
N  *         clock cycles.
N  */
N#define __HAL_RCC_HSI14_DISABLE() CLEAR_BIT(RCC->CR2, RCC_CR2_HSI14ON)
N
N/** @brief Macro to enable the Internal 14Mhz High Speed oscillator (HSI14) used by ADC.
N  */
N#define __HAL_RCC_HSI14ADC_ENABLE()  CLEAR_BIT(RCC->CR2, RCC_CR2_HSI14DIS)
N  
N/** @brief Macro to disable the Internal 14Mhz High Speed oscillator (HSI14) used by ADC.
N  */
N#define __HAL_RCC_HSI14ADC_DISABLE() SET_BIT(RCC->CR2, RCC_CR2_HSI14DIS)
N  
N/** @brief  Macro to adjust the Internal 14Mhz High Speed oscillator (HSI) calibration value.
N  * @note   The calibration is used to compensate for the variations in voltage
N  *         and temperature that influence the frequency of the internal HSI14 RC.
N  * @param  __HSI14CALIBRATIONVALUE__ specifies the calibration trimming value 
N  *         (default is RCC_HSI14CALIBRATION_DEFAULT).
N  *         This parameter must be a number between 0 and 0x1F.
N  */
N#define __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(__HSI14CALIBRATIONVALUE__) \
N                  MODIFY_REG(RCC->CR2, RCC_CR2_HSI14TRIM, (uint32_t)(__HSI14CALIBRATIONVALUE__) << RCC_HSI14TRIM_BIT_NUMBER)
X#define __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(__HSI14CALIBRATIONVALUE__)                   MODIFY_REG(RCC->CR2, RCC_CR2_HSI14TRIM, (uint32_t)(__HSI14CALIBRATIONVALUE__) << RCC_HSI14TRIM_BIT_NUMBER)
N/**
N  * @}
N  */
N
N/** @defgroup RCC_USARTx_Clock_Config RCC USARTx Clock Config
N  * @{   
N  */
N    
N/** @brief  Macro to configure the USART1 clock (USART1CLK).
N  * @param  __USART1CLKSOURCE__ specifies the USART1 clock source.
N  *         This parameter can be one of the following values:
N  *            @arg @ref RCC_USART1CLKSOURCE_PCLK1 PCLK1 selected as USART1 clock
N  *            @arg @ref RCC_USART1CLKSOURCE_HSI HSI selected as USART1 clock
N  *            @arg @ref RCC_USART1CLKSOURCE_SYSCLK System Clock selected as USART1 clock
N  *            @arg @ref RCC_USART1CLKSOURCE_LSE LSE selected as USART1 clock
N  */
N#define __HAL_RCC_USART1_CONFIG(__USART1CLKSOURCE__) \
N                  MODIFY_REG(RCC->CFGR3, RCC_CFGR3_USART1SW, (uint32_t)(__USART1CLKSOURCE__))
X#define __HAL_RCC_USART1_CONFIG(__USART1CLKSOURCE__)                   MODIFY_REG(RCC->CFGR3, RCC_CFGR3_USART1SW, (uint32_t)(__USART1CLKSOURCE__))
N
N/** @brief  Macro to get the USART1 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_USART1CLKSOURCE_PCLK1 PCLK1 selected as USART1 clock
N  *            @arg @ref RCC_USART1CLKSOURCE_HSI HSI selected as USART1 clock
N  *            @arg @ref RCC_USART1CLKSOURCE_SYSCLK System Clock selected as USART1 clock
N  *            @arg @ref RCC_USART1CLKSOURCE_LSE LSE selected as USART1 clock
N  */
N#define __HAL_RCC_GET_USART1_SOURCE() ((uint32_t)(READ_BIT(RCC->CFGR3, RCC_CFGR3_USART1SW)))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_I2Cx_Clock_Config RCC I2Cx Clock Config
N  * @{   
N  */
N
N/** @brief  Macro to configure the I2C1 clock (I2C1CLK).
N  * @param  __I2C1CLKSOURCE__ specifies the I2C1 clock source.
N  *         This parameter can be one of the following values:
N  *            @arg @ref RCC_I2C1CLKSOURCE_HSI HSI selected as I2C1 clock
N  *            @arg @ref RCC_I2C1CLKSOURCE_SYSCLK System Clock selected as I2C1 clock
N  */
N#define __HAL_RCC_I2C1_CONFIG(__I2C1CLKSOURCE__) \
N                  MODIFY_REG(RCC->CFGR3, RCC_CFGR3_I2C1SW, (uint32_t)(__I2C1CLKSOURCE__))
X#define __HAL_RCC_I2C1_CONFIG(__I2C1CLKSOURCE__)                   MODIFY_REG(RCC->CFGR3, RCC_CFGR3_I2C1SW, (uint32_t)(__I2C1CLKSOURCE__))
N
N/** @brief  Macro to get the I2C1 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_I2C1CLKSOURCE_HSI HSI selected as I2C1 clock
N  *            @arg @ref RCC_I2C1CLKSOURCE_SYSCLK System Clock selected as I2C1 clock
N  */
N#define __HAL_RCC_GET_I2C1_SOURCE() ((uint32_t)(READ_BIT(RCC->CFGR3, RCC_CFGR3_I2C1SW)))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Configuration PLL Configuration
N  * @{   
N  */
N
N/** @brief Macro to enable the main PLL.
N  * @note   After enabling the main PLL, the application software should wait on 
N  *         PLLRDY flag to be set indicating that PLL clock is stable and can
N  *         be used as system clock source.
N  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
N  */
N#define __HAL_RCC_PLL_ENABLE() SET_BIT(RCC->CR, RCC_CR_PLLON)
N
N/** @brief Macro to disable the main PLL.
N  * @note   The main PLL can not be disabled if it is used as system clock source
N  */
N#define __HAL_RCC_PLL_DISABLE() CLEAR_BIT(RCC->CR, RCC_CR_PLLON)
N
N/** @brief  Macro to configure the PLL clock source, multiplication and division factors.
N  * @note   This function must be used only when the main PLL is disabled.
N  *  
N  * @param  __RCC_PLLSOURCE__ specifies the PLL entry clock source.
N  *          This parameter can be one of the following values:
N  *            @arg @ref RCC_PLLSOURCE_HSI HSI oscillator clock selected as PLL clock entry
N  *            @arg @ref RCC_PLLSOURCE_HSE HSE oscillator clock selected as PLL clock entry
N  * @param  __PLLMUL__ specifies the multiplication factor for PLL VCO output clock
N  *          This parameter can be one of the following values:
N  *         This parameter must be a number between RCC_PLL_MUL2 and RCC_PLL_MUL16.
N  * @param  __PREDIV__ specifies the predivider factor for PLL VCO input clock
N  *         This parameter must be a number between RCC_PREDIV_DIV1 and RCC_PREDIV_DIV16.
N  *   
N  */
N#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSOURCE__ , __PREDIV__, __PLLMUL__) \
N                  do { \
N                    MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, (__PREDIV__)); \
N                    MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLMUL | RCC_CFGR_PLLSRC, (uint32_t)((__PLLMUL__)|(__RCC_PLLSOURCE__))); \
N                  } while(0U)
X#define __HAL_RCC_PLL_CONFIG(__RCC_PLLSOURCE__ , __PREDIV__, __PLLMUL__)                   do {                     MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, (__PREDIV__));                     MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLMUL | RCC_CFGR_PLLSRC, (uint32_t)((__PLLMUL__)|(__RCC_PLLSOURCE__)));                   } while(0U)
N
N
N/** @brief  Get oscillator clock selected as PLL input clock
N  * @retval The clock source used for PLL entry. The returned value can be one
N  *         of the following:
N  *             @arg @ref RCC_PLLSOURCE_HSE HSE oscillator clock selected as PLL input clock
N  */
N#define __HAL_RCC_GET_PLL_OSCSOURCE() ((uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLSRC)))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Get_Clock_source Get Clock source
N  * @{   
N  */
N
N/**
N  * @brief  Macro to configure the system clock source.
N  * @param  __SYSCLKSOURCE__ specifies the system clock source.
N  *          This parameter can be one of the following values:
N  *              @arg @ref RCC_SYSCLKSOURCE_HSI HSI oscillator is used as system clock source.
N  *              @arg @ref RCC_SYSCLKSOURCE_HSE HSE oscillator is used as system clock source.
N  *              @arg @ref RCC_SYSCLKSOURCE_PLLCLK PLL output is used as system clock source.
N  */
N#define __HAL_RCC_SYSCLK_CONFIG(__SYSCLKSOURCE__) \
N                  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, (__SYSCLKSOURCE__))
X#define __HAL_RCC_SYSCLK_CONFIG(__SYSCLKSOURCE__)                   MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, (__SYSCLKSOURCE__))
N
N/** @brief  Macro to get the clock source used as system clock.
N  * @retval The clock source used as system clock. The returned value can be one
N  *         of the following:
N  *             @arg @ref RCC_SYSCLKSOURCE_STATUS_HSI HSI used as system clock
N  *             @arg @ref RCC_SYSCLKSOURCE_STATUS_HSE HSE used as system clock
N  *             @arg @ref RCC_SYSCLKSOURCE_STATUS_PLLCLK PLL used as system clock
N  */
N#define __HAL_RCC_GET_SYSCLK_SOURCE() ((uint32_t)(READ_BIT(RCC->CFGR,RCC_CFGR_SWS)))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_MCOx_Clock_Config RCC Extended MCOx Clock Config
N  * @{   
N  */ 
N
N#if defined(RCC_CFGR_MCOPRE)
X#if 1L
N/** @brief  Macro to configure the MCO clock.
N  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
N  *          This parameter can be one of the following values:
N  *            @arg @ref RCC_MCO1SOURCE_NOCLOCK      No clock selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_SYSCLK       System Clock selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_HSI          HSI oscillator clock selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_HSE          HSE selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_LSI          LSI selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_LSE          LSE selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_HSI14        HSI14 selected as MCO clock
N  @if STM32F042x6
N  *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F048xx
N  *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F071xB
N  *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F072xB
N  *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F078xx
N  *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F091xC
N  *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F098xx
N  *            @arg @ref RCC_MCO1SOURCE_HSI48       HSI48 selected as MCO clock
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F030x6
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F030xC
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F031x6
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F038xx
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F070x6
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @elseif STM32F070xB
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLLCLK selected as MCO clock
N  @endif
N  *            @arg @ref RCC_MCO1SOURCE_PLLCLK_DIV2  PLLCLK Divided by 2 selected as MCO clock
N  * @param  __MCODIV__ specifies the MCO clock prescaler.
N  *          This parameter can be one of the following values:
N  *            @arg @ref RCC_MCODIV_1   MCO clock source is divided by 1
N  *            @arg @ref RCC_MCODIV_2   MCO clock source is divided by 2
N  *            @arg @ref RCC_MCODIV_4   MCO clock source is divided by 4
N  *            @arg @ref RCC_MCODIV_8   MCO clock source is divided by 8
N  *            @arg @ref RCC_MCODIV_16  MCO clock source is divided by 16
N  *            @arg @ref RCC_MCODIV_32  MCO clock source is divided by 32
N  *            @arg @ref RCC_MCODIV_64  MCO clock source is divided by 64
N  *            @arg @ref RCC_MCODIV_128 MCO clock source is divided by 128
N  */
N#else
S/** @brief  Macro to configure the MCO clock.
S  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
S  *         This parameter can be one of the following values:
S  *            @arg @ref RCC_MCO1SOURCE_NOCLOCK     No clock selected as MCO clock
S  *            @arg @ref RCC_MCO1SOURCE_SYSCLK      System Clock selected as MCO clock
S  *            @arg @ref RCC_MCO1SOURCE_HSI         HSI selected as MCO clock
S  *            @arg @ref RCC_MCO1SOURCE_HSE         HSE selected as MCO clock
S  *            @arg @ref RCC_MCO1SOURCE_LSI         LSI selected as MCO clock
S  *            @arg @ref RCC_MCO1SOURCE_LSE         LSE selected as MCO clock
S  *            @arg @ref RCC_MCO1SOURCE_HSI14       HSI14 selected as MCO clock
S  *            @arg @ref RCC_MCO1SOURCE_PLLCLK_DIV2 PLLCLK Divided by 2 selected as MCO clock
S  * @param  __MCODIV__ specifies the MCO clock prescaler.
S  *         This parameter can be one of the following values:
S  *            @arg @ref RCC_MCODIV_1 No division applied on MCO clock source
S  */
N#endif
N#if   defined(RCC_CFGR_MCOPRE)
X#if   1L
N#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__, __MCODIV__) \
N                 MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO | RCC_CFGR_MCOPRE), ((__MCOCLKSOURCE__) | (__MCODIV__)))
X#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__, __MCODIV__)                  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO | RCC_CFGR_MCOPRE), ((__MCOCLKSOURCE__) | (__MCODIV__)))
N#else
S
S#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__, __MCODIV__) \
S                 MODIFY_REG(RCC->CFGR, RCC_CFGR_MCO, (__MCOCLKSOURCE__))
X#define __HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__, __MCODIV__)                  MODIFY_REG(RCC->CFGR, RCC_CFGR_MCO, (__MCOCLKSOURCE__))
S
N#endif
N
N/**
N  * @}
N  */
N
N  /** @defgroup RCC_RTC_Clock_Configuration RCC RTC Clock Configuration
N  * @{   
N  */
N
N/** @brief Macro to configure the RTC clock (RTCCLK).
N  * @note   As the RTC clock configuration bits are in the Backup domain and write
N  *         access is denied to this domain after reset, you have to enable write
N  *         access using the Power Backup Access macro before to configure
N  *         the RTC clock source (to be done once after reset).    
N  * @note   Once the RTC clock is configured it cannot be changed unless the  
N  *         Backup domain is reset using @ref __HAL_RCC_BACKUPRESET_FORCE() macro, or by
N  *         a Power On Reset (POR).
N  *
N  * @param  __RTC_CLKSOURCE__ specifies the RTC clock source.
N  *          This parameter can be one of the following values:
N  *             @arg @ref RCC_RTCCLKSOURCE_NO_CLK No clock selected as RTC clock
N  *             @arg @ref RCC_RTCCLKSOURCE_LSE LSE selected as RTC clock
N  *             @arg @ref RCC_RTCCLKSOURCE_LSI LSI selected as RTC clock
N  *             @arg @ref RCC_RTCCLKSOURCE_HSE_DIV32 HSE clock divided by 32
N  * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
N  *         work in STOP and STANDBY modes, and can be used as wakeup source.
N  *         However, when the LSI clock and HSE clock divided by 32 is used as RTC clock source,
N  *         the RTC cannot be used in STOP and STANDBY modes.
N  * @note   The system must always be configured so as to get a PCLK frequency greater than or
N  *             equal to the RTCCLK frequency for a proper operation of the RTC.
N  */
N#define __HAL_RCC_RTC_CONFIG(__RTC_CLKSOURCE__) MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, (__RTC_CLKSOURCE__))
N                                                   
N/** @brief Macro to get the RTC clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_RTCCLKSOURCE_NO_CLK No clock selected as RTC clock
N  *            @arg @ref RCC_RTCCLKSOURCE_LSE LSE selected as RTC clock
N  *            @arg @ref RCC_RTCCLKSOURCE_LSI LSI selected as RTC clock
N  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIV32 HSE clock divided by 32
N  */
N#define __HAL_RCC_GET_RTC_SOURCE() (READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL))
N
N/** @brief Macro to enable the the RTC clock.
N  * @note   These macros must be used only after the RTC clock source was selected.
N  */
N#define __HAL_RCC_RTC_ENABLE() SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN)
N
N/** @brief Macro to disable the the RTC clock.
N  * @note  These macros must be used only after the RTC clock source was selected.
N  */
N#define __HAL_RCC_RTC_DISABLE() CLEAR_BIT(RCC->BDCR, RCC_BDCR_RTCEN)
N
N/** @brief  Macro to force the Backup domain reset.
N  * @note   This function resets the RTC peripheral (including the backup registers)
N  *         and the RTC clock source selection in RCC_BDCR register.
N  */
N#define __HAL_RCC_BACKUPRESET_FORCE()  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST) 
N
N/** @brief  Macros to release the Backup domain reset.
N  */
N#define __HAL_RCC_BACKUPRESET_RELEASE() CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST) 
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Flags_Interrupts_Management Flags Interrupts Management
N  * @brief macros to manage the specified RCC Flags and interrupts.
N  * @{
N  */
N
N/** @brief Enable RCC interrupt.
N  * @param  __INTERRUPT__ specifies the RCC interrupt sources to be enabled.
N  *          This parameter can be any combination of the following values:
N  *            @arg @ref RCC_IT_LSIRDY LSI ready interrupt
N  *            @arg @ref RCC_IT_LSERDY LSE ready interrupt
N  *            @arg @ref RCC_IT_HSIRDY HSI ready interrupt
N  *            @arg @ref RCC_IT_HSERDY HSE ready interrupt
N  *            @arg @ref RCC_IT_PLLRDY main PLL ready interrupt
N  *            @arg @ref RCC_IT_HSI14RDY HSI14 ready interrupt
N  @if STM32F042x6
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F048xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F071xB
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F072xB
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F078xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F091xC
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F098xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @endif
N  */
N#define __HAL_RCC_ENABLE_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE1_ADDRESS |= (__INTERRUPT__))
N
N/** @brief Disable RCC interrupt.
N  * @param  __INTERRUPT__ specifies the RCC interrupt sources to be disabled.
N  *          This parameter can be any combination of the following values:
N  *            @arg @ref RCC_IT_LSIRDY LSI ready interrupt
N  *            @arg @ref RCC_IT_LSERDY LSE ready interrupt
N  *            @arg @ref RCC_IT_HSIRDY HSI ready interrupt
N  *            @arg @ref RCC_IT_HSERDY HSE ready interrupt
N  *            @arg @ref RCC_IT_PLLRDY main PLL ready interrupt
N  *            @arg @ref RCC_IT_HSI14RDY HSI14 ready interrupt
N  @if STM32F042x6
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F048xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F071xB
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F072xB
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F078xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F091xC
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F098xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @endif
N  */
N#define __HAL_RCC_DISABLE_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE1_ADDRESS &= (uint8_t)(~(__INTERRUPT__)))
N
N/** @brief Clear the RCC's interrupt pending bits.
N  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg @ref RCC_IT_LSIRDY LSI ready interrupt.
N  *            @arg @ref RCC_IT_LSERDY LSE ready interrupt.
N  *            @arg @ref RCC_IT_HSIRDY HSI ready interrupt.
N  *            @arg @ref RCC_IT_HSERDY HSE ready interrupt.
N  *            @arg @ref RCC_IT_PLLRDY Main PLL ready interrupt.
N  *            @arg @ref RCC_IT_CSS Clock Security System interrupt
N  *            @arg @ref RCC_IT_HSI14RDY HSI14 ready interrupt
N  @if STM32F042x6
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F048xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F071xB
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F072xB
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F078xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F091xC
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F098xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @endif
N  */
N#define __HAL_RCC_CLEAR_IT(__INTERRUPT__) (*(__IO uint8_t *) RCC_CIR_BYTE2_ADDRESS = (__INTERRUPT__))
N
N/** @brief Check the RCC's interrupt has occurred or not.
N  * @param  __INTERRUPT__ specifies the RCC interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg @ref RCC_IT_LSIRDY LSI ready interrupt.
N  *            @arg @ref RCC_IT_LSERDY LSE ready interrupt.
N  *            @arg @ref RCC_IT_HSIRDY HSI ready interrupt.
N  *            @arg @ref RCC_IT_HSERDY HSE ready interrupt.
N  *            @arg @ref RCC_IT_PLLRDY Main PLL ready interrupt.
N  *            @arg @ref RCC_IT_CSS Clock Security System interrupt
N  *            @arg @ref RCC_IT_HSI14RDY HSI14 ready interrupt enable
N  @if STM32F042x6
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F048xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F071xB
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F072xB
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F078xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F091xC
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @elseif STM32F098xx
N  *            @arg @ref RCC_IT_HSI48RDY HSI48 ready interrupt
N  @endif
N  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
N  */
N#define __HAL_RCC_GET_IT(__INTERRUPT__) ((RCC->CIR & (__INTERRUPT__)) == (__INTERRUPT__))
N
N/** @brief Set RMVF bit to clear the reset flags.
N  *         The reset flags are RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST,
N  *         RCC_FLAG_OBLRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
N  */
N#define __HAL_RCC_CLEAR_RESET_FLAGS() (RCC->CSR |= RCC_CSR_RMVF)
N
N/** @brief  Check RCC flag is set or not.
N  * @param  __FLAG__ specifies the flag to check.
N  *          This parameter can be one of the following values:
N  *            @arg @ref RCC_FLAG_HSIRDY HSI oscillator clock ready.
N  *            @arg @ref RCC_FLAG_HSERDY HSE oscillator clock ready.
N  *            @arg @ref RCC_FLAG_PLLRDY Main PLL clock ready.
N  *            @arg @ref RCC_FLAG_HSI14RDY HSI14 oscillator clock ready
N  @if STM32F038xx
N  *            @arg @ref RCC_FLAG_V18PWRRST Reset flag of the 1.8 V domain
N  @elseif STM32F042x6
N  *            @arg @ref RCC_FLAG_HSI48RDY HSI48 oscillator clock ready
N  @elseif STM32F048xx
N  *            @arg @ref RCC_FLAG_HSI48RDY HSI48 oscillator clock ready
N  *            @arg @ref RCC_FLAG_V18PWRRST Reset flag of the 1.8 V domain
N  @elseif STM32F058xx
N  *            @arg @ref RCC_FLAG_V18PWRRST Reset flag of the 1.8 V domain
N  @elseif STM32F071xB
N  *            @arg @ref RCC_FLAG_HSI48RDY HSI48 oscillator clock ready
N  @elseif STM32F072xB
N  *            @arg @ref RCC_FLAG_HSI48RDY HSI48 oscillator clock ready
N  @elseif STM32F078xx
N  *            @arg @ref RCC_FLAG_HSI48RDY HSI48 oscillator clock ready
N  *            @arg @ref RCC_FLAG_V18PWRRST Reset flag of the 1.8 V domain
N  @elseif STM32F091xC
N  *            @arg @ref RCC_FLAG_HSI48RDY HSI48 oscillator clock ready
N  @elseif STM32F098xx
N  *            @arg @ref RCC_FLAG_HSI48RDY HSI48 oscillator clock ready
N  *            @arg @ref RCC_FLAG_V18PWRRST Reset flag of the 1.8 V domain
N  @endif
N  *            @arg @ref RCC_FLAG_LSERDY LSE oscillator clock ready.
N  *            @arg @ref RCC_FLAG_LSIRDY LSI oscillator clock ready.
N  *            @arg @ref RCC_FLAG_OBLRST Option Byte Load reset
N  *            @arg @ref RCC_FLAG_PINRST  Pin reset.
N  *            @arg @ref RCC_FLAG_PORRST  POR/PDR reset.
N  *            @arg @ref RCC_FLAG_SFTRST  Software reset.
N  *            @arg @ref RCC_FLAG_IWDGRST Independent Watchdog reset.
N  *            @arg @ref RCC_FLAG_WWDGRST Window Watchdog reset.
N  *            @arg @ref RCC_FLAG_LPWRRST Low Power reset.
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_RCC_GET_FLAG(__FLAG__) (((((__FLAG__) >> 5U) == CR_REG_INDEX)? RCC->CR :      \
N                                       (((__FLAG__) >> 5U) == CR2_REG_INDEX)? RCC->CR2 :    \
N                                       (((__FLAG__) >> 5U) == BDCR_REG_INDEX) ? RCC->BDCR : \
N                                       RCC->CSR) & (1U << ((__FLAG__) & RCC_FLAG_MASK)))
X#define __HAL_RCC_GET_FLAG(__FLAG__) (((((__FLAG__) >> 5U) == CR_REG_INDEX)? RCC->CR :                                             (((__FLAG__) >> 5U) == CR2_REG_INDEX)? RCC->CR2 :                                           (((__FLAG__) >> 5U) == BDCR_REG_INDEX) ? RCC->BDCR :                                        RCC->CSR) & (1U << ((__FLAG__) & RCC_FLAG_MASK)))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Include RCC HAL Extension module */
N#include "stm32f0xx_hal_rcc_ex.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rcc_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_rcc_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of RCC HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_RCC_EX_H
N#define __STM32F0xx_HAL_RCC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup RCC
N  * @{
N  */ 
N
N/** @addtogroup RCC_Private_Macros
N * @{
N */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N#define IS_RCC_OSCILLATORTYPE(OSCILLATOR) (((OSCILLATOR) == RCC_OSCILLATORTYPE_NONE)                               || \
N                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)     || \
N                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)     || \
N                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)     || \
N                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)     || \
N                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14) || \
N                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48))
X#define IS_RCC_OSCILLATORTYPE(OSCILLATOR) (((OSCILLATOR) == RCC_OSCILLATORTYPE_NONE)                               ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)     ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)     ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)     ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)     ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14) ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48))
N
N#define IS_RCC_SYSCLKSOURCE(SOURCE)  (((SOURCE) == RCC_SYSCLKSOURCE_HSI)    || \
N                                      ((SOURCE) == RCC_SYSCLKSOURCE_HSE)    || \
N                                      ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK) || \
N                                      ((SOURCE) == RCC_SYSCLKSOURCE_HSI48))
X#define IS_RCC_SYSCLKSOURCE(SOURCE)  (((SOURCE) == RCC_SYSCLKSOURCE_HSI)    ||                                       ((SOURCE) == RCC_SYSCLKSOURCE_HSE)    ||                                       ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK) ||                                       ((SOURCE) == RCC_SYSCLKSOURCE_HSI48))
N
N#define IS_RCC_SYSCLKSOURCE_STATUS(SOURCE) (((SOURCE) == RCC_SYSCLKSOURCE_STATUS_HSI)    || \
N                                            ((SOURCE) == RCC_SYSCLKSOURCE_STATUS_HSE)    || \
N                                            ((SOURCE) == RCC_SYSCLKSOURCE_STATUS_PLLCLK) || \
N                                            ((SOURCE) == RCC_SYSCLKSOURCE_STATUS_HSI48))
X#define IS_RCC_SYSCLKSOURCE_STATUS(SOURCE) (((SOURCE) == RCC_SYSCLKSOURCE_STATUS_HSI)    ||                                             ((SOURCE) == RCC_SYSCLKSOURCE_STATUS_HSE)    ||                                             ((SOURCE) == RCC_SYSCLKSOURCE_STATUS_PLLCLK) ||                                             ((SOURCE) == RCC_SYSCLKSOURCE_STATUS_HSI48))
N
N#define IS_RCC_PLLSOURCE(SOURCE) (((SOURCE) == RCC_PLLSOURCE_HSI)   || \
N                                  ((SOURCE) == RCC_PLLSOURCE_HSI48) || \
N                                  ((SOURCE) == RCC_PLLSOURCE_HSE))
X#define IS_RCC_PLLSOURCE(SOURCE) (((SOURCE) == RCC_PLLSOURCE_HSI)   ||                                   ((SOURCE) == RCC_PLLSOURCE_HSI48) ||                                   ((SOURCE) == RCC_PLLSOURCE_HSE))
N
N#define IS_RCC_HSI48(HSI48) (((HSI48) == RCC_HSI48_OFF) || ((HSI48) == RCC_HSI48_ON))
N
N#else
S
S#define IS_RCC_OSCILLATORTYPE(OSCILLATOR) (((OSCILLATOR) == RCC_OSCILLATORTYPE_NONE)                               || \
S                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)     || \
S                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)     || \
S                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)     || \
S                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)     || \
S                                           (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14))
X#define IS_RCC_OSCILLATORTYPE(OSCILLATOR) (((OSCILLATOR) == RCC_OSCILLATORTYPE_NONE)                               ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)     ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)     ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)     ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)     ||                                            (((OSCILLATOR) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14))
S#define IS_RCC_SYSCLKSOURCE(SOURCE)  (((SOURCE) == RCC_SYSCLKSOURCE_HSI)    || \
S                                      ((SOURCE) == RCC_SYSCLKSOURCE_HSE)    || \
S                                      ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK))
X#define IS_RCC_SYSCLKSOURCE(SOURCE)  (((SOURCE) == RCC_SYSCLKSOURCE_HSI)    ||                                       ((SOURCE) == RCC_SYSCLKSOURCE_HSE)    ||                                       ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK))
S
S#define IS_RCC_SYSCLKSOURCE_STATUS(SOURCE) (((SOURCE) == RCC_SYSCLKSOURCE_STATUS_HSI)    || \
S                                            ((SOURCE) == RCC_SYSCLKSOURCE_STATUS_HSE)    || \
S                                            ((SOURCE) == RCC_SYSCLKSOURCE_STATUS_PLLCLK))
X#define IS_RCC_SYSCLKSOURCE_STATUS(SOURCE) (((SOURCE) == RCC_SYSCLKSOURCE_STATUS_HSI)    ||                                             ((SOURCE) == RCC_SYSCLKSOURCE_STATUS_HSE)    ||                                             ((SOURCE) == RCC_SYSCLKSOURCE_STATUS_PLLCLK))
S#define IS_RCC_PLLSOURCE(SOURCE) (((SOURCE) == RCC_PLLSOURCE_HSI)   || \
S                                  ((SOURCE) == RCC_PLLSOURCE_HSE))
X#define IS_RCC_PLLSOURCE(SOURCE) (((SOURCE) == RCC_PLLSOURCE_HSI)   ||                                   ((SOURCE) == RCC_PLLSOURCE_HSE))
S
N#endif /* RCC_HSI48_SUPPORT */
N
N#if defined(RCC_CFGR_PLLNODIV) && !defined(RCC_CFGR_MCO_HSI48)
X#if 1L && !1L
S
S#define IS_RCC_MCO1SOURCE(SOURCE)  (((SOURCE) == RCC_MCO1SOURCE_NOCLOCK)     || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_LSI)          || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_LSE)          || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_SYSCLK)       || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_HSI)          || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_HSE)          || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_PLLCLK)       || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_PLLCLK_DIV2)  || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_HSI14))
X#define IS_RCC_MCO1SOURCE(SOURCE)  (((SOURCE) == RCC_MCO1SOURCE_NOCLOCK)     ||                                    ((SOURCE) == RCC_MCO1SOURCE_LSI)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_LSE)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_SYSCLK)       ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSI)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSE)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_PLLCLK)       ||                                    ((SOURCE) == RCC_MCO1SOURCE_PLLCLK_DIV2)  ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSI14))
S
N#elif defined(RCC_CFGR_PLLNODIV) && defined(RCC_CFGR_MCO_HSI48)
X#elif 1L && 1L
N
N#define IS_RCC_MCO1SOURCE(SOURCE)  (((SOURCE) == RCC_MCO1SOURCE_NOCLOCK)     || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_LSI)          || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_LSE)          || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_SYSCLK)       || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_HSI)          || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_HSE)          || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_PLLCLK)       || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_PLLCLK_DIV2)  || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_HSI14)        || \
N                                   ((SOURCE) == RCC_MCO1SOURCE_HSI48))
X#define IS_RCC_MCO1SOURCE(SOURCE)  (((SOURCE) == RCC_MCO1SOURCE_NOCLOCK)     ||                                    ((SOURCE) == RCC_MCO1SOURCE_LSI)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_LSE)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_SYSCLK)       ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSI)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSE)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_PLLCLK)       ||                                    ((SOURCE) == RCC_MCO1SOURCE_PLLCLK_DIV2)  ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSI14)        ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSI48))
N
N#elif !defined(RCC_CFGR_PLLNODIV) && !defined(RCC_CFGR_MCO_HSI48)
S
S#define IS_RCC_MCO1SOURCE(SOURCE)  (((SOURCE) == RCC_MCO1SOURCE_NOCLOCK)     || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_LSI)          || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_LSE)          || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_SYSCLK)       || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_HSI)          || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_HSE)          || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_PLLCLK_DIV2)  || \
S                                   ((SOURCE) == RCC_MCO1SOURCE_HSI14))
X#define IS_RCC_MCO1SOURCE(SOURCE)  (((SOURCE) == RCC_MCO1SOURCE_NOCLOCK)     ||                                    ((SOURCE) == RCC_MCO1SOURCE_LSI)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_LSE)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_SYSCLK)       ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSI)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSE)          ||                                    ((SOURCE) == RCC_MCO1SOURCE_PLLCLK_DIV2)  ||                                    ((SOURCE) == RCC_MCO1SOURCE_HSI14))
S
N#endif /* RCC_CFGR_PLLNODIV && !RCC_CFGR_MCO_HSI48 */
N
N/**
N  * @}
N  */
N
N/** @addtogroup RCC_Exported_Constants
N * @{
N */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N
N/** @addtogroup RCC_PLL_Clock_Source
N  * @{
N  */
N#define RCC_PLLSOURCE_HSI                RCC_CFGR_PLLSRC_HSI_PREDIV
N#define RCC_PLLSOURCE_HSI48              RCC_CFGR_PLLSRC_HSI48_PREDIV
N
N/**
N  * @}
N  */
N
N/** @addtogroup RCC_Interrupt
N  * @{
N  */
N#define RCC_IT_HSI48                   RCC_CIR_HSI48RDYF /*!< HSI48 Ready Interrupt flag */
N/**
N  * @}
N  */
N
N/** @addtogroup RCC_Flag
N  * @{
N  */
N#define RCC_FLAG_HSI48RDY                ((uint8_t)((CR2_REG_INDEX << 5U) | RCC_CR2_HSI48RDY_BitNumber))
N/**
N  * @}
N  */
N
N/** @addtogroup RCC_System_Clock_Source
N  * @{
N  */
N#define RCC_SYSCLKSOURCE_HSI48           RCC_CFGR_SW_HSI48
N/**
N  * @}
N  */
N
N/** @addtogroup RCC_System_Clock_Source_Status
N  * @{
N  */
N#define RCC_SYSCLKSOURCE_STATUS_HSI48    RCC_CFGR_SWS_HSI48
N/**
N  * @}
N  */
N
N#else
S/** @addtogroup RCC_PLL_Clock_Source
S  * @{
S  */
S
S#if defined(STM32F070xB) || defined(STM32F070x6) || defined(STM32F030xC)
S#define RCC_PLLSOURCE_HSI                RCC_CFGR_PLLSRC_HSI_PREDIV
S#else
S#define RCC_PLLSOURCE_HSI                RCC_CFGR_PLLSRC_HSI_DIV2
S#endif
S
S/**
S  * @}
S  */
S
N#endif /* RCC_HSI48_SUPPORT */
N
N/** @addtogroup RCC_MCO_Clock_Source
N  * @{
N  */
N  
N#if defined(RCC_CFGR_PLLNODIV)
X#if 1L
N
N#define RCC_MCO1SOURCE_PLLCLK       (RCC_CFGR_MCO_PLL | RCC_CFGR_PLLNODIV)
N
N#endif /* RCC_CFGR_PLLNODIV */
N
N#if defined(RCC_CFGR_MCO_HSI48)
X#if 1L
N
N#define RCC_MCO1SOURCE_HSI48        RCC_CFGR_MCO_HSI48
N
N#endif /* SRCC_CFGR_MCO_HSI48 */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/** @addtogroup RCCEx
N  * @{
N  */
N
N/* Private Constants -------------------------------------------------------------*/
N#if defined(CRS)
X#if 1L
N/** @addtogroup RCCEx_Private_Constants
N * @{
N */
N
N/* CRS IT Error Mask */
N#define  RCC_CRS_IT_ERROR_MASK   ((uint32_t)(RCC_CRS_IT_TRIMOVF | RCC_CRS_IT_SYNCERR | RCC_CRS_IT_SYNCMISS))
N
N/* CRS Flag Error Mask */
N#define RCC_CRS_FLAG_ERROR_MASK  ((uint32_t)(RCC_CRS_FLAG_TRIMOVF | RCC_CRS_FLAG_SYNCERR | RCC_CRS_FLAG_SYNCMISS))
N
N/**
N  * @}
N  */
N#endif /* CRS */
N
N/* Private macro -------------------------------------------------------------*/
N/** @defgroup RCCEx_Private_Macros RCCEx Private Macros
N  * @{
N  */
N#if defined(STM32F030x6) || defined(STM32F030x8) || defined(STM32F031x6) || defined(STM32F038xx)\
N || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 0L
S
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C1 | \
S                                                     RCC_PERIPHCLK_RTC))
X#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C1 |                                                      RCC_PERIPHCLK_RTC))
S#endif /* STM32F030x6 || STM32F030x8 || STM32F031x6 || STM32F038xx || 
N          STM32F030xC */
N
N#if defined(STM32F070x6) || defined(STM32F070xB)
X#if 0L || 0L
S
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C1 | \
S                                                     RCC_PERIPHCLK_RTC    | RCC_PERIPHCLK_USB))
X#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C1 |                                                      RCC_PERIPHCLK_RTC    | RCC_PERIPHCLK_USB))
N#endif /* STM32F070x6 || STM32F070xB */
N
N#if defined(STM32F042x6) || defined(STM32F048xx)
X#if 0L || 0L
S
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C1   | \
S                                                     RCC_PERIPHCLK_CEC    | RCC_PERIPHCLK_RTC    | \
S                                                     RCC_PERIPHCLK_USB))
X#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C1   |                                                      RCC_PERIPHCLK_CEC    | RCC_PERIPHCLK_RTC    |                                                      RCC_PERIPHCLK_USB))
N#endif /* STM32F042x6 || STM32F048xx */
N
N#if defined(STM32F051x8) || defined(STM32F058xx)
X#if 0L || 0L
S
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C1 | \
S                                                     RCC_PERIPHCLK_CEC    | RCC_PERIPHCLK_RTC))
X#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C1 |                                                      RCC_PERIPHCLK_CEC    | RCC_PERIPHCLK_RTC))
N#endif /* STM32F051x8 || STM32F058xx */
N
N#if defined(STM32F071xB)
X#if 0L
S
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART2 | \
S                                                     RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_CEC    | \
S                                                     RCC_PERIPHCLK_RTC))
X#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART2 |                                                      RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_CEC    |                                                      RCC_PERIPHCLK_RTC))
N#endif /* STM32F071xB */
N
N#if defined(STM32F072xB) || defined(STM32F078xx)
X#if 0L || 0L
S
S#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART2 | \
S                                                     RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_CEC    | \
S                                                     RCC_PERIPHCLK_RTC    | RCC_PERIPHCLK_USB))
X#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART2 |                                                      RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_CEC    |                                                      RCC_PERIPHCLK_RTC    | RCC_PERIPHCLK_USB))
N#endif /* STM32F072xB || STM32F078xx */
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N
N#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART2 | \
N                                                     RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_CEC    | \
N                                                     RCC_PERIPHCLK_RTC    | RCC_PERIPHCLK_USART3 ))
X#define IS_RCC_PERIPHCLOCK(SELECTION) ((SELECTION) <= (RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART2 |                                                      RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_CEC    |                                                      RCC_PERIPHCLK_RTC    | RCC_PERIPHCLK_USART3 ))
N#endif /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx)
X#if 0L || 0L || 0L || 0L
S
S#define IS_RCC_USBCLKSOURCE(SOURCE)  (((SOURCE) == RCC_USBCLKSOURCE_HSI48) || \
S                                      ((SOURCE) == RCC_USBCLKSOURCE_PLL))
X#define IS_RCC_USBCLKSOURCE(SOURCE)  (((SOURCE) == RCC_USBCLKSOURCE_HSI48) ||                                       ((SOURCE) == RCC_USBCLKSOURCE_PLL))
S
N#endif /* STM32F042x6 || STM32F048xx || STM32F072xB || STM32F078xx */
N
N#if defined(STM32F070x6) || defined(STM32F070xB)
X#if 0L || 0L
S
S#define IS_RCC_USBCLKSOURCE(SOURCE)  (((SOURCE) == RCC_USBCLKSOURCE_NONE) || \
S                                      ((SOURCE) == RCC_USBCLKSOURCE_PLL))
X#define IS_RCC_USBCLKSOURCE(SOURCE)  (((SOURCE) == RCC_USBCLKSOURCE_NONE) ||                                       ((SOURCE) == RCC_USBCLKSOURCE_PLL))
S
N#endif /* STM32F070x6 || STM32F070xB */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 1L || 0L
N
N#define IS_RCC_USART2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_USART2CLKSOURCE_PCLK1)  || \
N                                         ((SOURCE) == RCC_USART2CLKSOURCE_SYSCLK) || \
N                                         ((SOURCE) == RCC_USART2CLKSOURCE_LSE)    || \
N                                         ((SOURCE) == RCC_USART2CLKSOURCE_HSI))
X#define IS_RCC_USART2CLKSOURCE(SOURCE)  (((SOURCE) == RCC_USART2CLKSOURCE_PCLK1)  ||                                          ((SOURCE) == RCC_USART2CLKSOURCE_SYSCLK) ||                                          ((SOURCE) == RCC_USART2CLKSOURCE_LSE)    ||                                          ((SOURCE) == RCC_USART2CLKSOURCE_HSI))
N
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N
N#define IS_RCC_USART3CLKSOURCE(SOURCE)  (((SOURCE) == RCC_USART3CLKSOURCE_PCLK1)  || \
N                                         ((SOURCE) == RCC_USART3CLKSOURCE_SYSCLK) || \
N                                         ((SOURCE) == RCC_USART3CLKSOURCE_LSE)    || \
N                                         ((SOURCE) == RCC_USART3CLKSOURCE_HSI))
X#define IS_RCC_USART3CLKSOURCE(SOURCE)  (((SOURCE) == RCC_USART3CLKSOURCE_PCLK1)  ||                                          ((SOURCE) == RCC_USART3CLKSOURCE_SYSCLK) ||                                          ((SOURCE) == RCC_USART3CLKSOURCE_LSE)    ||                                          ((SOURCE) == RCC_USART3CLKSOURCE_HSI))
N#endif /* STM32F091xC || STM32F098xx */
N
N
N#if defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N#define IS_RCC_CECCLKSOURCE(SOURCE)  (((SOURCE) == RCC_CECCLKSOURCE_HSI) || \
N                                      ((SOURCE) == RCC_CECCLKSOURCE_LSE))
X#define IS_RCC_CECCLKSOURCE(SOURCE)  (((SOURCE) == RCC_CECCLKSOURCE_HSI) ||                                       ((SOURCE) == RCC_CECCLKSOURCE_LSE))
N#endif /* STM32F042x6 || STM32F048xx ||                */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(RCC_CFGR_MCOPRE)
X#if 1L
N
N#define IS_RCC_MCODIV(DIV) (((DIV) == RCC_MCODIV_1)  || ((DIV) == RCC_MCODIV_2)   || \
N                            ((DIV) == RCC_MCODIV_4)  || ((DIV) == RCC_MCODIV_8)   || \
N                            ((DIV) == RCC_MCODIV_16) || ((DIV) == RCC_MCODIV_32)  || \
N                            ((DIV) == RCC_MCODIV_64) || ((DIV) == RCC_MCODIV_128))
X#define IS_RCC_MCODIV(DIV) (((DIV) == RCC_MCODIV_1)  || ((DIV) == RCC_MCODIV_2)   ||                             ((DIV) == RCC_MCODIV_4)  || ((DIV) == RCC_MCODIV_8)   ||                             ((DIV) == RCC_MCODIV_16) || ((DIV) == RCC_MCODIV_32)  ||                             ((DIV) == RCC_MCODIV_64) || ((DIV) == RCC_MCODIV_128))
N#else
S  
S#define IS_RCC_MCODIV(DIV) (((DIV) == RCC_MCODIV_1))
S  
N#endif /* RCC_CFGR_MCOPRE */
N
N#define IS_RCC_LSE_DRIVE(__DRIVE__) (((__DRIVE__) == RCC_LSEDRIVE_LOW)        || \
N                                     ((__DRIVE__) == RCC_LSEDRIVE_MEDIUMLOW)  || \
N                                     ((__DRIVE__) == RCC_LSEDRIVE_MEDIUMHIGH) || \
N                                     ((__DRIVE__) == RCC_LSEDRIVE_HIGH))
X#define IS_RCC_LSE_DRIVE(__DRIVE__) (((__DRIVE__) == RCC_LSEDRIVE_LOW)        ||                                      ((__DRIVE__) == RCC_LSEDRIVE_MEDIUMLOW)  ||                                      ((__DRIVE__) == RCC_LSEDRIVE_MEDIUMHIGH) ||                                      ((__DRIVE__) == RCC_LSEDRIVE_HIGH))
N
N#if defined(CRS)
X#if 1L
N
N#define IS_RCC_CRS_SYNC_SOURCE(_SOURCE_) (((_SOURCE_) == RCC_CRS_SYNC_SOURCE_GPIO) || \
N                                          ((_SOURCE_) == RCC_CRS_SYNC_SOURCE_LSE)  || \
N                                          ((_SOURCE_) == RCC_CRS_SYNC_SOURCE_USB))
X#define IS_RCC_CRS_SYNC_SOURCE(_SOURCE_) (((_SOURCE_) == RCC_CRS_SYNC_SOURCE_GPIO) ||                                           ((_SOURCE_) == RCC_CRS_SYNC_SOURCE_LSE)  ||                                           ((_SOURCE_) == RCC_CRS_SYNC_SOURCE_USB))
N#define IS_RCC_CRS_SYNC_DIV(_DIV_) (((_DIV_) == RCC_CRS_SYNC_DIV1)  || ((_DIV_) == RCC_CRS_SYNC_DIV2)  || \
N                                    ((_DIV_) == RCC_CRS_SYNC_DIV4)  || ((_DIV_) == RCC_CRS_SYNC_DIV8)  || \
N                                    ((_DIV_) == RCC_CRS_SYNC_DIV16) || ((_DIV_) == RCC_CRS_SYNC_DIV32) || \
N                                    ((_DIV_) == RCC_CRS_SYNC_DIV64) || ((_DIV_) == RCC_CRS_SYNC_DIV128))
X#define IS_RCC_CRS_SYNC_DIV(_DIV_) (((_DIV_) == RCC_CRS_SYNC_DIV1)  || ((_DIV_) == RCC_CRS_SYNC_DIV2)  ||                                     ((_DIV_) == RCC_CRS_SYNC_DIV4)  || ((_DIV_) == RCC_CRS_SYNC_DIV8)  ||                                     ((_DIV_) == RCC_CRS_SYNC_DIV16) || ((_DIV_) == RCC_CRS_SYNC_DIV32) ||                                     ((_DIV_) == RCC_CRS_SYNC_DIV64) || ((_DIV_) == RCC_CRS_SYNC_DIV128))
N#define IS_RCC_CRS_SYNC_POLARITY(_POLARITY_) (((_POLARITY_) == RCC_CRS_SYNC_POLARITY_RISING) || \
N                                              ((_POLARITY_) == RCC_CRS_SYNC_POLARITY_FALLING))
X#define IS_RCC_CRS_SYNC_POLARITY(_POLARITY_) (((_POLARITY_) == RCC_CRS_SYNC_POLARITY_RISING) ||                                               ((_POLARITY_) == RCC_CRS_SYNC_POLARITY_FALLING))
N#define IS_RCC_CRS_RELOADVALUE(_VALUE_) (((_VALUE_) <= 0xFFFFU))
N#define IS_RCC_CRS_ERRORLIMIT(_VALUE_) (((_VALUE_) <= 0xFFU))
N#define IS_RCC_CRS_HSI48CALIBRATION(_VALUE_) (((_VALUE_) <= 0x3FU))
N#define IS_RCC_CRS_FREQERRORDIR(_DIR_) (((_DIR_) == RCC_CRS_FREQERRORDIR_UP) || \
N                                        ((_DIR_) == RCC_CRS_FREQERRORDIR_DOWN))
X#define IS_RCC_CRS_FREQERRORDIR(_DIR_) (((_DIR_) == RCC_CRS_FREQERRORDIR_UP) ||                                         ((_DIR_) == RCC_CRS_FREQERRORDIR_DOWN))
N#endif /* CRS */
N/**
N  * @}
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** @defgroup RCCEx_Exported_Types RCCEx Exported Types
N  * @{
N  */
N
N/**
N  * @brief  RCC extended clocks structure definition  
N  */
N#if defined(STM32F030x6) || defined(STM32F030x8) || defined(STM32F031x6) || defined(STM32F038xx)\
N || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 0L
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  uint32_t RTCClockSelection;    /*!< Specifies RTC Clock Prescalers Selection 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t Usart1ClockSelection; /*!< USART1 clock source
S                                      This parameter can be a value of @ref RCC_USART1_Clock_Source */
S
S  uint32_t I2c1ClockSelection;   /*!< I2C1 clock source
S                                      This parameter can be a value of @ref RCC_I2C1_Clock_Source */
S
S}RCC_PeriphCLKInitTypeDef;
S#endif /* STM32F030x6 || STM32F030x8 || STM32F031x6 || STM32F038xx ||
N          STM32F030xC */
N
N#if defined(STM32F070x6) || defined(STM32F070xB)
X#if 0L || 0L
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  uint32_t RTCClockSelection;    /*!< Specifies RTC Clock Prescalers Selection 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t Usart1ClockSelection; /*!< USART1 clock source
S                                      This parameter can be a value of @ref RCC_USART1_Clock_Source */
S
S  uint32_t I2c1ClockSelection;   /*!< I2C1 clock source
S                                      This parameter can be a value of @ref RCC_I2C1_Clock_Source */
S
S  uint32_t UsbClockSelection;    /*!< USB clock source
S                                      This parameter can be a value of @ref RCCEx_USB_Clock_Source */                                      
S
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F070x6 || STM32F070xB */
N
N#if defined(STM32F042x6) || defined(STM32F048xx)
X#if 0L || 0L
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  uint32_t RTCClockSelection;    /*!< Specifies RTC Clock Prescalers Selection 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t Usart1ClockSelection; /*!< USART1 clock source
S                                      This parameter can be a value of @ref RCC_USART1_Clock_Source */
S
S  uint32_t I2c1ClockSelection;   /*!< I2C1 clock source
S                                      This parameter can be a value of @ref RCC_I2C1_Clock_Source */
S
S  uint32_t CecClockSelection;    /*!< HDMI CEC clock source
S                                      This parameter can be a value of @ref RCCEx_CEC_Clock_Source */
S
S  uint32_t UsbClockSelection;    /*!< USB clock source
S                                      This parameter can be a value of @ref RCCEx_USB_Clock_Source */
S
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F042x6 || STM32F048xx */
N
N#if defined(STM32F051x8) || defined(STM32F058xx)
X#if 0L || 0L
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  uint32_t RTCClockSelection;    /*!< Specifies RTC Clock Prescalers Selection 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t Usart1ClockSelection; /*!< USART1 clock source
S                                      This parameter can be a value of @ref RCC_USART1_Clock_Source */
S
S  uint32_t I2c1ClockSelection;   /*!< I2C1 clock source
S                                      This parameter can be a value of @ref RCC_I2C1_Clock_Source */
S
S  uint32_t CecClockSelection;    /*!< HDMI CEC clock source
S                                      This parameter can be a value of @ref RCCEx_CEC_Clock_Source */
S
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F051x8 || STM32F058xx */
N
N#if defined(STM32F071xB)
X#if 0L
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  uint32_t RTCClockSelection;    /*!< Specifies RTC Clock Prescalers Selection 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t Usart1ClockSelection; /*!< USART1 clock source
S                                      This parameter can be a value of @ref RCC_USART1_Clock_Source */
S
S  uint32_t Usart2ClockSelection; /*!< USART2 clock source
S                                      This parameter can be a value of @ref RCCEx_USART2_Clock_Source */
S
S  uint32_t I2c1ClockSelection;   /*!< I2C1 clock source
S                                      This parameter can be a value of @ref RCC_I2C1_Clock_Source */
S
S  uint32_t CecClockSelection;    /*!< HDMI CEC clock source
S                                      This parameter can be a value of @ref RCCEx_CEC_Clock_Source */
S
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F071xB */
N
N#if defined(STM32F072xB) || defined(STM32F078xx)
X#if 0L || 0L
Stypedef struct
S{
S  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
S                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
S
S  uint32_t RTCClockSelection;    /*!< Specifies RTC Clock Prescalers Selection 
S                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
S
S  uint32_t Usart1ClockSelection; /*!< USART1 clock source
S                                      This parameter can be a value of @ref RCC_USART1_Clock_Source */
S
S  uint32_t Usart2ClockSelection; /*!< USART2 clock source
S                                      This parameter can be a value of @ref RCCEx_USART2_Clock_Source */
S
S  uint32_t I2c1ClockSelection;   /*!< I2C1 clock source
S                                      This parameter can be a value of @ref RCC_I2C1_Clock_Source */
S
S  uint32_t CecClockSelection;    /*!< HDMI CEC clock source
S                                      This parameter can be a value of @ref RCCEx_CEC_Clock_Source */
S
S  uint32_t UsbClockSelection;    /*!< USB clock source
S                                      This parameter can be a value of @ref RCCEx_USB_Clock_Source */
S
S}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F072xB || STM32F078xx */
N
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
Ntypedef struct
N{
N  uint32_t PeriphClockSelection; /*!< The Extended Clock to be configured.
N                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection */
N
N  uint32_t RTCClockSelection;    /*!< Specifies RTC Clock Prescalers Selection 
N                                      This parameter can be a value of @ref RCC_RTC_Clock_Source */
N
N  uint32_t Usart1ClockSelection; /*!< USART1 clock source
N                                      This parameter can be a value of @ref RCC_USART1_Clock_Source */
N
N  uint32_t Usart2ClockSelection; /*!< USART2 clock source
N                                      This parameter can be a value of @ref RCCEx_USART2_Clock_Source */
N
N  uint32_t Usart3ClockSelection; /*!< USART3 clock source
N                                      This parameter can be a value of @ref RCCEx_USART3_Clock_Source */
N
N  uint32_t I2c1ClockSelection;   /*!< I2C1 clock source
N                                      This parameter can be a value of @ref RCC_I2C1_Clock_Source */
N
N  uint32_t CecClockSelection;    /*!< HDMI CEC clock source
N                                      This parameter can be a value of @ref RCCEx_CEC_Clock_Source */
N
N}RCC_PeriphCLKInitTypeDef;
N#endif /* STM32F091xC || STM32F098xx */
N
N#if defined(CRS)
X#if 1L
N
N/** 
N  * @brief RCC_CRS Init structure definition  
N  */
Ntypedef struct
N{
N  uint32_t Prescaler;             /*!< Specifies the division factor of the SYNC signal.
N                                     This parameter can be a value of @ref RCCEx_CRS_SynchroDivider */
N
N  uint32_t Source;                /*!< Specifies the SYNC signal source.
N                                     This parameter can be a value of @ref RCCEx_CRS_SynchroSource */
N
N  uint32_t Polarity;              /*!< Specifies the input polarity for the SYNC signal source.
N                                     This parameter can be a value of @ref RCCEx_CRS_SynchroPolarity */
N
N  uint32_t ReloadValue;           /*!< Specifies the value to be loaded in the frequency error counter with each SYNC event.
N                                      It can be calculated in using macro @ref __HAL_RCC_CRS_RELOADVALUE_CALCULATE(__FTARGET__, __FSYNC__)
N                                     This parameter must be a number between 0 and 0xFFFF or a value of @ref RCCEx_CRS_ReloadValueDefault .*/
N
N  uint32_t ErrorLimitValue;       /*!< Specifies the value to be used to evaluate the captured frequency error value.
N                                     This parameter must be a number between 0 and 0xFF or a value of @ref RCCEx_CRS_ErrorLimitDefault */
N
N  uint32_t HSI48CalibrationValue; /*!< Specifies a user-programmable trimming value to the HSI48 oscillator.
N                                     This parameter must be a number between 0 and 0x3F or a value of @ref RCCEx_CRS_HSI48CalibrationDefault */
N
N}RCC_CRSInitTypeDef;
N
N/** 
N  * @brief RCC_CRS Synchronization structure definition  
N  */
Ntypedef struct
N{
N  uint32_t ReloadValue;           /*!< Specifies the value loaded in the Counter reload value.
N                                     This parameter must be a number between 0 and 0xFFFFU */
N
N  uint32_t HSI48CalibrationValue; /*!< Specifies value loaded in HSI48 oscillator smooth trimming.
N                                     This parameter must be a number between 0 and 0x3FU */
N
N  uint32_t FreqErrorCapture;      /*!< Specifies the value loaded in the .FECAP, the frequency error counter 
N                                                                    value latched in the time of the last SYNC event.
N                                    This parameter must be a number between 0 and 0xFFFFU */
N
N  uint32_t FreqErrorDirection;    /*!< Specifies the value loaded in the .FEDIR, the counting direction of the 
N                                                                    frequency error counter latched in the time of the last SYNC event. 
N                                                                    It shows whether the actual frequency is below or above the target.
N                                    This parameter must be a value of @ref RCCEx_CRS_FreqErrorDirection*/
N
N}RCC_CRSSynchroInfoTypeDef;
N
N#endif /* CRS */
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RCCEx_Exported_Constants RCCEx Exported Constants
N  * @{
N  */
N
N/** @defgroup RCCEx_Periph_Clock_Selection RCCEx Periph Clock Selection
N  * @{
N  */
N#if defined(STM32F030x6) || defined(STM32F030x8) || defined(STM32F031x6) || defined(STM32F038xx)\
N || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 0L
S#define RCC_PERIPHCLK_USART1           (0x00000001U)
S#define RCC_PERIPHCLK_I2C1             (0x00000020U)
S#define RCC_PERIPHCLK_RTC              (0x00010000U)
S
S#endif /* STM32F030x6 || STM32F030x8 || STM32F031x6 || STM32F038xx || 
N          STM32F030xC */
N
N#if defined(STM32F070x6) || defined(STM32F070xB)
X#if 0L || 0L
S#define RCC_PERIPHCLK_USART1           (0x00000001U)
S#define RCC_PERIPHCLK_I2C1             (0x00000020U)
S#define RCC_PERIPHCLK_RTC              (0x00010000U)
S#define RCC_PERIPHCLK_USB              (0x00020000U)
S
N#endif /* STM32F070x6 || STM32F070xB */
N
N#if defined(STM32F042x6) || defined(STM32F048xx)
X#if 0L || 0L
S#define RCC_PERIPHCLK_USART1           (0x00000001U)
S#define RCC_PERIPHCLK_I2C1             (0x00000020U)
S#define RCC_PERIPHCLK_CEC              (0x00000400U)
S#define RCC_PERIPHCLK_RTC              (0x00010000U)
S#define RCC_PERIPHCLK_USB              (0x00020000U)
S
N#endif /* STM32F042x6 || STM32F048xx */
N
N#if defined(STM32F051x8) || defined(STM32F058xx)
X#if 0L || 0L
S#define RCC_PERIPHCLK_USART1           (0x00000001U)
S#define RCC_PERIPHCLK_I2C1             (0x00000020U)
S#define RCC_PERIPHCLK_CEC              (0x00000400U)
S#define RCC_PERIPHCLK_RTC              (0x00010000U)
S
N#endif /* STM32F051x8 || STM32F058xx */
N
N#if defined(STM32F071xB)
X#if 0L
S#define RCC_PERIPHCLK_USART1           (0x00000001U)
S#define RCC_PERIPHCLK_USART2           (0x00000002U)
S#define RCC_PERIPHCLK_I2C1             (0x00000020U)
S#define RCC_PERIPHCLK_CEC              (0x00000400U)
S#define RCC_PERIPHCLK_RTC              (0x00010000U)
S
N#endif /* STM32F071xB */
N
N#if defined(STM32F072xB) || defined(STM32F078xx)
X#if 0L || 0L
S#define RCC_PERIPHCLK_USART1           (0x00000001U)
S#define RCC_PERIPHCLK_USART2           (0x00000002U)
S#define RCC_PERIPHCLK_I2C1             (0x00000020U)
S#define RCC_PERIPHCLK_CEC              (0x00000400U)
S#define RCC_PERIPHCLK_RTC              (0x00010000U)
S#define RCC_PERIPHCLK_USB              (0x00020000U)
S
N#endif /* STM32F072xB || STM32F078xx */
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N#define RCC_PERIPHCLK_USART1           (0x00000001U)
N#define RCC_PERIPHCLK_USART2           (0x00000002U)
N#define RCC_PERIPHCLK_I2C1             (0x00000020U)
N#define RCC_PERIPHCLK_CEC              (0x00000400U)
N#define RCC_PERIPHCLK_RTC              (0x00010000U)
N#define RCC_PERIPHCLK_USART3           (0x00040000U)
N
N#endif /* STM32F091xC || STM32F098xx */
N
N/**
N  * @}
N  */
N
N#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx)
X#if 0L || 0L || 0L || 0L
S
S/** @defgroup RCCEx_USB_Clock_Source RCCEx USB Clock Source
S  * @{
S  */
S#define RCC_USBCLKSOURCE_HSI48         RCC_CFGR3_USBSW_HSI48  /*!< HSI48 clock selected as USB clock source */
S#define RCC_USBCLKSOURCE_PLL           RCC_CFGR3_USBSW_PLLCLK /*!< PLL clock (PLLCLK) selected as USB clock */
S
S/**
S  * @}
S  */
S
N#endif /* STM32F042x6 || STM32F048xx || STM32F072xB || STM32F078xx */
N
N#if defined(STM32F070x6) || defined(STM32F070xB)
X#if 0L || 0L
S
S/** @defgroup RCCEx_USB_Clock_Source RCCEx USB Clock Source
S  * @{
S  */
S#define RCC_USBCLKSOURCE_NONE          (0x00000000U) /*!< USB clock disabled */
S#define RCC_USBCLKSOURCE_PLL           RCC_CFGR3_USBSW_PLLCLK /*!< PLL clock (PLLCLK) selected as USB clock */
S
S/**
S  * @}
S  */
S
N#endif /* STM32F070x6 || STM32F070xB */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 1L || 0L
N
N/** @defgroup RCCEx_USART2_Clock_Source RCCEx USART2 Clock Source
N  * @{
N  */
N#define RCC_USART2CLKSOURCE_PCLK1        RCC_CFGR3_USART2SW_PCLK
N#define RCC_USART2CLKSOURCE_SYSCLK       RCC_CFGR3_USART2SW_SYSCLK
N#define RCC_USART2CLKSOURCE_LSE          RCC_CFGR3_USART2SW_LSE
N#define RCC_USART2CLKSOURCE_HSI          RCC_CFGR3_USART2SW_HSI
N
N/**
N  * @}
N  */
N
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N
N/** @defgroup RCCEx_USART3_Clock_Source RCCEx USART3 Clock Source
N  * @{
N  */
N#define RCC_USART3CLKSOURCE_PCLK1        RCC_CFGR3_USART3SW_PCLK
N#define RCC_USART3CLKSOURCE_SYSCLK       RCC_CFGR3_USART3SW_SYSCLK
N#define RCC_USART3CLKSOURCE_LSE          RCC_CFGR3_USART3SW_LSE
N#define RCC_USART3CLKSOURCE_HSI          RCC_CFGR3_USART3SW_HSI
N
N/**
N  * @}
N  */
N
N#endif /* STM32F091xC || STM32F098xx */
N
N
N#if defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N/** @defgroup RCCEx_CEC_Clock_Source RCCEx CEC Clock Source
N  * @{
N  */
N#define RCC_CECCLKSOURCE_HSI             RCC_CFGR3_CECSW_HSI_DIV244
N#define RCC_CECCLKSOURCE_LSE             RCC_CFGR3_CECSW_LSE
N
N/**
N  * @}
N  */
N
N#endif /* STM32F042x6 || STM32F048xx ||                */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N/** @defgroup RCCEx_MCOx_Clock_Prescaler RCCEx MCOx Clock Prescaler
N  * @{
N  */
N  
N#if defined(RCC_CFGR_MCOPRE)
X#if 1L
N
N#define RCC_MCODIV_1                     (0x00000000U)
N#define RCC_MCODIV_2                     (0x10000000U)
N#define RCC_MCODIV_4                     (0x20000000U)
N#define RCC_MCODIV_8                     (0x30000000U)
N#define RCC_MCODIV_16                    (0x40000000U)
N#define RCC_MCODIV_32                    (0x50000000U)
N#define RCC_MCODIV_64                    (0x60000000U)
N#define RCC_MCODIV_128                   (0x70000000U)
N
N#else
S
S#define RCC_MCODIV_1                    (0x00000000U)
S
N#endif /* RCC_CFGR_MCOPRE */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_LSEDrive_Configuration RCC LSE Drive Configuration
N  * @{
N  */
N
N#define RCC_LSEDRIVE_LOW                 (0x00000000U) /*!< Xtal mode lower driving capability */
N#define RCC_LSEDRIVE_MEDIUMLOW           RCC_BDCR_LSEDRV_1      /*!< Xtal mode medium low driving capability */
N#define RCC_LSEDRIVE_MEDIUMHIGH          RCC_BDCR_LSEDRV_0      /*!< Xtal mode medium high driving capability */
N#define RCC_LSEDRIVE_HIGH                RCC_BDCR_LSEDRV        /*!< Xtal mode higher driving capability */
N
N/**
N  * @}
N  */
N
N#if defined(CRS)
X#if 1L
N
N/** @defgroup RCCEx_CRS_Status RCCEx CRS Status
N  * @{
N  */
N#define RCC_CRS_NONE      (0x00000000U)
N#define RCC_CRS_TIMEOUT   (0x00000001U)
N#define RCC_CRS_SYNCOK    (0x00000002U)
N#define RCC_CRS_SYNCWARN  (0x00000004U)
N#define RCC_CRS_SYNCERR   (0x00000008U)
N#define RCC_CRS_SYNCMISS  (0x00000010U)
N#define RCC_CRS_TRIMOVF   (0x00000020U)
N
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_CRS_SynchroSource RCCEx CRS Synchronization Source
N  * @{
N  */
N#define RCC_CRS_SYNC_SOURCE_GPIO       (0x00000000U) /*!< Synchro Signal source GPIO */
N#define RCC_CRS_SYNC_SOURCE_LSE        CRS_CFGR_SYNCSRC_0      /*!< Synchro Signal source LSE */
N#define RCC_CRS_SYNC_SOURCE_USB        CRS_CFGR_SYNCSRC_1      /*!< Synchro Signal source USB SOF (default)*/
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_CRS_SynchroDivider RCCEx CRS Synchronization Divider
N  * @{
N  */
N#define RCC_CRS_SYNC_DIV1        (0x00000000U)                   /*!< Synchro Signal not divided (default) */
N#define RCC_CRS_SYNC_DIV2        CRS_CFGR_SYNCDIV_0                        /*!< Synchro Signal divided by 2 */
N#define RCC_CRS_SYNC_DIV4        CRS_CFGR_SYNCDIV_1                        /*!< Synchro Signal divided by 4 */
N#define RCC_CRS_SYNC_DIV8        (CRS_CFGR_SYNCDIV_1 | CRS_CFGR_SYNCDIV_0) /*!< Synchro Signal divided by 8 */
N#define RCC_CRS_SYNC_DIV16       CRS_CFGR_SYNCDIV_2                        /*!< Synchro Signal divided by 16 */
N#define RCC_CRS_SYNC_DIV32       (CRS_CFGR_SYNCDIV_2 | CRS_CFGR_SYNCDIV_0) /*!< Synchro Signal divided by 32 */
N#define RCC_CRS_SYNC_DIV64       (CRS_CFGR_SYNCDIV_2 | CRS_CFGR_SYNCDIV_1) /*!< Synchro Signal divided by 64 */
N#define RCC_CRS_SYNC_DIV128      CRS_CFGR_SYNCDIV                          /*!< Synchro Signal divided by 128 */
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_CRS_SynchroPolarity RCCEx CRS Synchronization Polarity
N  * @{
N  */
N#define RCC_CRS_SYNC_POLARITY_RISING   (0x00000000U) /*!< Synchro Active on rising edge (default) */
N#define RCC_CRS_SYNC_POLARITY_FALLING  CRS_CFGR_SYNCPOL        /*!< Synchro Active on falling edge */
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_CRS_ReloadValueDefault RCCEx CRS Default Reload Value
N  * @{
N  */
N#define RCC_CRS_RELOADVALUE_DEFAULT    (0x0000BB7FU) /*!< The reset value of the RELOAD field corresponds 
N                                                                    to a target frequency of 48 MHz and a synchronization signal frequency of 1 kHz (SOF signal from USB). */
N/**
N  * @}
N  */
N  
N/** @defgroup RCCEx_CRS_ErrorLimitDefault RCCEx CRS Default Error Limit Value
N  * @{
N  */
N#define RCC_CRS_ERRORLIMIT_DEFAULT     (0x00000022U) /*!< Default Frequency error limit */
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_CRS_HSI48CalibrationDefault RCCEx CRS Default HSI48 Calibration vakye
N  * @{
N  */
N#define RCC_CRS_HSI48CALIBRATION_DEFAULT (0x00000020U) /*!< The default value is 32, which corresponds to the middle of the trimming interval. 
N                                                                      The trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value
N                                                                      corresponds to a higher output frequency */  
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_CRS_FreqErrorDirection RCCEx CRS Frequency Error Direction
N  * @{
N  */
N#define RCC_CRS_FREQERRORDIR_UP        (0x00000000U)   /*!< Upcounting direction, the actual frequency is above the target */
N#define RCC_CRS_FREQERRORDIR_DOWN      ((uint32_t)CRS_ISR_FEDIR) /*!< Downcounting direction, the actual frequency is below the target */
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_CRS_Interrupt_Sources RCCEx CRS Interrupt Sources
N  * @{
N  */
N#define RCC_CRS_IT_SYNCOK              CRS_CR_SYNCOKIE           /*!< SYNC event OK */
N#define RCC_CRS_IT_SYNCWARN            CRS_CR_SYNCWARNIE         /*!< SYNC warning */
N#define RCC_CRS_IT_ERR                 CRS_CR_ERRIE              /*!< Error */
N#define RCC_CRS_IT_ESYNC               CRS_CR_ESYNCIE            /*!< Expected SYNC */
N#define RCC_CRS_IT_SYNCERR             CRS_CR_ERRIE              /*!< SYNC error */
N#define RCC_CRS_IT_SYNCMISS            CRS_CR_ERRIE              /*!< SYNC missed */
N#define RCC_CRS_IT_TRIMOVF             CRS_CR_ERRIE              /*!< Trimming overflow or underflow */
N
N/**
N  * @}
N  */
N  
N/** @defgroup RCCEx_CRS_Flags RCCEx CRS Flags
N  * @{
N  */
N#define RCC_CRS_FLAG_SYNCOK            CRS_ISR_SYNCOKF           /*!< SYNC event OK flag     */
N#define RCC_CRS_FLAG_SYNCWARN          CRS_ISR_SYNCWARNF         /*!< SYNC warning flag      */
N#define RCC_CRS_FLAG_ERR               CRS_ISR_ERRF              /*!< Error flag        */
N#define RCC_CRS_FLAG_ESYNC             CRS_ISR_ESYNCF            /*!< Expected SYNC flag     */
N#define RCC_CRS_FLAG_SYNCERR           CRS_ISR_SYNCERR           /*!< SYNC error */
N#define RCC_CRS_FLAG_SYNCMISS          CRS_ISR_SYNCMISS          /*!< SYNC missed*/
N#define RCC_CRS_FLAG_TRIMOVF           CRS_ISR_TRIMOVF           /*!< Trimming overflow or underflow */
N
N/**
N  * @}
N  */
N
N#endif /* CRS */
N
N/**
N  * @}
N  */
N
N/* Exported macros ------------------------------------------------------------*/
N/** @defgroup RCCEx_Exported_Macros RCCEx Exported Macros
N  * @{
N  */
N
N/** @defgroup RCCEx_Peripheral_Clock_Enable_Disable RCCEx_Peripheral_Clock_Enable_Disable
N  * @brief  Enables or disables the AHB1 peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N#if defined(GPIOD)
X#if 1L
N
N#define __HAL_RCC_GPIOD_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIODEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIODEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_GPIOD_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIODEN);                                                                                  tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIODEN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_GPIOD_CLK_DISABLE()        (RCC->AHBENR &= ~(RCC_AHBENR_GPIODEN))
N
N#endif /* GPIOD */
N
N#if defined(GPIOE)
X#if 1L
N
N#define __HAL_RCC_GPIOE_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOEEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOEEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_GPIOE_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOEEN);                                                                                  tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOEEN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_GPIOE_CLK_DISABLE()        (RCC->AHBENR &= ~(RCC_AHBENR_GPIOEEN))
N
N#endif /* GPIOE */
N
N#if defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N      
N#define __HAL_RCC_TSC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_TSCEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_TSCEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TSC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_TSCEN);                                                                                  tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_TSCEN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_TSC_CLK_DISABLE()          (RCC->AHBENR &= ~(RCC_AHBENR_TSCEN))
N
N#endif /* STM32F042x6 || STM32F048xx ||                */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N
N#define __HAL_RCC_DMA2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->AHBENR, RCC_AHBENR_DMA2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_DMA2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_DMA2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_DMA2EN);                                                                                  tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_DMA2EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_DMA2_CLK_DISABLE()        (RCC->AHBENR &= ~(RCC_AHBENR_DMA2EN))
N
N#endif /* STM32F091xC || STM32F098xx */
N      
N/** @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  */
N#if defined(STM32F030x8)\
N || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_USART2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_USART2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_USART2_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART2EN))
N
N#endif /* STM32F030x8 || STM32F042x6 || STM32F048xx || */
N       /* STM32F051x8 || STM32F058xx || STM32F070x6 || */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F030x8)\
N || defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_SPI2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_SPI2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_SPI2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_SPI2EN))
N
N#endif /* STM32F030x8 || STM32F042x6 || STM32F048xx || */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F031x6) || defined(STM32F038xx)\
N || defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_TIM2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_TIM2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))
N
N#endif /* STM32F031x6 || STM32F038xx ||             */
N       /* STM32F042x6 || STM32F048xx ||             */
N       /* STM32F051x8 || STM32F058xx ||             */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F030x8) \
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L  || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_TIM6_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM6_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_I2C2_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_I2C2_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_TIM6_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))
N#define __HAL_RCC_I2C2_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_I2C2EN))
N
N#endif /* STM32F030x8 ||                               */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_DAC1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_DAC1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_DAC1_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))
N
N#endif /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_CEC_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_CEC_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_CEC_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CECEN))
N
N#endif /* STM32F042x6 || STM32F048xx ||                */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_TIM7_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM7_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_USART3_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_USART3_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_USART4_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART4EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART4EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_USART4_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART4EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART4EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_TIM7_CLK_DISABLE()   (RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))
N#define __HAL_RCC_USART3_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))
N#define __HAL_RCC_USART4_CLK_DISABLE() (RCC->APB1ENR &= ~(RCC_APB1ENR_USART4EN))
N
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6)\
N || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S
S#define __HAL_RCC_USB_CLK_ENABLE()   do { \
S                                        __IO uint32_t tmpreg; \
S                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USBEN);\
S                                        /* Delay after an RCC peripheral clock enabling */ \
S                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USBEN);\
S                                        UNUSED(tmpreg); \
S                                      } while(0U)
X#define __HAL_RCC_USB_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USBEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USBEN);                                        UNUSED(tmpreg);                                       } while(0U)
S
S#define __HAL_RCC_USB_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_USBEN))
S
N#endif /* STM32F042x6 || STM32F048xx || STM32F070x6 || */
N       /* STM32F072xB || STM32F078xx || STM32F070xB  */
N
N#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_CAN1_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CANEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CANEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_CAN1_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CANEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CANEN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_CAN1_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CANEN))
N
N#endif /* STM32F042x6 || STM32F048xx || STM32F072xB  || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(CRS)
X#if 1L
N
N#define __HAL_RCC_CRS_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CRSEN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CRSEN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_CRS_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CRSEN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CRSEN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_CRS_CLK_DISABLE()    (RCC->APB1ENR &= ~(RCC_APB1ENR_CRSEN))
N
N#endif /* CRS */
N
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 1L || 0L || 0L
N
N#define __HAL_RCC_USART5_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART5EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART5EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_USART5_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART5EN);                                                                                  tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART5EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_USART5_CLK_DISABLE()      (RCC->APB1ENR &= ~(RCC_APB1ENR_USART5EN))
N
N#endif /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N/** @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  */
N#if defined(STM32F030x8) || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC) 
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L 
N
N#define __HAL_RCC_TIM15_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM15EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM15EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_TIM15_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM15EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM15EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_TIM15_CLK_DISABLE()   (RCC->APB2ENR &= ~(RCC_APB2ENR_TIM15EN))
N
N#endif /* STM32F030x8 || STM32F042x6 || STM32F048xx || STM32F070x6 || */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 1L || 0L || 0L
N
N#define __HAL_RCC_USART6_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_USART6_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_USART6_CLK_DISABLE()      (RCC->APB2ENR &= ~(RCC_APB2ENR_USART6EN))
N
N#endif /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N
N#define __HAL_RCC_USART7_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART7EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART7EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_USART7_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART7EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART7EN);                                        UNUSED(tmpreg);                                       } while(0U)
N#define __HAL_RCC_USART8_CLK_ENABLE()   do { \
N                                        __IO uint32_t tmpreg; \
N                                        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART8EN);\
N                                        /* Delay after an RCC peripheral clock enabling */ \
N                                        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART8EN);\
N                                        UNUSED(tmpreg); \
N                                      } while(0U)
X#define __HAL_RCC_USART8_CLK_ENABLE()   do {                                         __IO uint32_t tmpreg;                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART8EN);                                                                                  tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART8EN);                                        UNUSED(tmpreg);                                       } while(0U)
N
N#define __HAL_RCC_USART7_CLK_DISABLE()      (RCC->APB2ENR &= ~(RCC_APB2ENR_USART7EN))
N#define __HAL_RCC_USART8_CLK_DISABLE()      (RCC->APB2ENR &= ~(RCC_APB2ENR_USART8EN))
N
N#endif /* STM32F091xC || STM32F098xx */
N
N/**
N  * @}
N  */
N
N
N/** @defgroup RCCEx_Force_Release_Peripheral_Reset RCCEx Force Release Peripheral Reset
N  * @brief  Forces or releases peripheral reset.
N  * @{
N  */
N
N/** @brief  Force or release AHB peripheral reset.
N  */
N#if defined(GPIOD)
X#if 1L
N
N#define __HAL_RCC_GPIOD_FORCE_RESET()   (RCC->AHBRSTR |= (RCC_AHBRSTR_GPIODRST))
N
N#define __HAL_RCC_GPIOD_RELEASE_RESET() (RCC->AHBRSTR &= ~(RCC_AHBRSTR_GPIODRST))
N
N#endif /* GPIOD */
N
N#if defined(GPIOE)
X#if 1L
N
N#define __HAL_RCC_GPIOE_FORCE_RESET()   (RCC->AHBRSTR |= (RCC_AHBRSTR_GPIOERST))
N
N#define __HAL_RCC_GPIOE_RELEASE_RESET() (RCC->AHBRSTR &= ~(RCC_AHBRSTR_GPIOERST))
N
N#endif /* GPIOE */
N
N#if defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N      
N#define __HAL_RCC_TSC_FORCE_RESET()     (RCC->AHBRSTR |= (RCC_AHBRSTR_TSCRST))
N
N#define __HAL_RCC_TSC_RELEASE_RESET()   (RCC->AHBRSTR &= ~(RCC_AHBRSTR_TSCRST))
N
N#endif /* STM32F042x6 || STM32F048xx ||                */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N/** @brief  Force or release APB1 peripheral reset.
N  */
N#if defined(STM32F030x8) \
N || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L  || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_USART2_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART2RST))
N#define __HAL_RCC_SPI2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_SPI2RST))
N
N#define __HAL_RCC_USART2_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART2RST))
N#define __HAL_RCC_SPI2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI2RST))
N
N#endif /* STM32F030x8 || STM32F042x6 || STM32F048xx || STM32F070x6 || */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F031x6) || defined(STM32F038xx)\
N || defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_TIM2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))
N
N#define __HAL_RCC_TIM2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))
N
N#endif /* STM32F031x6 || STM32F038xx ||             */
N       /* STM32F042x6 || STM32F048xx ||             */
N       /* STM32F051x8 || STM32F058xx ||             */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F030x8) \
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L  || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_TIM6_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))
N#define __HAL_RCC_I2C2_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_I2C2RST))
N
N#define __HAL_RCC_TIM6_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))
N#define __HAL_RCC_I2C2_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C2RST))
N
N#endif /* STM32F030x8 ||                               */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_DAC1_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))
N
N#define __HAL_RCC_DAC1_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))
N
N#endif /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_CEC_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_CECRST))
N
N#define __HAL_RCC_CEC_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CECRST))
N
N#endif /* STM32F042x6 || STM32F048xx ||                */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_TIM7_FORCE_RESET()     (RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))
N#define __HAL_RCC_USART3_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))
N#define __HAL_RCC_USART4_FORCE_RESET()   (RCC->APB1RSTR |= (RCC_APB1RSTR_USART4RST))
N
N#define __HAL_RCC_TIM7_RELEASE_RESET()   (RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))
N#define __HAL_RCC_USART3_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))
N#define __HAL_RCC_USART4_RELEASE_RESET() (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART4RST))
N
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6)\
N || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S
S#define __HAL_RCC_USB_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_USBRST))
S
S#define __HAL_RCC_USB_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USBRST))
S
N#endif /* STM32F042x6 || STM32F048xx || STM32F070x6 || */
N       /* STM32F072xB || STM32F078xx || STM32F070xB */
N
N#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_CAN1_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_CANRST))
N
N#define __HAL_RCC_CAN1_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CANRST))
N
N#endif /* STM32F042x6 || STM32F048xx || STM32F072xB || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(CRS)
X#if 1L
N
N#define __HAL_RCC_CRS_FORCE_RESET()      (RCC->APB1RSTR |= (RCC_APB1RSTR_CRSRST))
N
N#define __HAL_RCC_CRS_RELEASE_RESET()    (RCC->APB1RSTR &= ~(RCC_APB1RSTR_CRSRST))
N
N#endif /* CRS */
N
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 1L || 0L || 0L
N
N#define __HAL_RCC_USART5_FORCE_RESET()    (RCC->APB1RSTR |= (RCC_APB1RSTR_USART5RST))
N
N#define __HAL_RCC_USART5_RELEASE_RESET()  (RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART5RST))
N
N#endif /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N
N/** @brief  Force or release APB2 peripheral reset.
N  */
N#if defined(STM32F030x8) || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_TIM15_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_TIM15RST))
N
N#define __HAL_RCC_TIM15_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM15RST))
N
N#endif /* STM32F030x8 || STM32F042x6 || STM32F048xx || STM32F070x6 || */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 1L || 0L || 0L
N
N#define __HAL_RCC_USART6_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_USART6RST))
N
N#define __HAL_RCC_USART6_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART6RST))
N
N#endif /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N
N#define __HAL_RCC_USART7_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_USART7RST))
N#define __HAL_RCC_USART8_FORCE_RESET()    (RCC->APB2RSTR |= (RCC_APB2RSTR_USART8RST))
N
N#define __HAL_RCC_USART7_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART7RST))
N#define __HAL_RCC_USART8_RELEASE_RESET()  (RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART8RST))
N
N#endif /* STM32F091xC || STM32F098xx */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_Peripheral_Clock_Enable_Disable_Status Peripheral Clock Enable Disable Status
N  * @brief  Get the enable or disable status of peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before
N  *         using it.
N  * @{
N  */
N/** @brief  AHB Peripheral Clock Enable Disable Status
N  */
N#if defined(GPIOD)
X#if 1L
N
N#define __HAL_RCC_GPIOD_IS_CLK_ENABLED()     ((RCC->AHBENR & (RCC_AHBENR_GPIODEN)) != RESET)
N#define __HAL_RCC_GPIOD_IS_CLK_DISABLED()    ((RCC->AHBENR & (RCC_AHBENR_GPIODEN)) == RESET)
N
N#endif /* GPIOD */
N
N#if defined(GPIOE)
X#if 1L
N
N#define __HAL_RCC_GPIOE_IS_CLK_ENABLED()     ((RCC->AHBENR & (RCC_AHBENR_GPIOEEN)) != RESET)
N#define __HAL_RCC_GPIOE_IS_CLK_DISABLED()    ((RCC->AHBENR & (RCC_AHBENR_GPIOEEN)) == RESET)
N
N#endif /* GPIOE */
N
N#if defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N      
N#define __HAL_RCC_TSC_IS_CLK_ENABLED()       ((RCC->AHBENR & (RCC_AHBENR_TSCEN)) != RESET)
N#define __HAL_RCC_TSC_IS_CLK_DISABLED()      ((RCC->AHBENR & (RCC_AHBENR_TSCEN)) == RESET)
N
N#endif /* STM32F042x6 || STM32F048xx ||                */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N
N#define __HAL_RCC_DMA2_IS_CLK_ENABLED()      ((RCC->AHBENR & (RCC_AHBENR_DMA2EN)) != RESET)
N#define __HAL_RCC_DMA2_IS_CLK_DISABLED()     ((RCC->AHBENR & (RCC_AHBENR_DMA2EN)) == RESET)
N
N#endif /* STM32F091xC || STM32F098xx */
N      
N/** @brief  APB1 Peripheral Clock Enable Disable Status
N  */
N#if defined(STM32F030x8)\
N || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_USART2_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_USART2EN)) != RESET)
N#define __HAL_RCC_USART2_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_USART2EN)) == RESET)
N
N#endif /* STM32F030x8 || STM32F042x6 || STM32F048xx || */
N       /* STM32F051x8 || STM32F058xx || STM32F070x6 || */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F030x8)\
N || defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_SPI2_IS_CLK_ENABLED()      ((RCC->APB1ENR & (RCC_APB1ENR_SPI2EN)) != RESET)
N#define __HAL_RCC_SPI2_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_SPI2EN)) == RESET)
N
N#endif /* STM32F030x8 || STM32F042x6 || STM32F048xx || */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F031x6) || defined(STM32F038xx)\
N || defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_TIM2_IS_CLK_ENABLED()      ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET)
N#define __HAL_RCC_TIM2_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET)
N
N#endif /* STM32F031x6 || STM32F038xx ||             */
N       /* STM32F042x6 || STM32F048xx ||             */
N       /* STM32F051x8 || STM32F058xx ||             */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F030x8) \
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L  || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_TIM6_IS_CLK_ENABLED()      ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET)
N#define __HAL_RCC_I2C2_IS_CLK_ENABLED()      ((RCC->APB1ENR & (RCC_APB1ENR_I2C2EN)) != RESET)
N#define __HAL_RCC_TIM6_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET)
N#define __HAL_RCC_I2C2_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_I2C2EN)) == RESET)
N
N#endif /* STM32F030x8 ||                               */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_DAC1_IS_CLK_ENABLED()      ((RCC->APB1ENR & (RCC_APB1ENR_DAC1EN)) != RESET)
N#define __HAL_RCC_DAC1_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_DAC1EN)) == RESET)
N
N#endif /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_CEC_IS_CLK_ENABLED()       ((RCC->APB1ENR & (RCC_APB1ENR_CECEN)) != RESET)
N#define __HAL_RCC_CEC_IS_CLK_DISABLED()      ((RCC->APB1ENR & (RCC_APB1ENR_CECEN)) == RESET)
N
N#endif /* STM32F042x6 || STM32F048xx ||                */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L || 1L || 0L || 0L
N
N#define __HAL_RCC_TIM7_IS_CLK_ENABLED()      ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET)
N#define __HAL_RCC_USART3_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET)
N#define __HAL_RCC_USART4_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_USART4EN)) != RESET)
N#define __HAL_RCC_TIM7_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET)
N#define __HAL_RCC_USART3_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET)
N#define __HAL_RCC_USART4_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_USART4EN)) == RESET)
N
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6)\
N || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S
S#define __HAL_RCC_USB_IS_CLK_ENABLED()       ((RCC->APB1ENR & (RCC_APB1ENR_USBEN)) != RESET)
S#define __HAL_RCC_USB_IS_CLK_DISABLED()      ((RCC->APB1ENR & (RCC_APB1ENR_USBEN)) == RESET)
S
N#endif /* STM32F042x6 || STM32F048xx || STM32F070x6 || */
N       /* STM32F072xB || STM32F078xx || STM32F070xB  */
N
N#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 1L || 0L
N
N#define __HAL_RCC_CAN1_IS_CLK_ENABLED()      ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) != RESET)
N#define __HAL_RCC_CAN1_IS_CLK_DISABLED()     ((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET)
N
N#endif /* STM32F042x6 || STM32F048xx || STM32F072xB  || */
N       /* STM32F091xC || STM32F098xx */
N
N#if defined(CRS)
X#if 1L
N
N#define __HAL_RCC_CRS_IS_CLK_ENABLED()       ((RCC->APB1ENR & (RCC_APB1ENR_CRSEN)) != RESET)
N#define __HAL_RCC_CRS_IS_CLK_DISABLED()      ((RCC->APB1ENR & (RCC_APB1ENR_CRSEN)) == RESET)
N
N#endif /* CRS */
N
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 1L || 0L || 0L
N
N#define __HAL_RCC_USART5_IS_CLK_ENABLED()    ((RCC->APB1ENR & (RCC_APB1ENR_USART5EN)) != RESET)
N#define __HAL_RCC_USART5_IS_CLK_DISABLED()   ((RCC->APB1ENR & (RCC_APB1ENR_USART5EN)) == RESET)
N
N#endif /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N/** @brief  APB1 Peripheral Clock Enable Disable Status
N  */
N#if defined(STM32F030x8) || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)\
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC) 
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L || 0L 
N
N#define __HAL_RCC_TIM15_IS_CLK_ENABLED()     ((RCC->APB2ENR & (RCC_APB2ENR_TIM15EN)) != RESET)
N#define __HAL_RCC_TIM15_IS_CLK_DISABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_TIM15EN)) == RESET)
N
N#endif /* STM32F030x8 || STM32F042x6 || STM32F048xx || STM32F070x6 || */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB || */
N       /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 1L || 0L || 0L
N
N#define __HAL_RCC_USART6_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_USART6EN)) != RESET)
N#define __HAL_RCC_USART6_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_USART6EN)) == RESET)
N
N#endif /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N
N#define __HAL_RCC_USART7_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_USART7EN)) != RESET)
N#define __HAL_RCC_USART8_IS_CLK_ENABLED()    ((RCC->APB2ENR & (RCC_APB2ENR_USART8EN)) != RESET)
N#define __HAL_RCC_USART7_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_USART7EN)) == RESET)
N#define __HAL_RCC_USART8_IS_CLK_DISABLED()   ((RCC->APB2ENR & (RCC_APB2ENR_USART8EN)) == RESET)
N
N#endif /* STM32F091xC || STM32F098xx */
N/**
N  * @}
N  */
N
N  
N/** @defgroup RCCEx_HSI48_Enable_Disable RCCEx HSI48 Enable Disable    
N  * @brief  Macros to enable or disable the Internal 48Mhz High Speed oscillator (HSI48).
N  * @note   The HSI48 is stopped by hardware when entering STOP and STANDBY modes.
N  * @note   HSI48 can not be stopped if it is used as system clock source. In this case,
N  *         you have to select another source of the system clock then stop the HSI14.
N  * @note   After enabling the HSI48 with __HAL_RCC_HSI48_ENABLE(), the application software
N  *         should wait on HSI48RDY flag to be set indicating that HSI48 clock is stable and can be
N  *         used as system clock source. This is not necessary if HAL_RCC_OscConfig() is used.
N  * @note   When the HSI48 is stopped, HSI48RDY flag goes low after 6 HSI48 oscillator
N  *         clock cycles.
N  * @{
N  */
N#if defined(RCC_HSI48_SUPPORT)
X#if 1L
N
N#define __HAL_RCC_HSI48_ENABLE()  SET_BIT(RCC->CR2, RCC_CR2_HSI48ON)
N#define __HAL_RCC_HSI48_DISABLE() CLEAR_BIT(RCC->CR2, RCC_CR2_HSI48ON)
N
N/** @brief  Macro to get the Internal 48Mhz High Speed oscillator (HSI48) state.
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_HSI48_ON  HSI48 enabled
N  *            @arg @ref RCC_HSI48_OFF HSI48 disabled
N  */
N#define __HAL_RCC_GET_HSI48_STATE() \
N                  (((uint32_t)(READ_BIT(RCC->CR2, RCC_CR2_HSI48ON)) != RESET) ? RCC_HSI48_ON : RCC_HSI48_OFF)  
X#define __HAL_RCC_GET_HSI48_STATE()                   (((uint32_t)(READ_BIT(RCC->CR2, RCC_CR2_HSI48ON)) != RESET) ? RCC_HSI48_ON : RCC_HSI48_OFF)  
N
N#endif /* RCC_HSI48_SUPPORT */
N
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_Peripheral_Clock_Source_Config RCCEx Peripheral Clock Source Config
N  * @{
N  */
N#if defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F070x6) || defined(STM32F070xB)
X#if 0L || 0L || 0L || 0L || 0L || 0L
S
S/** @brief  Macro to configure the USB clock (USBCLK).
S  * @param  __USBCLKSOURCE__ specifies the USB clock source.
S  *         This parameter can be one of the following values:
S@if STM32F070xB
S@elseif STM32F070x6
S@else
S  *            @arg @ref RCC_USBCLKSOURCE_HSI48  HSI48 selected as USB clock
S@endif  
S  *            @arg @ref RCC_USBCLKSOURCE_PLL PLL Clock selected as USB clock
S  */
S#define __HAL_RCC_USB_CONFIG(__USBCLKSOURCE__) \
S                  MODIFY_REG(RCC->CFGR3, RCC_CFGR3_USBSW, (uint32_t)(__USBCLKSOURCE__))
X#define __HAL_RCC_USB_CONFIG(__USBCLKSOURCE__)                   MODIFY_REG(RCC->CFGR3, RCC_CFGR3_USBSW, (uint32_t)(__USBCLKSOURCE__))
S
S/** @brief  Macro to get the USB clock source.
S  * @retval The clock source can be one of the following values:
S@if STM32F070xB
S@elseif STM32F070x6
S@else
S  *            @arg @ref RCC_USBCLKSOURCE_HSI48  HSI48 selected as USB clock
S@endif  
S  *            @arg @ref RCC_USBCLKSOURCE_PLL PLL Clock selected as USB clock
S  */
S#define __HAL_RCC_GET_USB_SOURCE() ((uint32_t)(READ_BIT(RCC->CFGR3, RCC_CFGR3_USBSW)))
S
N#endif /* STM32F042x6 || STM32F048xx || */
N       /* STM32F072xB || STM32F078xx || */
N       /* STM32F070x6 || STM32F070xB    */
N
N#if defined(STM32F042x6) || defined(STM32F048xx)\
N || defined(STM32F051x8) || defined(STM32F058xx)\
N || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 0L || 0L || 0L || 0L || 1L || 0L
N
N/** @brief  Macro to configure the CEC clock.
N  * @param  __CECCLKSOURCE__ specifies the CEC clock source.
N  *         This parameter can be one of the following values:
N  *            @arg @ref RCC_CECCLKSOURCE_HSI HSI selected as CEC clock
N  *            @arg @ref RCC_CECCLKSOURCE_LSE LSE selected as CEC clock
N  */
N#define __HAL_RCC_CEC_CONFIG(__CECCLKSOURCE__) \
N                  MODIFY_REG(RCC->CFGR3, RCC_CFGR3_CECSW, (uint32_t)(__CECCLKSOURCE__))
X#define __HAL_RCC_CEC_CONFIG(__CECCLKSOURCE__)                   MODIFY_REG(RCC->CFGR3, RCC_CFGR3_CECSW, (uint32_t)(__CECCLKSOURCE__))
N
N/** @brief  Macro to get the HDMI CEC clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_CECCLKSOURCE_HSI HSI selected as CEC clock
N  *            @arg @ref RCC_CECCLKSOURCE_LSE LSE selected as CEC clock
N  */
N#define __HAL_RCC_GET_CEC_SOURCE() ((uint32_t)(READ_BIT(RCC->CFGR3, RCC_CFGR3_CECSW)))
N
N#endif /* STM32F042x6 || STM32F048xx ||                */
N       /* STM32F051x8 || STM32F058xx ||                */
N       /* STM32F071xB || STM32F072xB || STM32F078xx || */
N       /* STM32F091xC || defined(STM32F098xx) */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
N || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 1L || 0L
N/** @brief  Macro to configure the USART2 clock (USART2CLK).
N  * @param  __USART2CLKSOURCE__ specifies the USART2 clock source.
N  *         This parameter can be one of the following values:
N  *            @arg @ref RCC_USART2CLKSOURCE_PCLK1 PCLK1 selected as USART2 clock
N  *            @arg @ref RCC_USART2CLKSOURCE_HSI HSI selected as USART2 clock
N  *            @arg @ref RCC_USART2CLKSOURCE_SYSCLK System Clock selected as USART2 clock
N  *            @arg @ref RCC_USART2CLKSOURCE_LSE LSE selected as USART2 clock
N  */
N#define __HAL_RCC_USART2_CONFIG(__USART2CLKSOURCE__) \
N                  MODIFY_REG(RCC->CFGR3, RCC_CFGR3_USART2SW, (uint32_t)(__USART2CLKSOURCE__))
X#define __HAL_RCC_USART2_CONFIG(__USART2CLKSOURCE__)                   MODIFY_REG(RCC->CFGR3, RCC_CFGR3_USART2SW, (uint32_t)(__USART2CLKSOURCE__))
N
N/** @brief  Macro to get the USART2 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_USART2CLKSOURCE_PCLK1 PCLK1 selected as USART2 clock
N  *            @arg @ref RCC_USART2CLKSOURCE_HSI HSI selected as USART2 clock
N  *            @arg @ref RCC_USART2CLKSOURCE_SYSCLK System Clock selected as USART2 clock
N  *            @arg @ref RCC_USART2CLKSOURCE_LSE LSE selected as USART2 clock
N  */
N#define __HAL_RCC_GET_USART2_SOURCE() ((uint32_t)(READ_BIT(RCC->CFGR3, RCC_CFGR3_USART2SW)))
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F091xC || STM32F098xx*/
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N/** @brief  Macro to configure the USART3 clock (USART3CLK).
N  * @param  __USART3CLKSOURCE__ specifies the USART3 clock source.
N  *         This parameter can be one of the following values:
N  *            @arg @ref RCC_USART3CLKSOURCE_PCLK1 PCLK1 selected as USART3 clock
N  *            @arg @ref RCC_USART3CLKSOURCE_HSI HSI selected as USART3 clock
N  *            @arg @ref RCC_USART3CLKSOURCE_SYSCLK System Clock selected as USART3 clock
N  *            @arg @ref RCC_USART3CLKSOURCE_LSE LSE selected as USART3 clock
N  */
N#define __HAL_RCC_USART3_CONFIG(__USART3CLKSOURCE__) \
N                  MODIFY_REG(RCC->CFGR3, RCC_CFGR3_USART3SW, (uint32_t)(__USART3CLKSOURCE__))
X#define __HAL_RCC_USART3_CONFIG(__USART3CLKSOURCE__)                   MODIFY_REG(RCC->CFGR3, RCC_CFGR3_USART3SW, (uint32_t)(__USART3CLKSOURCE__))
N
N/** @brief  Macro to get the USART3 clock source.
N  * @retval The clock source can be one of the following values:
N  *            @arg @ref RCC_USART3CLKSOURCE_PCLK1 PCLK1 selected as USART3 clock
N  *            @arg @ref RCC_USART3CLKSOURCE_HSI HSI selected as USART3 clock
N  *            @arg @ref RCC_USART3CLKSOURCE_SYSCLK System Clock selected as USART3 clock
N  *            @arg @ref RCC_USART3CLKSOURCE_LSE LSE selected as USART3 clock
N  */
N#define __HAL_RCC_GET_USART3_SOURCE() ((uint32_t)(READ_BIT(RCC->CFGR3, RCC_CFGR3_USART3SW)))
N
N#endif /* STM32F091xC || STM32F098xx */
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_LSE_Configuration LSE Drive Configuration
N  * @{   
N  */
N
N/**
N  * @brief  Macro to configure the External Low Speed oscillator (LSE) drive capability.
N  * @param  __RCC_LSEDRIVE__ specifies the new state of the LSE drive capability.
N  *          This parameter can be one of the following values:
N  *            @arg @ref RCC_LSEDRIVE_LOW        LSE oscillator low drive capability.
N  *            @arg @ref RCC_LSEDRIVE_MEDIUMLOW  LSE oscillator medium low drive capability.
N  *            @arg @ref RCC_LSEDRIVE_MEDIUMHIGH LSE oscillator medium high drive capability.
N  *            @arg @ref RCC_LSEDRIVE_HIGH       LSE oscillator high drive capability.
N  * @retval None
N  */ 
N#define __HAL_RCC_LSEDRIVE_CONFIG(__RCC_LSEDRIVE__) (MODIFY_REG(RCC->BDCR,\
N        RCC_BDCR_LSEDRV, (uint32_t)(__RCC_LSEDRIVE__) ))
X#define __HAL_RCC_LSEDRIVE_CONFIG(__RCC_LSEDRIVE__) (MODIFY_REG(RCC->BDCR,        RCC_BDCR_LSEDRV, (uint32_t)(__RCC_LSEDRIVE__) ))
N
N/**
N  * @}
N  */
N
N#if defined(CRS)
X#if 1L
N
N/** @defgroup RCCEx_IT_And_Flag RCCEx IT and Flag
N  * @{
N  */
N/* Interrupt & Flag management */
N
N/**
N  * @brief  Enable the specified CRS interrupts.
N  * @param  __INTERRUPT__ specifies the CRS interrupt sources to be enabled.
N  *          This parameter can be any combination of the following values:
N  *              @arg @ref RCC_CRS_IT_SYNCOK  SYNC event OK interrupt
N  *              @arg @ref RCC_CRS_IT_SYNCWARN  SYNC warning interrupt
N  *              @arg @ref RCC_CRS_IT_ERR  Synchronization or trimming error interrupt
N  *              @arg @ref RCC_CRS_IT_ESYNC  Expected SYNC interrupt
N  * @retval None
N  */
N#define __HAL_RCC_CRS_ENABLE_IT(__INTERRUPT__)   SET_BIT(CRS->CR, (__INTERRUPT__))
N
N/**
N  * @brief  Disable the specified CRS interrupts.
N  * @param  __INTERRUPT__ specifies the CRS interrupt sources to be disabled.
N  *          This parameter can be any combination of the following values:
N  *              @arg @ref RCC_CRS_IT_SYNCOK  SYNC event OK interrupt
N  *              @arg @ref RCC_CRS_IT_SYNCWARN  SYNC warning interrupt
N  *              @arg @ref RCC_CRS_IT_ERR  Synchronization or trimming error interrupt
N  *              @arg @ref RCC_CRS_IT_ESYNC  Expected SYNC interrupt
N  * @retval None
N  */
N#define __HAL_RCC_CRS_DISABLE_IT(__INTERRUPT__)  CLEAR_BIT(CRS->CR, (__INTERRUPT__))
N
N/** @brief  Check whether the CRS interrupt has occurred or not.
N  * @param  __INTERRUPT__ specifies the CRS interrupt source to check.
N  *         This parameter can be one of the following values:
N  *              @arg @ref RCC_CRS_IT_SYNCOK  SYNC event OK interrupt
N  *              @arg @ref RCC_CRS_IT_SYNCWARN  SYNC warning interrupt
N  *              @arg @ref RCC_CRS_IT_ERR  Synchronization or trimming error interrupt
N  *              @arg @ref RCC_CRS_IT_ESYNC  Expected SYNC interrupt
N  * @retval The new state of __INTERRUPT__ (SET or RESET).
N  */
N#define __HAL_RCC_CRS_GET_IT_SOURCE(__INTERRUPT__)  ((READ_BIT(CRS->CR, (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/** @brief  Clear the CRS interrupt pending bits
N  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
N  *         This parameter can be any combination of the following values:
N  *              @arg @ref RCC_CRS_IT_SYNCOK  SYNC event OK interrupt
N  *              @arg @ref RCC_CRS_IT_SYNCWARN  SYNC warning interrupt
N  *              @arg @ref RCC_CRS_IT_ERR  Synchronization or trimming error interrupt
N  *              @arg @ref RCC_CRS_IT_ESYNC  Expected SYNC interrupt
N  *              @arg @ref RCC_CRS_IT_TRIMOVF  Trimming overflow or underflow interrupt
N  *              @arg @ref RCC_CRS_IT_SYNCERR  SYNC error interrupt
N  *              @arg @ref RCC_CRS_IT_SYNCMISS  SYNC missed interrupt
N  */
N#define __HAL_RCC_CRS_CLEAR_IT(__INTERRUPT__)  do { \
N                                                 if(((__INTERRUPT__) & RCC_CRS_IT_ERROR_MASK) != RESET) \
N                                                 { \
N                                                   WRITE_REG(CRS->ICR, CRS_ICR_ERRC | ((__INTERRUPT__) & ~RCC_CRS_IT_ERROR_MASK)); \
N                                                 } \
N                                                 else \
N                                                 { \
N                                                   WRITE_REG(CRS->ICR, (__INTERRUPT__)); \
N                                                 } \
N                                               } while(0U)
X#define __HAL_RCC_CRS_CLEAR_IT(__INTERRUPT__)  do {                                                  if(((__INTERRUPT__) & RCC_CRS_IT_ERROR_MASK) != RESET)                                                  {                                                    WRITE_REG(CRS->ICR, CRS_ICR_ERRC | ((__INTERRUPT__) & ~RCC_CRS_IT_ERROR_MASK));                                                  }                                                  else                                                  {                                                    WRITE_REG(CRS->ICR, (__INTERRUPT__));                                                  }                                                } while(0U)
N
N/**
N  * @brief  Check whether the specified CRS flag is set or not.
N  * @param  __FLAG__ specifies the flag to check.
N  *          This parameter can be one of the following values:
N  *              @arg @ref RCC_CRS_FLAG_SYNCOK  SYNC event OK
N  *              @arg @ref RCC_CRS_FLAG_SYNCWARN  SYNC warning
N  *              @arg @ref RCC_CRS_FLAG_ERR  Error
N  *              @arg @ref RCC_CRS_FLAG_ESYNC  Expected SYNC
N  *              @arg @ref RCC_CRS_FLAG_TRIMOVF  Trimming overflow or underflow
N  *              @arg @ref RCC_CRS_FLAG_SYNCERR  SYNC error
N  *              @arg @ref RCC_CRS_FLAG_SYNCMISS  SYNC missed
N  * @retval The new state of _FLAG_ (TRUE or FALSE).
N  */
N#define __HAL_RCC_CRS_GET_FLAG(__FLAG__)  (READ_BIT(CRS->ISR, (__FLAG__)) == (__FLAG__))
N
N/**
N  * @brief  Clear the CRS specified FLAG.
N  * @param __FLAG__ specifies the flag to clear.
N  *          This parameter can be one of the following values:
N  *              @arg @ref RCC_CRS_FLAG_SYNCOK  SYNC event OK
N  *              @arg @ref RCC_CRS_FLAG_SYNCWARN  SYNC warning
N  *              @arg @ref RCC_CRS_FLAG_ERR  Error
N  *              @arg @ref RCC_CRS_FLAG_ESYNC  Expected SYNC
N  *              @arg @ref RCC_CRS_FLAG_TRIMOVF  Trimming overflow or underflow
N  *              @arg @ref RCC_CRS_FLAG_SYNCERR  SYNC error
N  *              @arg @ref RCC_CRS_FLAG_SYNCMISS  SYNC missed
N  * @note RCC_CRS_FLAG_ERR clears RCC_CRS_FLAG_TRIMOVF, RCC_CRS_FLAG_SYNCERR, RCC_CRS_FLAG_SYNCMISS and consequently RCC_CRS_FLAG_ERR
N  * @retval None
N  */
N#define __HAL_RCC_CRS_CLEAR_FLAG(__FLAG__)     do { \
N                                                 if(((__FLAG__) & RCC_CRS_FLAG_ERROR_MASK) != RESET) \
N                                                 { \
N                                                   WRITE_REG(CRS->ICR, CRS_ICR_ERRC | ((__FLAG__) & ~RCC_CRS_FLAG_ERROR_MASK)); \
N                                                 } \
N                                                 else \
N                                                 { \
N                                                   WRITE_REG(CRS->ICR, (__FLAG__)); \
N                                                 } \
N                                               } while(0U)
X#define __HAL_RCC_CRS_CLEAR_FLAG(__FLAG__)     do {                                                  if(((__FLAG__) & RCC_CRS_FLAG_ERROR_MASK) != RESET)                                                  {                                                    WRITE_REG(CRS->ICR, CRS_ICR_ERRC | ((__FLAG__) & ~RCC_CRS_FLAG_ERROR_MASK));                                                  }                                                  else                                                  {                                                    WRITE_REG(CRS->ICR, (__FLAG__));                                                  }                                                } while(0U)
N
N/**
N  * @}
N  */
N
N/** @defgroup RCCEx_CRS_Extended_Features RCCEx CRS Extended Features
N  * @{
N  */  
N/**
N  * @brief  Enable the oscillator clock for frequency error counter.
N  * @note   when the CEN bit is set the CRS_CFGR register becomes write-protected.
N  * @retval None
N  */
N#define __HAL_RCC_CRS_FREQ_ERROR_COUNTER_ENABLE()  SET_BIT(CRS->CR, CRS_CR_CEN)
N
N/**
N  * @brief  Disable the oscillator clock for frequency error counter.
N  * @retval None
N  */
N#define __HAL_RCC_CRS_FREQ_ERROR_COUNTER_DISABLE() CLEAR_BIT(CRS->CR, CRS_CR_CEN)
N
N/**
N  * @brief  Enable the automatic hardware adjustement of TRIM bits.
N  * @note   When the AUTOTRIMEN bit is set the CRS_CFGR register becomes write-protected.
N  * @retval None
N  */
N#define __HAL_RCC_CRS_AUTOMATIC_CALIB_ENABLE()     SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN)
N
N/**
N  * @brief  Disable the automatic hardware adjustement of TRIM bits.
N  * @retval None
N  */
N#define __HAL_RCC_CRS_AUTOMATIC_CALIB_DISABLE()    CLEAR_BIT(CRS->CR, CRS_CR_AUTOTRIMEN)
N
N/**
N  * @brief  Macro to calculate reload value to be set in CRS register according to target and sync frequencies
N  * @note   The RELOAD value should be selected according to the ratio between the target frequency and the frequency 
N  *             of the synchronization source after prescaling. It is then decreased by one in order to 
N  *             reach the expected synchronization on the zero value. The formula is the following:
N  *             RELOAD = (fTARGET / fSYNC) -1
N  * @param  __FTARGET__ Target frequency (value in Hz)
N  * @param  __FSYNC__   Synchronization signal frequency (value in Hz)
N  * @retval None
N  */
N#define __HAL_RCC_CRS_RELOADVALUE_CALCULATE(__FTARGET__, __FSYNC__)  (((__FTARGET__) / (__FSYNC__)) - 1U)
N
N/**
N  * @}
N  */
N
N#endif /* CRS */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup RCCEx_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup RCCEx_Exported_Functions_Group1
N  * @{
N  */
N  
NHAL_StatusTypeDef     HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
Nvoid                  HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit);
Nuint32_t              HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk);
N
N/**
N  * @}
N  */
N
N#if defined(CRS)
X#if 1L
N
N/** @addtogroup RCCEx_Exported_Functions_Group3
N  * @{
N  */
N
Nvoid              HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit);
Nvoid              HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void);
Nvoid              HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo);
Nuint32_t          HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout);
Nvoid              HAL_RCCEx_CRS_IRQHandler(void);
Nvoid              HAL_RCCEx_CRS_SyncOkCallback(void);
Nvoid              HAL_RCCEx_CRS_SyncWarnCallback(void);
Nvoid              HAL_RCCEx_CRS_ExpectedSyncCallback(void);
Nvoid              HAL_RCCEx_CRS_ErrorCallback(uint32_t Error);
N
N/**
N  * @}
N  */
N
N#endif /* CRS */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */  
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_RCC_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 1642 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rcc.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup RCC_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup RCC_Exported_Functions_Group1
N  * @{
N  */
N
N/* Initialization and de-initialization functions  ******************************/
Nvoid              HAL_RCC_DeInit(void);
NHAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct);
NHAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency);
N
N/**
N  * @}
N  */
N
N/** @addtogroup RCC_Exported_Functions_Group2
N  * @{
N  */
N
N/* Peripheral Control functions  ************************************************/
Nvoid              HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv);
Nvoid              HAL_RCC_EnableCSS(void);
N/* CSS NMI IRQ handler */
Nvoid              HAL_RCC_NMI_IRQHandler(void);
N/* User Callbacks in non blocking mode (IT mode) */
Nvoid              HAL_RCC_CSSCallback(void);
Nvoid              HAL_RCC_DisableCSS(void);
Nuint32_t          HAL_RCC_GetSysClockFreq(void);
Nuint32_t          HAL_RCC_GetHCLKFreq(void);
Nuint32_t          HAL_RCC_GetPCLK1Freq(void);
Nvoid              HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct);
Nvoid              HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_RCC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 194 "../Inc/stm32f0xx_hal_conf.h" 2
N#endif /* HAL_RCC_MODULE_ENABLED */
N
N#ifdef HAL_EXTI_MODULE_ENABLED
S #include "stm32f0xx_hal_exti.h"
N#endif /* HAL_EXTI_MODULE_ENABLED */
N
N#ifdef HAL_GPIO_MODULE_ENABLED
N #include "stm32f0xx_hal_gpio.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_gpio.h
N  * @author  MCD Application Team
N  * @brief   Header file of GPIO HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_GPIO_H
N#define __STM32F0xx_HAL_GPIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup GPIO
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N
N/** @defgroup GPIO_Exported_Types GPIO Exported Types
N  * @{
N  */
N/** 
N  * @brief   GPIO Init structure definition  
N  */
Ntypedef struct
N{
N  uint32_t Pin;       /*!< Specifies the GPIO pins to be configured.
N                           This parameter can be any value of @ref GPIO_pins */
N
N  uint32_t Mode;      /*!< Specifies the operating mode for the selected pins.
N                           This parameter can be a value of @ref GPIO_mode */
N
N  uint32_t Pull;      /*!< Specifies the Pull-up or Pull-Down activation for the selected pins.
N                           This parameter can be a value of @ref GPIO_pull */
N
N  uint32_t Speed;     /*!< Specifies the speed for the selected pins.
N                           This parameter can be a value of @ref GPIO_speed */
N
N  uint32_t Alternate;  /*!< Peripheral to be connected to the selected pins 
N                            This parameter can be a value of @ref GPIOEx_Alternate_function_selection */
N}GPIO_InitTypeDef;
N
N/** 
N  * @brief  GPIO Bit SET and Bit RESET enumeration 
N  */
Ntypedef enum
N{
N  GPIO_PIN_RESET = 0U,
N  GPIO_PIN_SET
N}GPIO_PinState;
N/**
N  * @}
N  */
N  
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup GPIO_Exported_Constants GPIO Exported Constants
N  * @{
N  */
N/** @defgroup GPIO_pins GPIO pins
N  * @{
N  */
N#define GPIO_PIN_0                 ((uint16_t)0x0001U)  /* Pin 0 selected    */
N#define GPIO_PIN_1                 ((uint16_t)0x0002U)  /* Pin 1 selected    */
N#define GPIO_PIN_2                 ((uint16_t)0x0004U)  /* Pin 2 selected    */
N#define GPIO_PIN_3                 ((uint16_t)0x0008U)  /* Pin 3 selected    */
N#define GPIO_PIN_4                 ((uint16_t)0x0010U)  /* Pin 4 selected    */
N#define GPIO_PIN_5                 ((uint16_t)0x0020U)  /* Pin 5 selected    */
N#define GPIO_PIN_6                 ((uint16_t)0x0040U)  /* Pin 6 selected    */
N#define GPIO_PIN_7                 ((uint16_t)0x0080U)  /* Pin 7 selected    */
N#define GPIO_PIN_8                 ((uint16_t)0x0100U)  /* Pin 8 selected    */
N#define GPIO_PIN_9                 ((uint16_t)0x0200U)  /* Pin 9 selected    */
N#define GPIO_PIN_10                ((uint16_t)0x0400U)  /* Pin 10 selected   */
N#define GPIO_PIN_11                ((uint16_t)0x0800U)  /* Pin 11 selected   */
N#define GPIO_PIN_12                ((uint16_t)0x1000U)  /* Pin 12 selected   */
N#define GPIO_PIN_13                ((uint16_t)0x2000U)  /* Pin 13 selected   */
N#define GPIO_PIN_14                ((uint16_t)0x4000U)  /* Pin 14 selected   */
N#define GPIO_PIN_15                ((uint16_t)0x8000U)  /* Pin 15 selected   */
N#define GPIO_PIN_All               ((uint16_t)0xFFFFU)  /* All pins selected */
N
N#define GPIO_PIN_MASK              (0x0000FFFFU) /* PIN mask for assert test */
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_mode GPIO mode
N  * @brief GPIO Configuration Mode 
N  *        Elements values convention: 0xX0yz00YZ
N  *           - X  : GPIO mode or EXTI Mode
N  *           - y  : External IT or Event trigger detection 
N  *           - z  : IO configuration on External IT or Event
N  *           - Y  : Output type (Push Pull or Open Drain)
N  *           - Z  : IO Direction mode (Input, Output, Alternate or Analog)
N  * @{
N  */ 
N#define  GPIO_MODE_INPUT                        (0x00000000U)   /*!< Input Floating Mode                   */
N#define  GPIO_MODE_OUTPUT_PP                    (0x00000001U)   /*!< Output Push Pull Mode                 */
N#define  GPIO_MODE_OUTPUT_OD                    (0x00000011U)   /*!< Output Open Drain Mode                */
N#define  GPIO_MODE_AF_PP                        (0x00000002U)   /*!< Alternate Function Push Pull Mode     */
N#define  GPIO_MODE_AF_OD                        (0x00000012U)   /*!< Alternate Function Open Drain Mode    */
N#define  GPIO_MODE_ANALOG                       (0x00000003U)   /*!< Analog Mode  */  
N#define  GPIO_MODE_IT_RISING                    (0x10110000U)   /*!< External Interrupt Mode with Rising edge trigger detection          */
N#define  GPIO_MODE_IT_FALLING                   (0x10210000U)   /*!< External Interrupt Mode with Falling edge trigger detection         */
N#define  GPIO_MODE_IT_RISING_FALLING            (0x10310000U)   /*!< External Interrupt Mode with Rising/Falling edge trigger detection  */
N#define  GPIO_MODE_EVT_RISING                   (0x10120000U)   /*!< External Event Mode with Rising edge trigger detection               */
N#define  GPIO_MODE_EVT_FALLING                  (0x10220000U)   /*!< External Event Mode with Falling edge trigger detection              */
N#define  GPIO_MODE_EVT_RISING_FALLING           (0x10320000U)   /*!< External Event Mode with Rising/Falling edge trigger detection       */
N/**
N  * @}
N  */
N                                                         
N/** @defgroup GPIO_speed GPIO speed
N  * @brief GPIO Output Maximum frequency
N  * @{
N  */  
N#define  GPIO_SPEED_FREQ_LOW      (0x00000000U)  /*!< range up to 2 MHz, please refer to the product datasheet */
N#define  GPIO_SPEED_FREQ_MEDIUM   (0x00000001U)  /*!< range  4 MHz to 10 MHz, please refer to the product datasheet */
N#define  GPIO_SPEED_FREQ_HIGH     (0x00000003U)  /*!< range 10 MHz to 50 MHz, please refer to the product datasheet */
N/**
N  * @}
N  */
N
N /** @defgroup GPIO_pull GPIO pull
N   * @brief GPIO Pull-Up or Pull-Down Activation
N   * @{
N   */  
N#define  GPIO_NOPULL        (0x00000000U)   /*!< No Pull-up or Pull-down activation  */
N#define  GPIO_PULLUP        (0x00000001U)   /*!< Pull-up activation                  */
N#define  GPIO_PULLDOWN      (0x00000002U)   /*!< Pull-down activation                */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup GPIO_Exported_Macros GPIO Exported Macros
N  * @{
N  */
N  
N/**
N  * @brief  Check whether the specified EXTI line flag is set or not.
N  * @param  __EXTI_LINE__ specifies the EXTI line flag to check.
N  *         This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval The new state of __EXTI_LINE__ (SET or RESET).
N  */
N#define __HAL_GPIO_EXTI_GET_FLAG(__EXTI_LINE__) (EXTI->PR & (__EXTI_LINE__))
N
N/**
N  * @brief  Clear the EXTI's line pending flags.
N  * @param  __EXTI_LINE__ specifies the EXTI lines flags to clear.
N  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_CLEAR_FLAG(__EXTI_LINE__) (EXTI->PR = (__EXTI_LINE__))
N
N/**
N  * @brief  Check whether the specified EXTI line is asserted or not.
N  * @param  __EXTI_LINE__ specifies the EXTI line to check.
N  *          This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval The new state of __EXTI_LINE__ (SET or RESET).
N  */
N#define __HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__) (EXTI->PR & (__EXTI_LINE__))
N
N/**
N  * @brief  Clear the EXTI's line pending bits.
N  * @param  __EXTI_LINE__ specifies the EXTI lines to clear.
N  *          This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__) (EXTI->PR = (__EXTI_LINE__))
N
N/**
N  * @brief  Generate a Software interrupt on selected EXTI line.
N  * @param  __EXTI_LINE__ specifies the EXTI line to check.
N  *          This parameter can be GPIO_PIN_x where x can be(0..15)
N  * @retval None
N  */
N#define __HAL_GPIO_EXTI_GENERATE_SWIT(__EXTI_LINE__) (EXTI->SWIER |= (__EXTI_LINE__))
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @addtogroup GPIO_Private_Macros GPIO Private Macros
N  * @{
N  */
N#define IS_GPIO_PIN_ACTION(ACTION)  (((ACTION) == GPIO_PIN_RESET) || ((ACTION) == GPIO_PIN_SET))
N
N#define IS_GPIO_PIN(__PIN__)        ((((__PIN__) & GPIO_PIN_MASK) != 0x00U) &&\
N                                     (((__PIN__) & ~GPIO_PIN_MASK) == 0x00U))
X#define IS_GPIO_PIN(__PIN__)        ((((__PIN__) & GPIO_PIN_MASK) != 0x00U) &&                                     (((__PIN__) & ~GPIO_PIN_MASK) == 0x00U))
N
N#define IS_GPIO_MODE(__MODE__)      (((__MODE__) == GPIO_MODE_INPUT)              ||\
N                                     ((__MODE__) == GPIO_MODE_OUTPUT_PP)          ||\
N                                     ((__MODE__) == GPIO_MODE_OUTPUT_OD)          ||\
N                                     ((__MODE__) == GPIO_MODE_AF_PP)              ||\
N                                     ((__MODE__) == GPIO_MODE_AF_OD)              ||\
N                                     ((__MODE__) == GPIO_MODE_IT_RISING)          ||\
N                                     ((__MODE__) == GPIO_MODE_IT_FALLING)         ||\
N                                     ((__MODE__) == GPIO_MODE_IT_RISING_FALLING)  ||\
N                                     ((__MODE__) == GPIO_MODE_EVT_RISING)         ||\
N                                     ((__MODE__) == GPIO_MODE_EVT_FALLING)        ||\
N                                     ((__MODE__) == GPIO_MODE_EVT_RISING_FALLING) ||\
N                                     ((__MODE__) == GPIO_MODE_ANALOG))
X#define IS_GPIO_MODE(__MODE__)      (((__MODE__) == GPIO_MODE_INPUT)              ||                                     ((__MODE__) == GPIO_MODE_OUTPUT_PP)          ||                                     ((__MODE__) == GPIO_MODE_OUTPUT_OD)          ||                                     ((__MODE__) == GPIO_MODE_AF_PP)              ||                                     ((__MODE__) == GPIO_MODE_AF_OD)              ||                                     ((__MODE__) == GPIO_MODE_IT_RISING)          ||                                     ((__MODE__) == GPIO_MODE_IT_FALLING)         ||                                     ((__MODE__) == GPIO_MODE_IT_RISING_FALLING)  ||                                     ((__MODE__) == GPIO_MODE_EVT_RISING)         ||                                     ((__MODE__) == GPIO_MODE_EVT_FALLING)        ||                                     ((__MODE__) == GPIO_MODE_EVT_RISING_FALLING) ||                                     ((__MODE__) == GPIO_MODE_ANALOG))
N
N#define IS_GPIO_SPEED(__SPEED__)    (((__SPEED__) == GPIO_SPEED_FREQ_LOW)    ||\
N                                     ((__SPEED__) == GPIO_SPEED_FREQ_MEDIUM) ||\
N                                     ((__SPEED__) == GPIO_SPEED_FREQ_HIGH))
X#define IS_GPIO_SPEED(__SPEED__)    (((__SPEED__) == GPIO_SPEED_FREQ_LOW)    ||                                     ((__SPEED__) == GPIO_SPEED_FREQ_MEDIUM) ||                                     ((__SPEED__) == GPIO_SPEED_FREQ_HIGH))
N
N#define IS_GPIO_PULL(__PULL__)      (((__PULL__) == GPIO_NOPULL)   ||\
N                                     ((__PULL__) == GPIO_PULLUP)   || \
N                                     ((__PULL__) == GPIO_PULLDOWN))
X#define IS_GPIO_PULL(__PULL__)      (((__PULL__) == GPIO_NOPULL)   ||                                     ((__PULL__) == GPIO_PULLUP)   ||                                      ((__PULL__) == GPIO_PULLDOWN))
N/**
N  * @}
N  */
N
N/* Include GPIO HAL Extended module */
N#include "stm32f0xx_hal_gpio_ex.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_gpio_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_gpio_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of GPIO HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_GPIO_EX_H
N#define __STM32F0xx_HAL_GPIO_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup GPIOEx GPIOEx
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup GPIOEx_Exported_Constants GPIOEx Exported Constants
N  * @{
N  */ 
N  
N/** @defgroup GPIOEx_Alternate_function_selection GPIOEx Alternate function selection
N  * @{
N  */
N  
N#if defined (STM32F030x6)
X#if 0L
S/*------------------------- STM32F030x6---------------------------*/ 
S/* AF 0 */
S#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
S#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1 Alternate Function mapping      */
S#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
S#define GPIO_AF0_SWDIO        ((uint8_t)0x00U)  /*!< AF0: SWDIO Alternate Function mapping     */
S#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
S#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
S#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
S#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
S#define GPIO_AF0_TIM3         ((uint8_t)0x00U)  /*!< AF0: TIM3 Alternate Function mapping      */
S
S/* AF 1 */
S#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
S#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
S#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
S
S/* AF 2 */
S#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
S#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
S#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
S#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
S
S/* AF 3 */
S#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
S
S/* AF 4 */
S#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
S#define GPIO_AF4_I2C1         ((uint8_t)0x04U)  /*!< AF4: I2C1 Alternate Function mapping      */
S
S/* AF 5 */
S#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
S#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
S
S/* AF 6 */
S#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
S
S#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x06U)
S
N#endif /* STM32F030x6 */
N
N/*---------------------------------- STM32F030x8 -------------------------------------------*/
N#if defined (STM32F030x8)
X#if 0L
S/* AF 0 */
S#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
S#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1 Alternate Function mapping      */
S#define GPIO_AF0_SPI2         ((uint8_t)0x00U)  /*!< AF0: SPI2 Alternate Function mapping      */
S#define GPIO_AF0_TIM15        ((uint8_t)0x00U)  /*!< AF0: TIM15 Alternate Function mapping     */
S#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
S#define GPIO_AF0_SWDIO        ((uint8_t)0x00U)  /*!< AF0: SWDIO Alternate Function mapping     */
S#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
S#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
S#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
S#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
S#define GPIO_AF0_TIM3         ((uint8_t)0x00U)  /*!< AF0: TIM3 Alternate Function mapping      */
S
S/* AF 1 */
S#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
S#define GPIO_AF1_TIM15        ((uint8_t)0x01U)  /*!< AF1: TIM15 Alternate Function mapping     */
S#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
S#define GPIO_AF1_USART2       ((uint8_t)0x01U)  /*!< AF1: USART2 Alternate Function mapping    */
S#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_I2C2         ((uint8_t)0x01U)  /*!< AF1: I2C2 Alternate Function mapping      */
S#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
S
S/* AF 2 */
S#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
S#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
S#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
S#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
S
S/* AF 3 */
S#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
S#define GPIO_AF3_TIM15        ((uint8_t)0x03U)  /*!< AF3: TIM15 Alternate Function mapping     */
S
S/* AF 4 */
S#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
S
S/* AF 5 */
S#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
S#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
S
S/* AF 6 */
S#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
S
S#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x06U)
S
N#endif /* STM32F030x8 */
N
N#if defined (STM32F031x6) || defined (STM32F038xx)
X#if 0L || 0L
S/*--------------------------- STM32F031x6/STM32F038xx ---------------------------*/
S/* AF 0 */
S#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
S#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1/I2S1 Alternate Function mapping */
S#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
S#define GPIO_AF0_SWDAT        ((uint8_t)0x00U)  /*!< AF0: SWDAT Alternate Function mapping     */
S#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
S#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
S#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
S#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
S
S/* AF 1 */
S#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
S#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
S#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
S#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S
S/* AF 2 */
S#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
S#define GPIO_AF2_TIM2         ((uint8_t)0x02U)  /*!< AF2: TIM2 Alternate Function mapping      */
S#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
S#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
S#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
S
S/* AF 3 */
S#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
S
S/* AF 4 */
S#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
S#define GPIO_AF4_I2C1         ((uint8_t)0x04U)  /*!< AF4: I2C1 Alternate Function mapping      */
S
S/* AF 5 */
S#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
S#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
S
S/* AF 6 */
S#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
S
S#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x06U)
S
N#endif /* STM32F031x6 || STM32F038xx */
N
N#if defined (STM32F051x8) || defined (STM32F058xx)
X#if 0L || 0L
S/*--------------------------- STM32F051x8/STM32F058xx---------------------------*/
S/* AF 0 */
S#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
S#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1/I2S1 Alternate Function mapping */
S#define GPIO_AF0_SPI2         ((uint8_t)0x00U)  /*!< AF0: SPI2 Alternate Function mapping      */
S#define GPIO_AF0_TIM15        ((uint8_t)0x00U)  /*!< AF0: TIM15 Alternate Function mapping     */
S#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
S#define GPIO_AF0_SWDIO        ((uint8_t)0x00U)  /*!< AF0: SWDIO Alternate Function mapping     */
S#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
S#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
S#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
S#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
S#define GPIO_AF0_CEC          ((uint8_t)0x00U)  /*!< AF0: CEC Alternate Function mapping       */
S
S/* AF 1 */
S#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
S#define GPIO_AF1_TIM15        ((uint8_t)0x01U)  /*!< AF1: TIM15 Alternate Function mapping     */
S#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
S#define GPIO_AF1_USART2       ((uint8_t)0x01U)  /*!< AF1: USART2 Alternate Function mapping    */
S#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_I2C2         ((uint8_t)0x01U)  /*!< AF1: I2C2 Alternate Function mapping      */
S#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
S#define GPIO_AF1_CEC          ((uint8_t)0x01U)  /*!< AF1: CEC Alternate Function mapping       */
S
S/* AF 2 */
S#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
S#define GPIO_AF2_TIM2         ((uint8_t)0x02U)  /*!< AF2: TIM2 Alternate Function mapping      */
S#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
S#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
S#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
S
S/* AF 3 */
S#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
S#define GPIO_AF3_TIM15        ((uint8_t)0x03U)  /*!< AF3: TIM15 Alternate Function mapping     */
S#define GPIO_AF3_TSC          ((uint8_t)0x03U)  /*!< AF3: TSC Alternate Function mapping       */
S
S/* AF 4 */
S#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
S
S/* AF 5 */
S#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
S#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
S
S/* AF 6 */
S#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
S
S/* AF 7 */
S#define GPIO_AF7_COMP1        ((uint8_t)0x07U)  /*!< AF7: COMP1 Alternate Function mapping     */
S#define GPIO_AF7_COMP2        ((uint8_t)0x07U)  /*!< AF7: COMP2 Alternate Function mapping     */
S
S#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x07U)
S
N#endif /* STM32F051x8/STM32F058xx */
N
N#if defined (STM32F071xB)
X#if 0L
S/*--------------------------- STM32F071xB ---------------------------*/
S/* AF 0 */ 
S#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: AEVENTOUT Alternate Function mapping */
S#define GPIO_AF0_SWDIO        ((uint8_t)0x00U)  /*!< AF0: SWDIO Alternate Function mapping     */
S#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
S#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
S#define GPIO_AF0_CEC          ((uint8_t)0x00U)  /*!< AF0: CEC Alternate Function mapping       */
S#define GPIO_AF0_CRS          ((uint8_t)0x00U)  /*!< AF0: CRS Alternate Function mapping       */
S#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
S#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1/I2S1 Alternate Function mapping */
S#define GPIO_AF0_SPI2         ((uint8_t)0x00U)  /*!< AF0: SPI2/I2S2 Alternate Function mapping */
S#define GPIO_AF0_TIM1         ((uint8_t)0x00U)  /*!< AF0: TIM1 Alternate Function mapping      */
S#define GPIO_AF0_TIM3         ((uint8_t)0x00U)  /*!< AF0: TIM3 Alternate Function mapping      */
S#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
S#define GPIO_AF0_TIM15        ((uint8_t)0x00U)  /*!< AF0: TIM15 Alternate Function mapping     */
S#define GPIO_AF0_TIM16        ((uint8_t)0x00U)  /*!< AF0: TIM16 Alternate Function mapping     */
S#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
S#define GPIO_AF0_TSC          ((uint8_t)0x00U)  /*!< AF0: TSC Alternate Function mapping       */
S#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
S#define GPIO_AF0_USART2       ((uint8_t)0x00U)  /*!< AF0: USART2 Alternate Function mapping    */
S#define GPIO_AF0_USART3       ((uint8_t)0x00U)  /*!< AF0: USART3 Alternate Function mapping    */
S#define GPIO_AF0_USART4       ((uint8_t)0x00U)  /*!< AF0: USART4 Alternate Function mapping    */
S
S/* AF 1 */
S#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
S#define GPIO_AF1_TIM15        ((uint8_t)0x01U)  /*!< AF1: TIM15 Alternate Function mapping     */
S#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
S#define GPIO_AF1_USART2       ((uint8_t)0x01U)  /*!< AF1: USART2 Alternate Function mapping    */
S#define GPIO_AF1_USART3       ((uint8_t)0x01U)  /*!< AF1: USART3 Alternate Function mapping    */
S#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
S#define GPIO_AF1_CEC          ((uint8_t)0x01U)  /*!< AF1: CEC Alternate Function mapping       */
S#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_I2C2         ((uint8_t)0x01U)  /*!< AF1: I2C2 Alternate Function mapping      */
S#define GPIO_AF1_TSC          ((uint8_t)0x01U)  /*!< AF1: TSC Alternate Function mapping       */
S#define GPIO_AF1_SPI1         ((uint8_t)0x01U)  /*!< AF1: SPI1 Alternate Function mapping      */
S#define GPIO_AF1_SPI2         ((uint8_t)0x01U)  /*!< AF1: SPI2 Alternate Function mapping      */
S
S/* AF 2 */
S#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
S#define GPIO_AF2_TIM2         ((uint8_t)0x02U)  /*!< AF2: TIM2 Alternate Function mapping      */
S#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
S#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
S#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
S
S/* AF 3 */
S#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF3_TSC          ((uint8_t)0x03U)  /*!< AF3: TSC Alternate Function mapping       */
S#define GPIO_AF3_TIM15        ((uint8_t)0x03U)  /*!< AF3: TIM15 Alternate Function mapping     */
S#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
S
S/* AF 4 */
S#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
S#define GPIO_AF4_USART4       ((uint8_t)0x04U)  /*!< AF4: USART4 Alternate Function mapping    */
S#define GPIO_AF4_USART3       ((uint8_t)0x04U)  /*!< AF4: USART3 Alternate Function mapping    */
S#define GPIO_AF4_CRS          ((uint8_t)0x04U)  /*!< AF4: CRS Alternate Function mapping       */
S
S/* AF 5 */
S#define GPIO_AF5_TIM15        ((uint8_t)0x05U)  /*!< AF5: TIM15 Alternate Function mapping     */
S#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
S#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
S#define GPIO_AF5_SPI2         ((uint8_t)0x05U)  /*!< AF5: SPI2 Alternate Function mapping      */
S#define GPIO_AF5_I2C2         ((uint8_t)0x05U)  /*!< AF5: I2C2 Alternate Function mapping      */
S
S/* AF 6 */
S#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
S
S/* AF 7 */
S#define GPIO_AF7_COMP1        ((uint8_t)0x07U)  /*!< AF7: COMP1 Alternate Function mapping     */
S#define GPIO_AF7_COMP2        ((uint8_t)0x07U)  /*!< AF7: COMP2 Alternate Function mapping     */
S
S#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x07U)
S
N#endif /* STM32F071xB */
N
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N/*--------------------------- STM32F091xC || STM32F098xx ------------------------------*/
N/* AF 0 */
N#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: EVENTOUT Alternate Function mapping  */
N#define GPIO_AF0_SWDIO        ((uint8_t)0x00U)  /*!< AF0: SWDIO Alternate Function mapping     */
N#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
N#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
N#define GPIO_AF0_CEC          ((uint8_t)0x00U)  /*!< AF0: CEC Alternate Function mapping       */
N#define GPIO_AF0_CRS          ((uint8_t)0x00U)  /*!< AF0: CRS Alternate Function mapping       */
N#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
N#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1/I2S1 Alternate Function mapping */
N#define GPIO_AF0_SPI2         ((uint8_t)0x00U)  /*!< AF0: SPI2/I2S2 Alternate Function mapping */
N#define GPIO_AF0_TIM1         ((uint8_t)0x00U)  /*!< AF0: TIM1 Alternate Function mapping      */
N#define GPIO_AF0_TIM3         ((uint8_t)0x00U)  /*!< AF0: TIM3 Alternate Function mapping      */
N#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
N#define GPIO_AF0_TIM15        ((uint8_t)0x00U)  /*!< AF0: TIM15 Alternate Function mapping     */
N#define GPIO_AF0_TIM16        ((uint8_t)0x00U)  /*!< AF0: TIM16 Alternate Function mapping     */
N#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
N#define GPIO_AF0_TSC          ((uint8_t)0x00U)  /*!< AF0: TSC Alternate Function mapping       */
N#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
N#define GPIO_AF0_USART2       ((uint8_t)0x00U)  /*!< AF0: USART2 Alternate Function mapping    */
N#define GPIO_AF0_USART3       ((uint8_t)0x00U)  /*!< AF0: USART3 Alternate Function mapping    */
N#define GPIO_AF0_USART4       ((uint8_t)0x00U)  /*!< AF0: USART4 Alternate Function mapping    */
N#define GPIO_AF0_USART8       ((uint8_t)0x00U)  /*!< AF0: USART8 Alternate Function mapping    */
N#define GPIO_AF0_CAN          ((uint8_t)0x00U)  /*!< AF0: CAN Alternate Function mapping       */
N
N/* AF 1 */
N#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
N#define GPIO_AF1_TIM15        ((uint8_t)0x01U)  /*!< AF1: TIM15 Alternate Function mapping     */
N#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
N#define GPIO_AF1_USART2       ((uint8_t)0x01U)  /*!< AF1: USART2 Alternate Function mapping    */
N#define GPIO_AF1_USART3       ((uint8_t)0x01U)  /*!< AF1: USART3 Alternate Function mapping    */
N#define GPIO_AF1_USART4       ((uint8_t)0x01U)  /*!< AF1: USART4 Alternate Function mapping    */
N#define GPIO_AF1_USART5       ((uint8_t)0x01U)  /*!< AF1: USART5 Alternate Function mapping    */
N#define GPIO_AF1_USART6       ((uint8_t)0x01U)  /*!< AF1: USART6 Alternate Function mapping    */
N#define GPIO_AF1_USART7       ((uint8_t)0x01U)  /*!< AF1: USART7 Alternate Function mapping    */
N#define GPIO_AF1_USART8       ((uint8_t)0x01U)  /*!< AF1: USART8 Alternate Function mapping    */
N#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
N#define GPIO_AF1_CEC          ((uint8_t)0x01U)  /*!< AF1: CEC Alternate Function mapping       */
N#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
N#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
N#define GPIO_AF1_I2C2         ((uint8_t)0x01U)  /*!< AF1: I2C2 Alternate Function mapping      */
N#define GPIO_AF1_TSC          ((uint8_t)0x01U)  /*!< AF1: TSC Alternate Function mapping       */
N#define GPIO_AF1_SPI1         ((uint8_t)0x01U)  /*!< AF1: SPI1 Alternate Function mapping      */
N#define GPIO_AF1_SPI2         ((uint8_t)0x01U)  /*!< AF1: SPI2 Alternate Function mapping      */
N
N/* AF 2 */
N#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
N#define GPIO_AF2_TIM2         ((uint8_t)0x02U)  /*!< AF2: TIM2 Alternate Function mapping      */
N#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
N#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
N#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
N#define GPIO_AF2_USART5       ((uint8_t)0x02U)  /*!< AF2: USART5 Alternate Function mapping    */
N#define GPIO_AF2_USART6       ((uint8_t)0x02U)  /*!< AF2: USART6 Alternate Function mapping    */
N#define GPIO_AF2_USART7       ((uint8_t)0x02U)  /*!< AF2: USART7 Alternate Function mapping    */
N#define GPIO_AF2_USART8       ((uint8_t)0x02U)  /*!< AF2: USART8 Alternate Function mapping    */
N
N/* AF 3 */
N#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
N#define GPIO_AF3_TSC          ((uint8_t)0x03U)  /*!< AF3: TSC Alternate Function mapping       */
N#define GPIO_AF3_TIM15        ((uint8_t)0x03U)  /*!< AF3: TIM15 Alternate Function mapping     */
N#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
N
N/* AF 4 */
N#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
N#define GPIO_AF4_USART4       ((uint8_t)0x04U)  /*!< AF4: USART4 Alternate Function mapping    */
N#define GPIO_AF4_USART3       ((uint8_t)0x04U)  /*!< AF4: USART3 Alternate Function mapping    */
N#define GPIO_AF4_CRS          ((uint8_t)0x04U)  /*!< AF4: CRS Alternate Function mapping       */
N#define GPIO_AF4_CAN          ((uint8_t)0x04U)  /*!< AF4: CAN Alternate Function mapping       */
N#define GPIO_AF4_I2C1         ((uint8_t)0x04U)  /*!< AF4: I2C1 Alternate Function mapping      */
N#define GPIO_AF4_USART5       ((uint8_t)0x04U)  /*!< AF4: USART5 Alternate Function mapping    */
N
N/* AF 5 */
N#define GPIO_AF5_TIM15        ((uint8_t)0x05U)  /*!< AF5: TIM15 Alternate Function mapping     */
N#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
N#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
N#define GPIO_AF5_SPI2         ((uint8_t)0x05U)  /*!< AF5: SPI2 Alternate Function mapping      */
N#define GPIO_AF5_I2C2         ((uint8_t)0x05U)  /*!< AF5: I2C2 Alternate Function mapping      */
N#define GPIO_AF5_MCO          ((uint8_t)0x05U)  /*!< AF5: MCO Alternate Function mapping       */
N#define GPIO_AF5_USART6       ((uint8_t)0x05U)  /*!< AF5: USART6 Alternate Function mapping    */
N
N/* AF 6 */
N#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
N
N/* AF 7 */
N#define GPIO_AF7_COMP1        ((uint8_t)0x07U)  /*!< AF7: COMP1 Alternate Function mapping     */
N#define GPIO_AF7_COMP2        ((uint8_t)0x07U)  /*!< AF7: COMP2 Alternate Function mapping     */
N
N#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x07U)
N
N#endif /* STM32F091xC  || STM32F098xx */
N
N#if defined(STM32F030xC)
X#if 0L
S/*--------------------------- STM32F030xC ----------------------------------------------------*/
S/* AF 0 */
S#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF0_SWDIO        ((uint8_t)0x00U)  /*!< AF0: SWDIO Alternate Function mapping     */
S#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
S#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
S#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
S#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1 Alternate Function mapping      */
S#define GPIO_AF0_SPI2         ((uint8_t)0x00U)  /*!< AF0: SPI2 Alternate Function mapping      */
S#define GPIO_AF0_TIM3         ((uint8_t)0x00U)  /*!< AF0: TIM3 Alternate Function mapping      */
S#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
S#define GPIO_AF0_TIM15        ((uint8_t)0x00U)  /*!< AF0: TIM15 Alternate Function mapping     */
S#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
S#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
S#define GPIO_AF0_USART4       ((uint8_t)0x00U)  /*!< AF0: USART4 Alternate Function mapping    */
S
S/* AF 1 */
S#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
S#define GPIO_AF1_TIM15        ((uint8_t)0x01U)  /*!< AF1: TIM15 Alternate Function mapping     */
S#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
S#define GPIO_AF1_USART2       ((uint8_t)0x01U)  /*!< AF1: USART2 Alternate Function mapping    */
S#define GPIO_AF1_USART3       ((uint8_t)0x01U)  /*!< AF1: USART3 Alternate Function mapping    */
S#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
S#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_I2C2         ((uint8_t)0x01U)  /*!< AF1: I2C2 Alternate Function mapping      */
S#define GPIO_AF1_SPI2         ((uint8_t)0x01U)  /*!< AF1: SPI2 Alternate Function mapping      */
S
S/* AF 2 */
S#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
S#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
S#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
S#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF2_USART5       ((uint8_t)0x02U)  /*!< AF2: USART5 Alternate Function mapping    */
S#define GPIO_AF2_USART6       ((uint8_t)0x02U)  /*!< AF2: USART6 Alternate Function mapping    */
S
S/* AF 3 */
S#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF3_TIM15        ((uint8_t)0x03U)  /*!< AF3: TIM15 Alternate Function mapping     */
S#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
S
S/* AF 4 */
S#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
S#define GPIO_AF4_USART4       ((uint8_t)0x04U)  /*!< AF4: USART4 Alternate Function mapping    */
S#define GPIO_AF4_USART3       ((uint8_t)0x04U)  /*!< AF4: USART3 Alternate Function mapping    */
S#define GPIO_AF4_I2C1         ((uint8_t)0x04U)  /*!< AF4: I2C1 Alternate Function mapping      */
S#define GPIO_AF4_USART5       ((uint8_t)0x04U)  /*!< AF4: USART5 Alternate Function mapping    */
S
S/* AF 5 */
S#define GPIO_AF5_TIM15        ((uint8_t)0x05U)  /*!< AF5: TIM15 Alternate Function mapping     */
S#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
S#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
S#define GPIO_AF5_SPI2         ((uint8_t)0x05U)  /*!< AF5: SPI2 Alternate Function mapping      */
S#define GPIO_AF5_I2C2         ((uint8_t)0x05U)  /*!< AF5: I2C2 Alternate Function mapping      */
S#define GPIO_AF5_MCO          ((uint8_t)0x05U)  /*!< AF5: MCO Alternate Function mapping       */
S#define GPIO_AF5_USART6       ((uint8_t)0x05U)  /*!< AF5: USART6 Alternate Function mapping    */
S
S/* AF 6 */
S#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
S
S#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x06U)
S
N#endif /* STM32F030xC */
N
N#if defined (STM32F072xB) || defined (STM32F078xx)
X#if 0L || 0L
S/*--------------------------- STM32F072xB/STM32F078xx ---------------------------*/
S/* AF 0 */
S#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF0_SWDIO        ((uint8_t)0x00U)  /*!< AF0: SWDIO Alternate Function mapping     */
S#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
S#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
S#define GPIO_AF0_CEC          ((uint8_t)0x00U)  /*!< AF0: CEC Alternate Function mapping       */
S#define GPIO_AF0_CRS          ((uint8_t)0x00U)  /*!< AF0: CRS Alternate Function mapping       */
S#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
S#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1/I2S1 Alternate Function mapping */
S#define GPIO_AF0_SPI2         ((uint8_t)0x00U)  /*!< AF0: SPI2/I2S2 Alternate Function mapping */
S#define GPIO_AF0_TIM1         ((uint8_t)0x00U)  /*!< AF0: TIM1 Alternate Function mapping      */
S#define GPIO_AF0_TIM3         ((uint8_t)0x00U)  /*!< AF0: TIM3 Alternate Function mapping      */
S#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
S#define GPIO_AF0_TIM15        ((uint8_t)0x00U)  /*!< AF0: TIM15 Alternate Function mapping     */
S#define GPIO_AF0_TIM16        ((uint8_t)0x00U)  /*!< AF0: TIM16 Alternate Function mapping     */
S#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
S#define GPIO_AF0_TSC          ((uint8_t)0x00U)  /*!< AF0: TSC Alternate Function mapping       */
S#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
S#define GPIO_AF0_USART2       ((uint8_t)0x00U)  /*!< AF0: USART2 Alternate Function mapping    */
S#define GPIO_AF0_USART3       ((uint8_t)0x00U)  /*!< AF0: USART2 Alternate Function mapping    */
S#define GPIO_AF0_USART4       ((uint8_t)0x00U)  /*!< AF0: USART4 Alternate Function mapping    */
S#define GPIO_AF0_CAN          ((uint8_t)0x00U)  /*!< AF0: CAN Alternate Function mapping       */
S
S/* AF 1 */
S#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
S#define GPIO_AF1_TIM15        ((uint8_t)0x01U)  /*!< AF1: TIM15 Alternate Function mapping     */
S#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
S#define GPIO_AF1_USART2       ((uint8_t)0x01U)  /*!< AF1: USART2 Alternate Function mapping    */
S#define GPIO_AF1_USART3       ((uint8_t)0x01U)  /*!< AF1: USART3 Alternate Function mapping    */
S#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
S#define GPIO_AF1_CEC          ((uint8_t)0x01U)  /*!< AF1: CEC Alternate Function mapping       */
S#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_I2C2         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_TSC          ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_SPI1         ((uint8_t)0x01U)  /*!< AF1: SPI1 Alternate Function mapping      */
S#define GPIO_AF1_SPI2         ((uint8_t)0x01U)  /*!< AF1: SPI2 Alternate Function mapping      */
S
S/* AF 2 */
S#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
S#define GPIO_AF2_TIM2         ((uint8_t)0x02U)  /*!< AF2: TIM2 Alternate Function mapping      */
S#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
S#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
S#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF2_USB          ((uint8_t)0x02U)  /*!< AF2: USB Alternate Function mapping       */
S
S/* AF 3 */
S#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF3_TSC          ((uint8_t)0x03U)  /*!< AF3: TSC Alternate Function mapping       */
S#define GPIO_AF3_TIM15        ((uint8_t)0x03U)  /*!< AF3: TIM15 Alternate Function mapping     */
S#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
S
S/* AF 4 */
S#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
S#define GPIO_AF4_USART4       ((uint8_t)0x04U)  /*!< AF4: USART4 Alternate Function mapping    */
S#define GPIO_AF4_USART3       ((uint8_t)0x04U)  /*!< AF4: USART3 Alternate Function mapping    */
S#define GPIO_AF4_CRS          ((uint8_t)0x04U)  /*!< AF4: CRS Alternate Function mapping       */
S#define GPIO_AF4_CAN          ((uint8_t)0x04U)  /*!< AF4: CAN Alternate Function mapping       */
S
S/* AF 5 */
S#define GPIO_AF5_TIM15        ((uint8_t)0x05U)  /*!< AF5: TIM15 Alternate Function mapping     */
S#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
S#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
S#define GPIO_AF5_SPI2         ((uint8_t)0x05U)  /*!< AF5: SPI2 Alternate Function mapping      */
S#define GPIO_AF5_I2C2         ((uint8_t)0x05U)  /*!< AF5: I2C2 Alternate Function mapping      */
S
S/* AF 6 */
S#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
S
S/* AF 7 */
S#define GPIO_AF7_COMP1        ((uint8_t)0x07U)  /*!< AF7: COMP1 Alternate Function mapping     */
S#define GPIO_AF7_COMP2        ((uint8_t)0x07U)  /*!< AF7: COMP2 Alternate Function mapping     */
S
S#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x07U)
S
N#endif /* STM32F072xB || STM32F078xx */
N
N#if defined (STM32F070xB)
X#if 0L
S/*---------------------------------- STM32F070xB ---------------------------------------------*/
S/* AF 0 */
S#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF0_SWDIO        ((uint8_t)0x00U)  /*!< AF0: SWDIO Alternate Function mapping     */
S#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
S#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
S#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
S#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1 Alternate Function mapping      */
S#define GPIO_AF0_SPI2         ((uint8_t)0x00U)  /*!< AF0: SPI2 Alternate Function mapping      */
S#define GPIO_AF0_TIM3         ((uint8_t)0x00U)  /*!< AF0: TIM3 Alternate Function mapping      */
S#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
S#define GPIO_AF0_TIM15        ((uint8_t)0x00U)  /*!< AF0: TIM15 Alternate Function mapping     */
S#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
S#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
S#define GPIO_AF0_USART4       ((uint8_t)0x00U)  /*!< AF0: USART4 Alternate Function mapping    */
S
S/* AF 1 */
S#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
S#define GPIO_AF1_TIM15        ((uint8_t)0x01U)  /*!< AF1: TIM15 Alternate Function mapping     */
S#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
S#define GPIO_AF1_USART2       ((uint8_t)0x01U)  /*!< AF1: USART2 Alternate Function mapping    */
S#define GPIO_AF1_USART3       ((uint8_t)0x01U)  /*!< AF1: USART4 Alternate Function mapping    */
S#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
S#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_I2C2         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_SPI2         ((uint8_t)0x01U)  /*!< AF1: SPI2 Alternate Function mapping      */
S
S/* AF 2 */
S#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
S#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
S#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
S#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF2_USB          ((uint8_t)0x02U)  /*!< AF2: USB Alternate Function mapping       */
S
S/* AF 3 */
S#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
S#define GPIO_AF3_TIM15        ((uint8_t)0x03U)  /*!< AF3: TIM15 Alternate Function mapping     */
S
S/* AF 4 */
S#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
S#define GPIO_AF4_USART4       ((uint8_t)0x04U)  /*!< AF4: USART4 Alternate Function mapping    */
S#define GPIO_AF4_USART3       ((uint8_t)0x04U)  /*!< AF4: USART3 Alternate Function mapping    */
S
S/* AF 5 */
S#define GPIO_AF5_TIM15        ((uint8_t)0x05U)  /*!< AF5: TIM15 Alternate Function mapping     */
S#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
S#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
S#define GPIO_AF5_SPI2         ((uint8_t)0x05U)  /*!< AF5: SPI2 Alternate Function mapping      */
S#define GPIO_AF5_I2C2         ((uint8_t)0x05U)  /*!< AF5: I2C2 Alternate Function mapping      */
S
S/* AF 6 */
S#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
S
S#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x06U)
S   
N#endif /* STM32F070xB */
N
N#if defined (STM32F042x6) || defined (STM32F048xx)
X#if 0L || 0L
S/*--------------------------- STM32F042x6/STM32F048xx ---------------------------*/
S/* AF 0 */
S#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF0_CEC          ((uint8_t)0x00U)  /*!< AF0: CEC Alternate Function mapping       */
S#define GPIO_AF0_CRS          ((uint8_t)0x00U)  /*!< AF0: CRS Alternate Function mapping       */
S#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
S#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
S#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1/I2S1 Alternate Function mapping */
S#define GPIO_AF0_SPI2         ((uint8_t)0x00U)  /*!< AF0: SPI2/I2S2 Alternate Function mapping */
S#define GPIO_AF0_SWDIO        ((uint8_t)0x00U)  /*!< AF0: SWDIO Alternate Function mapping     */
S#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
S#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
S#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
S#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
S
S/* AF 1 */
S#define GPIO_AF1_CEC          ((uint8_t)0x01U)  /*!< AF1: CEC Alternate Function mapping       */
S#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
S#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
S#define GPIO_AF1_USART2       ((uint8_t)0x01U)  /*!< AF1: USART2 Alternate Function mapping    */
S#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
S
S/* AF 2 */
S#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
S#define GPIO_AF2_TIM2         ((uint8_t)0x02U)  /*!< AF2: TIM2 Alternate Function mapping      */
S#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
S#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
S#define GPIO_AF2_USB          ((uint8_t)0x02U)  /*!< AF2: USB Alternate Function mapping       */
S
S/* AF 3 */
S#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
S#define GPIO_AF3_TSC          ((uint8_t)0x03U)  /*!< AF3: TSC Alternate Function mapping       */
S
S/* AF 4 */
S#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
S#define GPIO_AF4_CAN          ((uint8_t)0x04U)  /*!< AF4: CAN Alternate Function mapping       */
S#define GPIO_AF4_CRS          ((uint8_t)0x04U)  /*!< AF4: CRS Alternate Function mapping       */
S#define GPIO_AF4_I2C1         ((uint8_t)0x04U)  /*!< AF4: I2C1 Alternate Function mapping      */
S
S/* AF 5 */ 
S#define GPIO_AF5_MCO          ((uint8_t)0x05U)  /*!< AF5: MCO Alternate Function mapping       */
S#define GPIO_AF5_I2C1         ((uint8_t)0x05U)  /*!< AF5: I2C1 Alternate Function mapping      */
S#define GPIO_AF5_I2C2         ((uint8_t)0x05U)  /*!< AF5: I2C2 Alternate Function mapping      */
S#define GPIO_AF5_SPI2         ((uint8_t)0x05U)  /*!< AF5: SPI2 Alternate Function mapping      */
S#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
S#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
S#define GPIO_AF5_USB          ((uint8_t)0x05U)  /*!< AF5: USB Alternate Function mapping       */
S
S/* AF 6 */ 
S#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
S
S#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x06U)
S
N#endif /* STM32F042x6 || STM32F048xx */
N
N#if defined (STM32F070x6)
X#if 0L
S/*--------------------------------------- STM32F070x6 ----------------------------------------*/
S/* AF 0 */
S#define GPIO_AF0_EVENTOUT     ((uint8_t)0x00U)  /*!< AF0: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF0_IR           ((uint8_t)0x00U)  /*!< AF0: IR Alternate Function mapping        */
S#define GPIO_AF0_MCO          ((uint8_t)0x00U)  /*!< AF0: MCO Alternate Function mapping       */
S#define GPIO_AF0_SPI1         ((uint8_t)0x00U)  /*!< AF0: SPI1 Alternate Function mapping      */
S#define GPIO_AF0_SWDIO        ((uint8_t)0x00U)  /*!< AF0: SWDIO Alternate Function mapping     */
S#define GPIO_AF0_SWCLK        ((uint8_t)0x00U)  /*!< AF0: SWCLK Alternate Function mapping     */
S#define GPIO_AF0_TIM14        ((uint8_t)0x00U)  /*!< AF0: TIM14 Alternate Function mapping     */
S#define GPIO_AF0_TIM17        ((uint8_t)0x00U)  /*!< AF0: TIM17 Alternate Function mapping     */
S#define GPIO_AF0_USART1       ((uint8_t)0x00U)  /*!< AF0: USART1 Alternate Function mapping    */
S
S/* AF 1 */
S#define GPIO_AF1_EVENTOUT     ((uint8_t)0x01U)  /*!< AF1: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF1_I2C1         ((uint8_t)0x01U)  /*!< AF1: I2C1 Alternate Function mapping      */
S#define GPIO_AF1_IR           ((uint8_t)0x01U)  /*!< AF1: IR Alternate Function mapping        */
S#define GPIO_AF1_USART1       ((uint8_t)0x01U)  /*!< AF1: USART1 Alternate Function mapping    */
S#define GPIO_AF1_USART2       ((uint8_t)0x01U)  /*!< AF1: USART2 Alternate Function mapping    */
S#define GPIO_AF1_TIM3         ((uint8_t)0x01U)  /*!< AF1: TIM3 Alternate Function mapping      */
S
S/* AF 2 */
S#define GPIO_AF2_EVENTOUT     ((uint8_t)0x02U)  /*!< AF2: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF2_TIM1         ((uint8_t)0x02U)  /*!< AF2: TIM1 Alternate Function mapping      */
S#define GPIO_AF2_TIM16        ((uint8_t)0x02U)  /*!< AF2: TIM16 Alternate Function mapping     */
S#define GPIO_AF2_TIM17        ((uint8_t)0x02U)  /*!< AF2: TIM17 Alternate Function mapping     */
S#define GPIO_AF2_USB          ((uint8_t)0x02U)  /*!< AF2: USB Alternate Function mapping       */
S
S/* AF 3 */
S#define GPIO_AF3_EVENTOUT     ((uint8_t)0x03U)  /*!< AF3: EVENTOUT Alternate Function mapping  */
S#define GPIO_AF3_I2C1         ((uint8_t)0x03U)  /*!< AF3: I2C1 Alternate Function mapping      */
S
S/* AF 4 */
S#define GPIO_AF4_TIM14        ((uint8_t)0x04U)  /*!< AF4: TIM14 Alternate Function mapping     */
S#define GPIO_AF4_I2C1         ((uint8_t)0x04U)  /*!< AF4: I2C1 Alternate Function mapping      */
S
S/* AF 5 */ 
S#define GPIO_AF5_MCO          ((uint8_t)0x05U)  /*!< AF5: MCO Alternate Function mapping       */
S#define GPIO_AF5_I2C1         ((uint8_t)0x05U)  /*!< AF5: I2C1 Alternate Function mapping      */
S#define GPIO_AF5_TIM16        ((uint8_t)0x05U)  /*!< AF5: TIM16 Alternate Function mapping     */
S#define GPIO_AF5_TIM17        ((uint8_t)0x05U)  /*!< AF5: TIM17 Alternate Function mapping     */
S#define GPIO_AF5_USB          ((uint8_t)0x05U)  /*!< AF5: USB Alternate Function mapping       */
S
S/* AF 6 */ 
S#define GPIO_AF6_EVENTOUT     ((uint8_t)0x06U)  /*!< AF6: EVENTOUT Alternate Function mapping  */
S
S#define IS_GPIO_AF(AF)        ((AF) <= (uint8_t)0x06U)
S
N#endif /* STM32F070x6 */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup GPIOEx_Exported_Macros GPIOEx Exported Macros
N  * @{
N  */
N
N/** @defgroup GPIOEx_Get_Port_Index GPIOEx_Get Port Index
N* @{
N  */
N#if defined(GPIOD) && defined(GPIOE)
X#if 1L && 1L
N#define GPIO_GET_INDEX(__GPIOx__)    (((__GPIOx__) == (GPIOA))? 0U :\
N                                      ((__GPIOx__) == (GPIOB))? 1U :\
N                                      ((__GPIOx__) == (GPIOC))? 2U :\
N                                      ((__GPIOx__) == (GPIOD))? 3U :\
N                                      ((__GPIOx__) == (GPIOE))? 4U : 5U)
X#define GPIO_GET_INDEX(__GPIOx__)    (((__GPIOx__) == (GPIOA))? 0U :                                      ((__GPIOx__) == (GPIOB))? 1U :                                      ((__GPIOx__) == (GPIOC))? 2U :                                      ((__GPIOx__) == (GPIOD))? 3U :                                      ((__GPIOx__) == (GPIOE))? 4U : 5U)
N#endif
N
N#if defined(GPIOD) && !defined(GPIOE)
X#if 1L && !1L
S#define GPIO_GET_INDEX(__GPIOx__)    (((__GPIOx__) == (GPIOA))? 0U :\
S                                      ((__GPIOx__) == (GPIOB))? 1U :\
S                                      ((__GPIOx__) == (GPIOC))? 2U :\
S                                      ((__GPIOx__) == (GPIOD))? 3U : 5U)
X#define GPIO_GET_INDEX(__GPIOx__)    (((__GPIOx__) == (GPIOA))? 0U :                                      ((__GPIOx__) == (GPIOB))? 1U :                                      ((__GPIOx__) == (GPIOC))? 2U :                                      ((__GPIOx__) == (GPIOD))? 3U : 5U)
N#endif
N
N#if !defined(GPIOD) && defined(GPIOE)
X#if !1L && 1L
S#define GPIO_GET_INDEX(__GPIOx__)    (((__GPIOx__) == (GPIOA))? 0U :\
S                                      ((__GPIOx__) == (GPIOB))? 1U :\
S                                      ((__GPIOx__) == (GPIOC))? 2U :\
S                                      ((__GPIOx__) == (GPIOE))? 4U : 5U)
X#define GPIO_GET_INDEX(__GPIOx__)    (((__GPIOx__) == (GPIOA))? 0U :                                      ((__GPIOx__) == (GPIOB))? 1U :                                      ((__GPIOx__) == (GPIOC))? 2U :                                      ((__GPIOx__) == (GPIOE))? 4U : 5U)
N#endif
N
N#if !defined(GPIOD) && !defined(GPIOE)
X#if !1L && !1L
S#define GPIO_GET_INDEX(__GPIOx__)    (((__GPIOx__) == (GPIOA))? 0U :\
S                                      ((__GPIOx__) == (GPIOB))? 1U :\
S                                      ((__GPIOx__) == (GPIOC))? 2U : 5U)
X#define GPIO_GET_INDEX(__GPIOx__)    (((__GPIOx__) == (GPIOA))? 0U :                                      ((__GPIOx__) == (GPIOB))? 1U :                                      ((__GPIOx__) == (GPIOC))? 2U : 5U)
N#endif
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/ 
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_GPIO_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 259 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_gpio.h" 2
N
N/* Exported functions --------------------------------------------------------*/ 
N/** @addtogroup GPIO_Exported_Functions GPIO Exported Functions
N  * @{
N  */
N
N/** @addtogroup GPIO_Exported_Functions_Group1 Initialization/de-initialization functions 
N *  @brief    Initialization and Configuration functions
N * @{
N */
N     
N/* Initialization and de-initialization functions *****************************/
Nvoid              HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init);
Nvoid              HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin);
N
N/**
N  * @}
N  */
N
N/** @addtogroup GPIO_Exported_Functions_Group2 IO operation functions 
N * @{
N */
N   
N/* IO operation functions *****************************************************/
NGPIO_PinState     HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid              HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
Nvoid              HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
NHAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid              HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin);
Nvoid              HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */  
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_GPIO_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 202 "../Inc/stm32f0xx_hal_conf.h" 2
N#endif /* HAL_GPIO_MODULE_ENABLED */
N
N#ifdef HAL_DMA_MODULE_ENABLED
N  #include "stm32f0xx_hal_dma.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_dma.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_dma.h
N  * @author  MCD Application Team
N  * @brief   Header file of DMA HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_DMA_H
N#define __STM32F0xx_HAL_DMA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup DMA
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N
N/** @defgroup DMA_Exported_Types DMA Exported Types
N  * @{
N  */
N
N/** 
N  * @brief  DMA Configuration Structure definition  
N  */
Ntypedef struct
N{
N  uint32_t Direction;                 /*!< Specifies if the data will be transferred from memory to peripheral, 
N                                           from memory to memory or from peripheral to memory.
N                                           This parameter can be a value of @ref DMA_Data_transfer_direction */
N
N  uint32_t PeriphInc;                 /*!< Specifies whether the Peripheral address register should be incremented or not.
N                                           This parameter can be a value of @ref DMA_Peripheral_incremented_mode */
N                               
N  uint32_t MemInc;                    /*!< Specifies whether the memory address register should be incremented or not.
N                                           This parameter can be a value of @ref DMA_Memory_incremented_mode */
N  
N  uint32_t PeriphDataAlignment;       /*!< Specifies the Peripheral data width.
N                                           This parameter can be a value of @ref DMA_Peripheral_data_size */
N
N  uint32_t MemDataAlignment;          /*!< Specifies the Memory data width.
N                                           This parameter can be a value of @ref DMA_Memory_data_size */
N                               
N  uint32_t Mode;                      /*!< Specifies the operation mode of the DMAy Channelx.
N                                           This parameter can be a value of @ref DMA_mode
N                                           @note The circular buffer mode cannot be used if the memory-to-memory
N                                                 data transfer is configured on the selected Channel */ 
N
N  uint32_t Priority;                   /*!< Specifies the software priority for the DMAy Channelx.
N                                            This parameter can be a value of @ref DMA_Priority_level */
N} DMA_InitTypeDef;
N
N/**
N  * @brief  HAL DMA State structures definition  
N  */
Ntypedef enum
N{
N  HAL_DMA_STATE_RESET             = 0x00U,  /*!< DMA not yet initialized or disabled */  
N  HAL_DMA_STATE_READY             = 0x01U,  /*!< DMA initialized and ready for use   */
N  HAL_DMA_STATE_BUSY              = 0x02U,  /*!< DMA process is ongoing              */     
N  HAL_DMA_STATE_TIMEOUT           = 0x03U   /*!< DMA timeout state                   */  
N}HAL_DMA_StateTypeDef;
N
N/** 
N  * @brief  HAL DMA Error Code structure definition  
N  */ 
Ntypedef enum
N{
N  HAL_DMA_FULL_TRANSFER      = 0x00U,    /*!< Full transfer     */
N  HAL_DMA_HALF_TRANSFER      = 0x01U     /*!< Half Transfer     */
N}HAL_DMA_LevelCompleteTypeDef;      
N
N/** 
N  * @brief  HAL DMA Callback ID structure definition
N  */
Ntypedef enum
N{
N  HAL_DMA_XFER_CPLT_CB_ID          = 0x00U,    /*!< Full transfer     */
N  HAL_DMA_XFER_HALFCPLT_CB_ID      = 0x01U,    /*!< Half transfer     */
N  HAL_DMA_XFER_ERROR_CB_ID         = 0x02U,    /*!< Error             */ 
N  HAL_DMA_XFER_ABORT_CB_ID         = 0x03U,    /*!< Abort             */ 
N  HAL_DMA_XFER_ALL_CB_ID           = 0x04U     /*!< All               */ 
N    
N}HAL_DMA_CallbackIDTypeDef;                                                                 
N
N/** 
N  * @brief  DMA handle Structure definition  
N  */ 
Ntypedef struct __DMA_HandleTypeDef
N{  
N  DMA_Channel_TypeDef   *Instance;                                                    /*!< Register base address                  */
N  
N  DMA_InitTypeDef       Init;                                                         /*!< DMA communication parameters           */ 
N  
N  HAL_LockTypeDef       Lock;                                                         /*!< DMA locking object                     */  
N  
N  __IO HAL_DMA_StateTypeDef  State;                                                   /*!< DMA transfer state                     */
X  volatile HAL_DMA_StateTypeDef  State;                                                    
N  
N  void                  *Parent;                                                      /*!< Parent object state                    */  
N  
N  void                  (* XferCpltCallback)( struct __DMA_HandleTypeDef * hdma);     /*!< DMA transfer complete callback         */
N  
N  void                  (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA Half transfer complete callback    */
N  
N  void                  (* XferErrorCallback)( struct __DMA_HandleTypeDef * hdma);    /*!< DMA transfer error callback            */
N  
N  void                  (* XferAbortCallback)( struct __DMA_HandleTypeDef * hdma);    /*!< DMA transfer abort callback            */  
N  
N  __IO uint32_t         ErrorCode;                                                    /*!< DMA Error code                         */
X  volatile uint32_t         ErrorCode;                                                     
N  
N  DMA_TypeDef          *DmaBaseAddress;                                               /*!< DMA Channel Base Address                */
N  
N  uint32_t              ChannelIndex;                                                 /*!< DMA Channel Index                       */
N} DMA_HandleTypeDef;    
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Constants DMA Exported Constants
N  * @{
N  */
N
N/** @defgroup DMA_Error_Code DMA Error Code
N  * @{
N  */ 
N#define HAL_DMA_ERROR_NONE          (0x00000000U)    /*!< No error             */
N#define HAL_DMA_ERROR_TE            (0x00000001U)    /*!< Transfer error       */
N#define HAL_DMA_ERROR_NO_XFER       (0x00000004U)    /*!< no ongoin transfer   */
N#define HAL_DMA_ERROR_TIMEOUT       (0x00000020U)    /*!< Timeout error        */
N#define HAL_DMA_ERROR_NOT_SUPPORTED (0x00000100U)    /*!< Not supported mode */     
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Data_transfer_direction DMA Data transfer direction
N  * @{
N  */ 
N#define DMA_PERIPH_TO_MEMORY         (0x00000000U)        /*!< Peripheral to memory direction */
N#define DMA_MEMORY_TO_PERIPH         ((uint32_t)DMA_CCR_DIR)       /*!< Memory to peripheral direction */
N#define DMA_MEMORY_TO_MEMORY         ((uint32_t)(DMA_CCR_MEM2MEM)) /*!< Memory to memory direction     */
N
N/**
N  * @}
N  */
N  
N/** @defgroup DMA_Peripheral_incremented_mode DMA Peripheral incremented mode
N  * @{
N  */ 
N#define DMA_PINC_ENABLE        ((uint32_t)DMA_CCR_PINC)  /*!< Peripheral increment mode Enable */
N#define DMA_PINC_DISABLE       (0x00000000U)    /*!< Peripheral increment mode Disable */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_incremented_mode DMA Memory incremented mode
N  * @{
N  */ 
N#define DMA_MINC_ENABLE         ((uint32_t)DMA_CCR_MINC)  /*!< Memory increment mode Enable  */
N#define DMA_MINC_DISABLE        (0x00000000U)    /*!< Memory increment mode Disable */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Peripheral_data_size DMA Peripheral data size
N  * @{
N  */ 
N#define DMA_PDATAALIGN_BYTE          (0x00000000U)       /*!< Peripheral data alignment : Byte     */
N#define DMA_PDATAALIGN_HALFWORD      ((uint32_t)DMA_CCR_PSIZE_0)  /*!< Peripheral data alignment : HalfWord */
N#define DMA_PDATAALIGN_WORD          ((uint32_t)DMA_CCR_PSIZE_1)  /*!< Peripheral data alignment : Word     */
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_Memory_data_size DMA Memory data size
N  * @{ 
N  */
N#define DMA_MDATAALIGN_BYTE          (0x00000000U)       /*!< Memory data alignment : Byte     */
N#define DMA_MDATAALIGN_HALFWORD      ((uint32_t)DMA_CCR_MSIZE_0)  /*!< Memory data alignment : HalfWord */
N#define DMA_MDATAALIGN_WORD          ((uint32_t)DMA_CCR_MSIZE_1)  /*!< Memory data alignment : Word     */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_mode DMA mode
N  * @{
N  */ 
N#define DMA_NORMAL         (0x00000000U)      /*!< Normal Mode                  */
N#define DMA_CIRCULAR       ((uint32_t)DMA_CCR_CIRC)    /*!< Circular Mode                */
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Priority_level DMA Priority level
N  * @{
N  */
N#define DMA_PRIORITY_LOW             (0x00000000U)    /*!< Priority level : Low       */
N#define DMA_PRIORITY_MEDIUM          ((uint32_t)DMA_CCR_PL_0)  /*!< Priority level : Medium    */
N#define DMA_PRIORITY_HIGH            ((uint32_t)DMA_CCR_PL_1)  /*!< Priority level : High      */
N#define DMA_PRIORITY_VERY_HIGH       ((uint32_t)DMA_CCR_PL)    /*!< Priority level : Very_High */
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_interrupt_enable_definitions DMA interrupt enable definitions
N  * @{
N  */
N#define DMA_IT_TC                         ((uint32_t)DMA_CCR_TCIE)
N#define DMA_IT_HT                         ((uint32_t)DMA_CCR_HTIE)
N#define DMA_IT_TE                         ((uint32_t)DMA_CCR_TEIE)
N/**
N  * @}
N  */
N
N/** @defgroup DMA_flag_definitions DMA flag definitions
N  * @{
N  */ 
N
N#define DMA_FLAG_GL1                      (0x00000001U) /*!< Channel 1 global interrupt flag  */
N#define DMA_FLAG_TC1                      (0x00000002U) /*!< Channel 1 transfer complete flag */
N#define DMA_FLAG_HT1                      (0x00000004U) /*!< Channel 1 half transfer flag     */
N#define DMA_FLAG_TE1                      (0x00000008U) /*!< Channel 1 transfer error flag    */
N#define DMA_FLAG_GL2                      (0x00000010U) /*!< Channel 2 global interrupt flag  */
N#define DMA_FLAG_TC2                      (0x00000020U) /*!< Channel 2 transfer complete flag */
N#define DMA_FLAG_HT2                      (0x00000040U) /*!< Channel 2 half transfer flag     */
N#define DMA_FLAG_TE2                      (0x00000080U) /*!< Channel 2 transfer error flag    */
N#define DMA_FLAG_GL3                      (0x00000100U) /*!< Channel 3 global interrupt flag  */
N#define DMA_FLAG_TC3                      (0x00000200U) /*!< Channel 3 transfer complete flag */
N#define DMA_FLAG_HT3                      (0x00000400U) /*!< Channel 3 half transfer flag     */
N#define DMA_FLAG_TE3                      (0x00000800U) /*!< Channel 3 transfer error flag    */
N#define DMA_FLAG_GL4                      (0x00001000U) /*!< Channel 4 global interrupt flag  */
N#define DMA_FLAG_TC4                      (0x00002000U) /*!< Channel 4 transfer complete flag */
N#define DMA_FLAG_HT4                      (0x00004000U) /*!< Channel 4 half transfer flag     */
N#define DMA_FLAG_TE4                      (0x00008000U) /*!< Channel 4 transfer error flag    */
N#define DMA_FLAG_GL5                      (0x00010000U) /*!< Channel 5 global interrupt flag  */
N#define DMA_FLAG_TC5                      (0x00020000U) /*!< Channel 5 transfer complete flag */
N#define DMA_FLAG_HT5                      (0x00040000U) /*!< Channel 5 half transfer flag     */
N#define DMA_FLAG_TE5                      (0x00080000U) /*!< Channel 5 transfer error flag    */
N#define DMA_FLAG_GL6                      (0x00100000U) /*!< Channel 6 global interrupt flag  */
N#define DMA_FLAG_TC6                      (0x00200000U) /*!< Channel 6 transfer complete flag */
N#define DMA_FLAG_HT6                      (0x00400000U) /*!< Channel 6 half transfer flag     */
N#define DMA_FLAG_TE6                      (0x00800000U) /*!< Channel 6 transfer error flag    */
N#define DMA_FLAG_GL7                      (0x01000000U) /*!< Channel 7 global interrupt flag  */
N#define DMA_FLAG_TC7                      (0x02000000U) /*!< Channel 7 transfer complete flag */
N#define DMA_FLAG_HT7                      (0x04000000U) /*!< Channel 7 half transfer flag     */
N#define DMA_FLAG_TE7                      (0x08000000U) /*!< Channel 7 transfer error flag    */
N
N/**
N  * @}
N  */
N
N#if defined(SYSCFG_CFGR1_DMA_RMP)
X#if 0L
S/** @defgroup HAL_DMA_remapping HAL DMA remapping
S  *        Elements values convention: 0xYYYYYYYY
S  *           - YYYYYYYY  : Position in the SYSCFG register CFGR1
S  * @{  
S  */
S#define DMA_REMAP_ADC_DMA_CH2         ((uint32_t)SYSCFG_CFGR1_ADC_DMA_RMP) /*!< ADC DMA remap 
S                                                                         0: No remap (ADC DMA requests mapped on DMA channel 1
S                                                                         1: Remap (ADC DMA requests mapped on DMA channel 2 */
S#define DMA_REMAP_USART1_TX_DMA_CH4   ((uint32_t)SYSCFG_CFGR1_USART1TX_DMA_RMP) /*!< USART1 TX DMA remap 
S                                                                         0: No remap (USART1_TX DMA request mapped on DMA channel 2
S                                                                         1: Remap (USART1_TX DMA request mapped on DMA channel 4 */
S#define DMA_REMAP_USART1_RX_DMA_CH5   ((uint32_t)SYSCFG_CFGR1_USART1RX_DMA_RMP) /*!< USART1 RX DMA remap 
S                                                                         0: No remap (USART1_RX DMA request mapped on DMA channel 3
S                                                                         1: Remap (USART1_RX DMA request mapped on DMA channel 5 */
S#define DMA_REMAP_TIM16_DMA_CH4       ((uint32_t)SYSCFG_CFGR1_TIM16_DMA_RMP) /*!< TIM16 DMA request remap
S                                                                         0: No remap (TIM16_CH1 and TIM16_UP DMA requests mapped on DMA channel 3)
S                                                                         1: Remap (TIM16_CH1 and TIM16_UP DMA requests mapped on DMA channel 4) */
S#define DMA_REMAP_TIM17_DMA_CH2       ((uint32_t)SYSCFG_CFGR1_TIM17_DMA_RMP) /*!< TIM17 DMA request remap
S                                                                         0: No remap (TIM17_CH1 and TIM17_UP DMA requests mapped on DMA channel 1
S                                                                         1: Remap (TIM17_CH1 and TIM17_UP DMA requests mapped on DMA channel 2) */
S#if defined (STM32F070xB)
S#define DMA_REMAP_USART3_DMA_CH32     ((uint32_t)SYSCFG_CFGR1_USART3_DMA_RMP) /*!< USART3 DMA request remapping bit. Available on STM32F070xB devices only.
S                                                                         0: Disabled, need to remap before use 
S                                                                         1: Remap (USART3_RX and USART3_TX DMA requests mapped on DMA channel 3 and 2 respectively) */
S
S#endif
S
S#if defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx)
S#define DMA_REMAP_TIM16_DMA_CH6       ((uint32_t)SYSCFG_CFGR1_TIM16_DMA_RMP2) /*!< TIM16 alternate DMA request remapping bit. Available on STM32F07x devices only
S                                                                         0: No alternate remap (TIM16 DMA requestsmapped according to TIM16_DMA_RMP bit)
S                                                                         1: Alternate remap (TIM16_CH1 and TIM16_UP DMA requests mapped on DMA channel 6) */
S#define DMA_REMAP_TIM17_DMA_CH7       ((uint32_t)SYSCFG_CFGR1_TIM17_DMA_RMP2) /*!< TIM17 alternate DMA request remapping bit. Available on STM32F07x devices only
S                                                                         0: No alternate remap (TIM17 DMA requestsmapped according to TIM17_DMA_RMP bit)
S                                                                         1: Alternate remap (TIM17_CH1 and TIM17_UP DMA requests mapped on DMA channel 7) */
S#define DMA_REMAP_SPI2_DMA_CH67       ((uint32_t)SYSCFG_CFGR1_SPI2_DMA_RMP) /*!< SPI2 DMA request remapping bit. Available on STM32F07x devices only.
S                                                                         0: No remap (SPI2_RX and SPI2_TX DMA requests mapped on DMA channel 4 and 5 respectively)
S                                                                         1: Remap (SPI2_RX and SPI2_TX DMA requests mapped on DMA channel 6 and 7 respectively) */
S#define DMA_REMAP_USART2_DMA_CH67     ((uint32_t)SYSCFG_CFGR1_USART2_DMA_RMP) /*!< USART2 DMA request remapping bit. Available on STM32F07x devices only.
S                                                                         0: No remap (USART2_RX and USART2_TX DMA requests mapped on DMA channel 5 and 4 respectively)
S                                                                         1: 1: Remap (USART2_RX and USART2_TX DMA requests mapped on DMA channel 6 and 7 respectively) */
S#define DMA_REMAP_USART3_DMA_CH32     ((uint32_t)SYSCFG_CFGR1_USART3_DMA_RMP) /*!< USART3 DMA request remapping bit. Available on STM32F07x devices only.
S                                                                         0: No remap (USART3_RX and USART3_TX DMA requests mapped on DMA channel 6 and 7 respectively)
S                                                                         1: Remap (USART3_RX and USART3_TX DMA requests mapped on DMA channel 3 and 2 respectively) */
S#define DMA_REMAP_I2C1_DMA_CH76       ((uint32_t)SYSCFG_CFGR1_I2C1_DMA_RMP) /*!< I2C1 DMA request remapping bit. Available on STM32F07x devices only.
S                                                                         0: No remap (I2C1_RX and I2C1_TX DMA requests mapped on DMA channel 3 and 2 respectively)
S                                                                         1: Remap (I2C1_RX and I2C1_TX DMA requests mapped on DMA channel 7 and 6 respectively) */
S#define DMA_REMAP_TIM1_DMA_CH6        ((uint32_t)SYSCFG_CFGR1_TIM1_DMA_RMP) /*!< TIM1 DMA request remapping bit. Available on STM32F07x devices only.
S                                                                         0: No remap (TIM1_CH1, TIM1_CH2 and TIM1_CH3 DMA requests mapped on DMA channel 2, 3 and 4 respectively)
S                                                                         1: Remap (TIM1_CH1, TIM1_CH2 and TIM1_CH3 DMA requests mapped on DMA channel 6 */
S#define DMA_REMAP_TIM2_DMA_CH7        ((uint32_t)SYSCFG_CFGR1_TIM2_DMA_RMP) /*!< TIM2 DMA request remapping bit. Available on STM32F07x devices only.
S                                                                         0: No remap (TIM2_CH2 and TIM2_CH4 DMA requests mapped on DMA channel 3 and 4 respectively)
S                                                                         1: Remap (TIM2_CH2 and TIM2_CH4 DMA requests mapped on DMA channel 7 */
S#define DMA_REMAP_TIM3_DMA_CH6        ((uint32_t)SYSCFG_CFGR1_TIM3_DMA_RMP) /*!< TIM3 DMA request remapping bit. Available on STM32F07x devices only.
S                                                                         0: No remap (TIM3_CH1 and TIM3_TRIG DMA requests mapped on DMA channel 4)
S                                                                         1: Remap (TIM3_CH1 and TIM3_TRIG DMA requests mapped on DMA channel 6) */
S#endif
S
S/**
S  * @}
S  */
S
N#endif /* SYSCFG_CFGR1_DMA_RMP */
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup DMA_Exported_Macros DMA Exported Macros
N  * @{
N  */
N
N/** @brief  Reset DMA handle state
N  * @param  __HANDLE__ DMA handle.
N  * @retval None
N  */
N#define __HAL_DMA_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_DMA_STATE_RESET)
N
N/**
N  * @brief  Enable the specified DMA Channel.
N  * @param  __HANDLE__ DMA handle
N  * @retval None
N  */
N#define __HAL_DMA_ENABLE(__HANDLE__)        ((__HANDLE__)->Instance->CCR |= DMA_CCR_EN)
N
N/**
N  * @brief  Disable the specified DMA Channel.
N  * @param  __HANDLE__ DMA handle
N  * @retval None
N  */
N#define __HAL_DMA_DISABLE(__HANDLE__)       ((__HANDLE__)->Instance->CCR &= ~DMA_CCR_EN)
N
N
N/* Interrupt & Flag management */
N
N/**
N  * @brief  Enables the specified DMA Channel interrupts.
N  * @param  __HANDLE__ DMA handle
N  * @param __INTERRUPT__ specifies the DMA interrupt sources to be enabled or disabled. 
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA_IT_TC:  Transfer complete interrupt mask
N  *            @arg DMA_IT_HT:  Half transfer complete interrupt mask
N  *            @arg DMA_IT_TE:  Transfer error interrupt mask
N  * @retval None
N  */
N#define __HAL_DMA_ENABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)->Instance->CCR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disables the specified DMA Channel interrupts.
N  * @param  __HANDLE__ DMA handle
N  * @param __INTERRUPT__ specifies the DMA interrupt sources to be enabled or disabled. 
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA_IT_TC:  Transfer complete interrupt mask
N  *            @arg DMA_IT_HT:  Half transfer complete interrupt mask
N  *            @arg DMA_IT_TE:  Transfer error interrupt mask
N  * @retval None
N  */
N#define __HAL_DMA_DISABLE_IT(__HANDLE__, __INTERRUPT__)  ((__HANDLE__)->Instance->CCR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Checks whether the specified DMA Channel interrupt is enabled or disabled.
N  * @param  __HANDLE__ DMA handle
N  * @param  __INTERRUPT__ specifies the DMA interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg DMA_IT_TC:  Transfer complete interrupt mask
N  *            @arg DMA_IT_HT:  Half transfer complete interrupt mask
N  *            @arg DMA_IT_TE:  Transfer error interrupt mask
N  * @retval The state of DMA_IT (SET or RESET).
N  */
N#define __HAL_DMA_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)  (((__HANDLE__)->Instance->CCR & (__INTERRUPT__)))
N
N/**
N  * @brief  Returns the number of remaining data units in the current DMAy Channelx transfer.
N  * @param  __HANDLE__ DMA handle
N  *   
N  * @retval The number of remaining data units in the current DMA Channel transfer.
N  */
N#define __HAL_DMA_GET_COUNTER(__HANDLE__) ((__HANDLE__)->Instance->CNDTR)
N
N#if defined(SYSCFG_CFGR1_DMA_RMP)
X#if 0L
S/** @brief  DMA remapping enable/disable macros
S  * @param __DMA_REMAP__ This parameter can be a value of @ref HAL_DMA_remapping
S  */
S#define __HAL_DMA_REMAP_CHANNEL_ENABLE(__DMA_REMAP__)   do {assert_param(IS_DMA_REMAP((__DMA_REMAP__)));                  \
S                                                           SYSCFG->CFGR1 |= (__DMA_REMAP__);                              \
S                                                         }while(0)
X#define __HAL_DMA_REMAP_CHANNEL_ENABLE(__DMA_REMAP__)   do {assert_param(IS_DMA_REMAP((__DMA_REMAP__)));                                                                             SYSCFG->CFGR1 |= (__DMA_REMAP__);                                                                                       }while(0)
S#define __HAL_DMA_REMAP_CHANNEL_DISABLE(__DMA_REMAP__)  do {assert_param(IS_DMA_REMAP((__DMA_REMAP__)));                  \
S                                                           SYSCFG->CFGR1 &= ~(__DMA_REMAP__);                             \
S                                                         }while(0)
X#define __HAL_DMA_REMAP_CHANNEL_DISABLE(__DMA_REMAP__)  do {assert_param(IS_DMA_REMAP((__DMA_REMAP__)));                                                                             SYSCFG->CFGR1 &= ~(__DMA_REMAP__);                                                                                      }while(0)
N#endif /* SYSCFG_CFGR1_DMA_RMP */
N
N/**
N  * @}
N  */
N
N/* Include DMA HAL Extension module */
N#include "stm32f0xx_hal_dma_ex.h"   
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_dma_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_dma_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of DMA HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_DMA_EX_H
N#define __STM32F0xx_HAL_DMA_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup DMAEx DMAEx
N  * @brief DMA HAL module driver
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/ 
N/* Exported constants --------------------------------------------------------*/
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 1L || 0L || 0L
N/** @defgroup DMAEx_Exported_Constants DMAEx Exported Constants
N  * @{
N  */ 
N#define DMA1_CHANNEL1_RMP                                     0x00000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#define DMA1_CHANNEL2_RMP                                     0x10000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#define DMA1_CHANNEL3_RMP                                     0x20000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#define DMA1_CHANNEL4_RMP                                     0x30000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#define DMA1_CHANNEL5_RMP                                     0x40000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#if !defined(STM32F030xC)
X#if !0L
N#define DMA1_CHANNEL6_RMP                                     0x50000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#define DMA1_CHANNEL7_RMP                                     0x60000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#define DMA2_CHANNEL1_RMP                                     0x00000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#define DMA2_CHANNEL2_RMP                                     0x10000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#define DMA2_CHANNEL3_RMP                                     0x20000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#define DMA2_CHANNEL4_RMP                                     0x30000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#define DMA2_CHANNEL5_RMP                                     0x40000000 /*!< Internal define for remaping on STM32F09x/30xC */
N#endif /* !defined(STM32F030xC) */
N
N/****************** DMA1 remap bit field definition********************/
N/* DMA1 - Channel 1 */
N#define HAL_DMA1_CH1_DEFAULT      (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define HAL_DMA1_CH1_ADC          (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_ADC)       /*!< Remap ADC on DMA1 Channel 1*/   
N#define HAL_DMA1_CH1_TIM17_CH1    (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_TIM17_CH1) /*!< Remap TIM17 channel 1 on DMA1 channel 1 */
N#define HAL_DMA1_CH1_TIM17_UP     (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_TIM17_UP)  /*!< Remap TIM17 up on DMA1 channel 1 */ 
N#define HAL_DMA1_CH1_USART1_RX    (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_USART1_RX) /*!< Remap USART1 Rx on DMA1 channel 1 */ 
N#define HAL_DMA1_CH1_USART2_RX    (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_USART2_RX) /*!< Remap USART2 Rx on DMA1 channel 1 */ 
N#define HAL_DMA1_CH1_USART3_RX    (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_USART3_RX) /*!< Remap USART3 Rx on DMA1 channel 1 */ 
N#define HAL_DMA1_CH1_USART4_RX    (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_USART4_RX) /*!< Remap USART4 Rx on DMA1 channel 1 */ 
N#define HAL_DMA1_CH1_USART5_RX    (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_USART5_RX) /*!< Remap USART5 Rx on DMA1 channel 1 */ 
N#define HAL_DMA1_CH1_USART6_RX    (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_USART6_RX) /*!< Remap USART6 Rx on DMA1 channel 1 */ 
N#if !defined(STM32F030xC)
X#if !0L
N#define HAL_DMA1_CH1_USART7_RX    (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_USART7_RX) /*!< Remap USART7 Rx on DMA1 channel 1 */ 
N#define HAL_DMA1_CH1_USART8_RX    (uint32_t) (DMA1_CHANNEL1_RMP | DMA1_CSELR_CH1_USART8_RX) /*!< Remap USART8 Rx on DMA1 channel 1 */ 
N#endif /* !defined(STM32F030xC) */
N
N/* DMA1 - Channel 2 */
N#define HAL_DMA1_CH2_DEFAULT      (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define HAL_DMA1_CH2_ADC          (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_ADC)       /*!< Remap ADC on DMA1 channel 2 */  
N#define HAL_DMA1_CH2_I2C1_TX      (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_I2C1_TX)   /*!< Remap I2C1 Tx on DMA1 channel 2 */ 
N#define HAL_DMA1_CH2_SPI1_RX      (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_SPI1_RX)   /*!< Remap SPI1 Rx on DMA1 channel 2 */ 
N#define HAL_DMA1_CH2_TIM1_CH1     (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_TIM1_CH1)  /*!< Remap TIM1 channel 1 on DMA1 channel 2 */
N#define HAL_DMA1_CH2_TIM17_CH1    (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_TIM17_CH1) /*!< Remap TIM17 channel 1 on DMA1 channel 2 */
N#define HAL_DMA1_CH2_TIM17_UP     (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_TIM17_UP)  /*!< Remap TIM17 up on DMA1 channel 2 */ 
N#define HAL_DMA1_CH2_USART1_TX    (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_USART1_TX) /*!< Remap USART1 Tx on DMA1 channel 2 */ 
N#define HAL_DMA1_CH2_USART2_TX    (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_USART2_TX) /*!< Remap USART2 Tx on DMA1 channel 2 */ 
N#define HAL_DMA1_CH2_USART3_TX    (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_USART3_TX) /*!< Remap USART3 Tx on DMA1 channel 2 */ 
N#define HAL_DMA1_CH2_USART4_TX    (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_USART4_TX) /*!< Remap USART4 Tx on DMA1 channel 2 */ 
N#define HAL_DMA1_CH2_USART5_TX    (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_USART5_TX) /*!< Remap USART5 Tx on DMA1 channel 2 */ 
N#define HAL_DMA1_CH2_USART6_TX    (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_USART6_TX) /*!< Remap USART6 Tx on DMA1 channel 2 */ 
N#if !defined(STM32F030xC)
X#if !0L
N#define HAL_DMA1_CH2_USART7_TX    (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_USART7_TX) /*!< Remap USART7 Tx on DMA1 channel 2 */ 
N#define HAL_DMA1_CH2_USART8_TX    (uint32_t) (DMA1_CHANNEL2_RMP | DMA1_CSELR_CH2_USART8_TX) /*!< Remap USART8 Tx on DMA1 channel 2 */ 
N#endif /* !defined(STM32F030xC) */
N
N/* DMA1 - Channel 3 */
N#define HAL_DMA1_CH3_DEFAULT      (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define HAL_DMA1_CH3_TIM6_UP      (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_TIM6_UP)   /*!< Remap TIM6 up on DMA1 channel 3 */ 
N#if !defined(STM32F030xC)
X#if !0L
N#define HAL_DMA1_CH3_DAC_CH1      (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_DAC_CH1)   /*!< Remap DAC Channel 1on DMA1 channel 3 */ 
N#endif /* !defined(STM32F030xC) */
N#define HAL_DMA1_CH3_I2C1_RX      (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_I2C1_RX)   /*!< Remap I2C1 Rx on DMA1 channel 3 */ 
N#define HAL_DMA1_CH3_SPI1_TX      (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_SPI1_TX)   /*!< Remap SPI1 Tx on DMA1 channel 3 */ 
N#define HAL_DMA1_CH3_TIM1_CH2     (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_TIM1_CH2)  /*!< Remap TIM1 channel 2 on DMA1 channel 3 */
N#if !defined(STM32F030xC)
X#if !0L
N#define HAL_DMA1_CH3_TIM2_CH2     (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_TIM2_CH2)  /*!< Remap TIM2 channel 2 on DMA1 channel 3 */
N#endif /* !defined(STM32F030xC) */
N#define HAL_DMA1_CH3_TIM16_CH1    (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_TIM16_CH1) /*!< Remap TIM16 channel 1 on DMA1 channel 3 */
N#define HAL_DMA1_CH3_TIM16_UP     (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_TIM16_UP)  /*!< Remap TIM16 up on DMA1 channel 3 */ 
N#define HAL_DMA1_CH3_USART1_RX    (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_USART1_RX) /*!< Remap USART1 Rx on DMA1 channel 3 */ 
N#define HAL_DMA1_CH3_USART2_RX    (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_USART2_RX) /*!< Remap USART2 Rx on DMA1 channel 3 */ 
N#define HAL_DMA1_CH3_USART3_RX    (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_USART3_RX) /*!< Remap USART3 Rx on DMA1 channel 3 */ 
N#define HAL_DMA1_CH3_USART4_RX    (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_USART4_RX) /*!< Remap USART4 Rx on DMA1 channel 3 */ 
N#define HAL_DMA1_CH3_USART5_RX    (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_USART5_RX) /*!< Remap USART5 Rx on DMA1 channel 3 */ 
N#define HAL_DMA1_CH3_USART6_RX    (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_USART6_RX) /*!< Remap USART6 Rx on DMA1 channel 3 */ 
N#if !defined(STM32F030xC)
X#if !0L
N#define HAL_DMA1_CH3_USART7_RX    (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_USART7_RX) /*!< Remap USART7 Rx on DMA1 channel 3 */ 
N#define HAL_DMA1_CH3_USART8_RX    (uint32_t) (DMA1_CHANNEL3_RMP | DMA1_CSELR_CH3_USART8_RX) /*!< Remap USART8 Rx on DMA1 channel 3 */ 
N#endif /* !defined(STM32F030xC) */
N
N/* DMA1 - Channel 4 */
N#define HAL_DMA1_CH4_DEFAULT      (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define HAL_DMA1_CH4_TIM7_UP      (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_TIM7_UP)   /*!< Remap TIM7 up on DMA1 channel 4 */ 
N#if !defined(STM32F030xC)
X#if !0L
N#define HAL_DMA1_CH4_DAC_CH2      (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_DAC_CH2)   /*!< Remap DAC Channel 2 on DMA1 channel 4 */
N#endif /* !defined(STM32F030xC) */
N#define HAL_DMA1_CH4_I2C2_TX      (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_I2C2_TX)   /*!< Remap I2C2 Tx on DMA1 channel 4 */ 
N#define HAL_DMA1_CH4_SPI2_RX      (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_SPI2_RX)   /*!< Remap SPI2 Rx on DMA1 channel 4 */ 
N#if !defined(STM32F030xC)
X#if !0L
N#define HAL_DMA1_CH4_TIM2_CH4     (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_TIM2_CH4)  /*!< Remap TIM2 channel 4 on DMA1 channel 4 */
N#endif /* !defined(STM32F030xC) */
N#define HAL_DMA1_CH4_TIM3_CH1     (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_TIM3_CH1)  /*!< Remap TIM3 channel 1 on DMA1 channel 4 */
N#define HAL_DMA1_CH4_TIM3_TRIG    (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_TIM3_TRIG) /*!< Remap TIM3 Trig on DMA1 channel 4 */ 
N#define HAL_DMA1_CH4_TIM16_CH1    (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_TIM16_CH1) /*!< Remap TIM16 channel 1 on DMA1 channel 4 */
N#define HAL_DMA1_CH4_TIM16_UP     (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_TIM16_UP)  /*!< Remap TIM16 up on DMA1 channel 4 */ 
N#define HAL_DMA1_CH4_USART1_TX    (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_USART1_TX) /*!< Remap USART1 Tx on DMA1 channel 4 */ 
N#define HAL_DMA1_CH4_USART2_TX    (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_USART2_TX) /*!< Remap USART2 Tx on DMA1 channel 4 */ 
N#define HAL_DMA1_CH4_USART3_TX    (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_USART3_TX) /*!< Remap USART3 Tx on DMA1 channel 4 */ 
N#define HAL_DMA1_CH4_USART4_TX    (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_USART4_TX) /*!< Remap USART4 Tx on DMA1 channel 4 */ 
N#define HAL_DMA1_CH4_USART5_TX    (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_USART5_TX) /*!< Remap USART5 Tx on DMA1 channel 4 */ 
N#define HAL_DMA1_CH4_USART6_TX    (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_USART6_TX) /*!< Remap USART6 Tx on DMA1 channel 4 */ 
N#if !defined(STM32F030xC)
X#if !0L
N#define HAL_DMA1_CH4_USART7_TX    (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_USART7_TX) /*!< Remap USART7 Tx on DMA1 channel 4 */ 
N#define HAL_DMA1_CH4_USART8_TX    (uint32_t) (DMA1_CHANNEL4_RMP | DMA1_CSELR_CH4_USART8_TX) /*!< Remap USART8 Tx on DMA1 channel 4 */ 
N#endif /* !defined(STM32F030xC) */
N
N/* DMA1 - Channel 5 */
N#define HAL_DMA1_CH5_DEFAULT      (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define HAL_DMA1_CH5_I2C2_RX      (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_I2C2_RX)   /*!< Remap I2C2 Rx on DMA1 channel 5 */ 
N#define HAL_DMA1_CH5_SPI2_TX      (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_SPI2_TX)   /*!< Remap SPI1 Tx on DMA1 channel 5 */ 
N#define HAL_DMA1_CH5_TIM1_CH3     (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_TIM1_CH3)  /*!< Remap TIM1 channel 3 on DMA1 channel 5 */
N#define HAL_DMA1_CH5_USART1_RX    (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_USART1_RX) /*!< Remap USART1 Rx on DMA1 channel 5 */ 
N#define HAL_DMA1_CH5_USART2_RX    (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_USART2_RX) /*!< Remap USART2 Rx on DMA1 channel 5 */ 
N#define HAL_DMA1_CH5_USART3_RX    (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_USART3_RX) /*!< Remap USART3 Rx on DMA1 channel 5 */ 
N#define HAL_DMA1_CH5_USART4_RX    (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_USART4_RX) /*!< Remap USART4 Rx on DMA1 channel 5 */ 
N#define HAL_DMA1_CH5_USART5_RX    (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_USART5_RX) /*!< Remap USART5 Rx on DMA1 channel 5 */ 
N#define HAL_DMA1_CH5_USART6_RX    (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_USART6_RX) /*!< Remap USART6 Rx on DMA1 channel 5 */ 
N#if !defined(STM32F030xC)
X#if !0L
N#define HAL_DMA1_CH5_USART7_RX    (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_USART7_RX) /*!< Remap USART7 Rx on DMA1 channel 5 */ 
N#define HAL_DMA1_CH5_USART8_RX    (uint32_t) (DMA1_CHANNEL5_RMP | DMA1_CSELR_CH5_USART8_RX) /*!< Remap USART8 Rx on DMA1 channel 5 */ 
N#endif /* !defined(STM32F030xC) */
N
N#if !defined(STM32F030xC)
X#if !0L
N/* DMA1 - Channel 6 */
N#define HAL_DMA1_CH6_DEFAULT      (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define HAL_DMA1_CH6_I2C1_TX      (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_I2C1_TX)   /*!< Remap I2C1 Tx on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_SPI2_RX      (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_SPI2_RX)   /*!< Remap SPI2 Rx on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_TIM1_CH1     (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_TIM1_CH1)  /*!< Remap TIM1 channel 1 on DMA1 channel 6 */
N#define HAL_DMA1_CH6_TIM1_CH2     (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_TIM1_CH2)  /*!< Remap TIM1 channel 2 on DMA1 channel 6 */
N#define HAL_DMA1_CH6_TIM1_CH3     (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_TIM1_CH3)  /*!< Remap TIM1 channel 3 on DMA1 channel 6 */
N#define HAL_DMA1_CH6_TIM3_CH1     (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_TIM3_CH1)  /*!< Remap TIM3 channel 1 on DMA1 channel 6 */
N#define HAL_DMA1_CH6_TIM3_TRIG    (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_TIM3_TRIG) /*!< Remap TIM3 Trig on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_TIM16_CH1    (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_TIM16_CH1) /*!< Remap TIM16 channel 1 on DMA1 channel 6 */
N#define HAL_DMA1_CH6_TIM16_UP     (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_TIM16_UP)  /*!< Remap TIM16 up on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_USART1_RX    (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_USART1_RX) /*!< Remap USART1 Rx on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_USART2_RX    (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_USART2_RX) /*!< Remap USART2 Rx on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_USART3_RX    (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_USART3_RX) /*!< Remap USART3 Rx on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_USART4_RX    (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_USART4_RX) /*!< Remap USART4 Rx on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_USART5_RX    (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_USART5_RX) /*!< Remap USART5 Rx on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_USART6_RX    (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_USART6_RX) /*!< Remap USART6 Rx on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_USART7_RX    (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_USART7_RX) /*!< Remap USART7 Rx on DMA1 channel 6 */ 
N#define HAL_DMA1_CH6_USART8_RX    (uint32_t) (DMA1_CHANNEL6_RMP | DMA1_CSELR_CH6_USART8_RX) /*!< Remap USART8 Rx on DMA1 channel 6 */ 
N/* DMA1 - Channel 7 */
N#define HAL_DMA1_CH7_DEFAULT      (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define HAL_DMA1_CH7_I2C1_RX      (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_I2C1_RX)   /*!< Remap I2C1 Rx on DMA1 channel 7 */ 
N#define HAL_DMA1_CH7_SPI2_TX      (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_SPI2_TX)   /*!< Remap SPI2 Tx on DMA1 channel 7 */ 
N#define HAL_DMA1_CH7_TIM2_CH2     (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_TIM2_CH2)  /*!< Remap TIM2 channel 2 on DMA1 channel 7 */
N#define HAL_DMA1_CH7_TIM2_CH4     (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_TIM2_CH4)  /*!< Remap TIM2 channel 4 on DMA1 channel 7 */
N#define HAL_DMA1_CH7_TIM17_CH1    (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_TIM17_CH1) /*!< Remap TIM17 channel 1 on DMA1 channel 7 */
N#define HAL_DMA1_CH7_TIM17_UP     (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_TIM17_UP)  /*!< Remap TIM17 up on DMA1 channel 7 */ 
N#define HAL_DMA1_CH7_USART1_TX    (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_USART1_TX) /*!< Remap USART1 Tx on DMA1 channel 7 */ 
N#define HAL_DMA1_CH7_USART2_TX    (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_USART2_TX) /*!< Remap USART2 Tx on DMA1 channel 7 */ 
N#define HAL_DMA1_CH7_USART3_TX    (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_USART3_TX) /*!< Remap USART3 Tx on DMA1 channel 7 */ 
N#define HAL_DMA1_CH7_USART4_TX    (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_USART4_TX) /*!< Remap USART4 Tx on DMA1 channel 7 */ 
N#define HAL_DMA1_CH7_USART5_TX    (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_USART5_TX) /*!< Remap USART5 Tx on DMA1 channel 7 */ 
N#define HAL_DMA1_CH7_USART6_TX    (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_USART6_TX) /*!< Remap USART6 Tx on DMA1 channel 7 */ 
N#define HAL_DMA1_CH7_USART7_TX    (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_USART7_TX) /*!< Remap USART7 Tx on DMA1 channel 7 */ 
N#define HAL_DMA1_CH7_USART8_TX    (uint32_t) (DMA1_CHANNEL7_RMP | DMA1_CSELR_CH7_USART8_TX) /*!< Remap USART8 Tx on DMA1 channel 7 */
N
N/****************** DMA2 remap bit field definition********************/
N/* DMA2 - Channel 1 */
N#define HAL_DMA2_CH1_DEFAULT      (uint32_t) (DMA2_CHANNEL1_RMP | DMA2_CSELR_DEFAULT)       /*!< Default remap position for DMA2 */   
N#define HAL_DMA2_CH1_I2C2_TX      (uint32_t) (DMA2_CHANNEL1_RMP | DMA2_CSELR_CH1_I2C2_TX)   /*!< Remap I2C2 TX on DMA2 channel 1 */ 
N#define HAL_DMA2_CH1_USART1_TX    (uint32_t) (DMA2_CHANNEL1_RMP | DMA2_CSELR_CH1_USART1_TX) /*!< Remap USART1 Tx on DMA2 channel 1 */ 
N#define HAL_DMA2_CH1_USART2_TX    (uint32_t) (DMA2_CHANNEL1_RMP | DMA2_CSELR_CH1_USART2_TX) /*!< Remap USART2 Tx on DMA2 channel 1 */ 
N#define HAL_DMA2_CH1_USART3_TX    (uint32_t) (DMA2_CHANNEL1_RMP | DMA2_CSELR_CH1_USART3_TX) /*!< Remap USART3 Tx on DMA2 channel 1 */ 
N#define HAL_DMA2_CH1_USART4_TX    (uint32_t) (DMA2_CHANNEL1_RMP | DMA2_CSELR_CH1_USART4_TX) /*!< Remap USART4 Tx on DMA2 channel 1 */ 
N#define HAL_DMA2_CH1_USART5_TX    (uint32_t) (DMA2_CHANNEL1_RMP | DMA2_CSELR_CH1_USART5_TX) /*!< Remap USART5 Tx on DMA2 channel 1 */ 
N#define HAL_DMA2_CH1_USART6_TX    (uint32_t) (DMA2_CHANNEL1_RMP | DMA2_CSELR_CH1_USART6_TX) /*!< Remap USART6 Tx on DMA2 channel 1 */ 
N#define HAL_DMA2_CH1_USART7_TX    (uint32_t) (DMA2_CHANNEL1_RMP | DMA2_CSELR_CH1_USART7_TX) /*!< Remap USART7 Tx on DMA2 channel 1 */ 
N#define HAL_DMA2_CH1_USART8_TX    (uint32_t) (DMA2_CHANNEL1_RMP | DMA2_CSELR_CH1_USART8_TX) /*!< Remap USART8 Tx on DMA2 channel 1 */ 
N/* DMA2 - Channel 2 */
N#define HAL_DMA2_CH2_DEFAULT      (uint32_t) (DMA2_CHANNEL2_RMP | DMA2_CSELR_DEFAULT)       /*!< Default remap position for DMA2 */   
N#define HAL_DMA2_CH2_I2C2_RX      (uint32_t) (DMA2_CHANNEL2_RMP | DMA2_CSELR_CH2_I2C2_RX)   /*!< Remap I2C2 Rx on DMA2 channel 2 */ 
N#define HAL_DMA2_CH2_USART1_RX    (uint32_t) (DMA2_CHANNEL2_RMP | DMA2_CSELR_CH2_USART1_RX) /*!< Remap USART1 Rx on DMA2 channel 2 */ 
N#define HAL_DMA2_CH2_USART2_RX    (uint32_t) (DMA2_CHANNEL2_RMP | DMA2_CSELR_CH2_USART2_RX) /*!< Remap USART2 Rx on DMA2 channel 2 */ 
N#define HAL_DMA2_CH2_USART3_RX    (uint32_t) (DMA2_CHANNEL2_RMP | DMA2_CSELR_CH2_USART3_RX) /*!< Remap USART3 Rx on DMA2 channel 2 */ 
N#define HAL_DMA2_CH2_USART4_RX    (uint32_t) (DMA2_CHANNEL2_RMP | DMA2_CSELR_CH2_USART4_RX) /*!< Remap USART4 Rx on DMA2 channel 2 */ 
N#define HAL_DMA2_CH2_USART5_RX    (uint32_t) (DMA2_CHANNEL2_RMP | DMA2_CSELR_CH2_USART5_RX) /*!< Remap USART5 Rx on DMA2 channel 2 */ 
N#define HAL_DMA2_CH2_USART6_RX    (uint32_t) (DMA2_CHANNEL2_RMP | DMA2_CSELR_CH2_USART6_RX) /*!< Remap USART6 Rx on DMA2 channel 2 */ 
N#define HAL_DMA2_CH2_USART7_RX    (uint32_t) (DMA2_CHANNEL2_RMP | DMA2_CSELR_CH2_USART7_RX) /*!< Remap USART7 Rx on DMA2 channel 2 */ 
N#define HAL_DMA2_CH2_USART8_RX    (uint32_t) (DMA2_CHANNEL2_RMP | DMA2_CSELR_CH2_USART8_RX) /*!< Remap USART8 Rx on DMA2 channel 2 */ 
N/* DMA2 - Channel 3 */
N#define HAL_DMA2_CH3_DEFAULT      (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_DEFAULT)       /*!< Default remap position for DMA2 */   
N#define HAL_DMA2_CH3_TIM6_UP      (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_TIM6_UP)   /*!< Remap TIM6 up on DMA2 channel 3 */ 
N#define HAL_DMA2_CH3_DAC_CH1      (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_DAC_CH1)   /*!< Remap DAC channel 1 on DMA2 channel 3 */
N#define HAL_DMA2_CH3_SPI1_RX      (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_SPI1_RX)   /*!< Remap SPI1 Rx on DMA2 channel 3 */ 
N#define HAL_DMA2_CH3_USART1_RX    (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_USART1_RX) /*!< Remap USART1 Rx on DMA2 channel 3 */ 
N#define HAL_DMA2_CH3_USART2_RX    (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_USART2_RX) /*!< Remap USART2 Rx on DMA2 channel 3 */ 
N#define HAL_DMA2_CH3_USART3_RX    (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_USART3_RX) /*!< Remap USART3 Rx on DMA2 channel 3 */ 
N#define HAL_DMA2_CH3_USART4_RX    (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_USART4_RX) /*!< Remap USART4 Rx on DMA2 channel 3 */ 
N#define HAL_DMA2_CH3_USART5_RX    (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_USART5_RX) /*!< Remap USART5 Rx on DMA2 channel 3 */ 
N#define HAL_DMA2_CH3_USART6_RX    (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_USART6_RX) /*!< Remap USART6 Rx on DMA2 channel 3 */ 
N#define HAL_DMA2_CH3_USART7_RX    (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_USART7_RX) /*!< Remap USART7 Rx on DMA2 channel 3 */ 
N#define HAL_DMA2_CH3_USART8_RX    (uint32_t) (DMA2_CHANNEL3_RMP | DMA2_CSELR_CH3_USART8_RX) /*!< Remap USART8 Rx on DMA2 channel 3 */ 
N/* DMA2 - Channel 4 */
N#define HAL_DMA2_CH4_DEFAULT      (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_DEFAULT)       /*!< Default remap position for DMA2 */   
N#define HAL_DMA2_CH4_TIM7_UP      (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_TIM7_UP)   /*!< Remap TIM7 up on DMA2 channel 4 */ 
N#define HAL_DMA2_CH4_DAC_CH2      (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_DAC_CH2)   /*!< Remap DAC channel 2 on DMA2 channel 4 */
N#define HAL_DMA2_CH4_SPI1_TX      (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_SPI1_TX)   /*!< Remap SPI1 Tx on DMA2 channel 4 */ 
N#define HAL_DMA2_CH4_USART1_TX    (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_USART1_TX) /*!< Remap USART1 Tx on DMA2 channel 4 */ 
N#define HAL_DMA2_CH4_USART2_TX    (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_USART2_TX) /*!< Remap USART2 Tx on DMA2 channel 4 */ 
N#define HAL_DMA2_CH4_USART3_TX    (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_USART3_TX) /*!< Remap USART3 Tx on DMA2 channel 4 */ 
N#define HAL_DMA2_CH4_USART4_TX    (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_USART4_TX) /*!< Remap USART4 Tx on DMA2 channel 4 */ 
N#define HAL_DMA2_CH4_USART5_TX    (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_USART5_TX) /*!< Remap USART5 Tx on DMA2 channel 4 */ 
N#define HAL_DMA2_CH4_USART6_TX    (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_USART6_TX) /*!< Remap USART6 Tx on DMA2 channel 4 */ 
N#define HAL_DMA2_CH4_USART7_TX    (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_USART7_TX) /*!< Remap USART7 Tx on DMA2 channel 4 */ 
N#define HAL_DMA2_CH4_USART8_TX    (uint32_t) (DMA2_CHANNEL4_RMP | DMA2_CSELR_CH4_USART8_TX) /*!< Remap USART8 Tx on DMA2 channel 4 */ 
N/* DMA2 - Channel 5 */
N#define HAL_DMA2_CH5_DEFAULT      (uint32_t) (DMA2_CHANNEL5_RMP | DMA2_CSELR_DEFAULT)       /*!< Default remap position for DMA2 */   
N#define HAL_DMA2_CH5_ADC          (uint32_t) (DMA2_CHANNEL5_RMP | DMA2_CSELR_CH5_ADC)       /*!< Remap ADC on DMA2 channel 5 */  
N#define HAL_DMA2_CH5_USART1_TX    (uint32_t) (DMA2_CHANNEL5_RMP | DMA2_CSELR_CH5_USART1_TX) /*!< Remap USART1 Tx on DMA2 channel 5 */ 
N#define HAL_DMA2_CH5_USART2_TX    (uint32_t) (DMA2_CHANNEL5_RMP | DMA2_CSELR_CH5_USART2_TX) /*!< Remap USART2 Tx on DMA2 channel 5 */ 
N#define HAL_DMA2_CH5_USART3_TX    (uint32_t) (DMA2_CHANNEL5_RMP | DMA2_CSELR_CH5_USART3_TX) /*!< Remap USART3 Tx on DMA2 channel 5 */ 
N#define HAL_DMA2_CH5_USART4_TX    (uint32_t) (DMA2_CHANNEL5_RMP | DMA2_CSELR_CH5_USART4_TX) /*!< Remap USART4 Tx on DMA2 channel 5 */ 
N#define HAL_DMA2_CH5_USART5_TX    (uint32_t) (DMA2_CHANNEL5_RMP | DMA2_CSELR_CH5_USART5_TX) /*!< Remap USART5 Tx on DMA2 channel 5 */ 
N#define HAL_DMA2_CH5_USART6_TX    (uint32_t) (DMA2_CHANNEL5_RMP | DMA2_CSELR_CH5_USART6_TX) /*!< Remap USART6 Tx on DMA2 channel 5 */ 
N#define HAL_DMA2_CH5_USART7_TX    (uint32_t) (DMA2_CHANNEL5_RMP | DMA2_CSELR_CH5_USART7_TX) /*!< Remap USART7 Tx on DMA2 channel 5 */ 
N#define HAL_DMA2_CH5_USART8_TX    (uint32_t) (DMA2_CHANNEL5_RMP | DMA2_CSELR_CH5_USART8_TX) /*!< Remap USART8 Tx on DMA2 channel 5 */ 
N#endif /* !defined(STM32F030xC) */
N
N#if defined(STM32F091xC) || defined(STM32F098xx) 
X#if 1L || 0L 
N#define IS_HAL_DMA1_REMAP(REQUEST)  (((REQUEST) == HAL_DMA1_CH1_DEFAULT)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_ADC)       ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_TIM17_CH1) ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_TIM17_UP)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_USART1_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_USART2_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_USART3_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_USART4_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_USART5_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_USART6_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_USART7_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH1_USART8_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_ADC)       ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_I2C1_TX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_SPI1_RX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_TIM1_CH1)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_I2C1_TX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_TIM17_CH1) ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_TIM17_UP)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_USART1_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_USART2_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_USART3_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_USART4_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_USART5_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_USART6_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_USART7_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH2_USART8_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_TIM6_UP)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_DAC_CH1)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_I2C1_RX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_SPI1_TX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_TIM1_CH2)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_TIM2_CH2)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_TIM16_CH1) ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_TIM16_UP)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_USART1_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_USART2_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_USART3_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_USART4_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_USART5_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_USART6_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_USART7_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH3_USART8_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_TIM7_UP)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_DAC_CH2)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_I2C2_TX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_SPI2_RX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_TIM2_CH4)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_TIM3_CH1)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_TIM3_TRIG) ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_TIM16_CH1) ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_TIM16_UP)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_USART1_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_USART2_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_USART3_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_USART4_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_USART5_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_USART6_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_USART7_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH4_USART8_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_I2C2_RX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_SPI2_TX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_TIM1_CH3)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_USART1_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_USART2_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_USART3_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_USART4_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_USART5_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_USART6_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_USART7_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH5_USART8_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_I2C1_TX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_SPI2_RX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_TIM1_CH1)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_TIM1_CH2)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_TIM1_CH3)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_TIM3_CH1)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_TIM3_TRIG) ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_TIM16_CH1) ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_TIM16_UP)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_USART1_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_USART2_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_USART3_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_USART4_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_USART5_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_USART6_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_USART7_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH6_USART8_RX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_I2C1_RX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_SPI2_TX)   ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_TIM2_CH2)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_TIM2_CH4)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_TIM17_CH1) ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_TIM17_UP)  ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_USART1_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_USART2_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_USART3_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_USART4_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_USART5_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_USART6_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_USART7_TX) ||\
N                                    ((REQUEST) == HAL_DMA1_CH7_USART8_TX))
X#define IS_HAL_DMA1_REMAP(REQUEST)  (((REQUEST) == HAL_DMA1_CH1_DEFAULT)  ||                                    ((REQUEST) == HAL_DMA1_CH1_ADC)       ||                                    ((REQUEST) == HAL_DMA1_CH1_TIM17_CH1) ||                                    ((REQUEST) == HAL_DMA1_CH1_TIM17_UP)  ||                                    ((REQUEST) == HAL_DMA1_CH1_USART1_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART2_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART3_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART4_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART5_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART6_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART7_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART8_RX) ||                                    ((REQUEST) == HAL_DMA1_CH2_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA1_CH2_ADC)       ||                                    ((REQUEST) == HAL_DMA1_CH2_I2C1_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH2_SPI1_RX)   ||                                    ((REQUEST) == HAL_DMA1_CH2_TIM1_CH1)  ||                                    ((REQUEST) == HAL_DMA1_CH2_I2C1_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH2_TIM17_CH1) ||                                    ((REQUEST) == HAL_DMA1_CH2_TIM17_UP)  ||                                    ((REQUEST) == HAL_DMA1_CH2_USART1_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART2_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART3_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART4_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART5_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART6_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART7_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART8_TX) ||                                    ((REQUEST) == HAL_DMA1_CH3_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA1_CH3_TIM6_UP)   ||                                    ((REQUEST) == HAL_DMA1_CH3_DAC_CH1)   ||                                    ((REQUEST) == HAL_DMA1_CH3_I2C1_RX)   ||                                    ((REQUEST) == HAL_DMA1_CH3_SPI1_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH3_TIM1_CH2)  ||                                    ((REQUEST) == HAL_DMA1_CH3_TIM2_CH2)  ||                                    ((REQUEST) == HAL_DMA1_CH3_TIM16_CH1) ||                                    ((REQUEST) == HAL_DMA1_CH3_TIM16_UP)  ||                                    ((REQUEST) == HAL_DMA1_CH3_USART1_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART2_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART3_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART4_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART5_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART6_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART7_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART8_RX) ||                                    ((REQUEST) == HAL_DMA1_CH4_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM7_UP)   ||                                    ((REQUEST) == HAL_DMA1_CH4_DAC_CH2)   ||                                    ((REQUEST) == HAL_DMA1_CH4_I2C2_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH4_SPI2_RX)   ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM2_CH4)  ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM3_CH1)  ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM3_TRIG) ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM16_CH1) ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM16_UP)  ||                                    ((REQUEST) == HAL_DMA1_CH4_USART1_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART2_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART3_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART4_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART5_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART6_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART7_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART8_TX) ||                                    ((REQUEST) == HAL_DMA1_CH5_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA1_CH5_I2C2_RX)   ||                                    ((REQUEST) == HAL_DMA1_CH5_SPI2_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH5_TIM1_CH3)  ||                                    ((REQUEST) == HAL_DMA1_CH5_USART1_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART2_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART3_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART4_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART5_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART6_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART7_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART8_RX) ||                                    ((REQUEST) == HAL_DMA1_CH6_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA1_CH6_I2C1_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH6_SPI2_RX)   ||                                    ((REQUEST) == HAL_DMA1_CH6_TIM1_CH1)  ||                                    ((REQUEST) == HAL_DMA1_CH6_TIM1_CH2)  ||                                    ((REQUEST) == HAL_DMA1_CH6_TIM1_CH3)  ||                                    ((REQUEST) == HAL_DMA1_CH6_TIM3_CH1)  ||                                    ((REQUEST) == HAL_DMA1_CH6_TIM3_TRIG) ||                                    ((REQUEST) == HAL_DMA1_CH6_TIM16_CH1) ||                                    ((REQUEST) == HAL_DMA1_CH6_TIM16_UP)  ||                                    ((REQUEST) == HAL_DMA1_CH6_USART1_RX) ||                                    ((REQUEST) == HAL_DMA1_CH6_USART2_RX) ||                                    ((REQUEST) == HAL_DMA1_CH6_USART3_RX) ||                                    ((REQUEST) == HAL_DMA1_CH6_USART4_RX) ||                                    ((REQUEST) == HAL_DMA1_CH6_USART5_RX) ||                                    ((REQUEST) == HAL_DMA1_CH6_USART6_RX) ||                                    ((REQUEST) == HAL_DMA1_CH6_USART7_RX) ||                                    ((REQUEST) == HAL_DMA1_CH6_USART8_RX) ||                                    ((REQUEST) == HAL_DMA1_CH7_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA1_CH7_I2C1_RX)   ||                                    ((REQUEST) == HAL_DMA1_CH7_SPI2_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH7_TIM2_CH2)  ||                                    ((REQUEST) == HAL_DMA1_CH7_TIM2_CH4)  ||                                    ((REQUEST) == HAL_DMA1_CH7_TIM17_CH1) ||                                    ((REQUEST) == HAL_DMA1_CH7_TIM17_UP)  ||                                    ((REQUEST) == HAL_DMA1_CH7_USART1_TX) ||                                    ((REQUEST) == HAL_DMA1_CH7_USART2_TX) ||                                    ((REQUEST) == HAL_DMA1_CH7_USART3_TX) ||                                    ((REQUEST) == HAL_DMA1_CH7_USART4_TX) ||                                    ((REQUEST) == HAL_DMA1_CH7_USART5_TX) ||                                    ((REQUEST) == HAL_DMA1_CH7_USART6_TX) ||                                    ((REQUEST) == HAL_DMA1_CH7_USART7_TX) ||                                    ((REQUEST) == HAL_DMA1_CH7_USART8_TX))
N
N#define IS_HAL_DMA2_REMAP(REQUEST)  (((REQUEST) == HAL_DMA2_CH1_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH1_I2C2_TX)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH1_USART1_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH1_USART2_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH1_USART3_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH1_USART4_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH1_USART5_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH1_USART6_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH1_USART7_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH1_USART8_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH2_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH2_I2C2_RX)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH2_USART1_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH2_USART2_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH2_USART3_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH2_USART4_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH2_USART5_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH2_USART6_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH2_USART7_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH2_USART8_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_TIM6_UP)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_DAC_CH1)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_SPI1_RX)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_USART1_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_USART2_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_USART3_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_USART4_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_USART5_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_USART6_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_USART7_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH3_USART8_RX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_TIM7_UP)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_DAC_CH2)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_SPI1_TX)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_USART1_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_USART2_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_USART3_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_USART4_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_USART5_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_USART6_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_USART7_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH4_USART8_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH5_DEFAULT)   ||\
N                                    ((REQUEST) == HAL_DMA2_CH5_ADC)       ||\
N                                    ((REQUEST) == HAL_DMA2_CH5_USART1_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH5_USART2_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH5_USART3_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH5_USART4_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH5_USART5_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH5_USART6_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH5_USART7_TX) ||\
N                                    ((REQUEST) == HAL_DMA2_CH5_USART8_TX ))
X#define IS_HAL_DMA2_REMAP(REQUEST)  (((REQUEST) == HAL_DMA2_CH1_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA2_CH1_I2C2_TX)   ||                                    ((REQUEST) == HAL_DMA2_CH1_USART1_TX) ||                                    ((REQUEST) == HAL_DMA2_CH1_USART2_TX) ||                                    ((REQUEST) == HAL_DMA2_CH1_USART3_TX) ||                                    ((REQUEST) == HAL_DMA2_CH1_USART4_TX) ||                                    ((REQUEST) == HAL_DMA2_CH1_USART5_TX) ||                                    ((REQUEST) == HAL_DMA2_CH1_USART6_TX) ||                                    ((REQUEST) == HAL_DMA2_CH1_USART7_TX) ||                                    ((REQUEST) == HAL_DMA2_CH1_USART8_TX) ||                                    ((REQUEST) == HAL_DMA2_CH2_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA2_CH2_I2C2_RX)   ||                                    ((REQUEST) == HAL_DMA2_CH2_USART1_RX) ||                                    ((REQUEST) == HAL_DMA2_CH2_USART2_RX) ||                                    ((REQUEST) == HAL_DMA2_CH2_USART3_RX) ||                                    ((REQUEST) == HAL_DMA2_CH2_USART4_RX) ||                                    ((REQUEST) == HAL_DMA2_CH2_USART5_RX) ||                                    ((REQUEST) == HAL_DMA2_CH2_USART6_RX) ||                                    ((REQUEST) == HAL_DMA2_CH2_USART7_RX) ||                                    ((REQUEST) == HAL_DMA2_CH2_USART8_RX) ||                                    ((REQUEST) == HAL_DMA2_CH3_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA2_CH3_TIM6_UP)   ||                                    ((REQUEST) == HAL_DMA2_CH3_DAC_CH1)   ||                                    ((REQUEST) == HAL_DMA2_CH3_SPI1_RX)   ||                                    ((REQUEST) == HAL_DMA2_CH3_USART1_RX) ||                                    ((REQUEST) == HAL_DMA2_CH3_USART2_RX) ||                                    ((REQUEST) == HAL_DMA2_CH3_USART3_RX) ||                                    ((REQUEST) == HAL_DMA2_CH3_USART4_RX) ||                                    ((REQUEST) == HAL_DMA2_CH3_USART5_RX) ||                                    ((REQUEST) == HAL_DMA2_CH3_USART6_RX) ||                                    ((REQUEST) == HAL_DMA2_CH3_USART7_RX) ||                                    ((REQUEST) == HAL_DMA2_CH3_USART8_RX) ||                                    ((REQUEST) == HAL_DMA2_CH4_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA2_CH4_TIM7_UP)   ||                                    ((REQUEST) == HAL_DMA2_CH4_DAC_CH2)   ||                                    ((REQUEST) == HAL_DMA2_CH4_SPI1_TX)   ||                                    ((REQUEST) == HAL_DMA2_CH4_USART1_TX) ||                                    ((REQUEST) == HAL_DMA2_CH4_USART2_TX) ||                                    ((REQUEST) == HAL_DMA2_CH4_USART3_TX) ||                                    ((REQUEST) == HAL_DMA2_CH4_USART4_TX) ||                                    ((REQUEST) == HAL_DMA2_CH4_USART5_TX) ||                                    ((REQUEST) == HAL_DMA2_CH4_USART6_TX) ||                                    ((REQUEST) == HAL_DMA2_CH4_USART7_TX) ||                                    ((REQUEST) == HAL_DMA2_CH4_USART8_TX) ||                                    ((REQUEST) == HAL_DMA2_CH5_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA2_CH5_ADC)       ||                                    ((REQUEST) == HAL_DMA2_CH5_USART1_TX) ||                                    ((REQUEST) == HAL_DMA2_CH5_USART2_TX) ||                                    ((REQUEST) == HAL_DMA2_CH5_USART3_TX) ||                                    ((REQUEST) == HAL_DMA2_CH5_USART4_TX) ||                                    ((REQUEST) == HAL_DMA2_CH5_USART5_TX) ||                                    ((REQUEST) == HAL_DMA2_CH5_USART6_TX) ||                                    ((REQUEST) == HAL_DMA2_CH5_USART7_TX) ||                                    ((REQUEST) == HAL_DMA2_CH5_USART8_TX ))
N#endif /* STM32F091xC || STM32F098xx */
N
N#if defined(STM32F030xC)
X#if 0L
S#define IS_HAL_DMA1_REMAP(REQUEST)  (((REQUEST) == HAL_DMA1_CH1_DEFAULT)  ||\
S                                    ((REQUEST) == HAL_DMA1_CH1_ADC)       ||\
S                                    ((REQUEST) == HAL_DMA1_CH1_TIM17_CH1) ||\
S                                    ((REQUEST) == HAL_DMA1_CH1_TIM17_UP)  ||\
S                                    ((REQUEST) == HAL_DMA1_CH1_USART1_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH1_USART2_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH1_USART3_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH1_USART4_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH1_USART5_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH1_USART6_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_DEFAULT)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_ADC)       ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_I2C1_TX)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_SPI1_RX)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_TIM1_CH1)  ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_I2C1_TX)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_TIM17_CH1) ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_TIM17_UP)  ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_USART1_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_USART2_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_USART3_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_USART4_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_USART5_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH2_USART6_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_DEFAULT)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_TIM6_UP)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_I2C1_RX)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_SPI1_TX)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_TIM1_CH2)  ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_TIM16_CH1) ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_TIM16_UP)  ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_USART1_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_USART2_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_USART3_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_USART4_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_USART5_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH3_USART6_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_DEFAULT)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_TIM7_UP)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_I2C2_TX)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_SPI2_RX)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_TIM3_CH1)  ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_TIM3_TRIG) ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_TIM16_CH1) ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_TIM16_UP)  ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_USART1_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_USART2_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_USART3_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_USART4_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_USART5_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH4_USART6_TX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH5_DEFAULT)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH5_I2C2_RX)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH5_SPI2_TX)   ||\
S                                    ((REQUEST) == HAL_DMA1_CH5_TIM1_CH3)  ||\
S                                    ((REQUEST) == HAL_DMA1_CH5_USART1_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH5_USART2_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH5_USART3_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH5_USART4_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH5_USART5_RX) ||\
S                                    ((REQUEST) == HAL_DMA1_CH5_USART6_RX))
X#define IS_HAL_DMA1_REMAP(REQUEST)  (((REQUEST) == HAL_DMA1_CH1_DEFAULT)  ||                                    ((REQUEST) == HAL_DMA1_CH1_ADC)       ||                                    ((REQUEST) == HAL_DMA1_CH1_TIM17_CH1) ||                                    ((REQUEST) == HAL_DMA1_CH1_TIM17_UP)  ||                                    ((REQUEST) == HAL_DMA1_CH1_USART1_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART2_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART3_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART4_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART5_RX) ||                                    ((REQUEST) == HAL_DMA1_CH1_USART6_RX) ||                                    ((REQUEST) == HAL_DMA1_CH2_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA1_CH2_ADC)       ||                                    ((REQUEST) == HAL_DMA1_CH2_I2C1_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH2_SPI1_RX)   ||                                    ((REQUEST) == HAL_DMA1_CH2_TIM1_CH1)  ||                                    ((REQUEST) == HAL_DMA1_CH2_I2C1_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH2_TIM17_CH1) ||                                    ((REQUEST) == HAL_DMA1_CH2_TIM17_UP)  ||                                    ((REQUEST) == HAL_DMA1_CH2_USART1_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART2_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART3_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART4_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART5_TX) ||                                    ((REQUEST) == HAL_DMA1_CH2_USART6_TX) ||                                    ((REQUEST) == HAL_DMA1_CH3_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA1_CH3_TIM6_UP)   ||                                    ((REQUEST) == HAL_DMA1_CH3_I2C1_RX)   ||                                    ((REQUEST) == HAL_DMA1_CH3_SPI1_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH3_TIM1_CH2)  ||                                    ((REQUEST) == HAL_DMA1_CH3_TIM16_CH1) ||                                    ((REQUEST) == HAL_DMA1_CH3_TIM16_UP)  ||                                    ((REQUEST) == HAL_DMA1_CH3_USART1_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART2_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART3_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART4_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART5_RX) ||                                    ((REQUEST) == HAL_DMA1_CH3_USART6_RX) ||                                    ((REQUEST) == HAL_DMA1_CH4_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM7_UP)   ||                                    ((REQUEST) == HAL_DMA1_CH4_I2C2_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH4_SPI2_RX)   ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM3_CH1)  ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM3_TRIG) ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM16_CH1) ||                                    ((REQUEST) == HAL_DMA1_CH4_TIM16_UP)  ||                                    ((REQUEST) == HAL_DMA1_CH4_USART1_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART2_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART3_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART4_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART5_TX) ||                                    ((REQUEST) == HAL_DMA1_CH4_USART6_TX) ||                                    ((REQUEST) == HAL_DMA1_CH5_DEFAULT)   ||                                    ((REQUEST) == HAL_DMA1_CH5_I2C2_RX)   ||                                    ((REQUEST) == HAL_DMA1_CH5_SPI2_TX)   ||                                    ((REQUEST) == HAL_DMA1_CH5_TIM1_CH3)  ||                                    ((REQUEST) == HAL_DMA1_CH5_USART1_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART2_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART3_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART4_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART5_RX) ||                                    ((REQUEST) == HAL_DMA1_CH5_USART6_RX))
N#endif /* STM32F030xC */
N
N/**
N  * @}
N  */ 
N#endif /* STM32F091xC  || STM32F098xx || STM32F030xC */
N
N/* Exported macros -----------------------------------------------------------*/
N
N/** @defgroup DMAEx_Exported_Macros DMAEx Exported Macros
N  * @{
N  */
N/* Interrupt & Flag management */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)
X#if 0L || 0L || 0L
S/**
S  * @brief  Returns the current DMA Channel transfer complete flag.
S  * @param  __HANDLE__ DMA handle
S  * @retval The specified transfer complete flag index.
S  */      
S#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) \
S(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TC1 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TC2 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TC3 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TC4 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_TC5 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_TC6 :\
S   DMA_FLAG_TC7)
X#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) (((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TC1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TC2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TC3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TC4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_TC5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_TC6 :   DMA_FLAG_TC7)
S
S/**
S  * @brief  Returns the current DMA Channel half transfer complete flag.
S  * @param  __HANDLE__ DMA handle
S  * @retval The specified half transfer complete flag index.
S  */      
S#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)\
S(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_HT1 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_HT2 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_HT3 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_HT4 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_HT5 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_HT6 :\
S   DMA_FLAG_HT7)
X#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_HT1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_HT2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_HT3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_HT4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_HT5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_HT6 :   DMA_FLAG_HT7)
S
S/**
S  * @brief  Returns the current DMA Channel transfer error flag.
S  * @param  __HANDLE__ DMA handle
S  * @retval The specified transfer error flag index.
S  */
S#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)\
S(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TE1 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TE2 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TE3 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TE4 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_TE5 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_TE6 :\
S   DMA_FLAG_TE7)
X#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TE1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TE2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TE3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TE4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_TE5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_TE6 :   DMA_FLAG_TE7)
S
S/**
S  * @brief  Return the current DMA Channel Global interrupt flag.
S  * @param  __HANDLE__ DMA handle
S  * @retval The specified transfer error flag index.
S  */
S#define __HAL_DMA_GET_GI_FLAG_INDEX(__HANDLE__)\
S(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_GL1 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_GL2 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_GL3 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_GL4 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_GL5 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_GL6 :\
S   DMA_FLAG_GL7)
X#define __HAL_DMA_GET_GI_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_GL1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_GL2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_GL3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_GL4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_GL5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_GL6 :   DMA_FLAG_GL7)
S
S/**
S  * @brief  Get the DMA Channel pending flags.
S  * @param  __HANDLE__ DMA handle
S  * @param  __FLAG__ Get the specified flag.
S  *          This parameter can be any combination of the following values:
S  *            @arg DMA_FLAG_TCx:  Transfer complete flag
S  *            @arg DMA_FLAG_HTx:  Half transfer complete flag
S  *            @arg DMA_FLAG_TEx:  Transfer error flag
S  *         Where x can be 1_7 to select the DMA Channel flag.   
S  * @retval The state of FLAG (SET or RESET).
S  */
S
S#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__)   (DMA1->ISR & (__FLAG__))
S
S/**
S  * @brief  Clears the DMA Channel pending flags.
S  * @param  __HANDLE__ DMA handle
S  * @param  __FLAG__ specifies the flag to clear.
S  *          This parameter can be any combination of the following values:
S  *            @arg DMA_FLAG_TCx:  Transfer complete flag
S  *            @arg DMA_FLAG_HTx:  Half transfer complete flag
S  *            @arg DMA_FLAG_TEx:  Transfer error flag
S  *         Where x can be 1_7 to select the DMA Channel flag.   
S  * @retval None
S  */
S#define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) (DMA1->IFCR = (__FLAG__))
S
N#elif defined(STM32F091xC) || defined(STM32F098xx)
X#elif 1L || 0L
N/**
N  * @brief  Returns the current DMA Channel transfer complete flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified transfer complete flag index.
N  */      
N#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) \
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TC1 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TC2 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TC3 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TC4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_TC5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_TC6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_TC7 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_TC1 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_TC2 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_TC3 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_TC4 :\
N   DMA_FLAG_TC5)
X#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) (((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TC1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TC2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TC3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TC4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_TC5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_TC6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_TC7 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_TC1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_TC2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_TC3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_TC4 :   DMA_FLAG_TC5)
N
N/**
N  * @brief  Returns the current DMA Channel half transfer complete flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified half transfer complete flag index.
N  */      
N#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_HT1 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_HT2 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_HT3 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_HT4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_HT5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_HT6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_HT7 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_HT1 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_HT2 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_HT3 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_HT4 :\
N   DMA_FLAG_HT5)
X#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_HT1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_HT2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_HT3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_HT4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_HT5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_HT6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_HT7 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_HT1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_HT2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_HT3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_HT4 :   DMA_FLAG_HT5)
N
N/**
N  * @brief  Returns the current DMA Channel transfer error flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified transfer error flag index.
N  */
N#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TE1 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TE2 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TE3 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TE4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_TE5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_TE6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_TE7 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_TE1 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_TE2 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_TE3 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_TE4 :\
N   DMA_FLAG_TE5)
X#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TE1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TE2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TE3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TE4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_TE5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_TE6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_TE7 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_TE1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_TE2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_TE3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_TE4 :   DMA_FLAG_TE5)
N
N/**
N  * @brief  Return the current DMA Channel Global interrupt flag.
N  * @param  __HANDLE__ DMA handle
N  * @retval The specified transfer error flag index.
N  */
N#define __HAL_DMA_GET_GI_FLAG_INDEX(__HANDLE__)\
N(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_GL1 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_GL2 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_GL3 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_GL4 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_GL5 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_GL6 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_GL7 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_GL1 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_GL2 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_GL3 :\
N ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_GL4 :\
N   DMA_FLAG_GL5)
X#define __HAL_DMA_GET_GI_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_GL1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_GL2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_GL3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_GL4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel5))? DMA_FLAG_GL5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel6))? DMA_FLAG_GL6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel7))? DMA_FLAG_GL7 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel1))? DMA_FLAG_GL1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel2))? DMA_FLAG_GL2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel3))? DMA_FLAG_GL3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Channel4))? DMA_FLAG_GL4 :   DMA_FLAG_GL5)
N
N/**
N  * @brief  Get the DMA Channel pending flags.
N  * @param  __HANDLE__ DMA handle
N  * @param  __FLAG__ Get the specified flag.
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA_FLAG_TCx:  Transfer complete flag
N  *            @arg DMA_FLAG_HTx:  Half transfer complete flag
N  *            @arg DMA_FLAG_TEx:  Transfer error flag
N  *         Where x can be 0_4, 1_5, 2_6 or 3_7 to select the DMA Channel flag.   
N  * @retval The state of FLAG (SET or RESET).
N  */
N
N#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__)\
N(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Channel7)? (DMA2->ISR & (__FLAG__)) :\
N  (DMA1->ISR & (__FLAG__)))
X#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__)(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Channel7)? (DMA2->ISR & (__FLAG__)) :  (DMA1->ISR & (__FLAG__)))
N
N/**
N  * @brief  Clears the DMA Channel pending flags.
N  * @param  __HANDLE__ DMA handle
N  * @param  __FLAG__ specifies the flag to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg DMA_FLAG_TCx:  Transfer complete flag
N  *            @arg DMA_FLAG_HTx:  Half transfer complete flag
N  *            @arg DMA_FLAG_TEx:  Transfer error flag
N  *         Where x can be 0_4, 1_5, 2_6 or 3_7 to select the DMA Channel flag.   
N  * @retval None
N  */
N#define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) \
N(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Channel7)? (DMA2->IFCR = (__FLAG__)) :\
N  (DMA1->IFCR = (__FLAG__)))
X#define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) (((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Channel7)? (DMA2->IFCR = (__FLAG__)) :  (DMA1->IFCR = (__FLAG__)))
N
N#else /* STM32F030x8_STM32F030xC_STM32F031x6_STM32F038xx_STM32F051x8_STM32F058xx_STM32F070x6_STM32F070xB Product devices */
S/**
S  * @brief  Returns the current DMA Channel transfer complete flag.
S  * @param  __HANDLE__ DMA handle
S  * @retval The specified transfer complete flag index.
S  */      
S#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) \
S(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TC1 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TC2 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TC3 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TC4 :\
S   DMA_FLAG_TC5)
X#define __HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__) (((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TC1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TC2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TC3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TC4 :   DMA_FLAG_TC5)
S
S/**
S  * @brief  Returns the current DMA Channel half transfer complete flag.
S  * @param  __HANDLE__ DMA handle
S  * @retval The specified half transfer complete flag index.
S  */      
S#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)\
S(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_HT1 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_HT2 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_HT3 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_HT4 :\
S   DMA_FLAG_HT5)
X#define __HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_HT1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_HT2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_HT3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_HT4 :   DMA_FLAG_HT5)
S
S/**
S  * @brief  Returns the current DMA Channel transfer error flag.
S  * @param  __HANDLE__ DMA handle
S  * @retval The specified transfer error flag index.
S  */
S#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)\
S(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TE1 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TE2 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TE3 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TE4 :\
S   DMA_FLAG_TE5)
X#define __HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_TE1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_TE2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_TE3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_TE4 :   DMA_FLAG_TE5)
S
S/**
S  * @brief  Return the current DMA Channel Global interrupt flag.
S  * @param  __HANDLE__ DMA handle
S  * @retval The specified transfer error flag index.
S  */
S#define __HAL_DMA_GET_GI_FLAG_INDEX(__HANDLE__)\
S(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_GL1 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_GL2 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_GL3 :\
S ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_GL4 :\
S   DMA_FLAG_GL5)
X#define __HAL_DMA_GET_GI_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel1))? DMA_FLAG_GL1 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel2))? DMA_FLAG_GL2 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel3))? DMA_FLAG_GL3 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Channel4))? DMA_FLAG_GL4 :   DMA_FLAG_GL5)
S
S/**
S  * @brief  Get the DMA Channel pending flags.
S  * @param  __HANDLE__ DMA handle
S  * @param  __FLAG__ Get the specified flag.
S  *          This parameter can be any combination of the following values:
S  *            @arg DMA_FLAG_TCx:  Transfer complete flag
S  *            @arg DMA_FLAG_HTx:  Half transfer complete flag
S  *            @arg DMA_FLAG_TEx:  Transfer error flag
S  *         Where x can be 1_5 to select the DMA Channel flag.   
S  * @retval The state of FLAG (SET or RESET).
S  */
S
S#define __HAL_DMA_GET_FLAG(__HANDLE__, __FLAG__)   (DMA1->ISR & (__FLAG__))
S
S/**
S  * @brief  Clears the DMA Channel pending flags.
S  * @param  __HANDLE__ DMA handle
S  * @param  __FLAG__ specifies the flag to clear.
S  *          This parameter can be any combination of the following values:
S  *            @arg DMA_FLAG_TCx:  Transfer complete flag
S  *            @arg DMA_FLAG_HTx:  Half transfer complete flag
S  *            @arg DMA_FLAG_TEx:  Transfer error flag
S  *         Where x can be 1_5 to select the DMA Channel flag.   
S  * @retval None
S  */
S#define __HAL_DMA_CLEAR_FLAG(__HANDLE__, __FLAG__) (DMA1->IFCR = (__FLAG__))
S
N#endif
N
N
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 1L || 0L || 0L
N#define __HAL_DMA1_REMAP(__REQUEST__)                                                              \
N         do { assert_param(IS_HAL_DMA1_REMAP(__REQUEST__));                                             \
N              DMA1->CSELR &= ~(0x0FU << (uint32_t)(((__REQUEST__) >> 28U) * 4U)); \
N              DMA1->CSELR |= (uint32_t)((__REQUEST__) & 0x0FFFFFFFU);                                     \
N  }while(0)
X#define __HAL_DMA1_REMAP(__REQUEST__)                                                                       do { assert_param(IS_HAL_DMA1_REMAP(__REQUEST__));                                                           DMA1->CSELR &= ~(0x0FU << (uint32_t)(((__REQUEST__) >> 28U) * 4U));               DMA1->CSELR |= (uint32_t)((__REQUEST__) & 0x0FFFFFFFU);                                       }while(0)
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N#define __HAL_DMA2_REMAP(__REQUEST__)                                                              \
N         do { assert_param(IS_HAL_DMA2_REMAP(__REQUEST__));                                             \
N              DMA2->CSELR &= ~(0x0FU << (uint32_t)(((__REQUEST__) >> 28U) * 4U)); \
N              DMA2->CSELR |= (uint32_t)((__REQUEST__) & 0x0FFFFFFFU);                                     \
N         }while(0)
X#define __HAL_DMA2_REMAP(__REQUEST__)                                                                       do { assert_param(IS_HAL_DMA2_REMAP(__REQUEST__));                                                           DMA2->CSELR &= ~(0x0FU << (uint32_t)(((__REQUEST__) >> 28U) * 4U));               DMA2->CSELR |= (uint32_t)((__REQUEST__) & 0x0FFFFFFFU);                                              }while(0)
N#endif /* STM32F091xC || STM32F098xx */
N
N#endif /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_DMA_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 450 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_dma.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup DMA_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup DMA_Exported_Functions_Group1
N  * @{
N  */
N/* Initialization and de-initialization functions *****************************/
NHAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_DeInit (DMA_HandleTypeDef *hdma);
N/**
N  * @}
N  */
N
N/** @addtogroup DMA_Exported_Functions_Group2
N  * @{
N  */
N/* Input and Output operation functions *****************************************************/
NHAL_StatusTypeDef HAL_DMA_Start (DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
NHAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, uint32_t CompleteLevel, uint32_t Timeout);
Nvoid HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma);
NHAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)( DMA_HandleTypeDef * _hdma));
NHAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID);
N
N/**
N  * @}
N  */
N
N/** @addtogroup DMA_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State and Error functions ***************************************/
NHAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma);
Nuint32_t             HAL_DMA_GetError(DMA_HandleTypeDef *hdma);
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/** @addtogroup DMA_Private_Macros
N  * @{
N  */
N#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_PERIPH_TO_MEMORY ) || \
N                                     ((DIRECTION) == DMA_MEMORY_TO_PERIPH)  || \
N                                     ((DIRECTION) == DMA_MEMORY_TO_MEMORY)) 
X#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_PERIPH_TO_MEMORY ) ||                                      ((DIRECTION) == DMA_MEMORY_TO_PERIPH)  ||                                      ((DIRECTION) == DMA_MEMORY_TO_MEMORY)) 
N#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PINC_ENABLE) || \
N                                            ((STATE) == DMA_PINC_DISABLE))
X#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PINC_ENABLE) ||                                             ((STATE) == DMA_PINC_DISABLE))
N
N#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MINC_ENABLE)  || \
N                                        ((STATE) == DMA_MINC_DISABLE))
X#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MINC_ENABLE)  ||                                         ((STATE) == DMA_MINC_DISABLE))
N
N#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PDATAALIGN_BYTE)     || \
N                                           ((SIZE) == DMA_PDATAALIGN_HALFWORD) || \
N                                           ((SIZE) == DMA_PDATAALIGN_WORD))
X#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PDATAALIGN_BYTE)     ||                                            ((SIZE) == DMA_PDATAALIGN_HALFWORD) ||                                            ((SIZE) == DMA_PDATAALIGN_WORD))
N
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MDATAALIGN_BYTE)     || \
N                                       ((SIZE) == DMA_MDATAALIGN_HALFWORD) || \
N                                       ((SIZE) == DMA_MDATAALIGN_WORD ))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MDATAALIGN_BYTE)     ||                                        ((SIZE) == DMA_MDATAALIGN_HALFWORD) ||                                        ((SIZE) == DMA_MDATAALIGN_WORD ))
N
N#define IS_DMA_MODE(MODE) (((MODE) == DMA_NORMAL )  || \
N                           ((MODE) == DMA_CIRCULAR))
X#define IS_DMA_MODE(MODE) (((MODE) == DMA_NORMAL )  ||                            ((MODE) == DMA_CIRCULAR))
N#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_PRIORITY_LOW )   || \
N                                   ((PRIORITY) == DMA_PRIORITY_MEDIUM) || \
N                                   ((PRIORITY) == DMA_PRIORITY_HIGH)   || \
N                                   ((PRIORITY) == DMA_PRIORITY_VERY_HIGH)) 
X#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_PRIORITY_LOW )   ||                                    ((PRIORITY) == DMA_PRIORITY_MEDIUM) ||                                    ((PRIORITY) == DMA_PRIORITY_HIGH)   ||                                    ((PRIORITY) == DMA_PRIORITY_VERY_HIGH)) 
N#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1U) && ((SIZE) < 0x10000U))
N
N#if defined(SYSCFG_CFGR1_DMA_RMP)
X#if 0L
S
S#if defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx)
S#define IS_DMA_REMAP(RMP) (((RMP) == DMA_REMAP_ADC_DMA_CH2)          || \
S                              ((RMP) == DMA_REMAP_USART1_TX_DMA_CH4) || \
S                              ((RMP) == DMA_REMAP_USART1_RX_DMA_CH5) || \
S                              ((RMP) == DMA_REMAP_TIM16_DMA_CH4)     || \
S                              ((RMP) == DMA_REMAP_TIM17_DMA_CH2)     || \
S                              ((RMP) == DMA_REMAP_TIM16_DMA_CH6)     || \
S                              ((RMP) == DMA_REMAP_TIM17_DMA_CH7)     || \
S                              ((RMP) == DMA_REMAP_SPI2_DMA_CH67)     || \
S                              ((RMP) == DMA_REMAP_USART2_DMA_CH67)   || \
S                              ((RMP) == DMA_REMAP_USART3_DMA_CH32)   || \
S                              ((RMP) == DMA_REMAP_I2C1_DMA_CH76)     || \
S                              ((RMP) == DMA_REMAP_TIM1_DMA_CH6)      || \
S                              ((RMP) == DMA_REMAP_TIM2_DMA_CH7)      || \
S                              ((RMP) == DMA_REMAP_TIM3_DMA_CH6))
X#define IS_DMA_REMAP(RMP) (((RMP) == DMA_REMAP_ADC_DMA_CH2)          ||                               ((RMP) == DMA_REMAP_USART1_TX_DMA_CH4) ||                               ((RMP) == DMA_REMAP_USART1_RX_DMA_CH5) ||                               ((RMP) == DMA_REMAP_TIM16_DMA_CH4)     ||                               ((RMP) == DMA_REMAP_TIM17_DMA_CH2)     ||                               ((RMP) == DMA_REMAP_TIM16_DMA_CH6)     ||                               ((RMP) == DMA_REMAP_TIM17_DMA_CH7)     ||                               ((RMP) == DMA_REMAP_SPI2_DMA_CH67)     ||                               ((RMP) == DMA_REMAP_USART2_DMA_CH67)   ||                               ((RMP) == DMA_REMAP_USART3_DMA_CH32)   ||                               ((RMP) == DMA_REMAP_I2C1_DMA_CH76)     ||                               ((RMP) == DMA_REMAP_TIM1_DMA_CH6)      ||                               ((RMP) == DMA_REMAP_TIM2_DMA_CH7)      ||                               ((RMP) == DMA_REMAP_TIM3_DMA_CH6))
S#elif defined (STM32F070xB)
S#define IS_DMA_REMAP(RMP)     (((RMP) == DMA_REMAP_USART3_DMA_CH32)  || \
S                              ((RMP) == DMA_REMAP_ADC_DMA_CH2)       || \
S                              ((RMP) == DMA_REMAP_USART1_TX_DMA_CH4) || \
S                              ((RMP) == DMA_REMAP_USART1_RX_DMA_CH5) || \
S                              ((RMP) == DMA_REMAP_TIM16_DMA_CH4)     || \
S                              ((RMP) == DMA_REMAP_TIM17_DMA_CH2))
X#define IS_DMA_REMAP(RMP)     (((RMP) == DMA_REMAP_USART3_DMA_CH32)  ||                               ((RMP) == DMA_REMAP_ADC_DMA_CH2)       ||                               ((RMP) == DMA_REMAP_USART1_TX_DMA_CH4) ||                               ((RMP) == DMA_REMAP_USART1_RX_DMA_CH5) ||                               ((RMP) == DMA_REMAP_TIM16_DMA_CH4)     ||                               ((RMP) == DMA_REMAP_TIM17_DMA_CH2))
S#else
S#define IS_DMA_REMAP(RMP)     (((RMP) == DMA_REMAP_ADC_DMA_CH2)      || \
S                              ((RMP) == DMA_REMAP_USART1_TX_DMA_CH4) || \
S                              ((RMP) == DMA_REMAP_USART1_RX_DMA_CH5) || \
S                              ((RMP) == DMA_REMAP_TIM16_DMA_CH4)     || \
S                              ((RMP) == DMA_REMAP_TIM17_DMA_CH2))
X#define IS_DMA_REMAP(RMP)     (((RMP) == DMA_REMAP_ADC_DMA_CH2)      ||                               ((RMP) == DMA_REMAP_USART1_TX_DMA_CH4) ||                               ((RMP) == DMA_REMAP_USART1_RX_DMA_CH5) ||                               ((RMP) == DMA_REMAP_TIM16_DMA_CH4)     ||                               ((RMP) == DMA_REMAP_TIM17_DMA_CH2))
S#endif
S
N#endif /* SYSCFG_CFGR1_DMA_RMP */  
N
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_DMA_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 206 "../Inc/stm32f0xx_hal_conf.h" 2
N#endif /* HAL_DMA_MODULE_ENABLED */
N
N#ifdef HAL_CORTEX_MODULE_ENABLED
N #include "stm32f0xx_hal_cortex.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_cortex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_cortex.h
N  * @author  MCD Application Team
N  * @brief   Header file of CORTEX HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_CORTEX_H
N#define __STM32F0xx_HAL_CORTEX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup CORTEX CORTEX
N  * @{
N  */ 
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CORTEX_Exported_Constants CORTEX Exported Constants
N  * @{
N  */
N  
N/** @defgroup CORTEX_SysTick_clock_source CORTEX SysTick clock source
N  * @{
N  */
N#define SYSTICK_CLKSOURCE_HCLK_DIV8    (0x00000000U)
N#define SYSTICK_CLKSOURCE_HCLK         (0x00000004U)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/* Exported Macros -----------------------------------------------------------*/
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup CORTEX_Exported_Functions CORTEX Exported Functions
N  * @{
N  */
N/** @addtogroup CORTEX_Exported_Functions_Group1 Initialization and de-initialization functions 
N *  @brief    Initialization and Configuration functions
N * @{
N */
N/* Initialization and de-initialization functions *******************************/
Nvoid HAL_NVIC_SetPriority(IRQn_Type IRQn,uint32_t PreemptPriority, uint32_t SubPriority);
Nvoid HAL_NVIC_EnableIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_DisableIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_SystemReset(void);
Nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb);
N/**
N  * @}
N  */
N
N/** @addtogroup CORTEX_Exported_Functions_Group2 Peripheral Control functions 
N *  @brief   Cortex control functions
N * @{
N */
N 
N/* Peripheral Control functions *************************************************/
Nuint32_t HAL_NVIC_GetPriority(IRQn_Type IRQn);
Nuint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn);
Nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn);
Nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource);
Nvoid HAL_SYSTICK_IRQHandler(void);
Nvoid HAL_SYSTICK_Callback(void);
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Private types -------------------------------------------------------------*/ 
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup CORTEX_Private_Macros CORTEX Private Macros
N  * @{
N  */
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x4)
N
N#define IS_NVIC_DEVICE_IRQ(IRQ)                ((IRQ) >= 0x00)
N
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) || \
N                                      ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SYSTICK_CLKSOURCE_HCLK) ||                                       ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N    
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_CORTEX_H */
N 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 210 "../Inc/stm32f0xx_hal_conf.h" 2
N#endif /* HAL_CORTEX_MODULE_ENABLED */
N
N#ifdef HAL_ADC_MODULE_ENABLED
S #include "stm32f0xx_hal_adc.h"
N#endif /* HAL_ADC_MODULE_ENABLED */
N
N#ifdef HAL_CAN_MODULE_ENABLED
S #include "stm32f0xx_hal_can.h"
N#endif /* HAL_CAN_MODULE_ENABLED */
N
N#ifdef HAL_CEC_MODULE_ENABLED
S #include "stm32f0xx_hal_cec.h"
N#endif /* HAL_CEC_MODULE_ENABLED */
N
N#ifdef HAL_COMP_MODULE_ENABLED
S #include "stm32f0xx_hal_comp.h"
N#endif /* HAL_COMP_MODULE_ENABLED */
N
N#ifdef HAL_CRC_MODULE_ENABLED
S #include "stm32f0xx_hal_crc.h"
N#endif /* HAL_CRC_MODULE_ENABLED */
N
N#ifdef HAL_DAC_MODULE_ENABLED
S #include "stm32f0xx_hal_dac.h"
N#endif /* HAL_DAC_MODULE_ENABLED */
N
N#ifdef HAL_FLASH_MODULE_ENABLED
N #include "stm32f0xx_hal_flash.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_flash.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_flash.h
N  * @author  MCD Application Team
N  * @brief   Header file of Flash HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_FLASH_H
N#define __STM32F0xx_HAL_FLASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N   
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup FLASH
N  * @{
N  */
N  
N/** @addtogroup FLASH_Private_Constants
N  * @{
N  */
N#define FLASH_TIMEOUT_VALUE      (50000U) /* 50 s */
N/**
N  * @}
N  */
N
N/** @addtogroup FLASH_Private_Macros
N  * @{
N  */
N
N#define IS_FLASH_TYPEPROGRAM(VALUE)  (((VALUE) == FLASH_TYPEPROGRAM_HALFWORD) || \
N                                      ((VALUE) == FLASH_TYPEPROGRAM_WORD)     || \
N                                      ((VALUE) == FLASH_TYPEPROGRAM_DOUBLEWORD))  
X#define IS_FLASH_TYPEPROGRAM(VALUE)  (((VALUE) == FLASH_TYPEPROGRAM_HALFWORD) ||                                       ((VALUE) == FLASH_TYPEPROGRAM_WORD)     ||                                       ((VALUE) == FLASH_TYPEPROGRAM_DOUBLEWORD))  
N
N#define IS_FLASH_LATENCY(__LATENCY__) (((__LATENCY__) == FLASH_LATENCY_0) || \
N                                       ((__LATENCY__) == FLASH_LATENCY_1))
X#define IS_FLASH_LATENCY(__LATENCY__) (((__LATENCY__) == FLASH_LATENCY_0) ||                                        ((__LATENCY__) == FLASH_LATENCY_1))
N
N/**
N  * @}
N  */  
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup FLASH_Exported_Types FLASH Exported Types
N  * @{
N  */  
N
N/**
N  * @brief  FLASH Procedure structure definition
N  */
Ntypedef enum 
N{
N  FLASH_PROC_NONE              = 0U, 
N  FLASH_PROC_PAGEERASE         = 1U,
N  FLASH_PROC_MASSERASE         = 2U,
N  FLASH_PROC_PROGRAMHALFWORD   = 3U,
N  FLASH_PROC_PROGRAMWORD       = 4U,
N  FLASH_PROC_PROGRAMDOUBLEWORD = 5U
N} FLASH_ProcedureTypeDef;
N
N/** 
N  * @brief  FLASH handle Structure definition  
N  */
Ntypedef struct
N{
N  __IO FLASH_ProcedureTypeDef ProcedureOnGoing; /*!< Internal variable to indicate which procedure is ongoing or not in IT context */
X  volatile FLASH_ProcedureTypeDef ProcedureOnGoing;  
N  
N  __IO uint32_t               DataRemaining;    /*!< Internal variable to save the remaining pages to erase or half-word to program in IT context */
X  volatile uint32_t               DataRemaining;     
N
N  __IO uint32_t               Address;          /*!< Internal variable to save address selected for program or erase */
X  volatile uint32_t               Address;           
N
N  __IO uint64_t               Data;             /*!< Internal variable to save data to be programmed */
X  volatile uint64_t               Data;              
N
N  HAL_LockTypeDef             Lock;             /*!< FLASH locking object                */
N
N  __IO uint32_t               ErrorCode;        /*!< FLASH error code                    
X  volatile uint32_t               ErrorCode;        
N                                                     This parameter can be a value of @ref FLASH_Error_Codes  */
N} FLASH_ProcessTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup FLASH_Exported_Constants FLASH Exported Constants
N  * @{
N  */  
N
N/** @defgroup FLASH_Error_Codes FLASH Error Codes
N  * @{
N  */
N
N#define HAL_FLASH_ERROR_NONE      0x00U  /*!< No error */
N#define HAL_FLASH_ERROR_PROG      0x01U  /*!< Programming error */
N#define HAL_FLASH_ERROR_WRP       0x02U  /*!< Write protection error */
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Type_Program FLASH Type Program
N  * @{
N  */ 
N#define FLASH_TYPEPROGRAM_HALFWORD   (0x01U)  /*!<Program a half-word (16-bit) at a specified address.*/
N#define FLASH_TYPEPROGRAM_WORD       (0x02U)  /*!<Program a word (32-bit) at a specified address.*/
N#define FLASH_TYPEPROGRAM_DOUBLEWORD (0x03U)  /*!<Program a double word (64-bit) at a specified address*/
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Latency FLASH Latency
N  * @{
N  */ 
N#define FLASH_LATENCY_0            (0x00000000U)    /*!< FLASH Zero Latency cycle */
N#define FLASH_LATENCY_1            FLASH_ACR_LATENCY         /*!< FLASH One Latency cycle */
N
N/**
N  * @}
N  */
N
N
N/** @defgroup FLASH_Flag_definition FLASH Flag definition
N  * @{
N  */ 
N#define FLASH_FLAG_BSY             FLASH_SR_BSY            /*!< FLASH Busy flag                           */ 
N#define FLASH_FLAG_PGERR           FLASH_SR_PGERR          /*!< FLASH Programming error flag    */
N#define FLASH_FLAG_WRPERR          FLASH_SR_WRPERR         /*!< FLASH Write protected error flag          */
N#define FLASH_FLAG_EOP             FLASH_SR_EOP            /*!< FLASH End of Operation flag               */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Interrupt_definition FLASH Interrupt definition
N  * @{
N  */ 
N#define FLASH_IT_EOP               FLASH_CR_EOPIE          /*!< End of FLASH Operation Interrupt source */
N#define FLASH_IT_ERR               FLASH_CR_ERRIE  /*!< Error Interrupt source */
N/**
N  * @}
N  */  
N
N/**
N  * @}
N  */  
N  
N/* Exported macro ------------------------------------------------------------*/
N
N/** @defgroup FLASH_Exported_Macros FLASH Exported Macros
N *  @brief macros to control FLASH features 
N *  @{
N */
N 
N
N/** @defgroup FLASH_EM_Latency FLASH Latency
N *  @brief macros to handle FLASH Latency
N * @{
N */ 
N  
N/**
N  * @brief  Set the FLASH Latency.
N  * @param  __LATENCY__ FLASH Latency                   
N  *         The value of this parameter depend on device used within the same series
N  * @retval None
N  */ 
N#define __HAL_FLASH_SET_LATENCY(__LATENCY__)    (FLASH->ACR = (FLASH->ACR&(~FLASH_ACR_LATENCY)) | (__LATENCY__))
N
N
N/**
N  * @brief  Get the FLASH Latency.
N  * @retval FLASH Latency                   
N  *         The value of this parameter depend on device used within the same series
N  */ 
N#define __HAL_FLASH_GET_LATENCY()     (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY))
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Prefetch FLASH Prefetch
N *  @brief macros to handle FLASH Prefetch buffer
N * @{
N */   
N/**
N  * @brief  Enable the FLASH prefetch buffer.
N  * @retval None
N  */ 
N#define __HAL_FLASH_PREFETCH_BUFFER_ENABLE()    (FLASH->ACR |= FLASH_ACR_PRFTBE)
N
N/**
N  * @brief  Disable the FLASH prefetch buffer.
N  * @retval None
N  */
N#define __HAL_FLASH_PREFETCH_BUFFER_DISABLE()   (FLASH->ACR &= (~FLASH_ACR_PRFTBE))
N
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Interrupt FLASH Interrupts
N *  @brief macros to handle FLASH interrupts
N * @{
N */ 
N
N/**
N  * @brief  Enable the specified FLASH interrupt.
N  * @param  __INTERRUPT__  FLASH interrupt 
N  *         This parameter can be any combination of the following values:
N  *     @arg @ref FLASH_IT_EOP End of FLASH Operation Interrupt
N  *     @arg @ref FLASH_IT_ERR Error Interrupt    
N  * @retval none
N  */  
N#define __HAL_FLASH_ENABLE_IT(__INTERRUPT__)  SET_BIT((FLASH->CR), (__INTERRUPT__))
N
N/**
N  * @brief  Disable the specified FLASH interrupt.
N  * @param  __INTERRUPT__  FLASH interrupt 
N  *         This parameter can be any combination of the following values:
N  *     @arg @ref FLASH_IT_EOP End of FLASH Operation Interrupt
N  *     @arg @ref FLASH_IT_ERR Error Interrupt    
N  * @retval none
N  */  
N#define __HAL_FLASH_DISABLE_IT(__INTERRUPT__)  CLEAR_BIT((FLASH->CR), (uint32_t)(__INTERRUPT__))
N
N/**
N  * @brief  Get the specified FLASH flag status. 
N  * @param  __FLAG__ specifies the FLASH flag to check.
N  *          This parameter can be one of the following values:
N  *            @arg @ref FLASH_FLAG_BSY         FLASH Busy flag
N  *            @arg @ref FLASH_FLAG_EOP         FLASH End of Operation flag 
N  *            @arg @ref FLASH_FLAG_WRPERR      FLASH Write protected error flag 
N  *            @arg @ref FLASH_FLAG_PGERR       FLASH Programming error flag
N  * @retval The new state of __FLAG__ (SET or RESET).
N  */
N#define __HAL_FLASH_GET_FLAG(__FLAG__)   (((FLASH->SR) & (__FLAG__)) == (__FLAG__))
N
N/**
N  * @brief  Clear the specified FLASH flag.
N  * @param  __FLAG__ specifies the FLASH flags to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg @ref FLASH_FLAG_EOP         FLASH End of Operation flag 
N  *            @arg @ref FLASH_FLAG_WRPERR      FLASH Write protected error flag 
N  *            @arg @ref FLASH_FLAG_PGERR       FLASH Programming error flag
N  * @retval none
N  */
N#define __HAL_FLASH_CLEAR_FLAG(__FLAG__)   ((FLASH->SR) = (__FLAG__))
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Include FLASH HAL Extended module */
N#include "stm32f0xx_hal_flash_ex.h"  
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_flash_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_flash_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of Flash HAL Extended module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_FLASH_EX_H
N#define __STM32F0xx_HAL_FLASH_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup FLASHEx
N  * @{
N  */ 
N
N/** @addtogroup FLASHEx_Private_Macros
N  * @{
N  */
N#define IS_FLASH_TYPEERASE(VALUE) (((VALUE) == FLASH_TYPEERASE_PAGES) || \
N                             ((VALUE) == FLASH_TYPEERASE_MASSERASE))  
X#define IS_FLASH_TYPEERASE(VALUE) (((VALUE) == FLASH_TYPEERASE_PAGES) ||                              ((VALUE) == FLASH_TYPEERASE_MASSERASE))  
N
N#define IS_OPTIONBYTE(VALUE) ((VALUE) <= (OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER | OPTIONBYTE_DATA))
N
N#define IS_WRPSTATE(VALUE) (((VALUE) == OB_WRPSTATE_DISABLE) || \
N                            ((VALUE) == OB_WRPSTATE_ENABLE))  
X#define IS_WRPSTATE(VALUE) (((VALUE) == OB_WRPSTATE_DISABLE) ||                             ((VALUE) == OB_WRPSTATE_ENABLE))  
N
N#define IS_OB_DATA_ADDRESS(ADDRESS) (((ADDRESS) == OB_DATA_ADDRESS_DATA0) || ((ADDRESS) == OB_DATA_ADDRESS_DATA1)) 
N
N#define IS_OB_RDP_LEVEL(LEVEL)     (((LEVEL) == OB_RDP_LEVEL_0)   ||\
N                                    ((LEVEL) == OB_RDP_LEVEL_1))/*||\
N                                    ((LEVEL) == OB_RDP_LEVEL_2))*/
X#define IS_OB_RDP_LEVEL(LEVEL)     (((LEVEL) == OB_RDP_LEVEL_0)   ||                                    ((LEVEL) == OB_RDP_LEVEL_1)) 
N
N#define IS_OB_IWDG_SOURCE(SOURCE)  (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
N
N#define IS_OB_STOP_SOURCE(SOURCE)  (((SOURCE) == OB_STOP_NO_RST) || ((SOURCE) == OB_STOP_RST))
N
N#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NO_RST) || ((SOURCE) == OB_STDBY_RST))
N
N#define IS_OB_BOOT1(BOOT1)         (((BOOT1) == OB_BOOT1_RESET) || ((BOOT1) == OB_BOOT1_SET))
N
N#define IS_OB_VDDA_ANALOG(ANALOG)  (((ANALOG) == OB_VDDA_ANALOG_ON) || ((ANALOG) == OB_VDDA_ANALOG_OFF))
N
N#define IS_OB_SRAM_PARITY(PARITY)  (((PARITY) == OB_SRAM_PARITY_SET) || ((PARITY) == OB_SRAM_PARITY_RESET))
N
N#if defined(FLASH_OBR_BOOT_SEL)
X#if 1L
N#define IS_OB_BOOT_SEL(BOOT_SEL)   (((BOOT_SEL) == OB_BOOT_SEL_RESET) || ((BOOT_SEL) == OB_BOOT_SEL_SET))
N#define IS_OB_BOOT0(BOOT0)         (((BOOT0) == OB_BOOT0_RESET) || ((BOOT0) == OB_BOOT0_SET))
N#endif /* FLASH_OBR_BOOT_SEL */
N
N
N#define IS_OB_WRP(PAGE) (((PAGE) != 0x0000000U))
N
N#define IS_FLASH_NB_PAGES(ADDRESS,NBPAGES) ((ADDRESS)+((NBPAGES)*FLASH_PAGE_SIZE)-1 <= FLASH_BANK1_END)
N
N#define IS_FLASH_PROGRAM_ADDRESS(ADDRESS) (((ADDRESS) >= FLASH_BASE) && ((ADDRESS) <= FLASH_BANK1_END))
N
N/**
N  * @}
N  */
N
N/* Exported types ------------------------------------------------------------*/ 
N/** @defgroup FLASHEx_Exported_Types FLASHEx Exported Types
N  * @{
N  */
N/**
N  * @brief  FLASH Erase structure definition
N  */
Ntypedef struct
N{
N  uint32_t TypeErase;   /*!< TypeErase: Mass erase or page erase.
N                             This parameter can be a value of @ref FLASHEx_Type_Erase */
N
N  uint32_t PageAddress; /*!< PageAdress: Initial FLASH page address to erase when mass erase is disabled
N                             This parameter must be a number between Min_Data = FLASH_BASE and Max_Data = FLASH_BANK1_END */
N  
N  uint32_t NbPages;     /*!< NbPages: Number of pagess to be erased.
N                             This parameter must be a value between Min_Data = 1 and Max_Data = (max number of pages - value of initial page)*/
N                                                          
N} FLASH_EraseInitTypeDef;
N
N/**
N  * @brief  FLASH Options bytes program structure definition
N  */
Ntypedef struct
N{
N  uint32_t OptionType;  /*!< OptionType: Option byte to be configured.
N                             This parameter can be a value of @ref FLASHEx_OB_Type */
N
N  uint32_t WRPState;    /*!< WRPState: Write protection activation or deactivation.
N                             This parameter can be a value of @ref FLASHEx_OB_WRP_State */
N
N  uint32_t WRPPage;     /*!< WRPPage: specifies the page(s) to be write protected
N                             This parameter can be a value of @ref FLASHEx_OB_Write_Protection */
N
N  uint8_t RDPLevel;     /*!< RDPLevel: Set the read protection level..
N                             This parameter can be a value of @ref FLASHEx_OB_Read_Protection */
N
N  uint8_t USERConfig;   /*!< USERConfig: Program the FLASH User Option Byte: 
N                             IWDG / STOP / STDBY / BOOT1 / VDDA_ANALOG / SRAM_PARITY
N                             This parameter can be a combination of @ref FLASHEx_OB_IWatchdog, @ref FLASHEx_OB_nRST_STOP,
N                             @ref FLASHEx_OB_nRST_STDBY, @ref FLASHEx_OB_BOOT1, @ref FLASHEx_OB_VDDA_Analog_Monitoring and
N                             @ref FLASHEx_OB_RAM_Parity_Check_Enable */
N
N  uint32_t DATAAddress; /*!< DATAAddress: Address of the option byte DATA to be programmed
N                             This parameter can be a value of @ref FLASHEx_OB_Data_Address */
N  
N  uint8_t DATAData;     /*!< DATAData: Data to be stored in the option byte DATA
N                             This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF */  
N} FLASH_OBProgramInitTypeDef;
N/**
N  * @}
N  */  
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup FLASHEx_Exported_Constants FLASHEx Exported Constants
N  * @{
N  */
N
N/** @defgroup FLASHEx_Page_Size FLASHEx Page Size
N  * @{
N  */
N#if defined(STM32F030x6) || defined(STM32F030x8) || defined(STM32F031x6) || defined(STM32F038xx) \
N || defined(STM32F051x8) || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F058xx) || defined(STM32F070x6)
X#if 0L || 0L || 0L || 0L  || 0L || 0L || 0L || 0L || 0L
S#define FLASH_PAGE_SIZE          0x400U
N#endif /* STM32F030x6 || STM32F030x8 || STM32F031x6 || STM32F051x8 || STM32F042x6 || STM32F048xx || STM32F058xx || STM32F070x6 */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) \
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L  || 1L || 0L || 0L
N#define FLASH_PAGE_SIZE          0x800U
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F091xC || STM32F098xx || STM32F030xC */
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_Type_Erase FLASH Type Erase
N  * @{
N  */ 
N#define FLASH_TYPEERASE_PAGES     (0x00U)  /*!<Pages erase only*/
N#define FLASH_TYPEERASE_MASSERASE (0x01U)  /*!<Flash mass erase activation*/
N
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_OptionByte_Constants Option Byte Constants
N  * @{
N  */ 
N
N/** @defgroup FLASHEx_OB_Type Option Bytes Type
N  * @{
N  */
N#define OPTIONBYTE_WRP       (0x01U)  /*!<WRP option byte configuration*/
N#define OPTIONBYTE_RDP       (0x02U)  /*!<RDP option byte configuration*/
N#define OPTIONBYTE_USER      (0x04U)  /*!<USER option byte configuration*/
N#define OPTIONBYTE_DATA      (0x08U)  /*!<DATA option byte configuration*/
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_OB_WRP_State Option Byte WRP State
N  * @{
N  */ 
N#define OB_WRPSTATE_DISABLE   (0x00U)  /*!<Disable the write protection of the desired pages*/
N#define OB_WRPSTATE_ENABLE    (0x01U)  /*!<Enable the write protection of the desired pagess*/
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_OB_Write_Protection FLASHEx OB Write Protection
N  * @{
N  */
N#if defined(STM32F030x6) || defined(STM32F030x8) || defined(STM32F031x6) || defined(STM32F038xx) \
N || defined(STM32F051x8) || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F058xx) || defined(STM32F070x6) 
X#if 0L || 0L || 0L || 0L  || 0L || 0L || 0L || 0L || 0L 
S#define OB_WRP_PAGES0TO3               (0x00000001U) /* Write protection of page 0 to 3 */
S#define OB_WRP_PAGES4TO7               (0x00000002U) /* Write protection of page 4 to 7 */
S#define OB_WRP_PAGES8TO11              (0x00000004U) /* Write protection of page 8 to 11 */
S#define OB_WRP_PAGES12TO15             (0x00000008U) /* Write protection of page 12 to 15 */
S#define OB_WRP_PAGES16TO19             (0x00000010U) /* Write protection of page 16 to 19 */
S#define OB_WRP_PAGES20TO23             (0x00000020U) /* Write protection of page 20 to 23 */
S#define OB_WRP_PAGES24TO27             (0x00000040U) /* Write protection of page 24 to 27 */
S#define OB_WRP_PAGES28TO31             (0x00000080U) /* Write protection of page 28 to 31 */
S#if defined(STM32F030x8) || defined(STM32F051x8) || defined(STM32F058xx)
S#define OB_WRP_PAGES32TO35             (0x00000100U) /* Write protection of page 32 to 35 */
S#define OB_WRP_PAGES36TO39             (0x00000200U) /* Write protection of page 36 to 39 */
S#define OB_WRP_PAGES40TO43             (0x00000400U) /* Write protection of page 40 to 43 */
S#define OB_WRP_PAGES44TO47             (0x00000800U) /* Write protection of page 44 to 47 */
S#define OB_WRP_PAGES48TO51             (0x00001000U) /* Write protection of page 48 to 51 */
S#define OB_WRP_PAGES52TO57             (0x00002000U) /* Write protection of page 52 to 57 */
S#define OB_WRP_PAGES56TO59             (0x00004000U) /* Write protection of page 56 to 59 */
S#define OB_WRP_PAGES60TO63             (0x00008000U) /* Write protection of page 60 to 63 */
S#endif /* STM32F030x8 || STM32F051x8 || STM32F058xx */
S
S#if defined(STM32F030x6) || defined(STM32F030x8) || defined(STM32F031x6) || defined(STM32F038xx) \
S || defined(STM32F051x8) || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F058xx) || defined(STM32F070x6) 
X#if defined(STM32F030x6) || defined(STM32F030x8) || defined(STM32F031x6) || defined(STM32F038xx)  || defined(STM32F051x8) || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F058xx) || defined(STM32F070x6) 
S#define OB_WRP_PAGES0TO31MASK          (0x000000FFU)
S#endif /* STM32F030x6 || STM32F030x8 || STM32F031x6 || STM32F051x8 || STM32F042x6 || STM32F048xx || STM32F038xx || STM32F058xx || STM32F070x6 */
S
S#if defined(STM32F030x8) || defined(STM32F051x8) || defined(STM32F058xx)
S#define OB_WRP_PAGES32TO63MASK         (0x0000FF00U)
S#endif /* STM32F030x8 || STM32F051x8 || STM32F058xx */
S
S#if defined(STM32F030x6) || defined(STM32F031x6) || defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F038xx)|| defined(STM32F070x6)
S#define OB_WRP_ALLPAGES                (0x000000FFU) /*!< Write protection of all pages */
S#endif /* STM32F030x6 || STM32F031x6 || STM32F042x6 || STM32F048xx || STM32F038xx || STM32F070x6 */
S
S#if defined(STM32F030x8) || defined(STM32F051x8) || defined(STM32F058xx)
S#define OB_WRP_ALLPAGES                (0x0000FFFFU) /*!< Write protection of all pages */
S#endif /* STM32F030x8 || STM32F051x8 || STM32F058xx */
N#endif /* STM32F030x6 || STM32F030x8 || STM32F031x6 || STM32F051x8 || STM32F042x6 || STM32F048xx || STM32F038xx || STM32F058xx || STM32F070x6 */
N      
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) \
N || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L  || 1L || 0L || 0L
N#define OB_WRP_PAGES0TO1               (0x00000001U) /* Write protection of page 0 to 1 */
N#define OB_WRP_PAGES2TO3               (0x00000002U) /* Write protection of page 2 to 3 */
N#define OB_WRP_PAGES4TO5               (0x00000004U) /* Write protection of page 4 to 5 */
N#define OB_WRP_PAGES6TO7               (0x00000008U) /* Write protection of page 6 to 7 */
N#define OB_WRP_PAGES8TO9               (0x00000010U) /* Write protection of page 8 to 9 */
N#define OB_WRP_PAGES10TO11             (0x00000020U) /* Write protection of page 10 to 11 */
N#define OB_WRP_PAGES12TO13             (0x00000040U) /* Write protection of page 12 to 13 */
N#define OB_WRP_PAGES14TO15             (0x00000080U) /* Write protection of page 14 to 15 */
N#define OB_WRP_PAGES16TO17             (0x00000100U) /* Write protection of page 16 to 17 */
N#define OB_WRP_PAGES18TO19             (0x00000200U) /* Write protection of page 18 to 19 */
N#define OB_WRP_PAGES20TO21             (0x00000400U) /* Write protection of page 20 to 21 */
N#define OB_WRP_PAGES22TO23             (0x00000800U) /* Write protection of page 22 to 23 */
N#define OB_WRP_PAGES24TO25             (0x00001000U) /* Write protection of page 24 to 25 */
N#define OB_WRP_PAGES26TO27             (0x00002000U) /* Write protection of page 26 to 27 */
N#define OB_WRP_PAGES28TO29             (0x00004000U) /* Write protection of page 28 to 29 */
N#define OB_WRP_PAGES30TO31             (0x00008000U) /* Write protection of page 30 to 31 */
N#define OB_WRP_PAGES32TO33             (0x00010000U) /* Write protection of page 32 to 33 */
N#define OB_WRP_PAGES34TO35             (0x00020000U) /* Write protection of page 34 to 35 */
N#define OB_WRP_PAGES36TO37             (0x00040000U) /* Write protection of page 36 to 37 */
N#define OB_WRP_PAGES38TO39             (0x00080000U) /* Write protection of page 38 to 39 */
N#define OB_WRP_PAGES40TO41             (0x00100000U) /* Write protection of page 40 to 41 */
N#define OB_WRP_PAGES42TO43             (0x00200000U) /* Write protection of page 42 to 43 */
N#define OB_WRP_PAGES44TO45             (0x00400000U) /* Write protection of page 44 to 45 */
N#define OB_WRP_PAGES46TO47             (0x00800000U) /* Write protection of page 46 to 47 */
N#define OB_WRP_PAGES48TO49             (0x01000000U) /* Write protection of page 48 to 49 */
N#define OB_WRP_PAGES50TO51             (0x02000000U) /* Write protection of page 50 to 51 */
N#define OB_WRP_PAGES52TO53             (0x04000000U) /* Write protection of page 52 to 53 */
N#define OB_WRP_PAGES54TO55             (0x08000000U) /* Write protection of page 54 to 55 */
N#define OB_WRP_PAGES56TO57             (0x10000000U) /* Write protection of page 56 to 57 */
N#define OB_WRP_PAGES58TO59             (0x20000000U) /* Write protection of page 58 to 59 */
N#define OB_WRP_PAGES60TO61             (0x40000000U) /* Write protection of page 60 to 61 */
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)
X#if 0L || 0L || 0L || 0L
S#define OB_WRP_PAGES62TO63             (0x80000000U) /* Write protection of page 62 to 63 */
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB */
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 1L || 0L || 0L
N#define OB_WRP_PAGES62TO127            (0x80000000U) /* Write protection of page 62 to 127 */
N#endif /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) \
N || defined(STM32F091xC) || defined(STM32F098xx)|| defined(STM32F030xC)
X#if 0L || 0L || 0L || 0L  || 1L || 0L|| 0L
N#define OB_WRP_PAGES0TO15MASK          (0x000000FFU)
N#define OB_WRP_PAGES16TO31MASK         (0x0000FF00U)
N#define OB_WRP_PAGES32TO47MASK         (0x00FF0000U)
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx  || STM32F091xC || STM32F098xx || STM32F070xB || STM32F030xC */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB)
X#if 0L || 0L || 0L || 0L
S#define OB_WRP_PAGES48TO63MASK         (0xFF000000U)
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx || STM32F070xB */
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC)
X#if 1L || 0L || 0L
N#define OB_WRP_PAGES48TO127MASK        (0xFF000000U)
N#endif /* STM32F091xC || STM32F098xx || STM32F030xC */
N
N#define OB_WRP_ALLPAGES                (0xFFFFFFFFU) /*!< Write protection of all pages */
N#endif /* STM32F071xB || STM32F072xB || STM32F078xx  || STM32F091xC || STM32F098xx || STM32F030xC || STM32F070xB */
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_OB_Read_Protection Option Byte Read Protection
N  * @{
N  */
N#define OB_RDP_LEVEL_0             ((uint8_t)0xAAU)
N#define OB_RDP_LEVEL_1             ((uint8_t)0xBBU)
N#define OB_RDP_LEVEL_2             ((uint8_t)0xCCU) /*!< Warning: When enabling read protection level 2 
N                                                      it's no more possible to go back to level 1 or 0 */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_OB_IWatchdog Option Byte IWatchdog
N  * @{
N  */ 
N#define OB_IWDG_SW                 ((uint8_t)0x01U)  /*!< Software IWDG selected */
N#define OB_IWDG_HW                 ((uint8_t)0x00U)  /*!< Hardware IWDG selected */
N/**
N  * @}
N  */
N  
N/** @defgroup FLASHEx_OB_nRST_STOP Option Byte nRST STOP
N  * @{
N  */ 
N#define OB_STOP_NO_RST             ((uint8_t)0x02U) /*!< No reset generated when entering in STOP */
N#define OB_STOP_RST                ((uint8_t)0x00U) /*!< Reset generated when entering in STOP */
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_OB_nRST_STDBY Option Byte nRST STDBY
N  * @{
N  */ 
N#define OB_STDBY_NO_RST            ((uint8_t)0x04U) /*!< No reset generated when entering in STANDBY */
N#define OB_STDBY_RST               ((uint8_t)0x00U) /*!< Reset generated when entering in STANDBY */
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_OB_BOOT1 Option Byte BOOT1
N  * @{
N  */
N#define OB_BOOT1_RESET             ((uint8_t)0x00U) /*!< BOOT1 Reset */
N#define OB_BOOT1_SET               ((uint8_t)0x10U) /*!< BOOT1 Set */
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_OB_VDDA_Analog_Monitoring Option Byte VDDA Analog Monitoring
N  * @{
N  */
N#define OB_VDDA_ANALOG_ON          ((uint8_t)0x20U) /*!< Analog monitoring on VDDA Power source ON */
N#define OB_VDDA_ANALOG_OFF         ((uint8_t)0x00U) /*!< Analog monitoring on VDDA Power source OFF */
N/**
N  * @}
N  */
N
N/** @defgroup FLASHEx_OB_RAM_Parity_Check_Enable Option Byte SRAM Parity Check Enable
N  * @{
N  */
N#define OB_SRAM_PARITY_SET         ((uint8_t)0x00U) /*!< SRAM parity check enable set */
N#define OB_SRAM_PARITY_RESET       ((uint8_t)0x40U) /*!< SRAM parity check enable reset */
N/**
N  * @}
N  */
N
N#if defined(FLASH_OBR_BOOT_SEL)
X#if 1L
N/** @defgroup FLASHEx_OB_BOOT_SEL FLASHEx Option Byte BOOT SEL
N  * @{
N  */
N#define OB_BOOT_SEL_RESET          ((uint8_t)0x00U) /*!< BOOT_SEL Reset */
N#define OB_BOOT_SEL_SET            ((uint8_t)0x80U) /*!< BOOT_SEL Set */
N/**
N  * @}
N  */  
N
N/** @defgroup FLASHEx_OB_BOOT0 FLASHEx Option Byte BOOT0
N  * @{
N  */
N#define OB_BOOT0_RESET             ((uint8_t)0x00U) /*!< BOOT0 Reset */
N#define OB_BOOT0_SET               ((uint8_t)0x08U) /*!< BOOT0 Set */
N/**
N  * @}
N  */
N#endif /* FLASH_OBR_BOOT_SEL */
N
N
N/** @defgroup FLASHEx_OB_Data_Address  Option Byte Data Address
N  * @{
N  */
N#define OB_DATA_ADDRESS_DATA0     (0x1FFFF804U)
N#define OB_DATA_ADDRESS_DATA1     (0x1FFFF806U)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup FLASHEx_Exported_Functions
N  * @{
N  */
N  
N/** @addtogroup FLASHEx_Exported_Functions_Group1
N  * @{
N  */   
N/* IO operation functions *****************************************************/
NHAL_StatusTypeDef  HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError);
NHAL_StatusTypeDef  HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit);
N
N/**
N  * @}
N  */ 
N
N/** @addtogroup FLASHEx_Exported_Functions_Group2
N  * @{
N  */   
N/* Peripheral Control functions ***********************************************/
NHAL_StatusTypeDef  HAL_FLASHEx_OBErase(void);
NHAL_StatusTypeDef  HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
Nvoid               HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
Nuint32_t           HAL_FLASHEx_OBGetUserData(uint32_t DATAAdress);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_FLASH_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 293 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_flash.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup FLASH_Exported_Functions
N  * @{
N  */
N  
N/** @addtogroup FLASH_Exported_Functions_Group1
N  * @{
N  */
N/* IO operation functions *****************************************************/
NHAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
NHAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
N
N/* FLASH IRQ handler function */
Nvoid       HAL_FLASH_IRQHandler(void);
N/* Callbacks in non blocking modes */ 
Nvoid       HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue);
Nvoid       HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue);
N
N/**
N  * @}
N  */
N
N/** @addtogroup FLASH_Exported_Functions_Group2
N  * @{
N  */
N/* Peripheral Control functions ***********************************************/
NHAL_StatusTypeDef HAL_FLASH_Unlock(void);
NHAL_StatusTypeDef HAL_FLASH_Lock(void);
NHAL_StatusTypeDef HAL_FLASH_OB_Unlock(void);
NHAL_StatusTypeDef HAL_FLASH_OB_Lock(void);
NHAL_StatusTypeDef HAL_FLASH_OB_Launch(void);
N
N/**
N  * @}
N  */
N
N/** @addtogroup FLASH_Exported_Functions_Group3
N  * @{
N  */
N/* Peripheral State and Error functions ***************************************/
Nuint32_t HAL_FLASH_GetError(void);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private function -------------------------------------------------*/
N/** @addtogroup FLASH_Private_Functions
N * @{
N */
NHAL_StatusTypeDef       FLASH_WaitForLastOperation(uint32_t Timeout);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_FLASH_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 238 "../Inc/stm32f0xx_hal_conf.h" 2
N#endif /* HAL_FLASH_MODULE_ENABLED */
N
N#ifdef HAL_I2C_MODULE_ENABLED
N #include "stm32f0xx_hal_i2c.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_i2c.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_i2c.h
N  * @author  MCD Application Team
N  * @brief   Header file of I2C HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_I2C_H
N#define __STM32F0xx_HAL_I2C_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup I2C
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup I2C_Exported_Types I2C Exported Types
N  * @{
N  */
N
N/** @defgroup I2C_Configuration_Structure_definition I2C Configuration Structure definition
N  * @brief  I2C Configuration Structure definition
N  * @{
N  */
Ntypedef struct
N{
N  uint32_t Timing;              /*!< Specifies the I2C_TIMINGR_register value.
N                                  This parameter calculated by referring to I2C initialization
N                                         section in Reference manual */
N
N  uint32_t OwnAddress1;         /*!< Specifies the first device own address.
N                                  This parameter can be a 7-bit or 10-bit address. */
N
N  uint32_t AddressingMode;      /*!< Specifies if 7-bit or 10-bit addressing mode is selected.
N                                  This parameter can be a value of @ref I2C_ADDRESSING_MODE */
N
N  uint32_t DualAddressMode;     /*!< Specifies if dual addressing mode is selected.
N                                  This parameter can be a value of @ref I2C_DUAL_ADDRESSING_MODE */
N
N  uint32_t OwnAddress2;         /*!< Specifies the second device own address if dual addressing mode is selected
N                                  This parameter can be a 7-bit address. */
N
N  uint32_t OwnAddress2Masks;    /*!< Specifies the acknowledge mask address second device own address if dual addressing mode is selected
N                                  This parameter can be a value of @ref I2C_OWN_ADDRESS2_MASKS */
N
N  uint32_t GeneralCallMode;     /*!< Specifies if general call mode is selected.
N                                  This parameter can be a value of @ref I2C_GENERAL_CALL_ADDRESSING_MODE */
N
N  uint32_t NoStretchMode;       /*!< Specifies if nostretch mode is selected.
N                                  This parameter can be a value of @ref I2C_NOSTRETCH_MODE */
N
N} I2C_InitTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_state_structure_definition HAL state structure definition
N  * @brief  HAL State structure definition
N  * @note  HAL I2C State value coding follow below described bitmap :\n
N  *          b7-b6  Error information\n
N  *             00 : No Error\n
N  *             01 : Abort (Abort user request on going)\n
N  *             10 : Timeout\n
N  *             11 : Error\n
N  *          b5     IP initilisation status\n
N  *             0  : Reset (IP not initialized)\n
N  *             1  : Init done (IP initialized and ready to use. HAL I2C Init function called)\n
N  *          b4     (not used)\n
N  *             x  : Should be set to 0\n
N  *          b3\n
N  *             0  : Ready or Busy (No Listen mode ongoing)\n
N  *             1  : Listen (IP in Address Listen Mode)\n
N  *          b2     Intrinsic process state\n
N  *             0  : Ready\n
N  *             1  : Busy (IP busy with some configuration or internal operations)\n
N  *          b1     Rx state\n
N  *             0  : Ready (no Rx operation ongoing)\n
N  *             1  : Busy (Rx operation ongoing)\n
N  *          b0     Tx state\n
N  *             0  : Ready (no Tx operation ongoing)\n
N  *             1  : Busy (Tx operation ongoing)
N  * @{
N  */
Ntypedef enum
N{
N  HAL_I2C_STATE_RESET             = 0x00U,   /*!< Peripheral is not yet Initialized         */
N  HAL_I2C_STATE_READY             = 0x20U,   /*!< Peripheral Initialized and ready for use  */
N  HAL_I2C_STATE_BUSY              = 0x24U,   /*!< An internal process is ongoing            */
N  HAL_I2C_STATE_BUSY_TX           = 0x21U,   /*!< Data Transmission process is ongoing      */
N  HAL_I2C_STATE_BUSY_RX           = 0x22U,   /*!< Data Reception process is ongoing         */
N  HAL_I2C_STATE_LISTEN            = 0x28U,   /*!< Address Listen Mode is ongoing            */
N  HAL_I2C_STATE_BUSY_TX_LISTEN    = 0x29U,   /*!< Address Listen Mode and Data Transmission
N                                                 process is ongoing                         */
N  HAL_I2C_STATE_BUSY_RX_LISTEN    = 0x2AU,   /*!< Address Listen Mode and Data Reception
N                                                 process is ongoing                         */
N  HAL_I2C_STATE_ABORT             = 0x60U,   /*!< Abort user request ongoing                */
N  HAL_I2C_STATE_TIMEOUT           = 0xA0U,   /*!< Timeout state                             */
N  HAL_I2C_STATE_ERROR             = 0xE0U    /*!< Error                                     */
N
N} HAL_I2C_StateTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup HAL_mode_structure_definition HAL mode structure definition
N  * @brief  HAL Mode structure definition
N  * @note  HAL I2C Mode value coding follow below described bitmap :\n
N  *          b7     (not used)\n
N  *             x  : Should be set to 0\n
N  *          b6\n
N  *             0  : None\n
N  *             1  : Memory (HAL I2C communication is in Memory Mode)\n
N  *          b5\n
N  *             0  : None\n
N  *             1  : Slave (HAL I2C communication is in Slave Mode)\n
N  *          b4\n
N  *             0  : None\n
N  *             1  : Master (HAL I2C communication is in Master Mode)\n
N  *          b3-b2-b1-b0  (not used)\n
N  *             xxxx : Should be set to 0000
N  * @{
N  */
Ntypedef enum
N{
N  HAL_I2C_MODE_NONE               = 0x00U,   /*!< No I2C communication on going             */
N  HAL_I2C_MODE_MASTER             = 0x10U,   /*!< I2C communication is in Master Mode       */
N  HAL_I2C_MODE_SLAVE              = 0x20U,   /*!< I2C communication is in Slave Mode        */
N  HAL_I2C_MODE_MEM                = 0x40U    /*!< I2C communication is in Memory Mode       */
N
N} HAL_I2C_ModeTypeDef;
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Error_Code_definition I2C Error Code definition
N  * @brief  I2C Error Code definition
N  * @{
N  */
N#define HAL_I2C_ERROR_NONE      (0x00000000U)    /*!< No error              */
N#define HAL_I2C_ERROR_BERR      (0x00000001U)    /*!< BERR error            */
N#define HAL_I2C_ERROR_ARLO      (0x00000002U)    /*!< ARLO error            */
N#define HAL_I2C_ERROR_AF        (0x00000004U)    /*!< ACKF error            */
N#define HAL_I2C_ERROR_OVR       (0x00000008U)    /*!< OVR error             */
N#define HAL_I2C_ERROR_DMA       (0x00000010U)    /*!< DMA transfer error    */
N#define HAL_I2C_ERROR_TIMEOUT   (0x00000020U)    /*!< Timeout error         */
N#define HAL_I2C_ERROR_SIZE      (0x00000040U)    /*!< Size Management error */
N/**
N  * @}
N  */
N
N/** @defgroup I2C_handle_Structure_definition I2C handle Structure definition
N  * @brief  I2C handle Structure definition
N  * @{
N  */
Ntypedef struct __I2C_HandleTypeDef
N{
N  I2C_TypeDef                *Instance;      /*!< I2C registers base address                */
N
N  I2C_InitTypeDef            Init;           /*!< I2C communication parameters              */
N
N  uint8_t                    *pBuffPtr;      /*!< Pointer to I2C transfer buffer            */
N
N  uint16_t                   XferSize;       /*!< I2C transfer size                         */
N
N  __IO uint16_t              XferCount;      /*!< I2C transfer counter                      */
X  volatile uint16_t              XferCount;       
N
N  __IO uint32_t              XferOptions;    /*!< I2C sequantial transfer options, this parameter can
X  volatile uint32_t              XferOptions;    
N                                                  be a value of @ref I2C_XFEROPTIONS */
N
N  __IO uint32_t              PreviousState;  /*!< I2C communication Previous state          */
X  volatile uint32_t              PreviousState;   
N
N  HAL_StatusTypeDef(*XferISR)(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources);  /*!< I2C transfer IRQ handler function pointer */
N
N  DMA_HandleTypeDef          *hdmatx;        /*!< I2C Tx DMA handle parameters              */
N
N  DMA_HandleTypeDef          *hdmarx;        /*!< I2C Rx DMA handle parameters              */
N
N  HAL_LockTypeDef            Lock;           /*!< I2C locking object                        */
N
N  __IO HAL_I2C_StateTypeDef  State;          /*!< I2C communication state                   */
X  volatile HAL_I2C_StateTypeDef  State;           
N
N  __IO HAL_I2C_ModeTypeDef   Mode;           /*!< I2C communication mode                    */
X  volatile HAL_I2C_ModeTypeDef   Mode;            
N
N  __IO uint32_t              ErrorCode;      /*!< I2C Error code                            */
X  volatile uint32_t              ErrorCode;       
N
N  __IO uint32_t              AddrEventCount; /*!< I2C Address Event counter                 */
X  volatile uint32_t              AddrEventCount;  
N} I2C_HandleTypeDef;
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup I2C_Exported_Constants I2C Exported Constants
N  * @{
N  */
N
N/** @defgroup I2C_XFEROPTIONS  I2C Sequential Transfer Options
N  * @{
N  */
N#define I2C_FIRST_FRAME                 ((uint32_t)I2C_SOFTEND_MODE)
N#define I2C_FIRST_AND_NEXT_FRAME        ((uint32_t)(I2C_RELOAD_MODE | I2C_SOFTEND_MODE))
N#define I2C_NEXT_FRAME                  ((uint32_t)(I2C_RELOAD_MODE | I2C_SOFTEND_MODE))
N#define I2C_FIRST_AND_LAST_FRAME        ((uint32_t)I2C_AUTOEND_MODE)
N#define I2C_LAST_FRAME                  ((uint32_t)I2C_AUTOEND_MODE)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_ADDRESSING_MODE I2C Addressing Mode
N  * @{
N  */
N#define I2C_ADDRESSINGMODE_7BIT         (0x00000001U)
N#define I2C_ADDRESSINGMODE_10BIT        (0x00000002U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_DUAL_ADDRESSING_MODE I2C Dual Addressing Mode
N  * @{
N  */
N#define I2C_DUALADDRESS_DISABLE         (0x00000000U)
N#define I2C_DUALADDRESS_ENABLE          I2C_OAR2_OA2EN
N/**
N  * @}
N  */
N
N/** @defgroup I2C_OWN_ADDRESS2_MASKS I2C Own Address2 Masks
N  * @{
N  */
N#define I2C_OA2_NOMASK                  ((uint8_t)0x00U)
N#define I2C_OA2_MASK01                  ((uint8_t)0x01U)
N#define I2C_OA2_MASK02                  ((uint8_t)0x02U)
N#define I2C_OA2_MASK03                  ((uint8_t)0x03U)
N#define I2C_OA2_MASK04                  ((uint8_t)0x04U)
N#define I2C_OA2_MASK05                  ((uint8_t)0x05U)
N#define I2C_OA2_MASK06                  ((uint8_t)0x06U)
N#define I2C_OA2_MASK07                  ((uint8_t)0x07U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_GENERAL_CALL_ADDRESSING_MODE I2C General Call Addressing Mode
N  * @{
N  */
N#define I2C_GENERALCALL_DISABLE         (0x00000000U)
N#define I2C_GENERALCALL_ENABLE          I2C_CR1_GCEN
N/**
N  * @}
N  */
N
N/** @defgroup I2C_NOSTRETCH_MODE I2C No-Stretch Mode
N  * @{
N  */
N#define I2C_NOSTRETCH_DISABLE           (0x00000000U)
N#define I2C_NOSTRETCH_ENABLE            I2C_CR1_NOSTRETCH
N/**
N  * @}
N  */
N
N/** @defgroup I2C_MEMORY_ADDRESS_SIZE I2C Memory Address Size
N  * @{
N  */
N#define I2C_MEMADD_SIZE_8BIT            (0x00000001U)
N#define I2C_MEMADD_SIZE_16BIT           (0x00000002U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_XFERDIRECTION I2C Transfer Direction Master Point of View
N  * @{
N  */
N#define I2C_DIRECTION_TRANSMIT          (0x00000000U)
N#define I2C_DIRECTION_RECEIVE           (0x00000001U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_RELOAD_END_MODE I2C Reload End Mode
N  * @{
N  */
N#define  I2C_RELOAD_MODE                I2C_CR2_RELOAD
N#define  I2C_AUTOEND_MODE               I2C_CR2_AUTOEND
N#define  I2C_SOFTEND_MODE               (0x00000000U)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_START_STOP_MODE I2C Start or Stop Mode
N  * @{
N  */
N#define  I2C_NO_STARTSTOP               (0x00000000U)
N#define  I2C_GENERATE_STOP              I2C_CR2_STOP
N#define  I2C_GENERATE_START_READ        (uint32_t)(I2C_CR2_START | I2C_CR2_RD_WRN)
N#define  I2C_GENERATE_START_WRITE       I2C_CR2_START
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Interrupt_configuration_definition I2C Interrupt configuration definition
N  * @brief I2C Interrupt definition
N  *        Elements values convention: 0xXXXXXXXX
N  *           - XXXXXXXX  : Interrupt control mask
N  * @{
N  */
N#define I2C_IT_ERRI                     I2C_CR1_ERRIE
N#define I2C_IT_TCI                      I2C_CR1_TCIE
N#define I2C_IT_STOPI                    I2C_CR1_STOPIE
N#define I2C_IT_NACKI                    I2C_CR1_NACKIE
N#define I2C_IT_ADDRI                    I2C_CR1_ADDRIE
N#define I2C_IT_RXI                      I2C_CR1_RXIE
N#define I2C_IT_TXI                      I2C_CR1_TXIE
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Flag_definition I2C Flag definition
N  * @{
N  */
N#define I2C_FLAG_TXE                    I2C_ISR_TXE
N#define I2C_FLAG_TXIS                   I2C_ISR_TXIS
N#define I2C_FLAG_RXNE                   I2C_ISR_RXNE
N#define I2C_FLAG_ADDR                   I2C_ISR_ADDR
N#define I2C_FLAG_AF                     I2C_ISR_NACKF
N#define I2C_FLAG_STOPF                  I2C_ISR_STOPF
N#define I2C_FLAG_TC                     I2C_ISR_TC
N#define I2C_FLAG_TCR                    I2C_ISR_TCR
N#define I2C_FLAG_BERR                   I2C_ISR_BERR
N#define I2C_FLAG_ARLO                   I2C_ISR_ARLO
N#define I2C_FLAG_OVR                    I2C_ISR_OVR
N#define I2C_FLAG_PECERR                 I2C_ISR_PECERR
N#define I2C_FLAG_TIMEOUT                I2C_ISR_TIMEOUT
N#define I2C_FLAG_ALERT                  I2C_ISR_ALERT
N#define I2C_FLAG_BUSY                   I2C_ISR_BUSY
N#define I2C_FLAG_DIR                    I2C_ISR_DIR
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N
N/** @defgroup I2C_Exported_Macros I2C Exported Macros
N  * @{
N  */
N
N/** @brief Reset I2C handle state.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)                ((__HANDLE__)->State = HAL_I2C_STATE_RESET)
N
N/** @brief  Enable the specified I2C interrupt.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __INTERRUPT__ specifies the interrupt source to enable.
N  *        This parameter can be one of the following values:
N  *            @arg @ref I2C_IT_ERRI  Errors interrupt enable
N  *            @arg @ref I2C_IT_TCI   Transfer complete interrupt enable
N  *            @arg @ref I2C_IT_STOPI STOP detection interrupt enable
N  *            @arg @ref I2C_IT_NACKI NACK received interrupt enable
N  *            @arg @ref I2C_IT_ADDRI Address match interrupt enable
N  *            @arg @ref I2C_IT_RXI   RX interrupt enable
N  *            @arg @ref I2C_IT_TXI   TX interrupt enable
N  *
N  * @retval None
N  */
N#define __HAL_I2C_ENABLE_IT(__HANDLE__, __INTERRUPT__)          ((__HANDLE__)->Instance->CR1 |= (__INTERRUPT__))
N
N/** @brief  Disable the specified I2C interrupt.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __INTERRUPT__ specifies the interrupt source to disable.
N  *        This parameter can be one of the following values:
N  *            @arg @ref I2C_IT_ERRI  Errors interrupt enable
N  *            @arg @ref I2C_IT_TCI   Transfer complete interrupt enable
N  *            @arg @ref I2C_IT_STOPI STOP detection interrupt enable
N  *            @arg @ref I2C_IT_NACKI NACK received interrupt enable
N  *            @arg @ref I2C_IT_ADDRI Address match interrupt enable
N  *            @arg @ref I2C_IT_RXI   RX interrupt enable
N  *            @arg @ref I2C_IT_TXI   TX interrupt enable
N  *
N  * @retval None
N  */
N#define __HAL_I2C_DISABLE_IT(__HANDLE__, __INTERRUPT__)         ((__HANDLE__)->Instance->CR1 &= (~(__INTERRUPT__)))
N
N/** @brief  Check whether the specified I2C interrupt source is enabled or not.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __INTERRUPT__ specifies the I2C interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg @ref I2C_IT_ERRI  Errors interrupt enable
N  *            @arg @ref I2C_IT_TCI   Transfer complete interrupt enable
N  *            @arg @ref I2C_IT_STOPI STOP detection interrupt enable
N  *            @arg @ref I2C_IT_NACKI NACK received interrupt enable
N  *            @arg @ref I2C_IT_ADDRI Address match interrupt enable
N  *            @arg @ref I2C_IT_RXI   RX interrupt enable
N  *            @arg @ref I2C_IT_TXI   TX interrupt enable
N  *
N  * @retval The new state of __INTERRUPT__ (SET or RESET).
N  */
N#define __HAL_I2C_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)      ((((__HANDLE__)->Instance->CR1 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)
N
N/** @brief  Check whether the specified I2C flag is set or not.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __FLAG__ specifies the flag to check.
N  *        This parameter can be one of the following values:
N  *            @arg @ref I2C_FLAG_TXE     Transmit data register empty
N  *            @arg @ref I2C_FLAG_TXIS    Transmit interrupt status
N  *            @arg @ref I2C_FLAG_RXNE    Receive data register not empty
N  *            @arg @ref I2C_FLAG_ADDR    Address matched (slave mode)
N  *            @arg @ref I2C_FLAG_AF      Acknowledge failure received flag
N  *            @arg @ref I2C_FLAG_STOPF   STOP detection flag
N  *            @arg @ref I2C_FLAG_TC      Transfer complete (master mode)
N  *            @arg @ref I2C_FLAG_TCR     Transfer complete reload
N  *            @arg @ref I2C_FLAG_BERR    Bus error
N  *            @arg @ref I2C_FLAG_ARLO    Arbitration lost
N  *            @arg @ref I2C_FLAG_OVR     Overrun/Underrun
N  *            @arg @ref I2C_FLAG_PECERR  PEC error in reception
N  *            @arg @ref I2C_FLAG_TIMEOUT Timeout or Tlow detection flag
N  *            @arg @ref I2C_FLAG_ALERT   SMBus alert
N  *            @arg @ref I2C_FLAG_BUSY    Bus busy
N  *            @arg @ref I2C_FLAG_DIR     Transfer direction (slave mode)
N  *
N  * @retval The new state of __FLAG__ (SET or RESET).
N  */
N#define __HAL_I2C_GET_FLAG(__HANDLE__, __FLAG__) (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) == (__FLAG__)) ? SET : RESET)
N
N/** @brief  Clear the I2C pending flags which are cleared by writing 1 in a specific bit.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @param  __FLAG__ specifies the flag to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg @ref I2C_FLAG_TXE     Transmit data register empty
N  *            @arg @ref I2C_FLAG_ADDR    Address matched (slave mode)
N  *            @arg @ref I2C_FLAG_AF      Acknowledge failure received flag
N  *            @arg @ref I2C_FLAG_STOPF   STOP detection flag
N  *            @arg @ref I2C_FLAG_BERR    Bus error
N  *            @arg @ref I2C_FLAG_ARLO    Arbitration lost
N  *            @arg @ref I2C_FLAG_OVR     Overrun/Underrun
N  *            @arg @ref I2C_FLAG_PECERR  PEC error in reception
N  *            @arg @ref I2C_FLAG_TIMEOUT Timeout or Tlow detection flag
N  *            @arg @ref I2C_FLAG_ALERT   SMBus alert
N  *
N  * @retval None
N  */
N#define __HAL_I2C_CLEAR_FLAG(__HANDLE__, __FLAG__) (((__FLAG__) == I2C_FLAG_TXE) ? ((__HANDLE__)->Instance->ISR |= (__FLAG__)) \
N                                                                                 : ((__HANDLE__)->Instance->ICR = (__FLAG__)))
X#define __HAL_I2C_CLEAR_FLAG(__HANDLE__, __FLAG__) (((__FLAG__) == I2C_FLAG_TXE) ? ((__HANDLE__)->Instance->ISR |= (__FLAG__))                                                                                  : ((__HANDLE__)->Instance->ICR = (__FLAG__)))
N
N/** @brief  Enable the specified I2C peripheral.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_ENABLE(__HANDLE__)                            (SET_BIT((__HANDLE__)->Instance->CR1,  I2C_CR1_PE))
N
N/** @brief  Disable the specified I2C peripheral.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_DISABLE(__HANDLE__)                           (CLEAR_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE))
N
N/** @brief  Generate a Non-Acknowledge I2C peripheral in Slave mode.
N  * @param  __HANDLE__ specifies the I2C Handle.
N  * @retval None
N  */
N#define __HAL_I2C_GENERATE_NACK(__HANDLE__)                     (SET_BIT((__HANDLE__)->Instance->CR2, I2C_CR2_NACK))
N/**
N  * @}
N  */
N
N/* Include I2C HAL Extended module */
N#include "stm32f0xx_hal_i2c_ex.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_i2c_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_i2c_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of I2C HAL Extended module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_I2C_EX_H
N#define __STM32F0xx_HAL_I2C_EX_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup I2CEx
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup I2CEx_Exported_Constants I2C Extended Exported Constants
N  * @{
N  */
N
N/** @defgroup I2CEx_Analog_Filter I2C Extended Analog Filter
N  * @{
N  */
N#define I2C_ANALOGFILTER_ENABLE         0x00000000U
N#define I2C_ANALOGFILTER_DISABLE        I2C_CR1_ANFOFF
N/**
N  * @}
N  */
N
N/** @defgroup I2CEx_FastModePlus I2C Extended Fast Mode Plus
N  * @{
N  */
N#define I2C_FMP_NOT_SUPPORTED           0xAAAA0000U                                     /*!< Fast Mode Plus not supported       */
N#if defined(SYSCFG_CFGR1_I2C_FMP_PA9)
X#if 1L
N#define I2C_FASTMODEPLUS_PA9            SYSCFG_CFGR1_I2C_FMP_PA9                        /*!< Enable Fast Mode Plus on PA9       */
N#define I2C_FASTMODEPLUS_PA10           SYSCFG_CFGR1_I2C_FMP_PA10                       /*!< Enable Fast Mode Plus on PA10      */
N#else
S#define I2C_FASTMODEPLUS_PA9            (uint32_t)(0x00000001U | I2C_FMP_NOT_SUPPORTED) /*!< Fast Mode Plus PA9 not supported   */
S#define I2C_FASTMODEPLUS_PA10           (uint32_t)(0x00000002U | I2C_FMP_NOT_SUPPORTED) /*!< Fast Mode Plus PA10 not supported  */
N#endif
N#define I2C_FASTMODEPLUS_PB6            SYSCFG_CFGR1_I2C_FMP_PB6                        /*!< Enable Fast Mode Plus on PB6       */
N#define I2C_FASTMODEPLUS_PB7            SYSCFG_CFGR1_I2C_FMP_PB7                        /*!< Enable Fast Mode Plus on PB7       */
N#define I2C_FASTMODEPLUS_PB8            SYSCFG_CFGR1_I2C_FMP_PB8                        /*!< Enable Fast Mode Plus on PB8       */
N#define I2C_FASTMODEPLUS_PB9            SYSCFG_CFGR1_I2C_FMP_PB9                        /*!< Enable Fast Mode Plus on PB9       */
N#if defined(SYSCFG_CFGR1_I2C_FMP_I2C1)
X#if 1L
N#define I2C_FASTMODEPLUS_I2C1           SYSCFG_CFGR1_I2C_FMP_I2C1                       /*!< Enable Fast Mode Plus on I2C1 pins */
N#else
S#define I2C_FASTMODEPLUS_I2C1           (uint32_t)(0x00000100U | I2C_FMP_NOT_SUPPORTED) /*!< Fast Mode Plus I2C1 not supported  */
N#endif
N#if defined(SYSCFG_CFGR1_I2C_FMP_I2C2)
X#if 1L
N#define I2C_FASTMODEPLUS_I2C2           SYSCFG_CFGR1_I2C_FMP_I2C2                       /*!< Enable Fast Mode Plus on I2C2 pins */
N#else
S#define I2C_FASTMODEPLUS_I2C2           (uint32_t)(0x00000200U | I2C_FMP_NOT_SUPPORTED) /*!< Fast Mode Plus I2C2 not supported  */
N#endif
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
N/** @addtogroup I2CEx_Exported_Functions I2C Extended Exported Functions
N  * @{
N  */
N
N/** @addtogroup I2CEx_Exported_Functions_Group1 Extended features functions
N  * @brief    Extended features functions
N  * @{
N  */
N
N/* Peripheral Control functions  ************************************************/
NHAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter);
NHAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter);
N#if defined(I2C_CR1_WUPEN)
X#if 1L
NHAL_StatusTypeDef HAL_I2CEx_EnableWakeUp(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2CEx_DisableWakeUp(I2C_HandleTypeDef *hi2c);
N#endif
Nvoid HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus);
Nvoid HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus);
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup I2CEx_Private_Constants I2C Extended Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup I2CEx_Private_Macro I2C Extended Private Macros
N  * @{
N  */
N#define IS_I2C_ANALOG_FILTER(FILTER)    (((FILTER) == I2C_ANALOGFILTER_ENABLE) || \
N                                          ((FILTER) == I2C_ANALOGFILTER_DISABLE))
X#define IS_I2C_ANALOG_FILTER(FILTER)    (((FILTER) == I2C_ANALOGFILTER_ENABLE) ||                                           ((FILTER) == I2C_ANALOGFILTER_DISABLE))
N
N#define IS_I2C_DIGITAL_FILTER(FILTER)   ((FILTER) <= 0x0000000FU)
N
N#define IS_I2C_FASTMODEPLUS(__CONFIG__) ((((__CONFIG__) & I2C_FMP_NOT_SUPPORTED) != I2C_FMP_NOT_SUPPORTED) && \
N                                         ((((__CONFIG__) & (I2C_FASTMODEPLUS_PA9))  == I2C_FASTMODEPLUS_PA9)     || \
N                                          (((__CONFIG__) & (I2C_FASTMODEPLUS_PA10)) == I2C_FASTMODEPLUS_PA10)    || \
N                                          (((__CONFIG__) & (I2C_FASTMODEPLUS_PB6))  == I2C_FASTMODEPLUS_PB6)     || \
N                                          (((__CONFIG__) & (I2C_FASTMODEPLUS_PB7))  == I2C_FASTMODEPLUS_PB7)     || \
N                                          (((__CONFIG__) & (I2C_FASTMODEPLUS_PB8))  == I2C_FASTMODEPLUS_PB8)     || \
N                                          (((__CONFIG__) & (I2C_FASTMODEPLUS_PB9))  == I2C_FASTMODEPLUS_PB9)     || \
N                                          (((__CONFIG__) & (I2C_FASTMODEPLUS_I2C1)) == I2C_FASTMODEPLUS_I2C1)    || \
N                                          (((__CONFIG__) & (I2C_FASTMODEPLUS_I2C2)) == I2C_FASTMODEPLUS_I2C2)))
X#define IS_I2C_FASTMODEPLUS(__CONFIG__) ((((__CONFIG__) & I2C_FMP_NOT_SUPPORTED) != I2C_FMP_NOT_SUPPORTED) &&                                          ((((__CONFIG__) & (I2C_FASTMODEPLUS_PA9))  == I2C_FASTMODEPLUS_PA9)     ||                                           (((__CONFIG__) & (I2C_FASTMODEPLUS_PA10)) == I2C_FASTMODEPLUS_PA10)    ||                                           (((__CONFIG__) & (I2C_FASTMODEPLUS_PB6))  == I2C_FASTMODEPLUS_PB6)     ||                                           (((__CONFIG__) & (I2C_FASTMODEPLUS_PB7))  == I2C_FASTMODEPLUS_PB7)     ||                                           (((__CONFIG__) & (I2C_FASTMODEPLUS_PB8))  == I2C_FASTMODEPLUS_PB8)     ||                                           (((__CONFIG__) & (I2C_FASTMODEPLUS_PB9))  == I2C_FASTMODEPLUS_PB9)     ||                                           (((__CONFIG__) & (I2C_FASTMODEPLUS_I2C1)) == I2C_FASTMODEPLUS_I2C1)    ||                                           (((__CONFIG__) & (I2C_FASTMODEPLUS_I2C2)) == I2C_FASTMODEPLUS_I2C2)))
N/**
N  * @}
N  */
N
N/* Private Functions ---------------------------------------------------------*/
N/** @defgroup I2CEx_Private_Functions I2C Extended Private Functions
N  * @{
N  */
N/* Private functions are defined in stm32f0xx_hal_i2c_ex.c file */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_I2C_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 517 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_i2c.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup I2C_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
N/* Initialization and de-initialization functions******************************/
NHAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c);
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group2 Input and Output operation functions
N  * @{
N  */
N/* IO operation functions  ****************************************************/
N/******* Blocking mode: Polling */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout);
N
N/******* Non-Blocking mode: Interrupt */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
N
NHAL_StatusTypeDef HAL_I2C_Master_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Master_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_Slave_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions);
NHAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c);
NHAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress);
N
N/******* Non-Blocking mode: DMA */
NHAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
N * @{
N */
N/******* I2C IRQHandler and Callbacks used in non blocking modes (Interrupt and DMA) */
Nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode);
Nvoid HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c);
Nvoid HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c);
N/**
N  * @}
N  */
N
N/** @addtogroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
N  * @{
N  */
N/* Peripheral State, Mode and Error functions  *********************************/
NHAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c);
NHAL_I2C_ModeTypeDef  HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c);
Nuint32_t             HAL_I2C_GetError(I2C_HandleTypeDef *hi2c);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup I2C_Private_Constants I2C Private Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup I2C_Private_Macro I2C Private Macros
N  * @{
N  */
N
N#define IS_I2C_ADDRESSING_MODE(MODE)    (((MODE) == I2C_ADDRESSINGMODE_7BIT) || \
N                                         ((MODE) == I2C_ADDRESSINGMODE_10BIT))
X#define IS_I2C_ADDRESSING_MODE(MODE)    (((MODE) == I2C_ADDRESSINGMODE_7BIT) ||                                          ((MODE) == I2C_ADDRESSINGMODE_10BIT))
N
N#define IS_I2C_DUAL_ADDRESS(ADDRESS)    (((ADDRESS) == I2C_DUALADDRESS_DISABLE) || \
N                                         ((ADDRESS) == I2C_DUALADDRESS_ENABLE))
X#define IS_I2C_DUAL_ADDRESS(ADDRESS)    (((ADDRESS) == I2C_DUALADDRESS_DISABLE) ||                                          ((ADDRESS) == I2C_DUALADDRESS_ENABLE))
N
N#define IS_I2C_OWN_ADDRESS2_MASK(MASK)  (((MASK) == I2C_OA2_NOMASK)  || \
N                                         ((MASK) == I2C_OA2_MASK01) || \
N                                         ((MASK) == I2C_OA2_MASK02) || \
N                                         ((MASK) == I2C_OA2_MASK03) || \
N                                         ((MASK) == I2C_OA2_MASK04) || \
N                                         ((MASK) == I2C_OA2_MASK05) || \
N                                         ((MASK) == I2C_OA2_MASK06) || \
N                                         ((MASK) == I2C_OA2_MASK07))
X#define IS_I2C_OWN_ADDRESS2_MASK(MASK)  (((MASK) == I2C_OA2_NOMASK)  ||                                          ((MASK) == I2C_OA2_MASK01) ||                                          ((MASK) == I2C_OA2_MASK02) ||                                          ((MASK) == I2C_OA2_MASK03) ||                                          ((MASK) == I2C_OA2_MASK04) ||                                          ((MASK) == I2C_OA2_MASK05) ||                                          ((MASK) == I2C_OA2_MASK06) ||                                          ((MASK) == I2C_OA2_MASK07))
N
N#define IS_I2C_GENERAL_CALL(CALL)       (((CALL) == I2C_GENERALCALL_DISABLE) || \
N                                         ((CALL) == I2C_GENERALCALL_ENABLE))
X#define IS_I2C_GENERAL_CALL(CALL)       (((CALL) == I2C_GENERALCALL_DISABLE) ||                                          ((CALL) == I2C_GENERALCALL_ENABLE))
N
N#define IS_I2C_NO_STRETCH(STRETCH)      (((STRETCH) == I2C_NOSTRETCH_DISABLE) || \
N                                         ((STRETCH) == I2C_NOSTRETCH_ENABLE))
X#define IS_I2C_NO_STRETCH(STRETCH)      (((STRETCH) == I2C_NOSTRETCH_DISABLE) ||                                          ((STRETCH) == I2C_NOSTRETCH_ENABLE))
N
N#define IS_I2C_MEMADD_SIZE(SIZE)        (((SIZE) == I2C_MEMADD_SIZE_8BIT) || \
N                                         ((SIZE) == I2C_MEMADD_SIZE_16BIT))
X#define IS_I2C_MEMADD_SIZE(SIZE)        (((SIZE) == I2C_MEMADD_SIZE_8BIT) ||                                          ((SIZE) == I2C_MEMADD_SIZE_16BIT))
N
N#define IS_TRANSFER_MODE(MODE)          (((MODE) == I2C_RELOAD_MODE)   || \
N                                         ((MODE) == I2C_AUTOEND_MODE) || \
N                                         ((MODE) == I2C_SOFTEND_MODE))
X#define IS_TRANSFER_MODE(MODE)          (((MODE) == I2C_RELOAD_MODE)   ||                                          ((MODE) == I2C_AUTOEND_MODE) ||                                          ((MODE) == I2C_SOFTEND_MODE))
N
N#define IS_TRANSFER_REQUEST(REQUEST)    (((REQUEST) == I2C_GENERATE_STOP)        || \
N                                         ((REQUEST) == I2C_GENERATE_START_READ)  || \
N                                         ((REQUEST) == I2C_GENERATE_START_WRITE) || \
N                                         ((REQUEST) == I2C_NO_STARTSTOP))
X#define IS_TRANSFER_REQUEST(REQUEST)    (((REQUEST) == I2C_GENERATE_STOP)        ||                                          ((REQUEST) == I2C_GENERATE_START_READ)  ||                                          ((REQUEST) == I2C_GENERATE_START_WRITE) ||                                          ((REQUEST) == I2C_NO_STARTSTOP))
N
N#define IS_I2C_TRANSFER_OPTIONS_REQUEST(REQUEST)  (((REQUEST) == I2C_FIRST_FRAME)          || \
N                                                   ((REQUEST) == I2C_FIRST_AND_NEXT_FRAME) || \
N                                                   ((REQUEST) == I2C_NEXT_FRAME)           || \
N                                                   ((REQUEST) == I2C_FIRST_AND_LAST_FRAME) || \
N                                                   ((REQUEST) == I2C_LAST_FRAME))
X#define IS_I2C_TRANSFER_OPTIONS_REQUEST(REQUEST)  (((REQUEST) == I2C_FIRST_FRAME)          ||                                                    ((REQUEST) == I2C_FIRST_AND_NEXT_FRAME) ||                                                    ((REQUEST) == I2C_NEXT_FRAME)           ||                                                    ((REQUEST) == I2C_FIRST_AND_LAST_FRAME) ||                                                    ((REQUEST) == I2C_LAST_FRAME))
N
N#define I2C_RESET_CR2(__HANDLE__)                 ((__HANDLE__)->Instance->CR2 &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_HEAD10R | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_RD_WRN)))
N
N#define I2C_GET_ADDR_MATCH(__HANDLE__)            (((__HANDLE__)->Instance->ISR & I2C_ISR_ADDCODE) >> 16U)
N#define I2C_GET_DIR(__HANDLE__)                   (((__HANDLE__)->Instance->ISR & I2C_ISR_DIR) >> 16U)
N#define I2C_GET_STOP_MODE(__HANDLE__)             ((__HANDLE__)->Instance->CR2 & I2C_CR2_AUTOEND)
N#define I2C_GET_OWN_ADDRESS1(__HANDLE__)          ((__HANDLE__)->Instance->OAR1 & I2C_OAR1_OA1)
N#define I2C_GET_OWN_ADDRESS2(__HANDLE__)          ((__HANDLE__)->Instance->OAR2 & I2C_OAR2_OA2)
N
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1)             ((ADDRESS1) <= 0x000003FFU)
N#define IS_I2C_OWN_ADDRESS2(ADDRESS2)             ((ADDRESS2) <= (uint16_t)0x00FFU)
N
N#define I2C_MEM_ADD_MSB(__ADDRESS__)              ((uint8_t)((uint16_t)(((uint16_t)((__ADDRESS__) & (uint16_t)(0xFF00U))) >> 8U)))
N#define I2C_MEM_ADD_LSB(__ADDRESS__)              ((uint8_t)((uint16_t)((__ADDRESS__) & (uint16_t)(0x00FFU))))
N
N#define I2C_GENERATE_START(__ADDMODE__,__ADDRESS__) (((__ADDMODE__) == I2C_ADDRESSINGMODE_7BIT) ? (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_START) | (I2C_CR2_AUTOEND)) & (~I2C_CR2_RD_WRN)) : \
N                                                          (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_ADD10) | (I2C_CR2_START)) & (~I2C_CR2_RD_WRN)))
X#define I2C_GENERATE_START(__ADDMODE__,__ADDRESS__) (((__ADDMODE__) == I2C_ADDRESSINGMODE_7BIT) ? (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_START) | (I2C_CR2_AUTOEND)) & (~I2C_CR2_RD_WRN)) :                                                           (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_ADD10) | (I2C_CR2_START)) & (~I2C_CR2_RD_WRN)))
N/**
N  * @}
N  */
N
N/* Private Functions ---------------------------------------------------------*/
N/** @defgroup I2C_Private_Functions I2C Private Functions
N  * @{
N  */
N/* Private functions are defined in stm32f0xx_hal_i2c.c file */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F0xx_HAL_I2C_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 242 "../Inc/stm32f0xx_hal_conf.h" 2
N#endif /* HAL_I2C_MODULE_ENABLED */
N
N#ifdef HAL_I2S_MODULE_ENABLED
S #include "stm32f0xx_hal_i2s.h"
N#endif /* HAL_I2S_MODULE_ENABLED */
N
N#ifdef HAL_IRDA_MODULE_ENABLED
S #include "stm32f0xx_hal_irda.h"
N#endif /* HAL_IRDA_MODULE_ENABLED */
N
N#ifdef HAL_IWDG_MODULE_ENABLED
S #include "stm32f0xx_hal_iwdg.h"
N#endif /* HAL_IWDG_MODULE_ENABLED */
N
N#ifdef HAL_PCD_MODULE_ENABLED
S #include "stm32f0xx_hal_pcd.h"
N#endif /* HAL_PCD_MODULE_ENABLED */
N
N#ifdef HAL_PWR_MODULE_ENABLED
N #include "stm32f0xx_hal_pwr.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_pwr.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_pwr.h
N  * @author  MCD Application Team
N  * @brief   Header file of PWR HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_PWR_H
N#define __STM32F0xx_HAL_PWR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup PWR PWR
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup PWR_Exported_Constants PWR Exported Constants
N  * @{
N  */ 
N
N/** @defgroup PWR_Regulator_state_in_STOP_mode PWR Regulator state in STOP mode
N  * @{
N  */
N#define PWR_MAINREGULATOR_ON                        (0x00000000U)
N#define PWR_LOWPOWERREGULATOR_ON                    PWR_CR_LPDS
N
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_ON) || \
N                                     ((REGULATOR) == PWR_LOWPOWERREGULATOR_ON))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MAINREGULATOR_ON) ||                                      ((REGULATOR) == PWR_LOWPOWERREGULATOR_ON))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_SLEEP_mode_entry PWR SLEEP mode entry
N  * @{
N  */
N#define PWR_SLEEPENTRY_WFI              ((uint8_t)0x01U)
N#define PWR_SLEEPENTRY_WFE              ((uint8_t)0x02U)
N#define IS_PWR_SLEEP_ENTRY(ENTRY) (((ENTRY) == PWR_SLEEPENTRY_WFI) || ((ENTRY) == PWR_SLEEPENTRY_WFE))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_STOP_mode_entry PWR STOP mode entry
N  * @{
N  */
N#define PWR_STOPENTRY_WFI               ((uint8_t)0x01U)
N#define PWR_STOPENTRY_WFE               ((uint8_t)0x02U)
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPENTRY_WFI) || ((ENTRY) == PWR_STOPENTRY_WFE))
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup PWR_Exported_Macro PWR Exported Macro
N  * @{
N  */
N
N/** @brief  Check PWR flag is set or not.
N  * @param  __FLAG__ specifies the flag to check.
N  *           This parameter can be one of the following values:
N  *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event
N  *                  was received from the WKUP pin or from the RTC alarm (Alarm A),
N  *                  RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
N  *                  An additional wakeup event is detected if the WKUP pin is enabled
N  *                  (by setting the EWUP bit) when the WKUP pin level is already high.
N  *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
N  *                  resumed from StandBy mode.
N  *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled
N  *                  by the HAL_PWR_EnablePVD() function. The PVD is stopped by Standby mode
N  *                  For this reason, this bit is equal to 0 after Standby or reset
N  *                  until the PVDE bit is set. 
N  *                  Warning: this Flag is not available on STM32F030x8 products
N  *            @arg PWR_FLAG_VREFINTRDY: This flag indicates that the internal reference
N  *                  voltage VREFINT is ready.
N  *                  Warning: this Flag is not available on STM32F030x8 products
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_PWR_GET_FLAG(__FLAG__) ((PWR->CSR & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Clear the PWR's pending flags.
N  * @param  __FLAG__ specifies the flag to clear.
N  *          This parameter can be one of the following values:
N  *            @arg PWR_FLAG_WU: Wake Up flag
N  *            @arg PWR_FLAG_SB: StandBy flag
N  */
N#define __HAL_PWR_CLEAR_FLAG(__FLAG__) (PWR->CR |=  (__FLAG__) << 2U)
N
N
N/**
N  * @}
N  */
N
N/* Include PWR HAL Extension module */
N#include "stm32f0xx_hal_pwr_ex.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_pwr_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_pwr_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of PWR HAL Extension module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_PWR_EX_H
N#define __STM32F0xx_HAL_PWR_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup PWREx
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/ 
N
N/** @defgroup PWREx_Exported_Types PWREx Exported Types
N *  @{
N */
N
N#if defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || \
N    defined (STM32F091xC)
X#if 0L || 0L || 0L ||     0L || 0L ||     1L
N
N/**
N  * @brief  PWR PVD configuration structure definition
N  */
Ntypedef struct
N{
N  uint32_t PVDLevel;   /*!< PVDLevel: Specifies the PVD detection level
N                            This parameter can be a value of @ref PWREx_PVD_detection_level */
N
N  uint32_t Mode;       /*!< Mode: Specifies the operating mode for the selected pins.
N                            This parameter can be a value of @ref PWREx_PVD_Mode */
N}PWR_PVDTypeDef;
N
N#endif /* defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || */
N       /* defined (STM32F071xB) || defined (STM32F072xB) || */
N       /* defined (STM32F091xC) */
N/**
N  * @}
N  */
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup PWREx_Exported_Constants PWREx Exported Constants
N  * @{
N  */
N
N
N/** @defgroup PWREx_WakeUp_Pins PWREx Wakeup Pins
N  * @{
N  */
N#if defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || \
N    defined (STM32F091xC) || defined (STM32F098xx)
X#if 0L || 0L || 0L ||     1L || 0L
N#define PWR_WAKEUP_PIN1                     ((uint32_t)PWR_CSR_EWUP1)
N#define PWR_WAKEUP_PIN2                     ((uint32_t)PWR_CSR_EWUP2)
N#define PWR_WAKEUP_PIN3                     ((uint32_t)PWR_CSR_EWUP3)
N#define PWR_WAKEUP_PIN4                     ((uint32_t)PWR_CSR_EWUP4)
N#define PWR_WAKEUP_PIN5                     ((uint32_t)PWR_CSR_EWUP5)
N#define PWR_WAKEUP_PIN6                     ((uint32_t)PWR_CSR_EWUP6)
N#define PWR_WAKEUP_PIN7                     ((uint32_t)PWR_CSR_EWUP7)
N#define PWR_WAKEUP_PIN8                     ((uint32_t)PWR_CSR_EWUP8)
N
N#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || \
N                                ((PIN) == PWR_WAKEUP_PIN2) || \
N                                ((PIN) == PWR_WAKEUP_PIN3) || \
N                                ((PIN) == PWR_WAKEUP_PIN4) || \
N                                ((PIN) == PWR_WAKEUP_PIN5) || \
N                                ((PIN) == PWR_WAKEUP_PIN6) || \
N                                ((PIN) == PWR_WAKEUP_PIN7) || \
N                                ((PIN) == PWR_WAKEUP_PIN8))
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) ||                                 ((PIN) == PWR_WAKEUP_PIN2) ||                                 ((PIN) == PWR_WAKEUP_PIN3) ||                                 ((PIN) == PWR_WAKEUP_PIN4) ||                                 ((PIN) == PWR_WAKEUP_PIN5) ||                                 ((PIN) == PWR_WAKEUP_PIN6) ||                                 ((PIN) == PWR_WAKEUP_PIN7) ||                                 ((PIN) == PWR_WAKEUP_PIN8))
N
N#elif defined(STM32F030xC) || defined (STM32F070xB)
S#define PWR_WAKEUP_PIN1                     ((uint32_t)PWR_CSR_EWUP1)
S#define PWR_WAKEUP_PIN2                     ((uint32_t)PWR_CSR_EWUP2)
S#define PWR_WAKEUP_PIN4                     ((uint32_t)PWR_CSR_EWUP4)
S#define PWR_WAKEUP_PIN5                     ((uint32_t)PWR_CSR_EWUP5)
S#define PWR_WAKEUP_PIN6                     ((uint32_t)PWR_CSR_EWUP6)
S#define PWR_WAKEUP_PIN7                     ((uint32_t)PWR_CSR_EWUP7)
S
S#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || \
S                                ((PIN) == PWR_WAKEUP_PIN2) || \
S                                ((PIN) == PWR_WAKEUP_PIN4) || \
S                                ((PIN) == PWR_WAKEUP_PIN5) || \
S                                ((PIN) == PWR_WAKEUP_PIN6) || \
S                                ((PIN) == PWR_WAKEUP_PIN7))
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) ||                                 ((PIN) == PWR_WAKEUP_PIN2) ||                                 ((PIN) == PWR_WAKEUP_PIN4) ||                                 ((PIN) == PWR_WAKEUP_PIN5) ||                                 ((PIN) == PWR_WAKEUP_PIN6) ||                                 ((PIN) == PWR_WAKEUP_PIN7))
S
S#elif defined(STM32F042x6) || defined (STM32F048xx)
S#define PWR_WAKEUP_PIN1                     ((uint32_t)PWR_CSR_EWUP1)
S#define PWR_WAKEUP_PIN2                     ((uint32_t)PWR_CSR_EWUP2)
S#define PWR_WAKEUP_PIN4                     ((uint32_t)PWR_CSR_EWUP4)
S#define PWR_WAKEUP_PIN6                     ((uint32_t)PWR_CSR_EWUP6)
S#define PWR_WAKEUP_PIN7                     ((uint32_t)PWR_CSR_EWUP7)
S
S#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || \
S                                ((PIN) == PWR_WAKEUP_PIN2) || \
S                                ((PIN) == PWR_WAKEUP_PIN4) || \
S                                ((PIN) == PWR_WAKEUP_PIN6) || \
S                                ((PIN) == PWR_WAKEUP_PIN7))
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) ||                                 ((PIN) == PWR_WAKEUP_PIN2) ||                                 ((PIN) == PWR_WAKEUP_PIN4) ||                                 ((PIN) == PWR_WAKEUP_PIN6) ||                                 ((PIN) == PWR_WAKEUP_PIN7))
S
S#else
S#define PWR_WAKEUP_PIN1                     ((uint32_t)PWR_CSR_EWUP1)
S#define PWR_WAKEUP_PIN2                     ((uint32_t)PWR_CSR_EWUP2)
S
S
S#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) || \
S                                ((PIN) == PWR_WAKEUP_PIN2))
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WAKEUP_PIN1) ||                                 ((PIN) == PWR_WAKEUP_PIN2))
S
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup PWREx_EXTI_Line PWREx EXTI Line
N  * @{
N  */
N#if defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || \
N    defined (STM32F091xC)
X#if 0L || 0L || 0L ||     0L || 0L ||     1L
N
N#define PWR_EXTI_LINE_PVD                   ((uint32_t)EXTI_IMR_MR16)  /*!< External interrupt line 16 Connected to the PVD EXTI Line */
N
N#endif /* defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || */
N       /* defined (STM32F071xB) || defined (STM32F072xB) || */
N       /* defined (STM32F091xC) */
N      
N#if defined (STM32F042x6) || defined (STM32F048xx) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || \
N    defined (STM32F091xC) || defined (STM32F098xx)
X#if 0L || 0L ||     0L || 0L || 0L ||     1L || 0L
N
N#define PWR_EXTI_LINE_VDDIO2                ((uint32_t)EXTI_IMR_MR31)  /*!< External interrupt line 31 Connected to the Vddio2 Monitor EXTI Line */
N
N#endif /* defined (STM32F042x6) || defined (STM32F048xx) ||\
N          defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || \
N          defined (STM32F091xC) || defined (STM32F098xx) ||*/
X#endif  
N/**
N  * @}
N  */
N
N#if defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || \
N    defined (STM32F091xC)
X#if 0L || 0L || 0L ||     0L || 0L ||     1L
N/** @defgroup PWREx_PVD_detection_level PWREx PVD detection level
N  * @{
N  */
N#define PWR_PVDLEVEL_0                      PWR_CR_PLS_LEV0
N#define PWR_PVDLEVEL_1                      PWR_CR_PLS_LEV1
N#define PWR_PVDLEVEL_2                      PWR_CR_PLS_LEV2
N#define PWR_PVDLEVEL_3                      PWR_CR_PLS_LEV3
N#define PWR_PVDLEVEL_4                      PWR_CR_PLS_LEV4
N#define PWR_PVDLEVEL_5                      PWR_CR_PLS_LEV5
N#define PWR_PVDLEVEL_6                      PWR_CR_PLS_LEV6
N#define PWR_PVDLEVEL_7                      PWR_CR_PLS_LEV7
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLEVEL_0) || ((LEVEL) == PWR_PVDLEVEL_1)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_2) || ((LEVEL) == PWR_PVDLEVEL_3)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_4) || ((LEVEL) == PWR_PVDLEVEL_5)|| \
N                                 ((LEVEL) == PWR_PVDLEVEL_6) || ((LEVEL) == PWR_PVDLEVEL_7))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLEVEL_0) || ((LEVEL) == PWR_PVDLEVEL_1)||                                  ((LEVEL) == PWR_PVDLEVEL_2) || ((LEVEL) == PWR_PVDLEVEL_3)||                                  ((LEVEL) == PWR_PVDLEVEL_4) || ((LEVEL) == PWR_PVDLEVEL_5)||                                  ((LEVEL) == PWR_PVDLEVEL_6) || ((LEVEL) == PWR_PVDLEVEL_7))
N/**
N  * @}
N  */
N
N/** @defgroup PWREx_PVD_Mode PWREx PVD Mode
N  * @{
N  */
N#define PWR_PVD_MODE_NORMAL                 (0x00000000U)   /*!< basic mode is used */
N#define PWR_PVD_MODE_IT_RISING              (0x00010001U)   /*!< External Interrupt Mode with Rising edge trigger detection */
N#define PWR_PVD_MODE_IT_FALLING             (0x00010002U)   /*!< External Interrupt Mode with Falling edge trigger detection */
N#define PWR_PVD_MODE_IT_RISING_FALLING      (0x00010003U)   /*!< External Interrupt Mode with Rising/Falling edge trigger detection */
N#define PWR_PVD_MODE_EVENT_RISING           (0x00020001U)   /*!< Event Mode with Rising edge trigger detection */
N#define PWR_PVD_MODE_EVENT_FALLING          (0x00020002U)   /*!< Event Mode with Falling edge trigger detection */
N#define PWR_PVD_MODE_EVENT_RISING_FALLING   (0x00020003U)   /*!< Event Mode with Rising/Falling edge trigger detection */
N
N#define IS_PWR_PVD_MODE(MODE) (((MODE) == PWR_PVD_MODE_IT_RISING)|| ((MODE) == PWR_PVD_MODE_IT_FALLING) || \
N                              ((MODE) == PWR_PVD_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING) || \
N                              ((MODE) == PWR_PVD_MODE_EVENT_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING_FALLING) || \
N                              ((MODE) == PWR_PVD_MODE_NORMAL))
X#define IS_PWR_PVD_MODE(MODE) (((MODE) == PWR_PVD_MODE_IT_RISING)|| ((MODE) == PWR_PVD_MODE_IT_FALLING) ||                               ((MODE) == PWR_PVD_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING) ||                               ((MODE) == PWR_PVD_MODE_EVENT_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING_FALLING) ||                               ((MODE) == PWR_PVD_MODE_NORMAL))
N/**
N  * @}
N  */
N#endif /* defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || */
N       /* defined (STM32F071xB) || defined (STM32F072xB) || */
N       /* defined (STM32F091xC) */
N
N/** @defgroup PWREx_Flag PWREx Flag
N  * @{
N  */
N#if defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || \
N    defined (STM32F091xC)
X#if 0L || 0L || 0L ||     0L || 0L ||     1L
N
N#define PWR_FLAG_WU                         PWR_CSR_WUF
N#define PWR_FLAG_SB                         PWR_CSR_SBF
N#define PWR_FLAG_PVDO                       PWR_CSR_PVDO
N#define PWR_FLAG_VREFINTRDY                 PWR_CSR_VREFINTRDYF
N#elif defined (STM32F070x6) || defined (STM32F070xB) || defined (STM32F030xC)
S#define PWR_FLAG_WU                         PWR_CSR_WUF
S#define PWR_FLAG_SB                         PWR_CSR_SBF
S#define PWR_FLAG_VREFINTRDY                 PWR_CSR_VREFINTRDYF
S#else
S#define PWR_FLAG_WU                         PWR_CSR_WUF
S#define PWR_FLAG_SB                         PWR_CSR_SBF
S
N#endif /* defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || */
N       /* defined (STM32F071xB) || defined (STM32F072xB) || */
N       /* defined (STM32F091xC) */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macro ------------------------------------------------------------*/
N/** @defgroup PWREx_Exported_Macros PWREx Exported Macros
N  * @{
N  */
N#if defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || \
N    defined (STM32F091xC)
X#if 0L || 0L || 0L ||     0L || 0L ||     1L
N/**
N  * @brief Enable interrupt on PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_IT()      (EXTI->IMR |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Disable interrupt on PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_IT()     (EXTI->IMR &= ~(PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Enable event on PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_EVENT()   (EXTI->EMR |= (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Disable event on PVD Exti Line 16.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_EVENT()  (EXTI->EMR &= ~(PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Disable the PVD Extended Interrupt Rising Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE()  CLEAR_BIT(EXTI->RTSR, PWR_EXTI_LINE_PVD)
N
N/**
N  * @brief Disable the PVD Extended Interrupt Falling Trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE()  CLEAR_BIT(EXTI->FTSR, PWR_EXTI_LINE_PVD)
N
N/**
N  * @brief Disable the PVD Extended Interrupt Rising & Falling Trigger.
N  * @retval None
N  */
N#define __HAL_PWR_PVD_EXTI_DISABLE_RISING_FALLING_EDGE()  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();__HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();
N
N
N/**
N  * @brief  PVD EXTI line configuration: set falling edge trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE()  EXTI->FTSR |= (PWR_EXTI_LINE_PVD)
N
N/**
N  * @brief  PVD EXTI line configuration: set rising edge trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE()   EXTI->RTSR |= (PWR_EXTI_LINE_PVD)
N
N/**
N  * @brief  Enable the PVD Extended Interrupt Rising & Falling Trigger.
N  * @retval None
N  */
N#define __HAL_PWR_PVD_EXTI_ENABLE_RISING_FALLING_EDGE()   __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();__HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
N
N/**
N  * @brief Check whether the specified PVD EXTI interrupt flag is set or not.
N  * @retval EXTI PVD Line Status.
N  */
N#define __HAL_PWR_PVD_EXTI_GET_FLAG()       (EXTI->PR & (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Clear the PVD EXTI flag.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_CLEAR_FLAG()     (EXTI->PR = (PWR_EXTI_LINE_PVD))
N
N/**
N  * @brief Generate a Software interrupt on selected EXTI line.
N  * @retval None.
N  */
N#define __HAL_PWR_PVD_EXTI_GENERATE_SWIT()  (EXTI->SWIER |= (PWR_EXTI_LINE_PVD))
N
N#endif /* defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || */
N       /* defined (STM32F071xB) || defined (STM32F072xB) || */
N       /* defined (STM32F091xC) */
N
N
N#if defined (STM32F042x6) || defined (STM32F048xx) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || \
N    defined (STM32F091xC) || defined (STM32F098xx)
X#if 0L || 0L ||     0L || 0L || 0L ||     1L || 0L
N/**
N  * @brief Enable interrupt on Vddio2 Monitor Exti Line 31.
N  * @retval None.
N  */
N#define __HAL_PWR_VDDIO2_EXTI_ENABLE_IT()             (EXTI->IMR |= (PWR_EXTI_LINE_VDDIO2))
N
N/**
N  * @brief Disable interrupt on Vddio2 Monitor Exti Line 31.
N  * @retval None.
N  */
N#define __HAL_PWR_VDDIO2_EXTI_DISABLE_IT()            (EXTI->IMR &= ~(PWR_EXTI_LINE_VDDIO2))
N
N/**
N  * @brief  Vddio2 Monitor EXTI line configuration: clear falling edge and rising edge trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_VDDIO2_EXTI_DISABLE_FALLING_EDGE()                 \
N                        do{                                          \
N                            EXTI->FTSR &= ~(PWR_EXTI_LINE_VDDIO2);   \
N                            EXTI->RTSR &= ~(PWR_EXTI_LINE_VDDIO2);   \
N                          } while(0)
X#define __HAL_PWR_VDDIO2_EXTI_DISABLE_FALLING_EDGE()                                         do{                                                                      EXTI->FTSR &= ~(PWR_EXTI_LINE_VDDIO2);                               EXTI->RTSR &= ~(PWR_EXTI_LINE_VDDIO2);                             } while(0)
N                    
N/**
N  * @brief  Vddio2 Monitor EXTI line configuration: set falling edge trigger.
N  * @retval None.
N  */
N#define __HAL_PWR_VDDIO2_EXTI_ENABLE_FALLING_EDGE()  EXTI->FTSR |= (PWR_EXTI_LINE_VDDIO2)
N
N/**
N  * @brief Check whether the specified VDDIO2 monitor EXTI interrupt flag is set or not.
N  * @retval EXTI VDDIO2 Monitor Line Status.
N  */
N#define __HAL_PWR_VDDIO2_EXTI_GET_FLAG()              (EXTI->PR & (PWR_EXTI_LINE_VDDIO2))
N
N/**
N  * @brief Clear the VDDIO2 Monitor EXTI flag.
N  * @retval None.
N  */
N#define __HAL_PWR_VDDIO2_EXTI_CLEAR_FLAG()            (EXTI->PR = (PWR_EXTI_LINE_VDDIO2))
N
N/**
N  * @brief Generate a Software interrupt on selected EXTI line.
N  * @retval None.
N  */
N#define __HAL_PWR_VDDIO2_EXTI_GENERATE_SWIT()         (EXTI->SWIER |= (PWR_EXTI_LINE_VDDIO2))
N
N
N#endif /* defined (STM32F042x6) || defined (STM32F048xx) ||\
N          defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || \
N          defined (STM32F091xC) || defined (STM32F098xx) */
X#endif  
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @addtogroup PWREx_Exported_Functions PWREx Exported Functions
N *  @{
N */
N
N/** @addtogroup PWREx_Exported_Functions_Group1
N  * @{
N  */
N/* I/O operation functions  ***************************************************/
N#if defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || \
N    defined (STM32F091xC)
X#if 0L || 0L || 0L ||     0L || 0L ||     1L
Nvoid HAL_PWR_PVD_IRQHandler(void);
Nvoid HAL_PWR_PVDCallback(void);
N#endif /* defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || */
N       /* defined (STM32F071xB) || defined (STM32F072xB) || */
N       /* defined (STM32F091xC) */
N
N#if defined (STM32F042x6) || defined (STM32F048xx) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || \
N    defined (STM32F091xC) || defined (STM32F098xx)
X#if 0L || 0L ||     0L || 0L || 0L ||     1L || 0L
Nvoid HAL_PWREx_Vddio2Monitor_IRQHandler(void);
Nvoid HAL_PWREx_Vddio2MonitorCallback(void);
N#endif /* defined (STM32F042x6) || defined (STM32F048xx) || \
N          defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || \
N          defined (STM32F091xC) || defined (STM32F098xx) */
X#endif  
N
N/* Peripheral Control functions  **********************************************/
N#if defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || \
N    defined (STM32F091xC)
X#if 0L || 0L || 0L ||     0L || 0L ||     1L
Nvoid HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD);
Nvoid HAL_PWR_EnablePVD(void);
Nvoid HAL_PWR_DisablePVD(void);
N#endif /* defined (STM32F031x6) || defined (STM32F042x6) || defined (STM32F051x8) || */
N       /* defined (STM32F071xB) || defined (STM32F072xB) || */
N       /* defined (STM32F091xC) */
N       
N#if defined (STM32F042x6) || defined (STM32F048xx) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || \
N    defined (STM32F091xC) || defined (STM32F098xx)
X#if 0L || 0L ||     0L || 0L || 0L ||     1L || 0L
Nvoid HAL_PWREx_EnableVddio2Monitor(void);
Nvoid HAL_PWREx_DisableVddio2Monitor(void);
N#endif /* defined (STM32F042x6) || defined (STM32F048xx) || \
N          defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || \
N          defined (STM32F091xC) || defined (STM32F098xx) */
X#endif  
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_PWR_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 141 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_pwr.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N
N/** @addtogroup PWR_Exported_Functions PWR Exported Functions
N  * @{
N  */
N  
N/** @addtogroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
N  * @{
N  */
N
N/* Initialization and de-initialization functions *****************************/
Nvoid HAL_PWR_DeInit(void);
N
N/**
N  * @}
N  */
N
N/** @addtogroup PWR_Exported_Functions_Group2 Peripheral Control functions 
N  * @{
N  */
N
N/* Peripheral Control functions  **********************************************/
Nvoid HAL_PWR_EnableBkUpAccess(void);
Nvoid HAL_PWR_DisableBkUpAccess(void);
N
N/* WakeUp pins configuration functions ****************************************/
Nvoid HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx);
Nvoid HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx);
N
N/* Low Power modes configuration functions ************************************/
Nvoid HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry);
Nvoid HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry);
Nvoid HAL_PWR_EnterSTANDBYMode(void);
N
Nvoid HAL_PWR_EnableSleepOnExit(void);
Nvoid HAL_PWR_DisableSleepOnExit(void);
Nvoid HAL_PWR_EnableSEVOnPend(void);
Nvoid HAL_PWR_DisableSEVOnPend(void);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __STM32F0xx_HAL_PWR_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 262 "../Inc/stm32f0xx_hal_conf.h" 2
N#endif /* HAL_PWR_MODULE_ENABLED */
N
N#ifdef HAL_RTC_MODULE_ENABLED
N #include "stm32f0xx_hal_rtc.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rtc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_rtc.h
N  * @author  MCD Application Team
N  * @brief   Header file of RTC HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_RTC_H
N#define __STM32F0xx_HAL_RTC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup RTC RTC
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup RTC_Exported_Types RTC Exported Types
N  * @{
N  */
N    
N/** 
N  * @brief  HAL State structures definition  
N  */ 
Ntypedef enum
N{
N  HAL_RTC_STATE_RESET             = 0x00U,  /*!< RTC not yet initialized or disabled */
N  HAL_RTC_STATE_READY             = 0x01U,  /*!< RTC initialized and ready for use   */
N  HAL_RTC_STATE_BUSY              = 0x02U,  /*!< RTC process is ongoing              */     
N  HAL_RTC_STATE_TIMEOUT           = 0x03U,  /*!< RTC timeout state                   */  
N  HAL_RTC_STATE_ERROR             = 0x04U   /*!< RTC error state                     */      
N                                                                        
N}HAL_RTCStateTypeDef;
N
N/** 
N  * @brief  RTC Configuration Structure definition  
N  */
Ntypedef struct
N{
N  uint32_t HourFormat;      /*!< Specifies the RTC Hour Format.
N                                 This parameter can be a value of @ref RTC_Hour_Formats */         
N
N  uint32_t AsynchPrediv;    /*!< Specifies the RTC Asynchronous Predivider value.
N                                 This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F */        
N                               
N  uint32_t SynchPrediv;     /*!< Specifies the RTC Synchronous Predivider value.
N                                 This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF */   
N  
N  uint32_t OutPut;          /*!< Specifies which signal will be routed to the RTC output.   
N                                 This parameter can be a value of @ref RTCEx_Output_selection_Definitions */
N
N  uint32_t OutPutPolarity;  /*!< Specifies the polarity of the output signal.  
N                                 This parameter can be a value of @ref RTC_Output_Polarity_Definitions */ 
N  
N  uint32_t OutPutType;      /*!< Specifies the RTC Output Pin mode.   
N                                 This parameter can be a value of @ref RTC_Output_Type_ALARM_OUT */             
N}RTC_InitTypeDef;
N
N/** 
N  * @brief  RTC Time structure definition  
N  */
Ntypedef struct
N{
N  uint8_t Hours;            /*!< Specifies the RTC Time Hour.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the RTC_HourFormat_12 is selected.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the RTC_HourFormat_24 is selected  */
N
N  uint8_t Minutes;          /*!< Specifies the RTC Time Minutes.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */
N  
N  uint8_t Seconds;          /*!< Specifies the RTC Time Seconds.
N                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */
N
N  uint8_t TimeFormat;       /*!< Specifies the RTC AM/PM Time.
N                                 This parameter can be a value of @ref RTC_AM_PM_Definitions */
N
N  uint32_t SubSeconds;     /*!< Specifies the RTC_SSR RTC Sub Second register content.
N                                 This parameter corresponds to a time unit range between [0-1] Second
N                                 with [1 Sec / SecondFraction +1] granularity */
N 
N  uint32_t SecondFraction;  /*!< Specifies the range or granularity of Sub Second register content
N                                 corresponding to Synchronous pre-scaler factor value (PREDIV_S)
N                                 This parameter corresponds to a time unit range between [0-1] Second
N                                 with [1 Sec / SecondFraction +1] granularity.
N                                 This field will be used only by HAL_RTC_GetTime function */
N  
N  uint32_t DayLightSaving;  /*!< Specifies RTC_DayLightSaveOperation: the value of hour adjustment.
N                                 This parameter can be a value of @ref RTC_DayLightSaving_Definitions */
N  
N  uint32_t StoreOperation;  /*!< Specifies RTC_StoreOperation value to be written in the BCK bit 
N                                 in CR register to store the operation.
N                                 This parameter can be a value of @ref RTC_StoreOperation_Definitions */
N}RTC_TimeTypeDef; 
N  
N/** 
N  * @brief  RTC Date structure definition  
N  */
Ntypedef struct
N{
N  uint8_t WeekDay;  /*!< Specifies the RTC Date WeekDay.
N                         This parameter can be a value of @ref RTC_WeekDay_Definitions */
N  
N  uint8_t Month;    /*!< Specifies the RTC Date Month (in BCD format).
N                         This parameter can be a value of @ref RTC_Month_Date_Definitions */
N
N  uint8_t Date;     /*!< Specifies the RTC Date.
N                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */
N  
N  uint8_t Year;     /*!< Specifies the RTC Date Year.
N                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */
N                        
N}RTC_DateTypeDef;
N
N/** 
N  * @brief  RTC Alarm structure definition  
N  */
Ntypedef struct
N{
N  RTC_TimeTypeDef AlarmTime;     /*!< Specifies the RTC Alarm Time members */
N    
N  uint32_t AlarmMask;            /*!< Specifies the RTC Alarm Masks.
N                                      This parameter can be a value of @ref RTC_AlarmMask_Definitions */
N  
N  uint32_t AlarmSubSecondMask;   /*!< Specifies the RTC Alarm SubSeconds Masks.
N                                      This parameter can be a value of @ref RTC_Alarm_Sub_Seconds_Masks_Definitions */                                   
N
N  uint32_t AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on Date or WeekDay.
N                                     This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions */
N  
N  uint8_t AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Date/WeekDay.
N                                      If the Alarm Date is selected, this parameter must be set to a value in the 1-31 range.
N                                      If the Alarm WeekDay is selected, this parameter can be a value of @ref RTC_WeekDay_Definitions */
N                                                                     
N  uint32_t Alarm;                /*!< Specifies the alarm .
N                                      This parameter can be a value of @ref RTC_Alarms_Definitions */                            
N}RTC_AlarmTypeDef;
N
N/** 
N  * @brief  RTC Handle Structure definition  
N  */ 
Ntypedef struct
N{
N  RTC_TypeDef                 *Instance;  /*!< Register base address    */
N   
N  RTC_InitTypeDef             Init;       /*!< RTC required parameters  */ 
N  
N  HAL_LockTypeDef             Lock;       /*!< RTC locking object       */
N  
N  __IO HAL_RTCStateTypeDef    State;      /*!< Time communication state */
X  volatile HAL_RTCStateTypeDef    State;       
N    
N}RTC_HandleTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RTC_Exported_Constants RTC Exported Constants
N  * @{
N  */
N
N/** @defgroup RTC_Hour_Formats RTC Hour Formats
N  * @{
N  */ 
N#define RTC_HOURFORMAT_24              0x00000000U
N#define RTC_HOURFORMAT_12              0x00000040U
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_Polarity_Definitions RTC Output Polarity Definitions
N  * @{
N  */ 
N#define RTC_OUTPUT_POLARITY_HIGH       0x00000000U
N#define RTC_OUTPUT_POLARITY_LOW        0x00100000U
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_Type_ALARM_OUT RTC Output Type ALARM OUT
N  * @{
N  */ 
N#define RTC_OUTPUT_TYPE_OPENDRAIN      0x00000000U
N#define RTC_OUTPUT_TYPE_PUSHPULL       0x00040000U
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_AM_PM_Definitions RTC AM PM Definitions
N  * @{
N  */ 
N#define RTC_HOURFORMAT12_AM            ((uint8_t)0x00)
N#define RTC_HOURFORMAT12_PM            ((uint8_t)0x40)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_DayLightSaving_Definitions RTC DayLight Saving Definitions
N  * @{
N  */ 
N#define RTC_DAYLIGHTSAVING_SUB1H       0x00020000U
N#define RTC_DAYLIGHTSAVING_ADD1H       0x00010000U
N#define RTC_DAYLIGHTSAVING_NONE        0x00000000U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_StoreOperation_Definitions RTC Store Operation Definitions
N  * @{
N  */ 
N#define RTC_STOREOPERATION_RESET        0x00000000U
N#define RTC_STOREOPERATION_SET          0x00040000U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Input_parameter_format_definitions RTC Input parameter format definitions
N  * @{
N  */ 
N#define RTC_FORMAT_BIN                      0x000000000U
N#define RTC_FORMAT_BCD                      0x000000001U
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Month_Date_Definitions RTC Month Date Definitions
N  * @{
N  */ 
N/* Coded in BCD format */
N#define RTC_MONTH_JANUARY              ((uint8_t)0x01)
N#define RTC_MONTH_FEBRUARY             ((uint8_t)0x02)
N#define RTC_MONTH_MARCH                ((uint8_t)0x03)
N#define RTC_MONTH_APRIL                ((uint8_t)0x04)
N#define RTC_MONTH_MAY                  ((uint8_t)0x05)
N#define RTC_MONTH_JUNE                 ((uint8_t)0x06)
N#define RTC_MONTH_JULY                 ((uint8_t)0x07)
N#define RTC_MONTH_AUGUST               ((uint8_t)0x08)
N#define RTC_MONTH_SEPTEMBER            ((uint8_t)0x09)
N#define RTC_MONTH_OCTOBER              ((uint8_t)0x10)
N#define RTC_MONTH_NOVEMBER             ((uint8_t)0x11)
N#define RTC_MONTH_DECEMBER             ((uint8_t)0x12)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_WeekDay_Definitions RTC WeekDay Definitions
N  * @{
N  */   
N#define RTC_WEEKDAY_MONDAY             ((uint8_t)0x01)
N#define RTC_WEEKDAY_TUESDAY            ((uint8_t)0x02)
N#define RTC_WEEKDAY_WEDNESDAY          ((uint8_t)0x03)
N#define RTC_WEEKDAY_THURSDAY           ((uint8_t)0x04)
N#define RTC_WEEKDAY_FRIDAY             ((uint8_t)0x05)
N#define RTC_WEEKDAY_SATURDAY           ((uint8_t)0x06)
N#define RTC_WEEKDAY_SUNDAY             ((uint8_t)0x07)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_AlarmDateWeekDay_Definitions RTC Alarm Date WeekDay Definitions
N  * @{
N  */ 
N#define RTC_ALARMDATEWEEKDAYSEL_DATE      0x00000000U
N#define RTC_ALARMDATEWEEKDAYSEL_WEEKDAY   0x40000000U
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_AlarmMask_Definitions RTC Alarm Mask Definitions
N  * @{
N  */ 
N#define RTC_ALARMMASK_NONE                0x00000000U
N#define RTC_ALARMMASK_DATEWEEKDAY         RTC_ALRMAR_MSK4
N#define RTC_ALARMMASK_HOURS               RTC_ALRMAR_MSK3
N#define RTC_ALARMMASK_MINUTES             RTC_ALRMAR_MSK2
N#define RTC_ALARMMASK_SECONDS             RTC_ALRMAR_MSK1
N#define RTC_ALARMMASK_ALL                 0x80808080U
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarms_Definitions RTC Alarms Definitions
N  * @{
N  */ 
N#define RTC_ALARM_A                       RTC_CR_ALRAE
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarm_Sub_Seconds_Masks_Definitions RTC Alarm Sub Seconds Masks Definitions
N  * @{
N  */ 
N#define RTC_ALARMSUBSECONDMASK_ALL         0x00000000U  /*!< All Alarm SS fields are masked. 
N                                                                        There is no comparison on sub seconds 
N                                                                        for Alarm */
N#define RTC_ALARMSUBSECONDMASK_SS14_1      0x01000000U  /*!< SS[14:1] are don't care in Alarm 
N                                                                        comparison. Only SS[0] is compared.    */
N#define RTC_ALARMSUBSECONDMASK_SS14_2      0x02000000U  /*!< SS[14:2] are don't care in Alarm 
N                                                                        comparison. Only SS[1:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_3      0x03000000U  /*!< SS[14:3] are don't care in Alarm 
N                                                                        comparison. Only SS[2:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_4      0x04000000U  /*!< SS[14:4] are don't care in Alarm 
N                                                                        comparison. Only SS[3:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_5      0x05000000U  /*!< SS[14:5] are don't care in Alarm 
N                                                                        comparison. Only SS[4:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_6      0x06000000U  /*!< SS[14:6] are don't care in Alarm 
N                                                                        comparison. Only SS[5:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_7      0x07000000U  /*!< SS[14:7] are don't care in Alarm 
N                                                                        comparison. Only SS[6:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_8      0x08000000U  /*!< SS[14:8] are don't care in Alarm 
N                                                                        comparison. Only SS[7:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_9      0x09000000U  /*!< SS[14:9] are don't care in Alarm 
N                                                                        comparison. Only SS[8:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_10     0x0A000000U  /*!< SS[14:10] are don't care in Alarm 
N                                                                        comparison. Only SS[9:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_11     0x0B000000U  /*!< SS[14:11] are don't care in Alarm 
N                                                                        comparison. Only SS[10:0] are compared */
N#define RTC_ALARMSUBSECONDMASK_SS14_12     0x0C000000U  /*!< SS[14:12] are don't care in Alarm 
N                                                                        comparison.Only SS[11:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_SS14_13     0x0D000000U  /*!< SS[14:13] are don't care in Alarm 
N                                                                        comparison. Only SS[12:0] are compared */
N#define RTC_ALARMSUBSECONDMASK_SS14        0x0E000000U  /*!< SS[14] is don't care in Alarm 
N                                                                        comparison.Only SS[13:0] are compared  */
N#define RTC_ALARMSUBSECONDMASK_NONE        0x0F000000U  /*!< SS[14:0] are compared and must match 
N                                                                        to activate alarm. */
N/**
N  * @}
N  */   
N
N/** @defgroup RTC_Interrupts_Definitions RTC Interrupts Definitions
N  * @{
N  */
N#define RTC_IT_TS                         0x00008000U
N#define RTC_IT_WUT                        0x00004000U
N#define RTC_IT_ALRA                       0x00001000U
N#define RTC_IT_TAMP                       0x00000004U /* Used only to Enable the Tamper Interrupt */
N#define RTC_IT_TAMP1                      0x00020000U /*only for RTC_ISR flag check*/
N#define RTC_IT_TAMP2                      0x00040000U /*only for RTC_ISR flag check*/
N#define RTC_IT_TAMP3                      0x00080000U /*only for RTC_ISR flag check*/
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Flags_Definitions RTC Flags Definitions
N  * @{
N  */
N#define RTC_FLAG_RECALPF                  0x00010000U
N#define RTC_FLAG_TAMP3F                   0x00008000U
N#define RTC_FLAG_TAMP2F                   0x00004000U
N#define RTC_FLAG_TAMP1F                   0x00002000U
N#define RTC_FLAG_TSOVF                    0x00001000U
N#define RTC_FLAG_TSF                      0x00000800U
N#define RTC_FLAG_WUTF                     0x00000400U
N#define RTC_FLAG_ALRAF                    0x00000100U
N#define RTC_FLAG_INITF                    0x00000040U
N#define RTC_FLAG_RSF                      0x00000020U
N#define RTC_FLAG_INITS                    0x00000010U
N#define RTC_FLAG_SHPF                     0x00000008U
N#define RTC_FLAG_WUTWF                    0x00000004U
N#define RTC_FLAG_ALRAWF                   0x00000001U
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N  
N/* Exported macros ------------------------------------------------------------*/
N/** @defgroup RTC_Exported_Macros RTC Exported Macros
N  * @{
N  */
N
N/** @brief Reset RTC handle state
N  * @param  __HANDLE__ RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = HAL_RTC_STATE_RESET)
N
N/**
N  * @brief  Disable the write protection for RTC registers.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WRITEPROTECTION_DISABLE(__HANDLE__)             \
N                        do{                                       \
N                            (__HANDLE__)->Instance->WPR = 0xCAU;   \
N                            (__HANDLE__)->Instance->WPR = 0x53U;   \
N                          } while(0)
X#define __HAL_RTC_WRITEPROTECTION_DISABLE(__HANDLE__)                                     do{                                                                   (__HANDLE__)->Instance->WPR = 0xCAU;                               (__HANDLE__)->Instance->WPR = 0x53U;                             } while(0)
N
N/**
N  * @brief  Enable the write protection for RTC registers.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WRITEPROTECTION_ENABLE(__HANDLE__)              \
N                        do{                                       \
N                            (__HANDLE__)->Instance->WPR = 0xFFU;   \
N                          } while(0)                            
X#define __HAL_RTC_WRITEPROTECTION_ENABLE(__HANDLE__)                                      do{                                                                   (__HANDLE__)->Instance->WPR = 0xFFU;                             } while(0)                            
N 
N/**
N  * @brief  Enable the RTC ALARMA peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_ALARMA_ENABLE(__HANDLE__)                           ((__HANDLE__)->Instance->CR |= (RTC_CR_ALRAE))
N
N/**
N  * @brief  Disable the RTC ALARMA peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_ALARMA_DISABLE(__HANDLE__)                          ((__HANDLE__)->Instance->CR &= ~(RTC_CR_ALRAE))
N
N/**
N  * @brief  Enable the RTC Alarm interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt sources to be enabled or disabled.
N  *          This parameter can be any combination of the following values:
N  *             @arg RTC_IT_ALRA: Alarm A interrupt
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_ENABLE_IT(__HANDLE__, __INTERRUPT__)          ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the RTC Alarm interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt sources to be enabled or disabled.
N  *         This parameter can be any combination of the following values:
N  *            @arg RTC_IT_ALRA: Alarm A interrupt
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_DISABLE_IT(__HANDLE__, __INTERRUPT__)         ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified RTC Alarm interrupt has occurred or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_ALRA: Alarm A interrupt
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_GET_IT(__HANDLE__, __INTERRUPT__)  (((((__HANDLE__)->Instance->ISR)& ((__INTERRUPT__)>> 4U)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Check whether the specified RTC Alarm interrupt has been enabled or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Alarm interrupt sources to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_ALRA: Alarm A interrupt
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)     (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC Alarm's flag status.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Alarm Flag sources to check.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_ALRAF
N  *            @arg RTC_FLAG_ALRAWF
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_GET_FLAG(__HANDLE__, __FLAG__)                (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Alarm's pending flags.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Alarm Flag sources to clear.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_ALRAF
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_CLEAR_FLAG(__HANDLE__, __FLAG__)   ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT) | ((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
N
N/**
N  * @brief  Enable interrupt on the RTC Alarm associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_IT()            (EXTI->IMR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable interrupt on the RTC Alarm associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_IT()           (EXTI->IMR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable event on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_EVENT()         (EXTI->EMR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable event on the RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_EVENT()         (EXTI->EMR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable falling edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_FALLING_EDGE()   (EXTI->FTSR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable falling edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_FALLING_EDGE()  (EXTI->FTSR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable rising edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE()    (EXTI->RTSR |= RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief  Disable rising edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_RISING_EDGE()   (EXTI->RTSR &= ~(RTC_EXTI_LINE_ALARM_EVENT))
N
N/**
N  * @brief  Enable rising & falling edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_ENABLE_RISING_FALLING_EDGE() __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();__HAL_RTC_ALARM_EXTI_ENABLE_FALLING_EDGE();
N
N/**
N  * @brief  Disable rising & falling edge trigger on the RTC Alarm associated Exti line.  
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_DISABLE_RISING_FALLING_EDGE() __HAL_RTC_ALARM_EXTI_DISABLE_RISING_EDGE();__HAL_RTC_ALARM_EXTI_DISABLE_FALLING_EDGE();
N
N/**
N  * @brief Check whether the RTC Alarm associated Exti line interrupt flag is set or not.
N  * @retval Line Status.
N  */
N#define __HAL_RTC_ALARM_EXTI_GET_FLAG()              (EXTI->PR & RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief Clear the RTC Alarm associated Exti line flag.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_CLEAR_FLAG()            (EXTI->PR = RTC_EXTI_LINE_ALARM_EVENT)
N
N/**
N  * @brief Generate a Software interrupt on RTC Alarm associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_ALARM_EXTI_GENERATE_SWIT()         (EXTI->SWIER |= RTC_EXTI_LINE_ALARM_EVENT)
N/**
N  * @}
N  */
N
N/* Include RTC HAL Extended module */
N#include "stm32f0xx_hal_rtc_ex.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rtc_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_rtc_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of RTC HAL Extended module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************  
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_RTC_EX_H
N#define __STM32F0xx_HAL_RTC_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @defgroup RTCEx RTCEx
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/ 
N
N/** @defgroup RTCEx_Exported_Types RTCEx Exported Types
N  * @{
N  */
N
N/**
N  * @brief  RTC Tamper structure definition
N  */
Ntypedef struct
N{
N  uint32_t Tamper;                      /*!< Specifies the Tamper Pin.
N                                             This parameter can be a value of @ref  RTCEx_Tamper_Pins_Definitions */
N
N  uint32_t Trigger;                     /*!< Specifies the Tamper Trigger.
N                                             This parameter can be a value of @ref  RTCEx_Tamper_Trigger_Definitions */
N
N  uint32_t Filter;                      /*!< Specifies the RTC Filter Tamper.
N                                             This parameter can be a value of @ref RTCEx_Tamper_Filter_Definitions */
N
N  uint32_t SamplingFrequency;           /*!< Specifies the sampling frequency.
N                                             This parameter can be a value of @ref RTCEx_Tamper_Sampling_Frequencies_Definitions */
N
N  uint32_t PrechargeDuration;           /*!< Specifies the Precharge Duration .
N                                             This parameter can be a value of @ref RTCEx_Tamper_Pin_Precharge_Duration_Definitions */
N
N  uint32_t TamperPullUp;                /*!< Specifies the Tamper PullUp .
N                                             This parameter can be a value of @ref RTCEx_Tamper_Pull_UP_Definitions */
N
N  uint32_t TimeStampOnTamperDetection;  /*!< Specifies the TimeStampOnTamperDetection.
N                                             This parameter can be a value of @ref RTCEx_Tamper_TimeStampOnTamperDetection_Definitions */
N}RTC_TamperTypeDef;
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup RTCEx_Exported_Constants RTCEx Exported Constants
N  * @{
N  */
N
N/** @defgroup RTCEx_Output_selection_Definitions RTCEx Output Selection Definition
N  * @{
N  */
N#define RTC_OUTPUT_DISABLE             0x00000000U
N#define RTC_OUTPUT_ALARMA              0x00200000U
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L
N#define RTC_OUTPUT_WAKEUP              0x00600000U
N#endif
N
N/**
N  * @}
N  */
N
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F030xC) && !defined(STM32F070x6) && !defined(STM32F070xB)
X#if !0L && !0L && !0L && !0L && !0L
N/** @defgroup RTCEx_Backup_Registers_Definitions RTCEx Backup Registers Definition
N  * @{
N  */
N#define RTC_BKP_DR0                       0x00000000U
N#define RTC_BKP_DR1                       0x00000001U
N#define RTC_BKP_DR2                       0x00000002U
N#define RTC_BKP_DR3                       0x00000003U
N#define RTC_BKP_DR4                       0x00000004U
N/**
N  * @}
N  */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F030xC) && !defined(STM32F070x6) && !defined(STM32F070xB) */
N
N/** @defgroup RTCEx_Time_Stamp_Edges_definitions RTCEx Time Stamp Edges definition
N  * @{
N  */
N#define RTC_TIMESTAMPEDGE_RISING          0x00000000U
N#define RTC_TIMESTAMPEDGE_FALLING         0x00000008U
N
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_TimeStamp_Pin_Selections RTCEx TimeStamp Pin Selection
N  * @{
N  */
N#define RTC_TIMESTAMPPIN_DEFAULT              0x00000000U
N
N/**
N  * @}
N  */
N
N  
N/** @defgroup RTCEx_Tamper_Pins_Definitions RTCEx Tamper Pins Definition
N  * @{
N  */
N#define RTC_TAMPER_1                    RTC_TAFCR_TAMP1E
N#define RTC_TAMPER_2                    RTC_TAFCR_TAMP2E
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 1L || 0L
N#define RTC_TAMPER_3                    RTC_TAFCR_TAMP3E
N#endif
N
N/**
N  * @}
N  */
N
N
N
N/** @defgroup RTCEx_Tamper_Trigger_Definitions RTCEx Tamper Trigger Definition
N  * @{
N  */
N#define RTC_TAMPERTRIGGER_RISINGEDGE       0x00000000U
N#define RTC_TAMPERTRIGGER_FALLINGEDGE      0x00000002U
N#define RTC_TAMPERTRIGGER_LOWLEVEL         RTC_TAMPERTRIGGER_RISINGEDGE
N#define RTC_TAMPERTRIGGER_HIGHLEVEL        RTC_TAMPERTRIGGER_FALLINGEDGE
N
N
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_Filter_Definitions RTCEx Tamper Filter Definition
N  * @{
N  */
N#define RTC_TAMPERFILTER_DISABLE   0x00000000U  /*!< Tamper filter is disabled */
N
N#define RTC_TAMPERFILTER_2SAMPLE   0x00000800U  /*!< Tamper is activated after 2
N                                                                consecutive samples at the active level */
N#define RTC_TAMPERFILTER_4SAMPLE   0x00001000U  /*!< Tamper is activated after 4
N                                                                consecutive samples at the active level */
N#define RTC_TAMPERFILTER_8SAMPLE   0x00001800U  /*!< Tamper is activated after 8
N                                                                consecutive samples at the active level. */
N
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_Sampling_Frequencies_Definitions RTCEx Tamper Sampling Frequencies Definition  
N  * @{
N  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768  0x00000000U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 32768 */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV16384  0x00000100U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 16384 */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV8192   0x00000200U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 8192  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV4096   0x00000300U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 4096  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV2048   0x00000400U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 2048  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV1024   0x00000500U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 1024  */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV512    0x00000600U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 512   */
N#define RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV256    0x00000700U  /*!< Each of the tamper inputs are sampled
N                                                                             with a frequency =  RTCCLK / 256   */
N
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_Pin_Precharge_Duration_Definitions RTCEx Tamper Pin Precharge Duration Definition
N  * @{
N  */
N#define RTC_TAMPERPRECHARGEDURATION_1RTCCLK 0x00000000U  /*!< Tamper pins are pre-charged before
N                                                                         sampling during 1 RTCCLK cycle */
N#define RTC_TAMPERPRECHARGEDURATION_2RTCCLK 0x00002000U  /*!< Tamper pins are pre-charged before
N                                                                         sampling during 2 RTCCLK cycles */
N#define RTC_TAMPERPRECHARGEDURATION_4RTCCLK 0x00004000U  /*!< Tamper pins are pre-charged before
N                                                                         sampling during 4 RTCCLK cycles */
N#define RTC_TAMPERPRECHARGEDURATION_8RTCCLK 0x00006000U  /*!< Tamper pins are pre-charged before
N                                                                         sampling during 8 RTCCLK cycles */
N
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_TimeStampOnTamperDetection_Definitions RTCEx Tamper TimeStampOnTamperDetection Definition
N  * @{
N  */
N#define RTC_TIMESTAMPONTAMPERDETECTION_ENABLE  ((uint32_t)RTC_TAFCR_TAMPTS)  /*!< TimeStamp on Tamper Detection event saved */
N#define RTC_TIMESTAMPONTAMPERDETECTION_DISABLE 0x00000000U        /*!< TimeStamp on Tamper Detection event is not saved */
N
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Tamper_Pull_UP_Definitions RTCEx Tamper Pull UP Definition
N  * @{
N  */
N#define RTC_TAMPER_PULLUP_ENABLE  0x00000000U            /*!< Tamper pins are pre-charged before sampling */
N#define RTC_TAMPER_PULLUP_DISABLE ((uint32_t)RTC_TAFCR_TAMPPUDIS)   /*!< Tamper pins are not pre-charged before sampling */
N
N/**
N  * @}
N  */
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L
N/** @defgroup RTCEx_Wakeup_Timer_Definitions RTCEx Wakeup Timer Definition
N  * @{
N  */
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV16        0x00000000U
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV8         0x00000001U
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV4         0x00000002U
N#define RTC_WAKEUPCLOCK_RTCCLK_DIV2         0x00000003U
N#define RTC_WAKEUPCLOCK_CK_SPRE_16BITS      0x00000004U
N#define RTC_WAKEUPCLOCK_CK_SPRE_17BITS      0x00000006U
N
N
N/**
N  * @}
N  */
N#endif /* defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC) */
N
N/** @defgroup RTCEx_Smooth_calib_period_Definitions RTCEx Smooth calib period Definition
N  * @{
N  */
N#define RTC_SMOOTHCALIB_PERIOD_32SEC   0x00000000U /*!<  If RTCCLK = 32768 Hz, Smooth calibation
N                                                                    period is 32s,  else 2exp20 RTCCLK seconds */
N#define RTC_SMOOTHCALIB_PERIOD_16SEC   0x00002000U /*!<  If RTCCLK = 32768 Hz, Smooth calibation
N                                                                    period is 16s, else 2exp19 RTCCLK seconds */
N#define RTC_SMOOTHCALIB_PERIOD_8SEC    0x00004000U /*!<  If RTCCLK = 32768 Hz, Smooth calibation
N                                                                    period is 8s, else 2exp18 RTCCLK seconds */
N
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Smooth_calib_Plus_pulses_Definitions RTCEx Smooth calib Plus pulses Definition
N  * @{
N  */
N#define RTC_SMOOTHCALIB_PLUSPULSES_SET    0x00008000U /*!<  The number of RTCCLK pulses added
N                                                                       during a X -second window = Y - CALM[8:0]
N                                                                       with Y = 512, 256, 128 when X = 32, 16, 8 */
N#define RTC_SMOOTHCALIB_PLUSPULSES_RESET  0x00000000U /*!<  The number of RTCCLK pulses subbstited
N                                                                       during a 32-second window =   CALM[8:0] */
N
N/**
N  * @}
N  */
N /** @defgroup RTCEx_Calib_Output_selection_Definitions RTCEx Calib Output selection Definitions
N  * @{
N  */
N#define RTC_CALIBOUTPUT_512HZ            0x00000000U
N#define RTC_CALIBOUTPUT_1HZ              0x00080000U
N
N/**
N  * @}
N  */
N
N/** @defgroup RTCEx_Add_1_Second_Parameter_Definition RTCEx Add 1 Second Parameter Definition
N  * @{
N  */
N#define RTC_SHIFTADD1S_RESET      0x00000000U
N#define RTC_SHIFTADD1S_SET        0x80000000U
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup RTCEx_Exported_Macros RTCEx Exported Macros
N  * @{
N  */
N
N/* ---------------------------------WAKEUPTIMER---------------------------------*/
N/** @defgroup RTCEx_WakeUp_Timer RTC WakeUp Timer
N  * @{
N  */
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L
N/**
N  * @brief  Enable the RTC WakeUp Timer peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_ENABLE(__HANDLE__)                      ((__HANDLE__)->Instance->CR |= (RTC_CR_WUTE))
N
N/**
N  * @brief  Disable the RTC WakeUp Timer peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_DISABLE(__HANDLE__)                     ((__HANDLE__)->Instance->CR &= ~(RTC_CR_WUTE))
N
N/**
N  * @brief  Enable the RTC WakeUpTimer interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC WakeUpTimer interrupt sources to be enabled.
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT: WakeUpTimer interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_ENABLE_IT(__HANDLE__, __INTERRUPT__)    ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the RTC WakeUpTimer interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC WakeUpTimer interrupt sources to be disabled.
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT: WakeUpTimer interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_DISABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified RTC WakeUpTimer interrupt has occurred or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC WakeUpTimer interrupt to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT:  WakeUpTimer interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_GET_IT(__HANDLE__, __INTERRUPT__)       (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 4U)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Check whether the specified RTC Wake Up timer interrupt has been enabled or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Wake Up timer interrupt sources to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_WUT:  WakeUpTimer interrupt
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)   (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC WakeUpTimer's flag status.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC WakeUpTimer Flag is pending or not.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_WUTF
N  *             @arg RTC_FLAG_WUTWF
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_GET_FLAG(__HANDLE__, __FLAG__)   (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Wake Up timer's pending flags.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC WakeUpTimer Flag to clear.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_WUTF
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT)) 
N
N/* WAKE-UP TIMER EXTI */
N/* ------------------ */
N/**
N  * @brief  Enable interrupt on the RTC WakeUp Timer associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT()       (EXTI->IMR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable interrupt on the RTC WakeUp Timer associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT()      (EXTI->IMR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable event on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_EVENT()    (EXTI->EMR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable event on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_EVENT()   (EXTI->EMR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable falling edge trigger on the RTC WakeUp Timer associated Exti line. 
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_FALLING_EDGE()   (EXTI->FTSR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable falling edge trigger on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_FALLING_EDGE()  (EXTI->FTSR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable rising edge trigger on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE()    (EXTI->RTSR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief  Disable rising edge trigger on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_EDGE()   (EXTI->RTSR &= ~(RTC_EXTI_LINE_WAKEUPTIMER_EVENT))
N
N/**
N  * @brief  Enable rising & falling edge trigger on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_FALLING_EDGE() __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();__HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_FALLING_EDGE();
N
N/**
N  * @brief  Disable rising & falling edge trigger on the RTC WakeUp Timer associated Exti line.
N  * This parameter can be:
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_FALLING_EDGE() __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_RISING_EDGE();__HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_FALLING_EDGE();
N
N/**
N  * @brief Check whether the RTC WakeUp Timer associated Exti line interrupt flag is set or not.
N  * @retval Line Status.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG()              (EXTI->PR & RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief Clear the RTC WakeUp Timer associated Exti line flag.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG()            (EXTI->PR = RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N
N/**
N  * @brief Generate a Software interrupt on the RTC WakeUp Timer associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT()         (EXTI->SWIER |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT)
N#endif /* defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC) */
N/**
N  * @}
N  */
N
N/* ---------------------------------TIMESTAMP---------------------------------*/
N/** @defgroup RTCEx_Timestamp RTC Timestamp
N  * @{
N  */
N/**
N  * @brief  Enable the RTC TimeStamp peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_ENABLE(__HANDLE__)                        ((__HANDLE__)->Instance->CR |= (RTC_CR_TSE))
N
N/**
N  * @brief  Disable the RTC TimeStamp peripheral.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_DISABLE(__HANDLE__)                       ((__HANDLE__)->Instance->CR &= ~(RTC_CR_TSE))
N
N/**
N  * @brief  Enable the RTC TimeStamp interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC TimeStamp interrupt source to be enabled.
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_ENABLE_IT(__HANDLE__, __INTERRUPT__)      ((__HANDLE__)->Instance->CR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the RTC TimeStamp interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC TimeStamp interrupt source to be disabled. 
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_DISABLE_IT(__HANDLE__, __INTERRUPT__)     ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))
N
N/**
N  * @brief  Check whether the specified RTC TimeStamp interrupt has occurred or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC TimeStamp interrupt to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_GET_IT(__HANDLE__, __INTERRUPT__)         (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 4U)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Check whether the specified RTC Time Stamp interrupt has been enabled or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Time Stamp interrupt source to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_TS: TimeStamp interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)     (((((__HANDLE__)->Instance->CR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N/**
N  * @brief  Get the selected RTC TimeStamp's flag status.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC TimeStamp Flag is pending or not.
N  *         This parameter can be:
N  *            @arg RTC_FLAG_TSF   
N  *            @arg RTC_FLAG_TSOVF     
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_GET_FLAG(__HANDLE__, __FLAG__)            (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
N
N/**
N  * @brief  Clear the RTC Time Stamp's pending flags.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Alarm Flag to clear.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_TSF  
N  * @retval None
N  */
N#define __HAL_RTC_TIMESTAMP_CLEAR_FLAG(__HANDLE__, __FLAG__)          ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
N
N/**
N  * @}
N  */
N
N/* ---------------------------------TAMPER------------------------------------*/
N/** @defgroup RTCEx_Tamper RTC Tamper
N  * @{
N  */
N
N/**
N  * @brief  Enable the RTC Tamper1 input detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER1_ENABLE(__HANDLE__)                         ((__HANDLE__)->Instance->TAFCR |= (RTC_TAFCR_TAMP1E))
N
N/**
N  * @brief  Disable the RTC Tamper1 input detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER1_DISABLE(__HANDLE__)                        ((__HANDLE__)->Instance->TAFCR &= ~(RTC_TAFCR_TAMP1E))
N
N/**
N  * @brief  Enable the RTC Tamper2 input detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER2_ENABLE(__HANDLE__)                         ((__HANDLE__)->Instance->TAFCR |= (RTC_TAFCR_TAMP2E))
N
N/**
N  * @brief  Disable the RTC Tamper2 input detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER2_DISABLE(__HANDLE__)                        ((__HANDLE__)->Instance->TAFCR &= ~(RTC_TAFCR_TAMP2E))
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L
N/**
N  * @brief  Enable the RTC Tamper3 input detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER3_ENABLE(__HANDLE__)                         ((__HANDLE__)->Instance->TAFCR |= (RTC_TAFCR_TAMP3E))
N
N/**
N  * @brief  Disable the RTC Tamper3 input detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER3_DISABLE(__HANDLE__)                        ((__HANDLE__)->Instance->TAFCR &= ~(RTC_TAFCR_TAMP3E))
N
N#endif /* defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC) */
N/**
N  * @brief  Enable the RTC Tamper interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Tamper interrupt sources to be enabled.
N  *          This parameter can be any combination of the following values:
N  *            @arg RTC_IT_TAMP: Tamper interrupt
N  * @retval None
N  */   
N#define __HAL_RTC_TAMPER_ENABLE_IT(__HANDLE__, __INTERRUPT__)        ((__HANDLE__)->Instance->TAFCR |= (__INTERRUPT__))
N
N/**
N  * @brief  Disable the RTC Tamper interrupt.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Tamper interrupt sources to be disabled. 
N  *         This parameter can be any combination of the following values:
N  *            @arg RTC_IT_TAMP: Tamper interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_DISABLE_IT(__HANDLE__, __INTERRUPT__)       ((__HANDLE__)->Instance->TAFCR &= ~(__INTERRUPT__))
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L
N/**
N  * @brief  Check whether the specified RTC Tamper interrupt has occurred or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Tamper interrupt to check.
N  *         This parameter can be:
N  *            @arg  RTC_IT_TAMP1: Tamper1 interrupt
N  *            @arg  RTC_IT_TAMP2: Tamper2 interrupt
N  *            @arg  RTC_IT_TAMP3: Tamper3 interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_GET_IT(__HANDLE__, __INTERRUPT__)       (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 4U)) != RESET)? SET : RESET)
N#else
S
S/**
S  * @brief  Check whether the specified RTC Tamper interrupt has occurred or not.
S  * @param  __HANDLE__ specifies the RTC handle.
S  * @param  __INTERRUPT__ specifies the RTC Tamper interrupt to check.
S  *         This parameter can be:
S  *            @arg  RTC_IT_TAMP1: Tamper1 interrupt
S  *            @arg  RTC_IT_TAMP2: Tamper2 interrupt
S  * @retval None
S  */
S#define __HAL_RTC_TAMPER_GET_IT(__HANDLE__, __INTERRUPT__)       (((((__HANDLE__)->Instance->ISR) & ((__INTERRUPT__)>> 4U)) != RESET)? SET : RESET)
S
N#endif /* defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC) */
N
N/**
N  * @brief  Check whether the specified RTC Tamper interrupt has been enabled or not.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __INTERRUPT__ specifies the RTC Tamper interrupt source to check.
N  *         This parameter can be:
N  *            @arg RTC_IT_TAMP: Tamper interrupt
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)     (((((__HANDLE__)->Instance->TAFCR) & (__INTERRUPT__)) != RESET) ? SET : RESET)
N
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L
N/**
N  * @brief  Get the selected RTC Tamper's flag status.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Tamper Flag is pending or not.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_TAMP1F 
N  *             @arg RTC_FLAG_TAMP2F
N  *             @arg RTC_FLAG_TAMP3F
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_GET_FLAG(__HANDLE__, __FLAG__)               (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
N
N
N/**
N  * @brief  Clear the RTC Tamper's pending flags.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC Tamper Flag to clear.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_TAMP1F
N  *             @arg RTC_FLAG_TAMP2F
N  *             @arg RTC_FLAG_TAMP3F  
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_CLEAR_FLAG(__HANDLE__, __FLAG__)      ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
N
N#else
S
S/**
S  * @brief  Get the selected RTC Tamper's flag status.
S  * @param  __HANDLE__ specifies the RTC handle.
S  * @param  __FLAG__ specifies the RTC Tamper Flag is pending or not.
S  *          This parameter can be:
S  *             @arg RTC_FLAG_TAMP1F 
S  *             @arg RTC_FLAG_TAMP2F  
S  * @retval None
S  */
S#define __HAL_RTC_TAMPER_GET_FLAG(__HANDLE__, __FLAG__)               (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
S
S
S/**
S  * @brief  Clear the RTC Tamper's pending flags.
S  * @param  __HANDLE__ specifies the RTC handle.
S  * @param  __FLAG__ specifies the RTC Tamper Flag to clear.
S  *          This parameter can be:
S  *             @arg RTC_FLAG_TAMP1F
S  *             @arg RTC_FLAG_TAMP2F 
S  * @retval None
S  */
S#define __HAL_RTC_TAMPER_CLEAR_FLAG(__HANDLE__, __FLAG__)      ((__HANDLE__)->Instance->ISR) = (~((__FLAG__) | RTC_ISR_INIT)|((__HANDLE__)->Instance->ISR & RTC_ISR_INIT))
S
N#endif /* defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC) */
N/**
N  * @}
N  */
N
N/* --------------------------TAMPER/TIMESTAMP---------------------------------*/
N/** @defgroup RTCEx_Tamper_Timestamp EXTI RTC Tamper Timestamp EXTI
N  * @{
N  */
N  
N/* TAMPER TIMESTAMP EXTI */
N/* --------------------- */
N/**
N  * @brief  Enable interrupt on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()        (EXTI->IMR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable interrupt on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()       (EXTI->IMR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable event on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_EVENT()    (EXTI->EMR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable event on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_EVENT()   (EXTI->EMR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable falling edge trigger on the RTC Tamper and Timestamp associated Exti line. 
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_FALLING_EDGE()   (EXTI->FTSR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable falling edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_FALLING_EDGE()  (EXTI->FTSR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable rising edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE()    (EXTI->RTSR |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief  Disable rising edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_EDGE()   (EXTI->RTSR &= ~(RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT))
N
N/**
N  * @brief  Enable rising & falling edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_FALLING_EDGE() __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();__HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_FALLING_EDGE();
N
N/**
N  * @brief  Disable rising & falling edge trigger on the RTC Tamper and Timestamp associated Exti line.
N  * This parameter can be:
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_FALLING_EDGE() __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_RISING_EDGE();__HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_FALLING_EDGE();
N
N/**
N  * @brief Check whether the RTC Tamper and Timestamp associated Exti line interrupt flag is set or not.
N  * @retval Line Status.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()         (EXTI->PR & RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief Clear the RTC Tamper and Timestamp associated Exti line flag.
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()       (EXTI->PR = RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N
N/**
N  * @brief Generate a Software interrupt on the RTC Tamper and Timestamp associated Exti line
N  * @retval None.
N  */
N#define __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()    (EXTI->SWIER |= RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT)
N/**
N  * @}
N  */
N
N/* ------------------------------Calibration----------------------------------*/
N/** @defgroup RTCEx_Calibration RTC Calibration
N  * @{
N  */
N
N/**
N  * @brief  Enable the RTC calibration output.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(__HANDLE__)                 ((__HANDLE__)->Instance->CR |= (RTC_CR_COE))
N
N/**
N  * @brief  Disable the calibration output.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(__HANDLE__)                ((__HANDLE__)->Instance->CR &= ~(RTC_CR_COE))
N
N/**
N  * @brief  Enable the clock reference detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CLOCKREF_DETECTION_ENABLE(__HANDLE__)                 ((__HANDLE__)->Instance->CR |= (RTC_CR_REFCKON))
N
N/**
N  * @brief  Disable the clock reference detection.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @retval None
N  */
N#define __HAL_RTC_CLOCKREF_DETECTION_DISABLE(__HANDLE__)                ((__HANDLE__)->Instance->CR &= ~(RTC_CR_REFCKON))
N
N/**
N  * @brief  Get the selected RTC shift operation's flag status.
N  * @param  __HANDLE__ specifies the RTC handle.
N  * @param  __FLAG__ specifies the RTC shift operation Flag is pending or not.
N  *          This parameter can be:
N  *             @arg RTC_FLAG_SHPF   
N  * @retval None
N  */
N#define __HAL_RTC_SHIFT_GET_FLAG(__HANDLE__, __FLAG__)                (((((__HANDLE__)->Instance->ISR) & (__FLAG__)) != RESET)? SET : RESET)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup RTCEx_Exported_Functions RTCEx Exported Functions
N  * @{
N  */
N
N/* RTC TimeStamp and Tamper functions *****************************************/
N/** @defgroup RTCEx_Exported_Functions_Group1 Extended RTC TimeStamp and Tamper functions
N * @{
N */ 
N
NHAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin);
NHAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTimeStamp, RTC_DateTypeDef *sTimeStampDate, uint32_t Format);
N
NHAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper);
NHAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper);
Nvoid              HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc);
N
Nvoid              HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc);
Nvoid              HAL_RTCEx_Tamper2EventCallback(RTC_HandleTypeDef *hrtc);
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L
Nvoid              HAL_RTCEx_Tamper3EventCallback(RTC_HandleTypeDef *hrtc);
N#endif
Nvoid              HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
NHAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
NHAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L
NHAL_StatusTypeDef HAL_RTCEx_PollForTamper3Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
N#endif
N/**
N  * @}
N  */
N 
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L
N/* RTC Wake-up functions ******************************************************/
N/** @defgroup RTCEx_Exported_Functions_Group2 Extended RTC Wake-up functions
N * @{
N */ 
N 
NHAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock);
NHAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock);
Nuint32_t          HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc);
Nuint32_t          HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc);
Nvoid              HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc);
Nvoid              HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
N#endif
N/**
N  * @}
N  */
N
N/* Extended Control functions ************************************************/
N/** @defgroup RTCEx_Exported_Functions_Group3 Extended Peripheral Control functions
N * @{
N */ 
N
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F030xC) && !defined(STM32F070x6) && !defined(STM32F070xB)
X#if !0L && !0L && !0L && !0L && !0L
Nvoid              HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data);
Nuint32_t          HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister);
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F030xC) && !defined(STM32F070x6) && !defined(STM32F070xB) */
N
NHAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef *hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmoothCalibMinusPulsesValue);
NHAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef *hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS);
NHAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef *hrtc, uint32_t CalibOutput);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N  
N/* Extended RTC features functions *******************************************/
N
N/**
N  * @}
N  */
N
N/* Private types -------------------------------------------------------------*/ 
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RTCEx_Private_Constants RTCEx Private Constants
N  * @{
N  */
N#define RTC_EXTI_LINE_TAMPER_TIMESTAMP_EVENT  ((uint32_t)EXTI_IMR_MR19)  /*!< External interrupt line 19 Connected to the RTC Tamper and Time Stamp events */                                               
N#define RTC_EXTI_LINE_WAKEUPTIMER_EVENT       ((uint32_t)EXTI_IMR_MR20)  /*!< External interrupt line 20 Connected to the RTC Wakeup event */                                               
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RTCEx_Private_Macros RTCEx Private Macros
N  * @{
N  */
N
N/** @defgroup RTCEx_IS_RTC_Definitions Private macros to check input parameters
N  * @{
N  */ 
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F070xB) || defined(STM32F030xC)
X#if 0L || 0L || 0L || 1L || 0L || 0L || 0L
N#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_OUTPUT_DISABLE) || \
N                               ((OUTPUT) == RTC_OUTPUT_ALARMA)  || \
N                               ((OUTPUT) == RTC_OUTPUT_WAKEUP))
X#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_OUTPUT_DISABLE) ||                                ((OUTPUT) == RTC_OUTPUT_ALARMA)  ||                                ((OUTPUT) == RTC_OUTPUT_WAKEUP))
N#else
S#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_OUTPUT_DISABLE) || \
S                               ((OUTPUT) == RTC_OUTPUT_ALARMA))
X#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_OUTPUT_DISABLE) ||                                ((OUTPUT) == RTC_OUTPUT_ALARMA))
N#endif  
N  
N#define IS_RTC_BKP(BKP)                   ((BKP) < (uint32_t) RTC_BKP_NUMBER)  
N
N#define IS_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TIMESTAMPEDGE_RISING) || \
N                                 ((EDGE) == RTC_TIMESTAMPEDGE_FALLING))
X#define IS_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TIMESTAMPEDGE_RISING) ||                                  ((EDGE) == RTC_TIMESTAMPEDGE_FALLING))
N#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F091xC) || defined(STM32F098xx)
X#if 0L || 0L || 0L || 1L || 0L
N#define IS_RTC_TAMPER(TAMPER) ((((TAMPER) & (uint32_t)0xFFFFFFD6U) == 0x00U) && ((TAMPER) != (uint32_t)RESET))
N
N#else
S#define IS_RTC_TAMPER(TAMPER) ((((TAMPER) & (uint32_t)0xFFFFFFF6U) == 0x00U) && ((TAMPER) != (uint32_t)RESET))
S
N#endif 
N								 
N#define IS_RTC_TIMESTAMP_PIN(PIN) (((PIN) == RTC_TIMESTAMPPIN_DEFAULT))
N
N
N#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TAMPERTRIGGER_RISINGEDGE) || \
N                                        ((TRIGGER) == RTC_TAMPERTRIGGER_FALLINGEDGE) || \
N                                        ((TRIGGER) == RTC_TAMPERTRIGGER_LOWLEVEL) || \
N                                        ((TRIGGER) == RTC_TAMPERTRIGGER_HIGHLEVEL)) 
X#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TAMPERTRIGGER_RISINGEDGE) ||                                         ((TRIGGER) == RTC_TAMPERTRIGGER_FALLINGEDGE) ||                                         ((TRIGGER) == RTC_TAMPERTRIGGER_LOWLEVEL) ||                                         ((TRIGGER) == RTC_TAMPERTRIGGER_HIGHLEVEL)) 
N#define IS_RTC_TAMPER_FILTER(FILTER)  (((FILTER) == RTC_TAMPERFILTER_DISABLE) || \
N                                       ((FILTER) == RTC_TAMPERFILTER_2SAMPLE) || \
N                                       ((FILTER) == RTC_TAMPERFILTER_4SAMPLE) || \
N                                       ((FILTER) == RTC_TAMPERFILTER_8SAMPLE))
X#define IS_RTC_TAMPER_FILTER(FILTER)  (((FILTER) == RTC_TAMPERFILTER_DISABLE) ||                                        ((FILTER) == RTC_TAMPERFILTER_2SAMPLE) ||                                        ((FILTER) == RTC_TAMPERFILTER_4SAMPLE) ||                                        ((FILTER) == RTC_TAMPERFILTER_8SAMPLE))
N#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768)|| \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV16384)|| \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV8192) || \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV4096) || \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV2048) || \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV1024) || \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV512)  || \
N                                           ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV256))
X#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768)||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV16384)||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV8192) ||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV4096) ||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV2048) ||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV1024) ||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV512)  ||                                            ((FREQ) == RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV256))
N#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TAMPERPRECHARGEDURATION_1RTCCLK) || \
N                                                    ((DURATION) == RTC_TAMPERPRECHARGEDURATION_2RTCCLK) || \
N                                                    ((DURATION) == RTC_TAMPERPRECHARGEDURATION_4RTCCLK) || \
N                                                    ((DURATION) == RTC_TAMPERPRECHARGEDURATION_8RTCCLK))
X#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TAMPERPRECHARGEDURATION_1RTCCLK) ||                                                     ((DURATION) == RTC_TAMPERPRECHARGEDURATION_2RTCCLK) ||                                                     ((DURATION) == RTC_TAMPERPRECHARGEDURATION_4RTCCLK) ||                                                     ((DURATION) == RTC_TAMPERPRECHARGEDURATION_8RTCCLK))
N#define IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(DETECTION) (((DETECTION) == RTC_TIMESTAMPONTAMPERDETECTION_ENABLE) || \
N                                                              ((DETECTION) == RTC_TIMESTAMPONTAMPERDETECTION_DISABLE))
X#define IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(DETECTION) (((DETECTION) == RTC_TIMESTAMPONTAMPERDETECTION_ENABLE) ||                                                               ((DETECTION) == RTC_TIMESTAMPONTAMPERDETECTION_DISABLE))
N#define IS_RTC_TAMPER_PULLUP_STATE(STATE) (((STATE) == RTC_TAMPER_PULLUP_ENABLE) || \
N                                           ((STATE) == RTC_TAMPER_PULLUP_DISABLE))
X#define IS_RTC_TAMPER_PULLUP_STATE(STATE) (((STATE) == RTC_TAMPER_PULLUP_ENABLE) ||                                            ((STATE) == RTC_TAMPER_PULLUP_DISABLE))
N#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV16)   || \
N                                    ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV8)    || \
N                                    ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV4)    || \
N                                    ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV2)    || \
N                                    ((CLOCK) == RTC_WAKEUPCLOCK_CK_SPRE_16BITS) || \
N                                    ((CLOCK) == RTC_WAKEUPCLOCK_CK_SPRE_17BITS))
X#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV16)   ||                                     ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV8)    ||                                     ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV4)    ||                                     ((CLOCK) == RTC_WAKEUPCLOCK_RTCCLK_DIV2)    ||                                     ((CLOCK) == RTC_WAKEUPCLOCK_CK_SPRE_16BITS) ||                                     ((CLOCK) == RTC_WAKEUPCLOCK_CK_SPRE_17BITS))
N
N#define IS_RTC_WAKEUP_COUNTER(COUNTER)  ((COUNTER) <= 0xFFFFU)
N
N
N#define IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SMOOTHCALIB_PERIOD_32SEC) || \
N                                            ((PERIOD) == RTC_SMOOTHCALIB_PERIOD_16SEC) || \
N                                            ((PERIOD) == RTC_SMOOTHCALIB_PERIOD_8SEC)) 
X#define IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SMOOTHCALIB_PERIOD_32SEC) ||                                             ((PERIOD) == RTC_SMOOTHCALIB_PERIOD_16SEC) ||                                             ((PERIOD) == RTC_SMOOTHCALIB_PERIOD_8SEC)) 
N#define IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_SET) || \
N                                        ((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_RESET))
X#define IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_SET) ||                                         ((PLUS) == RTC_SMOOTHCALIB_PLUSPULSES_RESET))
N
N
N#define  IS_RTC_SMOOTH_CALIB_MINUS(VALUE) ((VALUE) <= 0x000001FFU)
N#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_SHIFTADD1S_RESET) || \
N                                 ((SEL) == RTC_SHIFTADD1S_SET)) 
X#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_SHIFTADD1S_RESET) ||                                  ((SEL) == RTC_SHIFTADD1S_SET)) 
N#define IS_RTC_SHIFT_SUBFS(FS) ((FS) <= 0x00007FFFU)
N#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CALIBOUTPUT_512HZ) || \
N                                      ((OUTPUT) == RTC_CALIBOUTPUT_1HZ))
X#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CALIBOUTPUT_512HZ) ||                                       ((OUTPUT) == RTC_CALIBOUTPUT_1HZ))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_RTC_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 599 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rtc.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @defgroup RTC_Exported_Functions RTC Exported Functions
N  * @{
N  */
N
N/** @defgroup RTC_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
N  
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc);
Nvoid              HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc);
Nvoid              HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Exported_Functions_Group2 RTC Time and Date functions
N  * @{
N  */
N  
N/* RTC Time and Date functions ************************************************/
NHAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format);
N/**
N  * @}
N  */
N  
N/** @defgroup RTC_Exported_Functions_Group3 RTC Alarm functions
N  * @{
N  */
N/* RTC Alarm functions ********************************************************/
NHAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format);
NHAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm);
NHAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format);
Nvoid              HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc);
NHAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
Nvoid              HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N
N/** @defgroup  RTC_Exported_Functions_Group4 Peripheral Control functions
N  * @{
N  */  
N/* Peripheral Control functions ***********************************************/
NHAL_StatusTypeDef   HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc);
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Exported_Functions_Group5 Peripheral State functions
N  * @{
N  */  
N/* Peripheral State functions *************************************************/
NHAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef *hrtc);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */  
N
N/* Private types -------------------------------------------------------------*/ 
N/* Private variables ---------------------------------------------------------*/
N/* Private constants ---------------------------------------------------------*/
N/** @defgroup RTC_Private_Constants RTC Private Constants
N  * @{
N  */
N/* Masks Definition */
N#define RTC_TR_RESERVED_MASK    0x007F7F7FU
N#define RTC_DR_RESERVED_MASK    0x00FFFF3FU
N#define RTC_INIT_MASK           0xFFFFFFFFU
N#define RTC_RSF_MASK            0xFFFFFF5FU
N#define RTC_FLAGS_MASK          ((uint32_t) (RTC_FLAG_RECALPF | RTC_FLAG_TAMP3F | RTC_FLAG_TAMP2F | \
N                                             RTC_FLAG_TAMP1F| RTC_FLAG_TSOVF | RTC_FLAG_TSF       | \
N                                             RTC_FLAG_WUTF  | RTC_FLAG_ALRAF      | \
N                                             RTC_FLAG_INITF | RTC_FLAG_RSF | RTC_FLAG_INITS       | \
N                                             RTC_FLAG_SHPF | RTC_FLAG_WUTWF | RTC_FLAG_ALRAWF))
X#define RTC_FLAGS_MASK          ((uint32_t) (RTC_FLAG_RECALPF | RTC_FLAG_TAMP3F | RTC_FLAG_TAMP2F |                                              RTC_FLAG_TAMP1F| RTC_FLAG_TSOVF | RTC_FLAG_TSF       |                                              RTC_FLAG_WUTF  | RTC_FLAG_ALRAF      |                                              RTC_FLAG_INITF | RTC_FLAG_RSF | RTC_FLAG_INITS       |                                              RTC_FLAG_SHPF | RTC_FLAG_WUTWF | RTC_FLAG_ALRAWF))
N
N#define RTC_TIMEOUT_VALUE       1000U
N
N#define RTC_EXTI_LINE_ALARM_EVENT             ((uint32_t)EXTI_IMR_MR17)  /*!< External interrupt line 17 Connected to the RTC Alarm event */
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup RTC_Private_Macros RTC Private Macros
N  * @{
N  */
N
N/** @defgroup RTC_IS_RTC_Definitions RTC Private macros to check input parameters
N  * @{
N  */
N#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HOURFORMAT_12) || \
N                                        ((FORMAT) == RTC_HOURFORMAT_24))
X#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HOURFORMAT_12) ||                                         ((FORMAT) == RTC_HOURFORMAT_24))
N                                        
N#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OUTPUT_POLARITY_HIGH) || \
N                                ((POL) == RTC_OUTPUT_POLARITY_LOW))
X#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OUTPUT_POLARITY_HIGH) ||                                 ((POL) == RTC_OUTPUT_POLARITY_LOW))
N#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OUTPUT_TYPE_OPENDRAIN) || \
N                                  ((TYPE) == RTC_OUTPUT_TYPE_PUSHPULL))
X#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OUTPUT_TYPE_OPENDRAIN) ||                                   ((TYPE) == RTC_OUTPUT_TYPE_PUSHPULL))
N#define IS_RTC_HOUR12(HOUR)            (((HOUR) > 0U) && ((HOUR) <= 12U))
N#define IS_RTC_HOUR24(HOUR)            ((HOUR) <= 23U)
N#define IS_RTC_ASYNCH_PREDIV(PREDIV)   ((PREDIV) <= 0x7FU)
N#define IS_RTC_SYNCH_PREDIV(PREDIV)    ((PREDIV) <= 0x7FFFU)
N#define IS_RTC_MINUTES(MINUTES)        ((MINUTES) <= 59U)
N#define IS_RTC_SECONDS(SECONDS)        ((SECONDS) <= 59U)
N
N#define IS_RTC_HOURFORMAT12(PM)  (((PM) == RTC_HOURFORMAT12_AM) || \
N                                  ((PM) == RTC_HOURFORMAT12_PM))
X#define IS_RTC_HOURFORMAT12(PM)  (((PM) == RTC_HOURFORMAT12_AM) ||                                   ((PM) == RTC_HOURFORMAT12_PM))
N
N#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DAYLIGHTSAVING_SUB1H) || \
N                                      ((SAVE) == RTC_DAYLIGHTSAVING_ADD1H) || \
N                                      ((SAVE) == RTC_DAYLIGHTSAVING_NONE))
X#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DAYLIGHTSAVING_SUB1H) ||                                       ((SAVE) == RTC_DAYLIGHTSAVING_ADD1H) ||                                       ((SAVE) == RTC_DAYLIGHTSAVING_NONE))
N#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_STOREOPERATION_RESET) || \
N                                           ((OPERATION) == RTC_STOREOPERATION_SET))
X#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_STOREOPERATION_RESET) ||                                            ((OPERATION) == RTC_STOREOPERATION_SET))
N#define IS_RTC_FORMAT(FORMAT) (((FORMAT) == RTC_FORMAT_BIN) || ((FORMAT) == RTC_FORMAT_BCD))
N#define IS_RTC_YEAR(YEAR)              ((YEAR) <= 99U)
N#define IS_RTC_MONTH(MONTH)            (((MONTH) >= 1U) && ((MONTH) <= 12U))
N#define IS_RTC_DATE(DATE)              (((DATE) >= 1U) && ((DATE) <= 31U))
N#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_WEEKDAY_MONDAY)    || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_TUESDAY)   || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_WEDNESDAY) || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_THURSDAY)  || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_FRIDAY)    || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_SATURDAY)  || \
N                                 ((WEEKDAY) == RTC_WEEKDAY_SUNDAY))
X#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_WEEKDAY_MONDAY)    ||                                  ((WEEKDAY) == RTC_WEEKDAY_TUESDAY)   ||                                  ((WEEKDAY) == RTC_WEEKDAY_WEDNESDAY) ||                                  ((WEEKDAY) == RTC_WEEKDAY_THURSDAY)  ||                                  ((WEEKDAY) == RTC_WEEKDAY_FRIDAY)    ||                                  ((WEEKDAY) == RTC_WEEKDAY_SATURDAY)  ||                                  ((WEEKDAY) == RTC_WEEKDAY_SUNDAY))
N#define IS_RTC_ALARM_DATE_WEEKDAY_DATE(DATE) (((DATE) > 0U) && ((DATE) <= 31U))
N#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_WEEKDAY_MONDAY)    || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_TUESDAY)   || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_WEDNESDAY) || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_THURSDAY)  || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_FRIDAY)    || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_SATURDAY)  || \
N                                                    ((WEEKDAY) == RTC_WEEKDAY_SUNDAY))
X#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_WEEKDAY_MONDAY)    ||                                                     ((WEEKDAY) == RTC_WEEKDAY_TUESDAY)   ||                                                     ((WEEKDAY) == RTC_WEEKDAY_WEDNESDAY) ||                                                     ((WEEKDAY) == RTC_WEEKDAY_THURSDAY)  ||                                                     ((WEEKDAY) == RTC_WEEKDAY_FRIDAY)    ||                                                     ((WEEKDAY) == RTC_WEEKDAY_SATURDAY)  ||                                                     ((WEEKDAY) == RTC_WEEKDAY_SUNDAY))
N#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_ALARMDATEWEEKDAYSEL_DATE) || \
N                                            ((SEL) == RTC_ALARMDATEWEEKDAYSEL_WEEKDAY))
X#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_ALARMDATEWEEKDAYSEL_DATE) ||                                             ((SEL) == RTC_ALARMDATEWEEKDAYSEL_WEEKDAY))
N#define IS_RTC_ALARM_MASK(MASK)  (((MASK) & 0x7F7F7F7FU) == (uint32_t)RESET)
N#define IS_RTC_ALARM(ALARM)      ((ALARM) == RTC_ALARM_A)
N#define IS_RTC_ALARM_SUB_SECOND_VALUE(VALUE) ((VALUE) <= 0x00007FFFU)
N
N#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_ALARMSUBSECONDMASK_ALL) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_1) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_2) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_3) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_4) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_5) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_6) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_7) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_8) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_9) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_10) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_11) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_12) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_13) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_SS14) || \
N                                              ((MASK) == RTC_ALARMSUBSECONDMASK_NONE))
X#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_ALARMSUBSECONDMASK_ALL) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_1) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_2) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_3) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_4) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_5) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_6) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_7) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_8) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_9) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_10) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_11) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_12) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14_13) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_SS14) ||                                               ((MASK) == RTC_ALARMSUBSECONDMASK_NONE))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N/** @defgroup RTC_Private_Functions RTC Private Functions
N  * @{
N  */
NHAL_StatusTypeDef  RTC_EnterInitMode(RTC_HandleTypeDef* hrtc);
Nuint8_t            RTC_ByteToBcd2(uint8_t Value);
Nuint8_t            RTC_Bcd2ToByte(uint8_t Value);
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_RTC_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 266 "../Inc/stm32f0xx_hal_conf.h" 2
N#endif /* HAL_RTC_MODULE_ENABLED */
N
N#ifdef HAL_SMARTCARD_MODULE_ENABLED
S #include "stm32f0xx_hal_smartcard.h"
N#endif /* HAL_SMARTCARD_MODULE_ENABLED */
N
N#ifdef HAL_SMBUS_MODULE_ENABLED
S #include "stm32f0xx_hal_smbus.h"
N#endif /* HAL_SMBUS_MODULE_ENABLED */
N
N#ifdef HAL_SPI_MODULE_ENABLED
S #include "stm32f0xx_hal_spi.h"
N#endif /* HAL_SPI_MODULE_ENABLED */
N
N#ifdef HAL_TIM_MODULE_ENABLED
S #include "stm32f0xx_hal_tim.h"
N#endif /* HAL_TIM_MODULE_ENABLED */
N
N#ifdef HAL_TSC_MODULE_ENABLED
S #include "stm32f0xx_hal_tsc.h"
N#endif /* HAL_TSC_MODULE_ENABLED */
N
N#ifdef HAL_UART_MODULE_ENABLED
N #include "stm32f0xx_hal_uart.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_uart.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_uart.h
N  * @author  MCD Application Team
N  * @brief   Header file of UART HAL module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_UART_H
N#define __STM32F0xx_HAL_UART_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup UART
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/** @defgroup UART_Exported_Types UART Exported Types
N  * @{
N  */
N
N/**
N  * @brief UART Init Structure definition
N  */
Ntypedef struct
N{
N  uint32_t BaudRate;                  /*!< This member configures the UART communication baud rate.
N                                           The baud rate register is computed using the following formula:
N                                           - If oversampling is 16 or in LIN mode (LIN mode not available on F030xx devices),
N                                              Baud Rate Register = ((PCLKx) / ((huart->Init.BaudRate)))
N                                           - If oversampling is 8,
N                                              Baud Rate Register[15:4] = ((2 * PCLKx) / ((huart->Init.BaudRate)))[15:4]
N                                              Baud Rate Register[3] =  0
N                                              Baud Rate Register[2:0] =  (((2 * PCLKx) / ((huart->Init.BaudRate)))[3:0]) >> 1U      */
N
N  uint32_t WordLength;                /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref UARTEx_Word_Length. */
N
N  uint32_t StopBits;                  /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref UART_Stop_Bits. */
N
N  uint32_t Parity;                    /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref UART_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N
N  uint32_t Mode;                      /*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref UART_Mode. */
N
N  uint32_t HwFlowCtl;                 /*!< Specifies whether the hardware flow control mode is enabled
N                                           or disabled.
N                                           This parameter can be a value of @ref UART_Hardware_Flow_Control. */
N
N  uint32_t OverSampling;              /*!< Specifies whether the Over sampling 8 is enabled or disabled, to achieve higher speed (up to f_PCLK/8).
N                                           This parameter can be a value of @ref UART_Over_Sampling. */
N
N  uint32_t OneBitSampling;            /*!< Specifies whether a single sample or three samples' majority vote is selected.
N                                           Selecting the single sample method increases the receiver tolerance to clock
N                                           deviations. This parameter can be a value of @ref UART_OneBit_Sampling. */
N}UART_InitTypeDef;
N
N/**
N  * @brief  UART Advanced Features initalization structure definition
N  */
Ntypedef struct
N{
N  uint32_t AdvFeatureInit;        /*!< Specifies which advanced UART features is initialized. Several
N                                       Advanced Features may be initialized at the same time .
N                                       This parameter can be a value of @ref UART_Advanced_Features_Initialization_Type. */
N
N  uint32_t TxPinLevelInvert;      /*!< Specifies whether the TX pin active level is inverted.
N                                       This parameter can be a value of @ref UART_Tx_Inv.  */
N
N  uint32_t RxPinLevelInvert;      /*!< Specifies whether the RX pin active level is inverted.
N                                       This parameter can be a value of @ref UART_Rx_Inv.  */
N
N  uint32_t DataInvert;            /*!< Specifies whether data are inverted (positive/direct logic
N                                       vs negative/inverted logic).
N                                       This parameter can be a value of @ref UART_Data_Inv. */
N
N  uint32_t Swap;                  /*!< Specifies whether TX and RX pins are swapped.
N                                       This parameter can be a value of @ref UART_Rx_Tx_Swap. */
N
N  uint32_t OverrunDisable;        /*!< Specifies whether the reception overrun detection is disabled.
N                                       This parameter can be a value of @ref UART_Overrun_Disable. */
N
N  uint32_t DMADisableonRxError;   /*!< Specifies whether the DMA is disabled in case of reception error.
N                                       This parameter can be a value of @ref UART_DMA_Disable_on_Rx_Error. */
N
N  uint32_t AutoBaudRateEnable;    /*!< Specifies whether auto Baud rate detection is enabled.
N                                       This parameter can be a value of @ref UART_AutoBaudRate_Enable */
N
N  uint32_t AutoBaudRateMode;      /*!< If auto Baud rate detection is enabled, specifies how the rate
N                                       detection is carried out.
N                                       This parameter can be a value of @ref UARTEx_AutoBaud_Rate_Mode. */
N
N  uint32_t MSBFirst;              /*!< Specifies whether MSB is sent first on UART line.
N                                       This parameter can be a value of @ref UART_MSB_First. */
N} UART_AdvFeatureInitTypeDef;
N
N
N
N/**
N  * @brief HAL UART State structures definition
N  * @note  HAL UART State value is a combination of 2 different substates: gState and RxState.
N  *        - gState contains UART state information related to global Handle management 
N  *          and also information related to Tx operations.
N  *          gState value coding follow below described bitmap :
N  *          b7-b6  Error information 
N  *             00 : No Error
N  *             01 : (Not Used)
N  *             10 : Timeout
N  *             11 : Error
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP not initialized. HAL UART Init function already called)
N  *          b4-b3  (not used)
N  *             xx : Should be set to 00
N  *          b2     Intrinsic process state
N  *             0  : Ready
N  *             1  : Busy (IP busy with some configuration or internal operations)
N  *          b1     (not used)
N  *             x  : Should be set to 0
N  *          b0     Tx state
N  *             0  : Ready (no Tx operation ongoing)
N  *             1  : Busy (Tx operation ongoing)
N  *        - RxState contains information related to Rx operations.
N  *          RxState value coding follow below described bitmap :
N  *          b7-b6  (not used)
N  *             xx : Should be set to 00
N  *          b5     IP initilisation status
N  *             0  : Reset (IP not initialized)
N  *             1  : Init done (IP not initialized)
N  *          b4-b2  (not used)
N  *            xxx : Should be set to 000
N  *          b1     Rx state
N  *             0  : Ready (no Rx operation ongoing)
N  *             1  : Busy (Rx operation ongoing)
N  *          b0     (not used)
N  *             x  : Should be set to 0.
N  */
Ntypedef enum
N{
N  HAL_UART_STATE_RESET             = 0x00U,   /*!< Peripheral is not initialized
N                                                   Value is allowed for gState and RxState */
N  HAL_UART_STATE_READY             = 0x20U,   /*!< Peripheral Initialized and ready for use
N                                                   Value is allowed for gState and RxState */
N  HAL_UART_STATE_BUSY              = 0x24U,   /*!< an internal process is ongoing 
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_BUSY_TX           = 0x21U,   /*!< Data Transmission process is ongoing
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_BUSY_RX           = 0x22U,   /*!< Data Reception process is ongoing
N                                                   Value is allowed for RxState only */
N  HAL_UART_STATE_BUSY_TX_RX        = 0x23U,   /*!< Data Transmission and Reception process is ongoing
N                                                   Not to be used for neither gState nor RxState.
N                                                   Value is result of combination (Or) between gState and RxState values */
N  HAL_UART_STATE_TIMEOUT           = 0xA0U,   /*!< Timeout state
N                                                   Value is allowed for gState only */
N  HAL_UART_STATE_ERROR             = 0xE0U    /*!< Error
N                                                   Value is allowed for gState only */
N}HAL_UART_StateTypeDef;
N
N/**
N  * @brief UART clock sources definition
N  */
Ntypedef enum
N{
N  UART_CLOCKSOURCE_PCLK1      = 0x00U,    /*!< PCLK1 clock source     */
N  UART_CLOCKSOURCE_HSI        = 0x02U,    /*!< HSI clock source       */
N  UART_CLOCKSOURCE_SYSCLK     = 0x04U,    /*!< SYSCLK clock source    */
N  UART_CLOCKSOURCE_LSE        = 0x08U,    /*!< LSE clock source       */
N  UART_CLOCKSOURCE_UNDEFINED  = 0x10U     /*!< Undefined clock source */
N}UART_ClockSourceTypeDef;
N
N/**
N  * @brief  UART handle Structure definition
N  */
Ntypedef struct
N{
N  USART_TypeDef            *Instance;        /*!< UART registers base address        */
N
N  UART_InitTypeDef         Init;             /*!< UART communication parameters      */
N
N  UART_AdvFeatureInitTypeDef AdvancedInit;   /*!< UART Advanced Features initialization parameters */
N
N  uint8_t                  *pTxBuffPtr;      /*!< Pointer to UART Tx transfer Buffer */
N
N  uint16_t                 TxXferSize;       /*!< UART Tx Transfer size              */
N
N  __IO uint16_t            TxXferCount;      /*!< UART Tx Transfer Counter           */
X  volatile uint16_t            TxXferCount;       
N
N  uint8_t                  *pRxBuffPtr;      /*!< Pointer to UART Rx transfer Buffer */
N
N  uint16_t                 RxXferSize;       /*!< UART Rx Transfer size              */
N
N  __IO uint16_t            RxXferCount;      /*!< UART Rx Transfer Counter           */
X  volatile uint16_t            RxXferCount;       
N
N  uint16_t                 Mask;             /*!< UART Rx RDR register mask          */
N
N  DMA_HandleTypeDef        *hdmatx;          /*!< UART Tx DMA Handle parameters      */
N
N  DMA_HandleTypeDef        *hdmarx;          /*!< UART Rx DMA Handle parameters      */
N
N  HAL_LockTypeDef           Lock;            /*!< Locking object                     */
N
N  __IO HAL_UART_StateTypeDef    gState;      /*!< UART state information related to global Handle management 
X  volatile HAL_UART_StateTypeDef    gState;      
N                                                  and also related to Tx operations.
N                                                  This parameter can be a value of @ref HAL_UART_StateTypeDef */
N
N  __IO HAL_UART_StateTypeDef    RxState;     /*!< UART state information related to Rx operations.
X  volatile HAL_UART_StateTypeDef    RxState;     
N                                                  This parameter can be a value of @ref HAL_UART_StateTypeDef */
N
N  __IO uint32_t             ErrorCode;       /*!< UART Error code                    */
X  volatile uint32_t             ErrorCode;        
N
N}UART_HandleTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup UART_Exported_Constants UART Exported Constants
N  * @{
N  */
N
N/** @defgroup UART_Error UART Error
N  * @{
N  */
N#define HAL_UART_ERROR_NONE      (0x00000000U)    /*!< No error            */
N#define HAL_UART_ERROR_PE        (0x00000001U)    /*!< Parity error        */
N#define HAL_UART_ERROR_NE        (0x00000002U)    /*!< Noise error         */
N#define HAL_UART_ERROR_FE        (0x00000004U)    /*!< frame error         */
N#define HAL_UART_ERROR_ORE       (0x00000008U)    /*!< Overrun error       */
N#define HAL_UART_ERROR_DMA       (0x00000010U)    /*!< DMA transfer error  */
N#define HAL_UART_ERROR_BUSY      (0x00000020U)    /*!< Busy Error          */
N/**
N  * @}
N  */ 
N
N/** @defgroup UART_Stop_Bits   UART Number of Stop Bits
N  * @{
N  */
N#ifdef USART_SMARTCARD_SUPPORT
N#define UART_STOPBITS_0_5                   USART_CR2_STOP_0                                  /*!< UART frame with 0.5 stop bit  */
N#define UART_STOPBITS_1                     (0x00000000U)                                     /*!< UART frame with 1 stop bit    */
N#define UART_STOPBITS_1_5                   ((uint32_t)(USART_CR2_STOP_0 | USART_CR2_STOP_1)) /*!< UART frame with 1.5 stop bits */
N#define UART_STOPBITS_2                     ((uint32_t)USART_CR2_STOP_1)                      /*!< UART frame with 2 stop bits   */
N#else
S#define UART_STOPBITS_1                     (0x00000000U)                                     /*!< UART frame with 1 stop bit    */
S#define UART_STOPBITS_2                     ((uint32_t)USART_CR2_STOP_1)                      /*!< UART frame with 2 stop bits   */
N#endif
N/**
N  * @}
N  */
N
N/** @defgroup UART_Parity  UART Parity
N  * @{
N  */
N#define UART_PARITY_NONE                    (0x00000000U)                                  /*!< No parity   */
N#define UART_PARITY_EVEN                    ((uint32_t)USART_CR1_PCE)                      /*!< Even parity */
N#define UART_PARITY_ODD                     ((uint32_t)(USART_CR1_PCE | USART_CR1_PS))     /*!< Odd parity  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Hardware_Flow_Control UART Hardware Flow Control
N  * @{
N  */
N#define UART_HWCONTROL_NONE                  (0x00000000U)                                    /*!< No hardware control       */
N#define UART_HWCONTROL_RTS                   ((uint32_t)USART_CR3_RTSE)                       /*!< Request To Send           */
N#define UART_HWCONTROL_CTS                   ((uint32_t)USART_CR3_CTSE)                       /*!< Clear To Send             */
N#define UART_HWCONTROL_RTS_CTS               ((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE))    /*!< Request and Clear To Send */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Mode UART Transfer Mode
N  * @{
N  */
N#define UART_MODE_RX                        ((uint32_t)USART_CR1_RE)                    /*!< RX mode        */ 
N#define UART_MODE_TX                        ((uint32_t)USART_CR1_TE)                    /*!< TX mode        */ 
N#define UART_MODE_TX_RX                     ((uint32_t)(USART_CR1_TE |USART_CR1_RE))    /*!< RX and TX mode */ 
N/**
N  * @}
N  */
N
N/** @defgroup UART_State  UART State
N  * @{
N  */
N#define UART_STATE_DISABLE                  (0x00000000U)                   /*!< UART disabled  */
N#define UART_STATE_ENABLE                   ((uint32_t)USART_CR1_UE)        /*!< UART enabled   */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Over_Sampling UART Over Sampling
N  * @{
N  */
N#define UART_OVERSAMPLING_16                (0x00000000U)                   /*!< Oversampling by 16 */
N#define UART_OVERSAMPLING_8                 ((uint32_t)USART_CR1_OVER8)     /*!< Oversampling by 8  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_OneBit_Sampling UART One Bit Sampling Method
N  * @{
N  */
N#define UART_ONE_BIT_SAMPLE_DISABLE         (0x00000000U)                   /*!< One-bit sampling disable */
N#define UART_ONE_BIT_SAMPLE_ENABLE          ((uint32_t)USART_CR3_ONEBIT)    /*!< One-bit sampling enable  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Receiver_TimeOut UART Receiver TimeOut
N  * @{
N  */
N#define UART_RECEIVER_TIMEOUT_DISABLE       (0x00000000U)                   /*!< UART receiver timeout disable */
N#define UART_RECEIVER_TIMEOUT_ENABLE        ((uint32_t)USART_CR2_RTOEN)     /*!< UART receiver timeout enable  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_DMA_Tx    UART DMA Tx
N  * @{
N  */
N#define UART_DMA_TX_DISABLE                 (0x00000000U)                   /*!< UART DMA TX disabled */
N#define UART_DMA_TX_ENABLE                  ((uint32_t)USART_CR3_DMAT)      /*!< UART DMA TX enabled  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_DMA_Rx   UART DMA Rx
N  * @{
N  */
N#define UART_DMA_RX_DISABLE                 (0x00000000U)                   /*!< UART DMA RX disabled */
N#define UART_DMA_RX_ENABLE                  ((uint32_t)USART_CR3_DMAR)      /*!< UART DMA RX enabled  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Half_Duplex_Selection  UART Half Duplex Selection
N  * @{
N  */
N#define UART_HALF_DUPLEX_DISABLE            (0x00000000U)                   /*!< UART half-duplex disabled */
N#define UART_HALF_DUPLEX_ENABLE             ((uint32_t)USART_CR3_HDSEL)     /*!< UART half-duplex enabled  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_WakeUp_Address_Length    UART WakeUp Address Length
N  * @{
N  */
N#define UART_ADDRESS_DETECT_4B              (0x00000000U)                   /*!< 4-bit long wake-up address */
N#define UART_ADDRESS_DETECT_7B              ((uint32_t)USART_CR2_ADDM7)     /*!< 7-bit long wake-up address */
N/**
N  * @}
N  */
N
N/** @defgroup UART_WakeUp_Methods   UART WakeUp Methods
N  * @{
N  */
N#define UART_WAKEUPMETHOD_IDLELINE          (0x00000000U)                   /*!< UART wake-up on idle line    */
N#define UART_WAKEUPMETHOD_ADDRESSMARK       ((uint32_t)USART_CR1_WAKE)      /*!< UART wake-up on address mark */
N/**
N  * @}
N  */
N
N/** @defgroup UART_IT   UART IT
N  *       Elements values convention: 0000ZZZZ0XXYYYYYb
N  *           - YYYYY  : Interrupt source position in the XX register (5bits)
N  *           - XX  : Interrupt source register (2bits)
N  *                 - 01: CR1 register
N  *                 - 10: CR2 register
N  *                 - 11: CR3 register
N  *           - ZZZZ  : Flag position in the ISR register(4bits)
N  * @{
N  */
N#define UART_IT_ERR                         (0x0060U)                  /*!< UART error interruption         */   
N#define UART_IT_ORE                         (0x0300U)                  /*!< UART overrun error interruption */ 
N#define UART_IT_NE                          (0x0200U)                  /*!< UART noise error interruption   */ 
N#define UART_IT_FE                          (0x0100U)                  /*!< UART frame error interruption   */ 
N/**
N  * @}
N  */
N
N/** @defgroup UART_Advanced_Features_Initialization_Type  UART Advanced Feature Initialization Type
N  * @{
N  */
N#define UART_ADVFEATURE_NO_INIT                 (0x00000000U)          /*!< No advanced feature initialization       */
N#define UART_ADVFEATURE_TXINVERT_INIT           (0x00000001U)          /*!< TX pin active level inversion            */
N#define UART_ADVFEATURE_RXINVERT_INIT           (0x00000002U)          /*!< RX pin active level inversion            */
N#define UART_ADVFEATURE_DATAINVERT_INIT         (0x00000004U)          /*!< Binary data inversion                    */
N#define UART_ADVFEATURE_SWAP_INIT               (0x00000008U)          /*!< TX/RX pins swap                          */
N#define UART_ADVFEATURE_RXOVERRUNDISABLE_INIT   (0x00000010U)          /*!< RX overrun disable                       */
N#define UART_ADVFEATURE_DMADISABLEONERROR_INIT  (0x00000020U)          /*!< DMA disable on Reception Error           */
N#define UART_ADVFEATURE_AUTOBAUDRATE_INIT       (0x00000040U)          /*!< Auto Baud rate detection initialization  */
N#define UART_ADVFEATURE_MSBFIRST_INIT           (0x00000080U)          /*!< Most significant bit sent/received first */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Tx_Inv UART Advanced Feature TX Pin Active Level Inversion
N  * @{
N  */
N#define UART_ADVFEATURE_TXINV_DISABLE       (0x00000000U)                   /*!< TX pin active level inversion disable */
N#define UART_ADVFEATURE_TXINV_ENABLE        ((uint32_t)USART_CR2_TXINV)     /*!< TX pin active level inversion enable  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Rx_Inv UART Advanced Feature RX Pin Active Level Inversion
N  * @{
N  */
N#define UART_ADVFEATURE_RXINV_DISABLE       (0x00000000U)                   /*!< RX pin active level inversion disable */ 
N#define UART_ADVFEATURE_RXINV_ENABLE        ((uint32_t)USART_CR2_RXINV)     /*!< RX pin active level inversion enable  */ 
N/**
N  * @}
N  */
N
N/** @defgroup UART_Data_Inv  UART Advanced Feature Binary Data Inversion
N  * @{
N  */
N#define UART_ADVFEATURE_DATAINV_DISABLE     (0x00000000U)                   /*!< Binary data inversion disable */
N#define UART_ADVFEATURE_DATAINV_ENABLE      ((uint32_t)USART_CR2_DATAINV)   /*!< Binary data inversion enable  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Rx_Tx_Swap UART Advanced Feature RX TX Pins Swap
N  * @{
N  */
N#define UART_ADVFEATURE_SWAP_DISABLE        (0x00000000U)                   /*!< TX/RX pins swap disable */
N#define UART_ADVFEATURE_SWAP_ENABLE         ((uint32_t)USART_CR2_SWAP)      /*!< TX/RX pins swap enable  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Overrun_Disable  UART Advanced Feature Overrun Disable
N  * @{
N  */
N#define UART_ADVFEATURE_OVERRUN_ENABLE      (0x00000000U)                   /*!< RX overrun enable  */ 
N#define UART_ADVFEATURE_OVERRUN_DISABLE     ((uint32_t)USART_CR3_OVRDIS)    /*!< RX overrun disable */ 
N/**
N  * @}
N  */
N
N/** @defgroup UART_AutoBaudRate_Enable  UART Advanced Feature Auto BaudRate Enable
N  * @{
N  */
N#define UART_ADVFEATURE_AUTOBAUDRATE_DISABLE   (0x00000000U)                /*!< RX Auto Baud rate detection enable  */ 
N#define UART_ADVFEATURE_AUTOBAUDRATE_ENABLE    ((uint32_t)USART_CR2_ABREN)  /*!< RX Auto Baud rate detection disable */ 
N/**
N  * @}
N  */
N
N/** @defgroup UART_DMA_Disable_on_Rx_Error   UART Advanced Feature DMA Disable On Rx Error
N  * @{
N  */
N#define UART_ADVFEATURE_DMA_ENABLEONRXERROR    (0x00000000U)                /*!< DMA enable on Reception Error  */
N#define UART_ADVFEATURE_DMA_DISABLEONRXERROR   ((uint32_t)USART_CR3_DDRE)   /*!< DMA disable on Reception Error */
N/**
N  * @}
N  */
N
N/** @defgroup UART_MSB_First   UART Advanced Feature MSB First
N  * @{
N  */
N#define UART_ADVFEATURE_MSBFIRST_DISABLE    (0x00000000U)                   /*!< Most significant bit sent/received first disable */
N#define UART_ADVFEATURE_MSBFIRST_ENABLE     ((uint32_t)USART_CR2_MSBFIRST)  /*!< Most significant bit sent/received first enable  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Mute_Mode   UART Advanced Feature Mute Mode Enable
N  * @{
N  */
N#define UART_ADVFEATURE_MUTEMODE_DISABLE    (0x00000000U)                   /*!< UART mute mode disable */
N#define UART_ADVFEATURE_MUTEMODE_ENABLE     ((uint32_t)USART_CR1_MME)       /*!< UART mute mode enable  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_CR2_ADDRESS_LSB_POS    UART Address-matching LSB Position In CR2 Register
N  * @{
N  */
N#define UART_CR2_ADDRESS_LSB_POS            ( 24U)                     /*!< UART address-matching LSB position in CR2 register */
N/**
N  * @}
N  */
N
N/** @defgroup UART_DriverEnable_Polarity      UART DriverEnable Polarity
N  * @{
N  */
N#define UART_DE_POLARITY_HIGH               (0x00000000U)              /*!< Driver enable signal is active high */
N#define UART_DE_POLARITY_LOW                ((uint32_t)USART_CR3_DEP)  /*!< Driver enable signal is active low  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_CR1_DEAT_ADDRESS_LSB_POS    UART Driver Enable Assertion Time LSB Position In CR1 Register
N  * @{
N  */
N#define UART_CR1_DEAT_ADDRESS_LSB_POS       ( 21U)                     /*!< UART Driver Enable assertion time LSB position in CR1 register */
N/**
N  * @}
N  */
N
N/** @defgroup UART_CR1_DEDT_ADDRESS_LSB_POS    UART Driver Enable DeAssertion Time LSB Position In CR1 Register
N  * @{
N  */
N#define UART_CR1_DEDT_ADDRESS_LSB_POS       ( 16U)                     /*!< UART Driver Enable de-assertion time LSB position in CR1 register */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Interruption_Mask    UART Interruptions Flag Mask
N  * @{
N  */
N#define UART_IT_MASK                        (0x001FU)                  /*!< UART interruptions flags mask */
N/**
N  * @}
N  */
N
N/** @defgroup UART_TimeOut_Value    UART polling-based communications time-out value
N  * @{
N  */
N#define HAL_UART_TIMEOUT_VALUE              0x1FFFFFFU                 /*!< UART polling-based communications time-out value */
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup UART_Exported_Macros UART Exported Macros
N  * @{
N  */
N
N/** @brief  Reset UART handle states.
N  * @param  __HANDLE__ UART handle.
N  * @retval None
N  */
N#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                   \
N                                                       (__HANDLE__)->gState = HAL_UART_STATE_RESET;      \
N                                                       (__HANDLE__)->RxState = HAL_UART_STATE_RESET;     \
N                                                     } while(0)
X#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)  do{                                                                                                          (__HANDLE__)->gState = HAL_UART_STATE_RESET;                                                             (__HANDLE__)->RxState = HAL_UART_STATE_RESET;                                                          } while(0)
N
N/** @brief  Clear the specified UART pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @param  __FLAG__ specifies the flag to check.
N  *          This parameter can be any combination of the following values:
N  *            @arg @ref UART_CLEAR_PEF      Parity Error Clear Flag           
N  *            @arg @ref UART_CLEAR_FEF      Framing Error Clear Flag          
N  *            @arg @ref UART_CLEAR_NEF      Noise detected Clear Flag         
N  *            @arg @ref UART_CLEAR_OREF     Overrun Error Clear Flag          
N  *            @arg @ref UART_CLEAR_IDLEF    IDLE line detected Clear Flag     
N  *            @arg @ref UART_CLEAR_TCF      Transmission Complete Clear Flag  
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_CLEAR_LBDF     LIN Break Detection Clear Flag  (not available on all devices)
N  @endif
N  *            @arg @ref UART_CLEAR_CTSF     CTS Interrupt Clear Flag          
N  *            @arg @ref UART_CLEAR_RTOF     Receiver Time Out Clear Flag      
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_CLEAR_EOBF     End Of Block Clear Flag (not available on all devices)
N  @endif
N  *            @arg @ref UART_CLEAR_CMF      Character Match Clear Flag        
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_CLEAR_WUF      Wake Up from stop mode Clear Flag (not available on all devices)
N  @endif
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_FLAG(__HANDLE__, __FLAG__) ((__HANDLE__)->Instance->ICR = (__FLAG__))
N
N/** @brief  Clear the UART PE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_PEFLAG(__HANDLE__)   __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_PEF)
N
N/** @brief  Clear the UART FE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_FEFLAG(__HANDLE__)   __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_FEF)
N
N/** @brief  Clear the UART NE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_NEFLAG(__HANDLE__)  __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_NEF)
N
N/** @brief  Clear the UART ORE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_OREFLAG(__HANDLE__)   __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_OREF)
N
N/** @brief  Clear the UART IDLE pending flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_IDLEFLAG(__HANDLE__)   __HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_IDLEF)
N
N/** @brief  Check whether the specified UART flag is set or not.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @param  __FLAG__ specifies the flag to check.
N  *        This parameter can be one of the following values:
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_FLAG_REACK Receive enable acknowledge flag
N  @endif
N  *            @arg @ref UART_FLAG_TEACK Transmit enable acknowledge flag
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_FLAG_WUF   Wake up from stop mode flag (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_FLAG_RWU   Receiver wake up flag (not available on F030xx devices)
N  *            @arg @ref UART_FLAG_SBKF  Send Break flag
N  *            @arg @ref UART_FLAG_CMF   Character match flag
N  *            @arg @ref UART_FLAG_BUSY  Busy flag
N  *            @arg @ref UART_FLAG_ABRF  Auto Baud rate detection flag
N  *            @arg @ref UART_FLAG_ABRE  Auto Baud rate detection error flag
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_FLAG_EOBF  End of block flag (not available on F030xx devices) 
N  @endif
N  *            @arg @ref UART_FLAG_RTOF  Receiver timeout flag
N  *            @arg @ref UART_FLAG_CTS   CTS Change flag
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_FLAG_LBDF  LIN Break detection flag (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_FLAG_TXE   Transmit data register empty flag
N  *            @arg @ref UART_FLAG_TC    Transmission Complete flag
N  *            @arg @ref UART_FLAG_RXNE  Receive data register not empty flag
N  *            @arg @ref UART_FLAG_IDLE  Idle Line detection flag
N  *            @arg @ref UART_FLAG_ORE   Overrun Error flag
N  *            @arg @ref UART_FLAG_NE    Noise Error flag
N  *            @arg @ref UART_FLAG_FE    Framing Error flag
N  *            @arg @ref UART_FLAG_PE    Parity Error flag
N  * @retval The new state of __FLAG__ (TRUE or FALSE).
N  */
N#define __HAL_UART_GET_FLAG(__HANDLE__, __FLAG__) (((__HANDLE__)->Instance->ISR & (__FLAG__)) == (__FLAG__))
N
N/** @brief  Enable the specified UART interrupt.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @param  __INTERRUPT__ specifies the UART interrupt source to enable.
N  *          This parameter can be one of the following values:
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_IT_WUF  Wakeup from stop mode interrupt (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_IT_CM   Character match interrupt
N  *            @arg @ref UART_IT_CTS  CTS change interrupt
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_IT_LBD  LIN Break detection interrupt (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_IT_TXE  Transmit Data Register empty interrupt
N  *            @arg @ref UART_IT_TC   Transmission complete interrupt
N  *            @arg @ref UART_IT_RXNE Receive Data register not empty interrupt
N  *            @arg @ref UART_IT_IDLE Idle line detection interrupt
N  *            @arg @ref UART_IT_PE   Parity Error interrupt
N  *            @arg @ref UART_IT_ERR  Error interrupt (Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U)? ((__HANDLE__)->Instance->CR1 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))): \
N                                                           ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U)? ((__HANDLE__)->Instance->CR2 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))): \
N                                                           ((__HANDLE__)->Instance->CR3 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))))
X#define __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)   (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U)? ((__HANDLE__)->Instance->CR1 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))):                                                            ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U)? ((__HANDLE__)->Instance->CR2 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))):                                                            ((__HANDLE__)->Instance->CR3 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))))
N
N
N/** @brief  Disable the specified UART interrupt.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @param  __INTERRUPT__ specifies the UART interrupt source to disable.
N  *          This parameter can be one of the following values:
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_IT_WUF  Wakeup from stop mode interrupt (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_IT_CM   Character match interrupt
N  *            @arg @ref UART_IT_CTS  CTS change interrupt
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_IT_LBD  LIN Break detection interrupt (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_IT_TXE  Transmit Data Register empty interrupt
N  *            @arg @ref UART_IT_TC   Transmission complete interrupt
N  *            @arg @ref UART_IT_RXNE Receive Data register not empty interrupt
N  *            @arg @ref UART_IT_IDLE Idle line detection interrupt
N  *            @arg @ref UART_IT_PE   Parity Error interrupt
N  *            @arg @ref UART_IT_ERR  Error interrupt (Frame error, noise error, overrun error)
N  * @retval None
N  */
N#define __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U)? ((__HANDLE__)->Instance->CR1 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))): \
N                                                           ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U)? ((__HANDLE__)->Instance->CR2 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))): \
N                                                           ((__HANDLE__)->Instance->CR3 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))))
X#define __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)  (((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U)? ((__HANDLE__)->Instance->CR1 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))):                                                            ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U)? ((__HANDLE__)->Instance->CR2 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))):                                                            ((__HANDLE__)->Instance->CR3 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))))
N
N/** @brief  Check whether the specified UART interrupt has occurred or not.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @param  __IT__ specifies the UART interrupt to check.
N  *          This parameter can be one of the following values:
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_IT_WUF  Wakeup from stop mode interrupt (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_IT_CM   Character match interrupt
N  *            @arg @ref UART_IT_CTS  CTS change interrupt
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_IT_LBD  LIN Break detection interrupt (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_IT_TXE  Transmit Data Register empty interrupt
N  *            @arg @ref UART_IT_TC   Transmission complete interrupt
N  *            @arg @ref UART_IT_RXNE Receive Data register not empty interrupt
N  *            @arg @ref UART_IT_IDLE Idle line detection interrupt
N  *            @arg @ref UART_IT_ORE  Overrun Error interrupt
N  *            @arg @ref UART_IT_NE   Noise Error interrupt
N  *            @arg @ref UART_IT_FE   Framing Error interrupt
N  *            @arg @ref UART_IT_PE   Parity Error interrupt
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_UART_GET_IT(__HANDLE__, __IT__) ((__HANDLE__)->Instance->ISR & (1U << ((__IT__)>> 0x08U)))
N
N/** @brief  Check whether the specified UART interrupt source is enabled or not.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @param  __IT__ specifies the UART interrupt source to check.
N  *          This parameter can be one of the following values:
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_IT_WUF  Wakeup from stop mode interrupt (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_IT_CM   Character match interrupt  
N  *            @arg @ref UART_IT_CTS  CTS change interrupt
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_IT_LBD  LIN Break detection interrupt (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_IT_TXE  Transmit Data Register empty interrupt
N  *            @arg @ref UART_IT_TC   Transmission complete interrupt
N  *            @arg @ref UART_IT_RXNE Receive Data register not empty interrupt
N  *            @arg @ref UART_IT_IDLE Idle line detection interrupt
N  *            @arg @ref UART_IT_ERR  Error interrupt (Frame error, noise error, overrun error)
N  *            @arg @ref UART_IT_PE   Parity Error interrupt
N  * @retval The new state of __IT__ (TRUE or FALSE).
N  */
N#define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__) ((((((uint8_t)(__IT__)) >> 5U) == 1U)? (__HANDLE__)->Instance->CR1:(((((uint8_t)(__IT__)) >> 5U) == 2U)? \
N                                                       (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & (1U << (((uint16_t)(__IT__)) & UART_IT_MASK)))
X#define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__) ((((((uint8_t)(__IT__)) >> 5U) == 1U)? (__HANDLE__)->Instance->CR1:(((((uint8_t)(__IT__)) >> 5U) == 2U)?                                                        (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & (1U << (((uint16_t)(__IT__)) & UART_IT_MASK)))
N
N/** @brief  Clear the specified UART ISR flag, in setting the proper ICR register flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @param  __IT_CLEAR__ specifies the interrupt clear register flag that needs to be set
N  *                       to clear the corresponding interrupt
N  *          This parameter can be one of the following values:
N  *            @arg @ref UART_CLEAR_PEF Parity Error Clear Flag
N  *            @arg @ref UART_CLEAR_FEF Framing Error Clear Flag
N  *            @arg @ref UART_CLEAR_NEF Noise detected Clear Flag
N  *            @arg @ref UART_CLEAR_OREF Overrun Error Clear Flag
N  *            @arg @ref UART_CLEAR_IDLEF IDLE line detected Clear Flag
N  *            @arg @ref UART_CLEAR_TCF Transmission Complete Clear Flag
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_CLEAR_LBDF LIN Break Detection Clear Flag (not available on F030xx devices)
N  @endif
N  *            @arg @ref UART_CLEAR_CTSF CTS Interrupt Clear Flag
N  *            @arg @ref UART_CLEAR_RTOF Receiver Time Out Clear Flag
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_CLEAR_EOBF End Of Block Clear Flag
N  @endif
N  *            @arg @ref UART_CLEAR_CMF Character Match Clear Flag
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_CLEAR_WUF  Wake Up from stop mode Clear Flag (not available on F030xx devices)
N  @endif
N  * @retval None
N  */
N#define __HAL_UART_CLEAR_IT(__HANDLE__, __IT_CLEAR__) ((__HANDLE__)->Instance->ICR = (uint32_t)(__IT_CLEAR__))
N
N/** @brief  Set a specific UART request flag.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @param  __REQ__ specifies the request flag to set
N  *          This parameter can be one of the following values:
N  *            @arg @ref UART_AUTOBAUD_REQUEST Auto-Baud Rate Request
N  *            @arg @ref UART_SENDBREAK_REQUEST Send Break Request
N  *            @arg @ref UART_MUTE_MODE_REQUEST Mute Mode Request
N  *            @arg @ref UART_RXDATA_FLUSH_REQUEST Receive Data flush Request
N  @if STM32F030x6
N  @elseif STM32F030x8
N  @elseif STM32F030xC
N  @elseif STM32F070x6
N  @elseif STM32F070xB
N  @else
N  *            @arg @ref UART_TXDATA_FLUSH_REQUEST Transmit data flush Request (not available on F030xx devices)
N  @endif
N  * @retval None
N  */
N#define __HAL_UART_SEND_REQ(__HANDLE__, __REQ__) ((__HANDLE__)->Instance->RQR |= (uint32_t)(__REQ__))
N
N/** @brief  Enable the UART one bit sample method.
N  * @param  __HANDLE__ specifies the UART Handle.  
N  * @retval None
N  */     
N#define __HAL_UART_ONE_BIT_SAMPLE_ENABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3|= USART_CR3_ONEBIT)
N
N/** @brief  Disable the UART one bit sample method.
N  * @param  __HANDLE__ specifies the UART Handle.  
N  * @retval None
N  */      
N#define __HAL_UART_ONE_BIT_SAMPLE_DISABLE(__HANDLE__) ((__HANDLE__)->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT))
N
N/** @brief  Enable UART.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_ENABLE(__HANDLE__)                   ((__HANDLE__)->Instance->CR1 |=  USART_CR1_UE)
N
N/** @brief  Disable UART.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_DISABLE(__HANDLE__)                  ((__HANDLE__)->Instance->CR1 &=  ~USART_CR1_UE)
N
N/** @brief  Enable CTS flow control.
N  * @note   This macro allows to enable CTS hardware flow control for a given UART instance, 
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e. __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e. __HAL_UART_ENABLE(__HANDLE__)).                                                                                                                  
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__)        \
N  do{                                                      \
N    SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);  \
N    (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_CTSE;        \
N  } while(0)
X#define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__)          do{                                                          SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);      (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_CTSE;          } while(0)
N
N/** @brief  Disable CTS flow control.
N  * @note   This macro allows to disable CTS hardware flow control for a given UART instance, 
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e. __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e. __HAL_UART_ENABLE(__HANDLE__)). 
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__)        \
N  do{                                                       \
N    CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE); \
N    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_CTSE);      \
N  } while(0)
X#define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__)          do{                                                           CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);     (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_CTSE);        } while(0)
N
N/** @brief  Enable RTS flow control.
N  * @note   This macro allows to enable RTS hardware flow control for a given UART instance, 
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e. __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e. __HAL_UART_ENABLE(__HANDLE__)). 
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__)       \
N  do{                                                     \
N    SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE); \
N    (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_RTSE;       \
N  } while(0)
X#define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__)         do{                                                         SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);     (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_RTSE;         } while(0)
N
N/** @brief  Disable RTS flow control.
N  * @note   This macro allows to disable RTS hardware flow control for a given UART instance, 
N  *         without need to call HAL_UART_Init() function.
N  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
N  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
N  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
N  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
N  *           - macro could only be called when corresponding UART instance is disabled (i.e. __HAL_UART_DISABLE(__HANDLE__))
N  *             and should be followed by an Enable macro (i.e. __HAL_UART_ENABLE(__HANDLE__)). 
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__)       \
N  do{                                                      \
N    CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);\
N    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_RTSE);     \
N  } while(0)
X#define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__)         do{                                                          CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);    (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_RTSE);       } while(0)
N
N/**
N  * @}
N  */
N
N/* Private macros --------------------------------------------------------*/
N/** @defgroup UART_Private_Macros   UART Private Macros
N  * @{
N  */
N
N/** @brief  BRR division operation to set BRR register in 8-bit oversampling mode.
N  * @param  __PCLK__ UART clock.
N  * @param  __BAUD__ Baud rate set by the user.
N  * @retval Division result
N  */
N#define UART_DIV_SAMPLING8(__PCLK__, __BAUD__)   ((((__PCLK__)*2U) + ((__BAUD__)/2U)) / (__BAUD__))
N
N/** @brief  BRR division operation to set BRR register in 16-bit oversampling mode.
N  * @param  __PCLK__ UART clock.
N  * @param  __BAUD__ Baud rate set by the user.
N  * @retval Division result
N  */
N#define UART_DIV_SAMPLING16(__PCLK__, __BAUD__)  (((__PCLK__) + ((__BAUD__)/2U)) / (__BAUD__))
N
N/** @brief  Check UART Baud rate.
N  * @param  __BAUDRATE__ Baudrate specified by the user.
N  *         The maximum Baud Rate is derived from the maximum clock on F0 (i.e. 48 MHz) 
N  *         divided by the smallest oversampling used on the USART (i.e. 8)
N  * @retval SET (__BAUDRATE__ is valid) or RESET (__BAUDRATE__ is invalid)
N  */
N#define IS_UART_BAUDRATE(__BAUDRATE__) ((__BAUDRATE__) < 6000001U)
N
N/** @brief  Check UART assertion time.
N  * @param  __TIME__ 5-bit value assertion time.
N  * @retval Test result (TRUE or FALSE).
N  */
N#define IS_UART_ASSERTIONTIME(__TIME__)    ((__TIME__) <= 0x1F)
N
N/** @brief  Check UART deassertion time.
N  * @param  __TIME__ 5-bit value deassertion time.
N  * @retval Test result (TRUE or FALSE).
N  */
N#define IS_UART_DEASSERTIONTIME(__TIME__) ((__TIME__) <= 0x1F)
N
N/**
N  * @brief Ensure that UART frame number of stop bits is valid.
N  * @param __STOPBITS__ UART frame number of stop bits. 
N  * @retval SET (__STOPBITS__ is valid) or RESET (__STOPBITS__ is invalid)
N  */
N#ifdef USART_SMARTCARD_SUPPORT
N#define IS_UART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == UART_STOPBITS_0_5) || \
N                                        ((__STOPBITS__) == UART_STOPBITS_1)   || \
N                                        ((__STOPBITS__) == UART_STOPBITS_1_5) || \
N                                        ((__STOPBITS__) == UART_STOPBITS_2))
X#define IS_UART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == UART_STOPBITS_0_5) ||                                         ((__STOPBITS__) == UART_STOPBITS_1)   ||                                         ((__STOPBITS__) == UART_STOPBITS_1_5) ||                                         ((__STOPBITS__) == UART_STOPBITS_2))
N#else
S#define IS_UART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == UART_STOPBITS_1)   || \
S                                        ((__STOPBITS__) == UART_STOPBITS_2))
X#define IS_UART_STOPBITS(__STOPBITS__) (((__STOPBITS__) == UART_STOPBITS_1)   ||                                         ((__STOPBITS__) == UART_STOPBITS_2))
N#endif
N
N/**
N  * @brief Ensure that UART frame parity is valid.
N  * @param __PARITY__ UART frame parity. 
N  * @retval SET (__PARITY__ is valid) or RESET (__PARITY__ is invalid)
N  */ 
N#define IS_UART_PARITY(__PARITY__) (((__PARITY__) == UART_PARITY_NONE) || \
N                                    ((__PARITY__) == UART_PARITY_EVEN) || \
N                                    ((__PARITY__) == UART_PARITY_ODD))
X#define IS_UART_PARITY(__PARITY__) (((__PARITY__) == UART_PARITY_NONE) ||                                     ((__PARITY__) == UART_PARITY_EVEN) ||                                     ((__PARITY__) == UART_PARITY_ODD))
N
N/**
N  * @brief Ensure that UART hardware flow control is valid.
N  * @param __CONTROL__ UART hardware flow control. 
N  * @retval SET (__CONTROL__ is valid) or RESET (__CONTROL__ is invalid)
N  */ 
N#define IS_UART_HARDWARE_FLOW_CONTROL(__CONTROL__)\
N                                   (((__CONTROL__) == UART_HWCONTROL_NONE) || \
N                                    ((__CONTROL__) == UART_HWCONTROL_RTS)  || \
N                                    ((__CONTROL__) == UART_HWCONTROL_CTS)  || \
N                                    ((__CONTROL__) == UART_HWCONTROL_RTS_CTS))
X#define IS_UART_HARDWARE_FLOW_CONTROL(__CONTROL__)                                   (((__CONTROL__) == UART_HWCONTROL_NONE) ||                                     ((__CONTROL__) == UART_HWCONTROL_RTS)  ||                                     ((__CONTROL__) == UART_HWCONTROL_CTS)  ||                                     ((__CONTROL__) == UART_HWCONTROL_RTS_CTS))
N
N/**
N  * @brief Ensure that UART communication mode is valid.
N  * @param __MODE__ UART communication mode. 
N  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
N  */ 
N#define IS_UART_MODE(__MODE__) ((((__MODE__) & (~((uint32_t)(UART_MODE_TX_RX)))) == 0x00U) && ((__MODE__) != 0x00U))
N
N/**
N  * @brief Ensure that UART state is valid.
N  * @param __STATE__ UART state. 
N  * @retval SET (__STATE__ is valid) or RESET (__STATE__ is invalid)
N  */ 
N#define IS_UART_STATE(__STATE__) (((__STATE__) == UART_STATE_DISABLE) || \
N                                  ((__STATE__) == UART_STATE_ENABLE))
X#define IS_UART_STATE(__STATE__) (((__STATE__) == UART_STATE_DISABLE) ||                                   ((__STATE__) == UART_STATE_ENABLE))
N
N/**
N  * @brief Ensure that UART oversampling is valid.
N  * @param __SAMPLING__ UART oversampling. 
N  * @retval SET (__SAMPLING__ is valid) or RESET (__SAMPLING__ is invalid)
N  */ 
N#define IS_UART_OVERSAMPLING(__SAMPLING__) (((__SAMPLING__) == UART_OVERSAMPLING_16) || \
N                                            ((__SAMPLING__) == UART_OVERSAMPLING_8))
X#define IS_UART_OVERSAMPLING(__SAMPLING__) (((__SAMPLING__) == UART_OVERSAMPLING_16) ||                                             ((__SAMPLING__) == UART_OVERSAMPLING_8))
N
N/**
N  * @brief Ensure that UART frame sampling is valid.
N  * @param __ONEBIT__ UART frame sampling. 
N  * @retval SET (__ONEBIT__ is valid) or RESET (__ONEBIT__ is invalid)
N  */
N#define IS_UART_ONE_BIT_SAMPLE(__ONEBIT__) (((__ONEBIT__) == UART_ONE_BIT_SAMPLE_DISABLE) || \
N                                            ((__ONEBIT__) == UART_ONE_BIT_SAMPLE_ENABLE))
X#define IS_UART_ONE_BIT_SAMPLE(__ONEBIT__) (((__ONEBIT__) == UART_ONE_BIT_SAMPLE_DISABLE) ||                                             ((__ONEBIT__) == UART_ONE_BIT_SAMPLE_ENABLE))
N
N/**
N  * @brief Ensure that Address Length detection parameter is valid.
N  * @param __ADDRESS__ UART Adress length value. 
N  * @retval SET (__ADDRESS__ is valid) or RESET (__ADDRESS__ is invalid)
N  */
N#define IS_UART_ADDRESSLENGTH_DETECT(__ADDRESS__) (((__ADDRESS__) == UART_ADDRESS_DETECT_4B) || \
N                                                   ((__ADDRESS__) == UART_ADDRESS_DETECT_7B))
X#define IS_UART_ADDRESSLENGTH_DETECT(__ADDRESS__) (((__ADDRESS__) == UART_ADDRESS_DETECT_4B) ||                                                    ((__ADDRESS__) == UART_ADDRESS_DETECT_7B))
N
N/**
N  * @brief Ensure that UART receiver timeout setting is valid.
N  * @param __TIMEOUT__ UART receiver timeout setting. 
N  * @retval SET (__TIMEOUT__ is valid) or RESET (__TIMEOUT__ is invalid)
N  */
N#define IS_UART_RECEIVER_TIMEOUT(__TIMEOUT__) (((__TIMEOUT__) == UART_RECEIVER_TIMEOUT_DISABLE) || \
N                                               ((__TIMEOUT__) == UART_RECEIVER_TIMEOUT_ENABLE))
X#define IS_UART_RECEIVER_TIMEOUT(__TIMEOUT__) (((__TIMEOUT__) == UART_RECEIVER_TIMEOUT_DISABLE) ||                                                ((__TIMEOUT__) == UART_RECEIVER_TIMEOUT_ENABLE))
N
N/**
N  * @brief Ensure that UART DMA TX state is valid.
N  * @param __DMATX__ UART DMA TX state. 
N  * @retval SET (__DMATX__ is valid) or RESET (__DMATX__ is invalid)
N  */
N#define IS_UART_DMA_TX(__DMATX__)     (((__DMATX__) == UART_DMA_TX_DISABLE) || \
N                                       ((__DMATX__) == UART_DMA_TX_ENABLE))
X#define IS_UART_DMA_TX(__DMATX__)     (((__DMATX__) == UART_DMA_TX_DISABLE) ||                                        ((__DMATX__) == UART_DMA_TX_ENABLE))
N
N/**
N  * @brief Ensure that UART DMA RX state is valid.
N  * @param __DMARX__ UART DMA RX state. 
N  * @retval SET (__DMARX__ is valid) or RESET (__DMARX__ is invalid)
N  */
N#define IS_UART_DMA_RX(__DMARX__)     (((__DMARX__) == UART_DMA_RX_DISABLE) || \
N                                       ((__DMARX__) == UART_DMA_RX_ENABLE))
X#define IS_UART_DMA_RX(__DMARX__)     (((__DMARX__) == UART_DMA_RX_DISABLE) ||                                        ((__DMARX__) == UART_DMA_RX_ENABLE))
N
N/**
N  * @brief Ensure that UART half-duplex state is valid.
N  * @param __HDSEL__ UART half-duplex state. 
N  * @retval SET (__HDSEL__ is valid) or RESET (__HDSEL__ is invalid)
N  */
N#define IS_UART_HALF_DUPLEX(__HDSEL__)     (((__HDSEL__) == UART_HALF_DUPLEX_DISABLE) || \
N                                            ((__HDSEL__) == UART_HALF_DUPLEX_ENABLE))
X#define IS_UART_HALF_DUPLEX(__HDSEL__)     (((__HDSEL__) == UART_HALF_DUPLEX_DISABLE) ||                                             ((__HDSEL__) == UART_HALF_DUPLEX_ENABLE))
N
N/**
N  * @brief Ensure that UART wake-up method is valid.
N  * @param __WAKEUP__ UART wake-up method . 
N  * @retval SET (__WAKEUP__ is valid) or RESET (__WAKEUP__ is invalid)
N  */
N#define IS_UART_WAKEUPMETHOD(__WAKEUP__) (((__WAKEUP__) == UART_WAKEUPMETHOD_IDLELINE) || \
N                                          ((__WAKEUP__) == UART_WAKEUPMETHOD_ADDRESSMARK))
X#define IS_UART_WAKEUPMETHOD(__WAKEUP__) (((__WAKEUP__) == UART_WAKEUPMETHOD_IDLELINE) ||                                           ((__WAKEUP__) == UART_WAKEUPMETHOD_ADDRESSMARK))
N
N/**
N  * @brief Ensure that UART advanced features initialization is valid.
N  * @param __INIT__ UART advanced features initialization. 
N  * @retval SET (__INIT__ is valid) or RESET (__INIT__ is invalid)
N  */
N#define IS_UART_ADVFEATURE_INIT(__INIT__)   ((__INIT__) <= (UART_ADVFEATURE_NO_INIT                | \
N                                                            UART_ADVFEATURE_TXINVERT_INIT          | \
N                                                            UART_ADVFEATURE_RXINVERT_INIT          | \
N                                                            UART_ADVFEATURE_DATAINVERT_INIT        | \
N                                                            UART_ADVFEATURE_SWAP_INIT              | \
N                                                            UART_ADVFEATURE_RXOVERRUNDISABLE_INIT  | \
N                                                            UART_ADVFEATURE_DMADISABLEONERROR_INIT | \
N                                                            UART_ADVFEATURE_AUTOBAUDRATE_INIT      | \
N                                                            UART_ADVFEATURE_MSBFIRST_INIT))
X#define IS_UART_ADVFEATURE_INIT(__INIT__)   ((__INIT__) <= (UART_ADVFEATURE_NO_INIT                |                                                             UART_ADVFEATURE_TXINVERT_INIT          |                                                             UART_ADVFEATURE_RXINVERT_INIT          |                                                             UART_ADVFEATURE_DATAINVERT_INIT        |                                                             UART_ADVFEATURE_SWAP_INIT              |                                                             UART_ADVFEATURE_RXOVERRUNDISABLE_INIT  |                                                             UART_ADVFEATURE_DMADISABLEONERROR_INIT |                                                             UART_ADVFEATURE_AUTOBAUDRATE_INIT      |                                                             UART_ADVFEATURE_MSBFIRST_INIT))
N
N/**
N  * @brief Ensure that UART frame TX inversion setting is valid.
N  * @param __TXINV__ UART frame TX inversion setting. 
N  * @retval SET (__TXINV__ is valid) or RESET (__TXINV__ is invalid)
N  */
N#define IS_UART_ADVFEATURE_TXINV(__TXINV__) (((__TXINV__) == UART_ADVFEATURE_TXINV_DISABLE) || \
N                                             ((__TXINV__) == UART_ADVFEATURE_TXINV_ENABLE))
X#define IS_UART_ADVFEATURE_TXINV(__TXINV__) (((__TXINV__) == UART_ADVFEATURE_TXINV_DISABLE) ||                                              ((__TXINV__) == UART_ADVFEATURE_TXINV_ENABLE))
N
N/**
N  * @brief Ensure that UART frame RX inversion setting is valid.
N  * @param __RXINV__ UART frame RX inversion setting. 
N  * @retval SET (__RXINV__ is valid) or RESET (__RXINV__ is invalid)
N  */
N#define IS_UART_ADVFEATURE_RXINV(__RXINV__) (((__RXINV__) == UART_ADVFEATURE_RXINV_DISABLE) || \
N                                             ((__RXINV__) == UART_ADVFEATURE_RXINV_ENABLE))
X#define IS_UART_ADVFEATURE_RXINV(__RXINV__) (((__RXINV__) == UART_ADVFEATURE_RXINV_DISABLE) ||                                              ((__RXINV__) == UART_ADVFEATURE_RXINV_ENABLE))
N
N/**
N  * @brief Ensure that UART frame data inversion setting is valid.
N  * @param __DATAINV__ UART frame data inversion setting. 
N  * @retval SET (__DATAINV__ is valid) or RESET (__DATAINV__ is invalid)
N  */
N#define IS_UART_ADVFEATURE_DATAINV(__DATAINV__) (((__DATAINV__) == UART_ADVFEATURE_DATAINV_DISABLE) || \
N                                                 ((__DATAINV__) == UART_ADVFEATURE_DATAINV_ENABLE))
X#define IS_UART_ADVFEATURE_DATAINV(__DATAINV__) (((__DATAINV__) == UART_ADVFEATURE_DATAINV_DISABLE) ||                                                  ((__DATAINV__) == UART_ADVFEATURE_DATAINV_ENABLE))
N
N/**
N  * @brief Ensure that UART frame RX/TX pins swap setting is valid.
N  * @param __SWAP__ UART frame RX/TX pins swap setting. 
N  * @retval SET (__SWAP__ is valid) or RESET (__SWAP__ is invalid)
N  */
N#define IS_UART_ADVFEATURE_SWAP(__SWAP__) (((__SWAP__) == UART_ADVFEATURE_SWAP_DISABLE) || \
N                                           ((__SWAP__) == UART_ADVFEATURE_SWAP_ENABLE))
X#define IS_UART_ADVFEATURE_SWAP(__SWAP__) (((__SWAP__) == UART_ADVFEATURE_SWAP_DISABLE) ||                                            ((__SWAP__) == UART_ADVFEATURE_SWAP_ENABLE))
N
N/**
N  * @brief Ensure that UART frame overrun setting is valid.
N  * @param __OVERRUN__ UART frame overrun setting. 
N  * @retval SET (__OVERRUN__ is valid) or RESET (__OVERRUN__ is invalid)
N  */
N#define IS_UART_OVERRUN(__OVERRUN__)     (((__OVERRUN__) == UART_ADVFEATURE_OVERRUN_ENABLE) || \
N                                          ((__OVERRUN__) == UART_ADVFEATURE_OVERRUN_DISABLE))
X#define IS_UART_OVERRUN(__OVERRUN__)     (((__OVERRUN__) == UART_ADVFEATURE_OVERRUN_ENABLE) ||                                           ((__OVERRUN__) == UART_ADVFEATURE_OVERRUN_DISABLE))
N
N/**
N  * @brief Ensure that UART auto Baud rate state is valid.
N  * @param __AUTOBAUDRATE__ UART auto Baud rate state. 
N  * @retval SET (__AUTOBAUDRATE__ is valid) or RESET (__AUTOBAUDRATE__ is invalid)
N  */
N#define IS_UART_ADVFEATURE_AUTOBAUDRATE(__AUTOBAUDRATE__)  (((__AUTOBAUDRATE__) == UART_ADVFEATURE_AUTOBAUDRATE_DISABLE) || \
N                                                            ((__AUTOBAUDRATE__) == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE))
X#define IS_UART_ADVFEATURE_AUTOBAUDRATE(__AUTOBAUDRATE__)  (((__AUTOBAUDRATE__) == UART_ADVFEATURE_AUTOBAUDRATE_DISABLE) ||                                                             ((__AUTOBAUDRATE__) == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE))
N
N/**
N  * @brief Ensure that UART DMA enabling or disabling on error setting is valid.
N  * @param __DMA__ UART DMA enabling or disabling on error setting. 
N  * @retval SET (__DMA__ is valid) or RESET (__DMA__ is invalid)
N  */
N#define IS_UART_ADVFEATURE_DMAONRXERROR(__DMA__)  (((__DMA__) == UART_ADVFEATURE_DMA_ENABLEONRXERROR) || \
N                                                   ((__DMA__) == UART_ADVFEATURE_DMA_DISABLEONRXERROR))
X#define IS_UART_ADVFEATURE_DMAONRXERROR(__DMA__)  (((__DMA__) == UART_ADVFEATURE_DMA_ENABLEONRXERROR) ||                                                    ((__DMA__) == UART_ADVFEATURE_DMA_DISABLEONRXERROR))
N
N/**
N  * @brief Ensure that UART frame MSB first setting is valid.
N  * @param __MSBFIRST__ UART frame MSB first setting. 
N  * @retval SET (__MSBFIRST__ is valid) or RESET (__MSBFIRST__ is invalid)
N  */
N#define IS_UART_ADVFEATURE_MSBFIRST(__MSBFIRST__) (((__MSBFIRST__) == UART_ADVFEATURE_MSBFIRST_DISABLE) || \
N                                                   ((__MSBFIRST__) == UART_ADVFEATURE_MSBFIRST_ENABLE))
X#define IS_UART_ADVFEATURE_MSBFIRST(__MSBFIRST__) (((__MSBFIRST__) == UART_ADVFEATURE_MSBFIRST_DISABLE) ||                                                    ((__MSBFIRST__) == UART_ADVFEATURE_MSBFIRST_ENABLE))
N
N/**
N  * @brief Ensure that UART mute mode state is valid.
N  * @param __MUTE__ UART mute mode state. 
N  * @retval SET (__MUTE__ is valid) or RESET (__MUTE__ is invalid)
N  */
N#define IS_UART_MUTE_MODE(__MUTE__)       (((__MUTE__) == UART_ADVFEATURE_MUTEMODE_DISABLE) || \
N                                           ((__MUTE__) == UART_ADVFEATURE_MUTEMODE_ENABLE))
X#define IS_UART_MUTE_MODE(__MUTE__)       (((__MUTE__) == UART_ADVFEATURE_MUTEMODE_DISABLE) ||                                            ((__MUTE__) == UART_ADVFEATURE_MUTEMODE_ENABLE))
N
N/**
N  * @brief Ensure that UART driver enable polarity is valid.
N  * @param __POLARITY__ UART driver enable polarity. 
N  * @retval SET (__POLARITY__ is valid) or RESET (__POLARITY__ is invalid)
N  */
N#define IS_UART_DE_POLARITY(__POLARITY__)    (((__POLARITY__) == UART_DE_POLARITY_HIGH) || \
N                                              ((__POLARITY__) == UART_DE_POLARITY_LOW))
X#define IS_UART_DE_POLARITY(__POLARITY__)    (((__POLARITY__) == UART_DE_POLARITY_HIGH) ||                                               ((__POLARITY__) == UART_DE_POLARITY_LOW))
N
N/**
N  * @}
N  */
N
N/* Include UART HAL Extended module */
N#include "stm32f0xx_hal_uart_ex.h"
L 1 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_uart_ex.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f0xx_hal_uart_ex.h
N  * @author  MCD Application Team
N  * @brief   Header file of UART HAL Extended module.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0xx_HAL_UART_EX_H
N#define __STM32F0xx_HAL_UART_EX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal_def.h"
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup UARTEx
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L  && !0L  && !0L
N/** @defgroup UARTEx_Exported_Types UARTEx Exported Types
N  * @{
N  */
N
N/**
N  * @brief  UART wake up from stop mode parameters
N  */
Ntypedef struct
N{
N  uint32_t WakeUpEvent;        /*!< Specifies which event will activat the Wakeup from Stop mode flag (WUF).
N                                    This parameter can be a value of @ref UART_WakeUp_from_Stop_Selection.
N                                    If set to UART_WAKEUP_ON_ADDRESS, the two other fields below must
N                                    be filled up. */
N
N  uint16_t AddressLength;      /*!< Specifies whether the address is 4 or 7-bit long.
N                                    This parameter can be a value of @ref UART_WakeUp_Address_Length.  */
N
N  uint8_t Address;             /*!< UART/USART node address (7-bit long max). */
N} UART_WakeUpTypeDef;
N
N/**
N  * @}
N  */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */  
N
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup UARTEx_Exported_Constants UARTEx Exported Constants
N  * @{
N  */
N
N/** @defgroup UARTEx_Word_Length UARTEx Word Length
N  * @{
N  */
N#if defined (STM32F042x6) || defined (STM32F048xx) || defined (STM32F070x6) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || defined (STM32F070xB) || \
N    defined (STM32F091xC) || defined (STM32F098xx) || defined (STM32F030xC)
X#if 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     1L || 0L || 0L
N#define UART_WORDLENGTH_7B                  ((uint32_t)USART_CR1_M1)   /*!< 7-bit long UART frame */
N#define UART_WORDLENGTH_8B                  (0x00000000U)              /*!< 8-bit long UART frame */
N#define UART_WORDLENGTH_9B                  ((uint32_t)USART_CR1_M0)   /*!< 9-bit long UART frame */
N#else
S#define UART_WORDLENGTH_8B                  (0x00000000U)              /*!< 8-bit long UART frame */
S#define UART_WORDLENGTH_9B                  ((uint32_t)USART_CR1_M)    /*!< 9-bit long UART frame */
N#endif /* defined (STM32F042x6) || defined (STM32F048xx) || defined (STM32F070x6) || \
N          defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || defined (STM32F070xB) || \
N          defined (STM32F091xC) || defined (STM32F098xx) || defined (STM32F030xC) */
X#endif  
N/**
N  * @}
N  */
N
N/** @defgroup UARTEx_AutoBaud_Rate_Mode    UARTEx Advanced Feature AutoBaud Rate Mode
N  * @{
N  */
N#if defined (STM32F042x6) || defined (STM32F048xx) || defined (STM32F070x6) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || defined (STM32F070xB) || \
N    defined (STM32F091xC) || defined (STM32F098xx) || defined (STM32F030xC)
X#if 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     1L || 0L || 0L
N#define UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT    (0x00000000U)                     /*!< Auto Baud rate detection on start bit            */
N#define UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE ((uint32_t)USART_CR2_ABRMODE_0)   /*!< Auto Baud rate detection on falling edge         */
N#define UART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAME   ((uint32_t)USART_CR2_ABRMODE_1)   /*!< Auto Baud rate detection on 0x7F frame detection */
N#define UART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAME   ((uint32_t)USART_CR2_ABRMODE)     /*!< Auto Baud rate detection on 0x55 frame detection */
N#else
S#define UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT    (0x00000000U)                     /*!< Auto Baud rate detection on start bit            */
S#define UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE ((uint32_t)USART_CR2_ABRMODE_0)   /*!< Auto Baud rate detection on falling edge         */
N#endif /* defined (STM32F042x6) || defined (STM32F048xx) || defined (STM32F070x6) || \
N          defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || defined (STM32F070xB) || \
N          defined (STM32F091xC) || defined (STM32F098xx) || defined (STM32F030xC) */
X#endif  
N/**
N  * @}
N  */
N
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L  && !0L  && !0L
N/** @defgroup UARTEx_LIN    UARTEx Local Interconnection Network mode
N  * @{
N  */
N#define UART_LIN_DISABLE                    (0x00000000U)                          /*!< Local Interconnect Network disable */
N#define UART_LIN_ENABLE                     ((uint32_t)USART_CR2_LINEN)            /*!< Local Interconnect Network enable  */
N/**
N  * @}
N  */
N
N/** @defgroup UARTEx_LIN_Break_Detection  UARTEx LIN Break Detection
N  * @{
N  */
N#define UART_LINBREAKDETECTLENGTH_10B       (0x00000000U)                         /*!< LIN 10-bit break detection length */
N#define UART_LINBREAKDETECTLENGTH_11B       ((uint32_t)USART_CR2_LBDL)            /*!< LIN 11-bit break detection length  */
N/**
N  * @}
N  */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */  
N
N/** @defgroup UART_Flags     UARTEx Status Flags
N  *        Elements values convention: 0xXXXX
N  *           - 0xXXXX  : Flag mask in the ISR register
N  * @{
N  */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L  && !0L  && !0L
N#define UART_FLAG_REACK                     (0x00400000U)              /*!< UART receive enable acknowledge flag      */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */ 
N#define UART_FLAG_TEACK                     (0x00200000U)              /*!< UART transmit enable acknowledge flag     */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L  && !0L  && !0L
N#define UART_FLAG_WUF                       (0x00100000U)              /*!< UART wake-up from stop mode flag          */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */ 
N#define UART_FLAG_RWU                       (0x00080000U)              /*!< UART receiver wake-up from mute mode flag */
N#define UART_FLAG_SBKF                      (0x00040000U)              /*!< UART send break flag                      */
N#define UART_FLAG_CMF                       (0x00020000U)              /*!< UART character match flag                 */
N#define UART_FLAG_BUSY                      (0x00010000U)              /*!< UART busy flag                            */
N#define UART_FLAG_ABRF                      (0x00008000U)              /*!< UART auto Baud rate flag                  */
N#define UART_FLAG_ABRE                      (0x00004000U)              /*!< UART auto Baud rate error                 */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L  && !0L  && !0L
N#define UART_FLAG_EOBF                      (0x00001000U)              /*!< UART end of block flag                    */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */ 
N#define UART_FLAG_RTOF                      (0x00000800U)              /*!< UART receiver timeout flag                */
N#define UART_FLAG_CTS                       (0x00000400U)              /*!< UART clear to send flag                   */
N#define UART_FLAG_CTSIF                     (0x00000200U)              /*!< UART clear to send interrupt flag         */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L  && !0L  && !0L
N#define UART_FLAG_LBDF                      (0x00000100U)              /*!< UART LIN break detection flag (not available on F030xx devices)*/
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */ 
N#define UART_FLAG_TXE                       (0x00000080U)              /*!< UART transmit data register empty         */
N#define UART_FLAG_TC                        (0x00000040U)              /*!< UART transmission complete                */
N#define UART_FLAG_RXNE                      (0x00000020U)              /*!< UART read data register not empty         */
N#define UART_FLAG_IDLE                      (0x00000010U)              /*!< UART idle flag                            */
N#define UART_FLAG_ORE                       (0x00000008U)              /*!< UART overrun error                        */
N#define UART_FLAG_NE                        (0x00000004U)              /*!< UART noise error                          */
N#define UART_FLAG_FE                        (0x00000002U)              /*!< UART frame error                          */
N#define UART_FLAG_PE                        (0x00000001U)              /*!< UART parity error                         */
N/**
N  * @}
N  */
N
N/** @defgroup UART_Interrupt_definition   UARTEx Interrupts Definition
N  *        Elements values convention: 000ZZZZZ0XXYYYYYb
N  *           - YYYYY  : Interrupt source position in the XX register (5bits)
N  *           - XX  : Interrupt source register (2bits)
N  *                 - 01: CR1 register
N  *                 - 10: CR2 register
N  *                 - 11: CR3 register
N  *           - ZZZZZ  : Flag position in the ISR register(5bits)
N  * @{
N  */
N#define UART_IT_PE                          (0x0028U)                  /*!< UART parity error interruption                 */
N#define UART_IT_TXE                         (0x0727U)                  /*!< UART transmit data register empty interruption */
N#define UART_IT_TC                          (0x0626U)                  /*!< UART transmission complete interruption        */
N#define UART_IT_RXNE                        (0x0525U)                  /*!< UART read data register not empty interruption */
N#define UART_IT_IDLE                        (0x0424U)                  /*!< UART idle interruption                         */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) 
X#if !0L && !0L && !0L  && !0L  && !0L 
N#define UART_IT_LBD                         (0x0846U)                  /*!< UART LIN break detection interruption          */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */ 
N#define UART_IT_CTS                         (0x096AU)                  /*!< UART CTS interruption                          */
N#define UART_IT_CM                          (0x112EU)                  /*!< UART character match interruption              */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) 
X#if !0L && !0L && !0L  && !0L  && !0L 
N#define UART_IT_WUF                         (0x1476U)                  /*!< UART wake-up from stop mode interruption       */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */ 
N/**
N  * @}
N  */
N
N
N/** @defgroup UART_IT_CLEAR_Flags  UARTEx Interruption Clear Flags
N  * @{
N  */
N#define UART_CLEAR_PEF                       USART_ICR_PECF            /*!< Parity Error Clear Flag           */
N#define UART_CLEAR_FEF                       USART_ICR_FECF            /*!< Framing Error Clear Flag          */
N#define UART_CLEAR_NEF                       USART_ICR_NCF             /*!< Noise detected Clear Flag         */
N#define UART_CLEAR_OREF                      USART_ICR_ORECF           /*!< Overrun Error Clear Flag          */
N#define UART_CLEAR_IDLEF                     USART_ICR_IDLECF          /*!< IDLE line detected Clear Flag     */
N#define UART_CLEAR_TCF                       USART_ICR_TCCF            /*!< Transmission Complete Clear Flag  */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L  && !0L  && !0L
N#define UART_CLEAR_LBDF                      USART_ICR_LBDCF           /*!< LIN Break Detection Clear Flag (not available on F030xx devices)*/
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */    
N#define UART_CLEAR_CTSF                      USART_ICR_CTSCF           /*!< CTS Interrupt Clear Flag          */
N#define UART_CLEAR_RTOF                      USART_ICR_RTOCF           /*!< Receiver Time Out Clear Flag      */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L  && !0L  && !0L
N#define UART_CLEAR_EOBF                      USART_ICR_EOBCF           /*!< End Of Block Clear Flag           */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */    
N#define UART_CLEAR_CMF                       USART_ICR_CMCF            /*!< Character Match Clear Flag        */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)      
X#if !0L && !0L && !0L  && !0L  && !0L      
N#define UART_CLEAR_WUF                       USART_ICR_WUCF            /*!< Wake Up from stop mode Clear Flag */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */ 
N/**
N  * @}
N  */
N
N/** @defgroup UART_Request_Parameters UARTEx Request Parameters
N  * @{
N  */
N#define UART_AUTOBAUD_REQUEST               ((uint32_t)USART_RQR_ABRRQ)        /*!< Auto-Baud Rate Request      */
N#define UART_SENDBREAK_REQUEST              ((uint32_t)USART_RQR_SBKRQ)        /*!< Send Break Request          */
N#define UART_MUTE_MODE_REQUEST              ((uint32_t)USART_RQR_MMRQ)         /*!< Mute Mode Request           */
N#define UART_RXDATA_FLUSH_REQUEST           ((uint32_t)USART_RQR_RXFRQ)        /*!< Receive Data flush Request  */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)      
X#if !0L && !0L && !0L  && !0L  && !0L      
N#define UART_TXDATA_FLUSH_REQUEST           ((uint32_t)USART_RQR_TXFRQ)        /*!< Transmit data flush Request */
N#else
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */ 
N/**
N  * @}
N  */
N
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6) && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L && !0L  && !0L
N/** @defgroup UART_Stop_Mode_Enable   UARTEx Advanced Feature Stop Mode Enable
N  * @{
N  */
N#define UART_ADVFEATURE_STOPMODE_DISABLE    (0x00000000U)                       /*!< UART stop mode disable */
N#define UART_ADVFEATURE_STOPMODE_ENABLE     ((uint32_t)USART_CR1_UESM)          /*!< UART stop mode enable  */
N/**
N  * @}
N  */
N
N/** @defgroup UART_WakeUp_from_Stop_Selection   UART WakeUp From Stop Selection
N  * @{
N  */
N#define UART_WAKEUP_ON_ADDRESS              (0x00000000U)                       /*!< UART wake-up on address                         */
N#define UART_WAKEUP_ON_STARTBIT             ((uint32_t)USART_CR3_WUS_1)         /*!< UART wake-up on start bit                       */
N#define UART_WAKEUP_ON_READDATA_NONEMPTY    ((uint32_t)USART_CR3_WUS)           /*!< UART wake-up on receive data register not empty */
N/**
N  * @}
N  */
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6) && !defined(STM32F070xB) && !defined(STM32F030xC) */   
N
N/**
N  * @}
N  */
N
N/* Exported macros ------------------------------------------------------------*/
N/** @defgroup UARTEx_Exported_Macros UARTEx Exported Macros
N  * @{
N  */
N
N/** @brief  Flush the UART Data registers.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None
N  */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) 
X#if !0L && !0L 
N#define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__)  \
N  do{                \
N      SET_BIT((__HANDLE__)->Instance->RQR, UART_RXDATA_FLUSH_REQUEST); \
N      SET_BIT((__HANDLE__)->Instance->RQR, UART_TXDATA_FLUSH_REQUEST); \
N    }  while(0)
X#define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__)    do{                      SET_BIT((__HANDLE__)->Instance->RQR, UART_RXDATA_FLUSH_REQUEST);       SET_BIT((__HANDLE__)->Instance->RQR, UART_TXDATA_FLUSH_REQUEST);     }  while(0)
N#else
S#define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__)  \
S  do{                \
S      SET_BIT((__HANDLE__)->Instance->RQR, UART_RXDATA_FLUSH_REQUEST); \
S    }  while(0)
X#define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__)    do{                      SET_BIT((__HANDLE__)->Instance->RQR, UART_RXDATA_FLUSH_REQUEST);     }  while(0)
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) */ 
N
N/**
N  * @}
N  */
N
N/* Private macros ------------------------------------------------------------*/
N/** @defgroup UARTEx_Private_Macros UARTEx Private Macros
N  * @{
N  */
N
N/** @brief  Report the UART clock source.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @param  __CLOCKSOURCE__ output variable.
N  * @retval UART clocking source, written in __CLOCKSOURCE__.
N  */
N#if defined(STM32F030x6) || defined(STM32F031x6) || defined(STM32F038xx)
X#if 0L || 0L || 0L
S#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)       \
S  do {                                                        \
S     switch(__HAL_RCC_GET_USART1_SOURCE())                    \
S     {                                                        \
S      case RCC_USART1CLKSOURCE_PCLK1:                         \
S        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;           \
S        break;                                                \
S      case RCC_USART1CLKSOURCE_HSI:                           \
S        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;             \
S        break;                                                \
S      case RCC_USART1CLKSOURCE_SYSCLK:                        \
S        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;          \
S        break;                                                \
S      case RCC_USART1CLKSOURCE_LSE:                           \
S        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;             \
S        break;                                                \
S      default:                                                \
S        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;       \
S        break;                                                \
S     }                                                        \
S  } while(0) 
X#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)         do {                                                             switch(__HAL_RCC_GET_USART1_SOURCE())                         {                                                              case RCC_USART1CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART1CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART1CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART1CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;               break;                                                     }                                                          } while(0) 
S#elif defined (STM32F030x8) || defined (STM32F070x6) ||       \
S      defined (STM32F042x6) || defined (STM32F048xx) ||       \
S      defined (STM32F051x8) || defined (STM32F058xx)
X#elif 0L || 0L ||             0L || 0L ||             0L || 0L
S#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__) \
S  do {                                                        \
S    if((__HANDLE__)->Instance == USART1)                      \
S    {                                                         \
S       switch(__HAL_RCC_GET_USART1_SOURCE())                  \
S       {                                                      \
S        case RCC_USART1CLKSOURCE_PCLK1:                       \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_HSI:                         \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_SYSCLK:                      \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_LSE:                         \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
S          break;                                              \
S        default:                                              \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;     \
S          break;                                              \
S       }                                                      \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART2)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else                                                      \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;         \
S    }                                                         \
S  } while(0) 
X#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)   do {                                                            if((__HANDLE__)->Instance == USART1)                          {                                                                switch(__HAL_RCC_GET_USART1_SOURCE())                         {                                                              case RCC_USART1CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART1CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART1CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART1CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;               break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART2)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else                                                          {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;             }                                                           } while(0) 
S#elif defined(STM32F070xB)
X#elif 0L
S#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__) \
S  do {                                                        \
S    if((__HANDLE__)->Instance == USART1)                      \
S    {                                                         \
S       switch(__HAL_RCC_GET_USART1_SOURCE())                  \
S       {                                                      \
S        case RCC_USART1CLKSOURCE_PCLK1:                       \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_HSI:                         \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_SYSCLK:                      \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_LSE:                         \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
S          break;                                              \
S        default:                                              \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;     \
S          break;                                              \
S       }                                                      \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART2)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART3)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART4)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else                                                      \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;         \
S    }                                                         \
S  } while(0)   
X#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)   do {                                                            if((__HANDLE__)->Instance == USART1)                          {                                                                switch(__HAL_RCC_GET_USART1_SOURCE())                         {                                                              case RCC_USART1CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART1CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART1CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART1CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;               break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART2)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART3)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART4)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else                                                          {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;             }                                                           } while(0)   
S#elif defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)
X#elif 0L || 0L || 0L
S#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__) \
S  do {                                                        \
S    if((__HANDLE__)->Instance == USART1)                      \
S    {                                                         \
S       switch(__HAL_RCC_GET_USART1_SOURCE())                  \
S       {                                                      \
S        case RCC_USART1CLKSOURCE_PCLK1:                       \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_HSI:                         \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_SYSCLK:                      \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_LSE:                         \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
S          break;                                              \
S        default:                                              \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;     \
S          break;                                              \
S       }                                                      \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART2)                 \
S    {                                                         \
S       switch(__HAL_RCC_GET_USART2_SOURCE())                  \
S       {                                                      \
S        case RCC_USART2CLKSOURCE_PCLK1:                       \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
S          break;                                              \
S        case RCC_USART2CLKSOURCE_HSI:                         \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
S          break;                                              \
S        case RCC_USART2CLKSOURCE_SYSCLK:                      \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
S          break;                                              \
S        case RCC_USART2CLKSOURCE_LSE:                         \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
S          break;                                              \
S        default:                                              \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;     \
S          break;                                              \
S       }                                                      \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART3)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART4)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else                                                      \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;         \
S    }                                                         \
S  } while(0)   
X#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)   do {                                                            if((__HANDLE__)->Instance == USART1)                          {                                                                switch(__HAL_RCC_GET_USART1_SOURCE())                         {                                                              case RCC_USART1CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART1CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART1CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART1CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;               break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART2)                     {                                                                switch(__HAL_RCC_GET_USART2_SOURCE())                         {                                                              case RCC_USART2CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART2CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART2CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART2CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;               break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART3)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART4)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else                                                          {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;             }                                                           } while(0)   
N#elif defined(STM32F091xC) || defined (STM32F098xx)
X#elif 1L || 0L
N#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__) \
N  do {                                                        \
N    if((__HANDLE__)->Instance == USART1)                      \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART1_SOURCE())                  \
N       {                                                      \
N        case RCC_USART1CLKSOURCE_PCLK1:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_USART1CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART1CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART1CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;     \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART2)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART2_SOURCE())                  \
N       {                                                      \
N        case RCC_USART2CLKSOURCE_PCLK1:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_USART2CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART2CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART2CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;     \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART3)                 \
N    {                                                         \
N       switch(__HAL_RCC_GET_USART3_SOURCE())                  \
N       {                                                      \
N        case RCC_USART3CLKSOURCE_PCLK1:                       \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
N          break;                                              \
N        case RCC_USART3CLKSOURCE_HSI:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
N          break;                                              \
N        case RCC_USART3CLKSOURCE_SYSCLK:                      \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
N          break;                                              \
N        case RCC_USART3CLKSOURCE_LSE:                         \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
N          break;                                              \
N        default:                                              \
N          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;     \
N          break;                                              \
N       }                                                      \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART4)                 \
N    {                                                         \
N      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART5)                 \
N    {                                                         \
N      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART6)                 \
N    {                                                         \
N      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART7)                 \
N    {                                                         \
N      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
N    }                                                         \
N    else if((__HANDLE__)->Instance == USART8)                 \
N    {                                                         \
N      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
N    }                                                         \
N    else                                                      \
N    {                                                         \
N      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;         \
N    }                                                         \
N  } while(0)
X#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)   do {                                                            if((__HANDLE__)->Instance == USART1)                          {                                                                switch(__HAL_RCC_GET_USART1_SOURCE())                         {                                                              case RCC_USART1CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART1CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART1CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART1CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;               break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART2)                     {                                                                switch(__HAL_RCC_GET_USART2_SOURCE())                         {                                                              case RCC_USART2CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART2CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART2CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART2CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;               break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART3)                     {                                                                switch(__HAL_RCC_GET_USART3_SOURCE())                         {                                                              case RCC_USART3CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART3CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART3CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART3CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;               break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART4)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART5)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART6)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART7)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART8)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else                                                          {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;             }                                                           } while(0)
N#elif defined(STM32F030xC)
S#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__) \
S  do {                                                        \
S    if((__HANDLE__)->Instance == USART1)                      \
S    {                                                         \
S       switch(__HAL_RCC_GET_USART1_SOURCE())                  \
S       {                                                      \
S        case RCC_USART1CLKSOURCE_PCLK1:                       \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;         \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_HSI:                         \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;           \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_SYSCLK:                      \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;        \
S          break;                                              \
S        case RCC_USART1CLKSOURCE_LSE:                         \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;           \
S          break;                                              \
S        default:                                              \
S          (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;     \
S          break;                                              \
S       }                                                      \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART2)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART3)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART4)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART5)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else if((__HANDLE__)->Instance == USART6)                 \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;             \
S    }                                                         \
S    else                                                      \
S    {                                                         \
S      (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;         \
S    }                                                         \
S  } while(0)
X#define UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)   do {                                                            if((__HANDLE__)->Instance == USART1)                          {                                                                switch(__HAL_RCC_GET_USART1_SOURCE())                         {                                                              case RCC_USART1CLKSOURCE_PCLK1:                                 (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                   break;                                                      case RCC_USART1CLKSOURCE_HSI:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI;                     break;                                                      case RCC_USART1CLKSOURCE_SYSCLK:                                (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK;                  break;                                                      case RCC_USART1CLKSOURCE_LSE:                                   (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE;                     break;                                                      default:                                                        (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;               break;                                                     }                                                          }                                                             else if((__HANDLE__)->Instance == USART2)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART3)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART4)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART5)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else if((__HANDLE__)->Instance == USART6)                     {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1;                 }                                                             else                                                          {                                                               (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED;             }                                                           } while(0)
S  
N#endif /* defined(STM32F030x6) || defined(STM32F031x6) || defined(STM32F038xx) */
N  
N
N/** @brief  Compute the UART mask to apply to retrieve the received data
N  *         according to the word length and to the parity bits activation.
N  * @note   If PCE = 1, the parity bit is not included in the data extracted
N  *         by the reception API().
N  *         This masking operation is not carried out in the case of
N  *         DMA transfers.
N  * @param  __HANDLE__ specifies the UART Handle.
N  * @retval None, the mask to apply to UART RDR register is stored in (__HANDLE__)->Mask field.
N  */
N#if defined (STM32F042x6) || defined (STM32F048xx) || defined (STM32F070x6) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || defined (STM32F070xB) || \
N    defined (STM32F091xC) || defined (STM32F098xx) || defined (STM32F030xC)
X#if 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     1L || 0L || 0L
N#define UART_MASK_COMPUTATION(__HANDLE__)                             \
N  do {                                                                \
N  if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_9B)            \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)               \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x01FFU;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x00FFU;                                 \
N     }                                                                \
N  }                                                                   \
N  else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_8B)       \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)               \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x00FFU;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x007FU;                                 \
N     }                                                                \
N  }                                                                   \
N  else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_7B)       \
N  {                                                                   \
N     if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)               \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x007FU;                                 \
N     }                                                                \
N     else                                                             \
N     {                                                                \
N        (__HANDLE__)->Mask = 0x003FU;                                 \
N     }                                                                \
N  }                                                                   \
N} while(0)
X#define UART_MASK_COMPUTATION(__HANDLE__)                               do {                                                                  if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_9B)              {                                                                        if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x01FFU;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x00FFU;                                      }                                                                  }                                                                     else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_8B)         {                                                                        if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x00FFU;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x007FU;                                      }                                                                  }                                                                     else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_7B)         {                                                                        if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x007FU;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x003FU;                                      }                                                                  }                                                                   } while(0)
N#else
S#define UART_MASK_COMPUTATION(__HANDLE__)                             \
S  do {                                                                \
S  if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_9B)            \
S  {                                                                   \
S     if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)               \
S     {                                                                \
S        (__HANDLE__)->Mask = 0x01FFU;                                 \
S     }                                                                \
S     else                                                             \
S     {                                                                \
S        (__HANDLE__)->Mask = 0x00FFU;                                 \
S     }                                                                \
S  }                                                                   \
S  else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_8B)       \
S  {                                                                   \
S     if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)               \
S     {                                                                \
S        (__HANDLE__)->Mask = 0x00FFU;                                 \
S     }                                                                \
S     else                                                             \
S     {                                                                \
S        (__HANDLE__)->Mask = 0x007FU;                                 \
S     }                                                                \
S  }                                                                   \
S} while(0) 
X#define UART_MASK_COMPUTATION(__HANDLE__)                               do {                                                                  if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_9B)              {                                                                        if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x01FFU;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x00FFU;                                      }                                                                  }                                                                     else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_8B)         {                                                                        if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE)                    {                                                                        (__HANDLE__)->Mask = 0x00FFU;                                      }                                                                     else                                                                  {                                                                        (__HANDLE__)->Mask = 0x007FU;                                      }                                                                  }                                                                   } while(0) 
N#endif /* defined (STM32F042x6) || defined (STM32F048xx) || defined (STM32F070x6) || \
N          defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || defined (STM32F070xB) || \
N          defined (STM32F091xC) || defined (STM32F098xx) || defined (STM32F030xC)  */
X#endif  
N
N/**
N  * @brief Ensure that UART frame length is valid.
N  * @param __LENGTH__ UART frame length. 
N  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
N  */
N#if defined (STM32F042x6) || defined (STM32F048xx) || defined (STM32F070x6) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || defined (STM32F070xB) || \
N    defined (STM32F091xC) || defined (STM32F098xx) || defined (STM32F030xC)
X#if 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     1L || 0L || 0L
N#define IS_UART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == UART_WORDLENGTH_7B) || \
N                                         ((__LENGTH__) == UART_WORDLENGTH_8B) || \
N                                         ((__LENGTH__) == UART_WORDLENGTH_9B))
X#define IS_UART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == UART_WORDLENGTH_7B) ||                                          ((__LENGTH__) == UART_WORDLENGTH_8B) ||                                          ((__LENGTH__) == UART_WORDLENGTH_9B))
N#else
S#define IS_UART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == UART_WORDLENGTH_8B) || \
S                                         ((__LENGTH__) == UART_WORDLENGTH_9B))
X#define IS_UART_WORD_LENGTH(__LENGTH__) (((__LENGTH__) == UART_WORDLENGTH_8B) ||                                          ((__LENGTH__) == UART_WORDLENGTH_9B))
N#endif /* defined (STM32F042x6) || defined (STM32F048xx) || defined (STM32F070x6) || \
N          defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || defined (STM32F070xB) || \
N          defined (STM32F091xC) || defined (STM32F098xx) || defined (STM32F030xC) */
X#endif  
N
N/**
N  * @brief Ensure that UART auto Baud rate detection mode is valid.
N  * @param __MODE__ UART auto Baud rate detection mode. 
N  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
N  */
N#if defined (STM32F042x6) || defined (STM32F048xx) || defined (STM32F070x6) || \
N    defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || defined (STM32F070xB) || \
N    defined (STM32F091xC) || defined (STM32F098xx) || defined (STM32F030xC)
X#if 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     1L || 0L || 0L
N#define IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(__MODE__)  (((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT)    || \
N                                                        ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE) || \
N                                                        ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAME)   || \
N                                                        ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAME))
X#define IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(__MODE__)  (((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT)    ||                                                         ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE) ||                                                         ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAME)   ||                                                         ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAME))
N#else
S#define IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(__MODE__)  (((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT)    || \
S                                                        ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE))
X#define IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(__MODE__)  (((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT)    ||                                                         ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE))
N#endif /* defined (STM32F042x6) || defined (STM32F048xx) || defined (STM32F070x6) || \
N          defined (STM32F071xB) || defined (STM32F072xB) || defined (STM32F078xx) || defined (STM32F070xB) || \
N          defined (STM32F091xC) || defined (STM32F098xx) || defined (STM32F030xC) */
X#endif  
N
N
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L  && !0L  && !0L
N/**
N  * @brief Ensure that UART LIN state is valid.
N  * @param __LIN__ UART LIN state. 
N  * @retval SET (__LIN__ is valid) or RESET (__LIN__ is invalid)
N  */
N#define IS_UART_LIN(__LIN__)        (((__LIN__) == UART_LIN_DISABLE) || \
N                                     ((__LIN__) == UART_LIN_ENABLE))
X#define IS_UART_LIN(__LIN__)        (((__LIN__) == UART_LIN_DISABLE) ||                                      ((__LIN__) == UART_LIN_ENABLE))
N
N/**
N  * @brief Ensure that UART LIN break detection length is valid.
N  * @param __LENGTH__ UART LIN break detection length. 
N  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
N  */
N#define IS_UART_LIN_BREAK_DETECT_LENGTH(__LENGTH__) (((__LENGTH__) == UART_LINBREAKDETECTLENGTH_10B) || \
N                                                     ((__LENGTH__) == UART_LINBREAKDETECTLENGTH_11B))
X#define IS_UART_LIN_BREAK_DETECT_LENGTH(__LENGTH__) (((__LENGTH__) == UART_LINBREAKDETECTLENGTH_10B) ||                                                      ((__LENGTH__) == UART_LINBREAKDETECTLENGTH_11B))
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */  
N
N/**
N  * @brief Ensure that UART request parameter is valid.
N  * @param __PARAM__ UART request parameter. 
N  * @retval SET (__PARAM__ is valid) or RESET (__PARAM__ is invalid)
N  */
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L  && !0L  && !0L
N#define IS_UART_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == UART_AUTOBAUD_REQUEST)     || \
N                                              ((__PARAM__) == UART_SENDBREAK_REQUEST)    || \
N                                              ((__PARAM__) == UART_MUTE_MODE_REQUEST)    || \
N                                              ((__PARAM__) == UART_RXDATA_FLUSH_REQUEST) || \
N                                              ((__PARAM__) == UART_TXDATA_FLUSH_REQUEST))
X#define IS_UART_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == UART_AUTOBAUD_REQUEST)     ||                                               ((__PARAM__) == UART_SENDBREAK_REQUEST)    ||                                               ((__PARAM__) == UART_MUTE_MODE_REQUEST)    ||                                               ((__PARAM__) == UART_RXDATA_FLUSH_REQUEST) ||                                               ((__PARAM__) == UART_TXDATA_FLUSH_REQUEST))
N#else
S#define IS_UART_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == UART_AUTOBAUD_REQUEST)     || \
S                                              ((__PARAM__) == UART_SENDBREAK_REQUEST)    || \
S                                              ((__PARAM__) == UART_MUTE_MODE_REQUEST)    || \
S                                              ((__PARAM__) == UART_RXDATA_FLUSH_REQUEST))
X#define IS_UART_REQUEST_PARAMETER(__PARAM__) (((__PARAM__) == UART_AUTOBAUD_REQUEST)     ||                                               ((__PARAM__) == UART_SENDBREAK_REQUEST)    ||                                               ((__PARAM__) == UART_MUTE_MODE_REQUEST)    ||                                               ((__PARAM__) == UART_RXDATA_FLUSH_REQUEST))
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6)  && !defined(STM32F070xB)  && !defined(STM32F030xC) */  
N
N#if !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6) && !defined(STM32F070xB)  && !defined(STM32F030xC)
X#if !0L && !0L && !0L && !0L  && !0L
N/**
N  * @brief Ensure that UART stop mode state is valid.
N  * @param __STOPMODE__ UART stop mode state. 
N  * @retval SET (__STOPMODE__ is valid) or RESET (__STOPMODE__ is invalid)
N  */
N#define IS_UART_ADVFEATURE_STOPMODE(__STOPMODE__) (((__STOPMODE__) == UART_ADVFEATURE_STOPMODE_DISABLE) || \
N                                                   ((__STOPMODE__) == UART_ADVFEATURE_STOPMODE_ENABLE))
X#define IS_UART_ADVFEATURE_STOPMODE(__STOPMODE__) (((__STOPMODE__) == UART_ADVFEATURE_STOPMODE_DISABLE) ||                                                    ((__STOPMODE__) == UART_ADVFEATURE_STOPMODE_ENABLE))
N
N/**
N  * @brief Ensure that UART wake-up selection is valid.
N  * @param __WAKE__ UART wake-up selection. 
N  * @retval SET (__WAKE__ is valid) or RESET (__WAKE__ is invalid)
N  */
N#define IS_UART_WAKEUP_SELECTION(__WAKE__) (((__WAKE__) == UART_WAKEUP_ON_ADDRESS) || \
N                                            ((__WAKE__) == UART_WAKEUP_ON_STARTBIT) || \
N                                            ((__WAKE__) == UART_WAKEUP_ON_READDATA_NONEMPTY))
X#define IS_UART_WAKEUP_SELECTION(__WAKE__) (((__WAKE__) == UART_WAKEUP_ON_ADDRESS) ||                                             ((__WAKE__) == UART_WAKEUP_ON_STARTBIT) ||                                             ((__WAKE__) == UART_WAKEUP_ON_READDATA_NONEMPTY))
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8) && !defined(STM32F070x6) && !defined(STM32F070xB) && !defined(STM32F030xC) */   
N  
N/**
N  * @}
N  */
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup UARTEx_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup UARTEx_Exported_Functions_Group1
N  * @brief    Extended Initialization and Configuration Functions
N  * @{
N  */
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime, uint32_t DeassertionTime);
N#if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
X#if !0L && !0L&& !0L&& !0L&& !0L
NHAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength);
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */ 
N/**
N  * @}
N  */
N
N/** @addtogroup UARTEx_Exported_Functions_Group2
N  * @brief    Extended UART Interrupt handling function
N  * @{
N  */
N
N/* IO operation functions  ***************************************************/
N#if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
X#if !0L && !0L&& !0L&& !0L&& !0L
Nvoid HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart);
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */ 
N/**
N  * @}
N  */
N
N/** @addtogroup UARTEx_Exported_Functions_Group3
N  * @brief    Extended Peripheral Control functions
N  * @{
N  */
N
N/* Peripheral Control functions  **********************************************/
NHAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength);
N#if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6) && !defined(STM32F030xC)
X#if !0L && !0L&& !0L&& !0L && !0L
NHAL_StatusTypeDef HAL_UARTEx_StopModeWakeUpSourceConfig(UART_HandleTypeDef *huart, UART_WakeUpTypeDef WakeUpSelection);
NHAL_StatusTypeDef HAL_UARTEx_EnableStopMode(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UARTEx_DisableStopMode(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart);
N#endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */ 
N/**
N  * @}
N  */
N/* Peripheral State functions  ************************************************/
N
N/**
N  * @}
N  */
N
N/* Private functions ---------------------------------------------------------*/
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_UART_EX_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 1271 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_uart.h" 2
N
N/* Exported functions --------------------------------------------------------*/
N/** @addtogroup UART_Exported_Functions UART Exported Functions
N  * @{
N  */
N
N/** @addtogroup UART_Exported_Functions_Group1 Initialization and de-initialization functions
N  * @{
N  */
N
N/* Initialization and de-initialization functions  ****************************/
NHAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod);
NHAL_StatusTypeDef HAL_UART_DeInit (UART_HandleTypeDef *huart);
Nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart);
Nvoid HAL_UART_MspDeInit(UART_HandleTypeDef *huart);
N
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group2 IO operation functions
N  * @{
N  */
N
N/* IO operation functions *****************************************************/
NHAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
NHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
NHAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart);
N/* Transfer Abort functions */
NHAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart);
N
Nvoid HAL_UART_IRQHandler(UART_HandleTypeDef *huart);
Nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_ErrorCallback(UART_HandleTypeDef *huart);
Nvoid HAL_UART_AbortCpltCallback (UART_HandleTypeDef *huart);
Nvoid HAL_UART_AbortTransmitCpltCallback (UART_HandleTypeDef *huart);
Nvoid HAL_UART_AbortReceiveCpltCallback (UART_HandleTypeDef *huart);
N
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group3 Peripheral Control functions
N  * @{
N  */
N
N/* Peripheral Control functions  ************************************************/
NHAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart);
Nvoid HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart);
N
N/**
N  * @}
N  */
N
N/** @addtogroup UART_Exported_Functions_Group4 Peripheral State and Error functions
N  * @{
N  */
N
N/* Peripheral State and Errors functions  **************************************************/
NHAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart);
Nuint32_t              HAL_UART_GetError(UART_HandleTypeDef *huart);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Private functions -----------------------------------------------------------*/
N/** @addtogroup UART_Private_Functions UART Private Functions
N  * @{
N  */
Nvoid UART_AdvFeatureConfig(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
NHAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout);
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_UART_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
N
L 290 "../Inc/stm32f0xx_hal_conf.h" 2
N#endif /* HAL_UART_MODULE_ENABLED */
N
N#ifdef HAL_USART_MODULE_ENABLED
S #include "stm32f0xx_hal_usart.h"
N#endif /* HAL_USART_MODULE_ENABLED */
N
N#ifdef HAL_WWDG_MODULE_ENABLED
S #include "stm32f0xx_hal_wwdg.h"
N#endif /* HAL_WWDG_MODULE_ENABLED */
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr: If expr is false, it calls assert_failed function
S  *         which reports the name of the source file and the source
S  *         line number of the call that failed. 
S  *         If expr is true, it returns no value.
S  * @retval None
S  */
S  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((char *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(char* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0U)
N#endif /* USE_FULL_ASSERT */    
N    
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_CONF_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 47 "../Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal.h" 2
N
N/** @addtogroup STM32F0xx_HAL_Driver
N  * @{
N  */
N
N/** @addtogroup HAL
N  * @{
N  */ 
N
N/* Private macros ------------------------------------------------------------*/
N/** @addtogroup HAL_Private_Macros
N  * @{
N  */
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F042x6) || defined(STM32F048xx) || \
N    defined(STM32F030x6) || defined(STM32F031x6) || defined(STM32F038xx) || defined(STM32F070x6) || \
N    defined(STM32F070xB) || defined(STM32F030x6)
X#if 1L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L
N#define IS_SYSCFG_FASTMODEPLUS(__PIN__) ((((__PIN__) & SYSCFG_FASTMODEPLUS_PA9)  == SYSCFG_FASTMODEPLUS_PA9)  || \
N                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PA10) == SYSCFG_FASTMODEPLUS_PA10) || \
N                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB6)  == SYSCFG_FASTMODEPLUS_PB6)  || \
N                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB7)  == SYSCFG_FASTMODEPLUS_PB7)  || \
N                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB8)  == SYSCFG_FASTMODEPLUS_PB8)  || \
N                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB9)  == SYSCFG_FASTMODEPLUS_PB9))
X#define IS_SYSCFG_FASTMODEPLUS(__PIN__) ((((__PIN__) & SYSCFG_FASTMODEPLUS_PA9)  == SYSCFG_FASTMODEPLUS_PA9)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PA10) == SYSCFG_FASTMODEPLUS_PA10) ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB6)  == SYSCFG_FASTMODEPLUS_PB6)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB7)  == SYSCFG_FASTMODEPLUS_PB7)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB8)  == SYSCFG_FASTMODEPLUS_PB8)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB9)  == SYSCFG_FASTMODEPLUS_PB9))
N#else
S#define IS_SYSCFG_FASTMODEPLUS(__PIN__) ((((__PIN__) & SYSCFG_FASTMODEPLUS_PB6)  == SYSCFG_FASTMODEPLUS_PB6)  || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB7)  == SYSCFG_FASTMODEPLUS_PB7)  || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB8)  == SYSCFG_FASTMODEPLUS_PB8)  || \
S                                         (((__PIN__) & SYSCFG_FASTMODEPLUS_PB9)  == SYSCFG_FASTMODEPLUS_PB9))
X#define IS_SYSCFG_FASTMODEPLUS(__PIN__) ((((__PIN__) & SYSCFG_FASTMODEPLUS_PB6)  == SYSCFG_FASTMODEPLUS_PB6)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB7)  == SYSCFG_FASTMODEPLUS_PB7)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB8)  == SYSCFG_FASTMODEPLUS_PB8)  ||                                          (((__PIN__) & SYSCFG_FASTMODEPLUS_PB9)  == SYSCFG_FASTMODEPLUS_PB9))
N#endif
N#if defined(SYSCFG_CFGR1_PA11_PA12_RMP)
X#if 0L
S#define IS_HAL_REMAP_PIN(RMP) ((RMP) == HAL_REMAP_PA11_PA12)
N#endif /* SYSCFG_CFGR1_PA11_PA12_RMP */
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N#define IS_HAL_SYSCFG_IRDA_ENV_SEL(SEL)   (((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_TIM16)   || \
N                                           ((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_USART1)   || \
N                                           ((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_USART4))
X#define IS_HAL_SYSCFG_IRDA_ENV_SEL(SEL)   (((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_TIM16)   ||                                            ((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_USART1)   ||                                            ((SEL) == HAL_SYSCFG_IRDA_ENV_SEL_USART4))
N#endif /* STM32F091xC || STM32F098xx */
N/**
N  * @}
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup HAL_Exported_Constants HAL Exported Constants
N  * @{
N  */
N   
N#if defined(SYSCFG_CFGR1_PA11_PA12_RMP)
X#if 0L
S/** @defgroup HAL_Pin_remapping HAL Pin remapping
S  * @{
S  */
S#define HAL_REMAP_PA11_PA12                 (SYSCFG_CFGR1_PA11_PA12_RMP)  /*!< PA11 and PA12 remapping bit for small packages (28 and 20 pins).
S                                                                           0: No remap (pin pair PA9/10 mapped on the pins)
S                                                                           1: Remap (pin pair PA11/12 mapped instead of PA9/10) */
S
S/**
S  * @}
S  */
N#endif /* SYSCFG_CFGR1_PA11_PA12_RMP */
N
N#if defined(STM32F091xC) || defined(STM32F098xx)
X#if 1L || 0L
N/** @defgroup HAL_IRDA_ENV_SEL HAL IRDA Enveloppe Selection
N  * @note Applicable on STM32F09x
N  * @{
N  */
N#define HAL_SYSCFG_IRDA_ENV_SEL_TIM16     (SYSCFG_CFGR1_IRDA_ENV_SEL_0 & SYSCFG_CFGR1_IRDA_ENV_SEL_1)    /* 00: Timer16 is selected as IRDA Modulation enveloppe source */
N#define HAL_SYSCFG_IRDA_ENV_SEL_USART1    (SYSCFG_CFGR1_IRDA_ENV_SEL_0)  /* 01: USART1 is selected as IRDA Modulation enveloppe source */
N#define HAL_SYSCFG_IRDA_ENV_SEL_USART4    (SYSCFG_CFGR1_IRDA_ENV_SEL_1)  /* 10: USART4 is selected as IRDA Modulation enveloppe source */
N
N/**
N  * @}
N  */
N#endif /* STM32F091xC || STM32F098xx */
N
N
N/** @defgroup SYSCFG_FastModePlus_GPIO Fast-mode Plus on GPIO
N  * @{
N  */
N
N/** @brief  Fast-mode Plus driving capability on a specific GPIO
N  */  
N#if defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F042x6) || defined(STM32F048xx) || \
N    defined(STM32F030x6) || defined(STM32F031x6) || defined(STM32F038xx) || defined(STM32F070x6) || \
N    defined(STM32F070xB) || defined(STM32F030x6)
X#if 1L || 0L || 0L || 0L ||     0L || 0L || 0L || 0L ||     0L || 0L
N#define SYSCFG_FASTMODEPLUS_PA9        SYSCFG_CFGR1_I2C_FMP_PA9  /*!< Enable Fast-mode Plus on PA9  */
N#define SYSCFG_FASTMODEPLUS_PA10       SYSCFG_CFGR1_I2C_FMP_PA10 /*!< Enable Fast-mode Plus on PA10 */
N#endif
N#define SYSCFG_FASTMODEPLUS_PB6        SYSCFG_CFGR1_I2C_FMP_PB6  /*!< Enable Fast-mode Plus on PB6  */
N#define SYSCFG_FASTMODEPLUS_PB7        SYSCFG_CFGR1_I2C_FMP_PB7  /*!< Enable Fast-mode Plus on PB7  */
N#define SYSCFG_FASTMODEPLUS_PB8        SYSCFG_CFGR1_I2C_FMP_PB8  /*!< Enable Fast-mode Plus on PB8  */
N#define SYSCFG_FASTMODEPLUS_PB9        SYSCFG_CFGR1_I2C_FMP_PB9  /*!< Enable Fast-mode Plus on PB9  */
N
N/**
N * @}
N */
N
N
N#if defined(STM32F091xC) || defined (STM32F098xx)
X#if 1L || 0L
N/** @defgroup HAL_ISR_Wrapper HAL ISR Wrapper
N  * @brief ISR Wrapper
N  * @note applicable on STM32F09x
N  * @{
N  */
N#define HAL_SYSCFG_ITLINE0                           ( 0x00000000U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE1                           ( 0x00000001U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE2                           ( 0x00000002U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE3                           ( 0x00000003U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE4                           ( 0x00000004U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE5                           ( 0x00000005U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE6                           ( 0x00000006U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE7                           ( 0x00000007U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE8                           ( 0x00000008U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE9                           ( 0x00000009U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE10                          ( 0x0000000AU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE11                          ( 0x0000000BU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE12                          ( 0x0000000CU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE13                          ( 0x0000000DU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE14                          ( 0x0000000EU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE15                          ( 0x0000000FU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE16                          ( 0x00000010U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE17                          ( 0x00000011U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE18                          ( 0x00000012U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE19                          ( 0x00000013U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE20                          ( 0x00000014U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE21                          ( 0x00000015U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE22                          ( 0x00000016U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE23                          ( 0x00000017U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE24                          ( 0x00000018U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE25                          ( 0x00000019U) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE26                          ( 0x0000001AU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE27                          ( 0x0000001BU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE28                          ( 0x0000001CU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE29                          ( 0x0000001DU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE30                          ( 0x0000001EU) /*!< Internal define for macro handling */
N#define HAL_SYSCFG_ITLINE31                          ( 0x0000001FU) /*!< Internal define for macro handling */
N
N#define HAL_ITLINE_EWDG           ((uint32_t) ((HAL_SYSCFG_ITLINE0 << 0x18U) | SYSCFG_ITLINE0_SR_EWDG)) /*!< EWDG has expired .... */
N#if defined(STM32F091xC)
X#if 1L
N#define HAL_ITLINE_PVDOUT         ((uint32_t) ((HAL_SYSCFG_ITLINE1 << 0x18U) | SYSCFG_ITLINE1_SR_PVDOUT)) /*!< Power voltage detection Interrupt .... */
N#endif
N#define HAL_ITLINE_VDDIO2         ((uint32_t) ((HAL_SYSCFG_ITLINE1 << 0x18U) | SYSCFG_ITLINE1_SR_VDDIO2)) /*!< VDDIO2 Interrupt .... */
N#define HAL_ITLINE_RTC_WAKEUP     ((uint32_t) ((HAL_SYSCFG_ITLINE2 << 0x18U) | SYSCFG_ITLINE2_SR_RTC_WAKEUP)) /*!< RTC WAKEUP -> exti[20] Interrupt */
N#define HAL_ITLINE_RTC_TSTAMP     ((uint32_t) ((HAL_SYSCFG_ITLINE2 << 0x18U) | SYSCFG_ITLINE2_SR_RTC_TSTAMP)) /*!< RTC Time Stamp -> exti[19] interrupt */
N#define HAL_ITLINE_RTC_ALRA       ((uint32_t) ((HAL_SYSCFG_ITLINE2 << 0x18U) | SYSCFG_ITLINE2_SR_RTC_ALRA)) /*!< RTC Alarm -> exti[17] interrupt .... */
N#define HAL_ITLINE_FLASH_ITF      ((uint32_t) ((HAL_SYSCFG_ITLINE3 << 0x18U) | SYSCFG_ITLINE3_SR_FLASH_ITF)) /*!< Flash ITF Interrupt */
N#define HAL_ITLINE_CRS            ((uint32_t) ((HAL_SYSCFG_ITLINE4 << 0x18U) | SYSCFG_ITLINE4_SR_CRS)) /*!< CRS Interrupt */
N#define HAL_ITLINE_CLK_CTRL       ((uint32_t) ((HAL_SYSCFG_ITLINE4 << 0x18U) | SYSCFG_ITLINE4_SR_CLK_CTRL)) /*!< CLK Control Interrupt */
N#define HAL_ITLINE_EXTI0          ((uint32_t) ((HAL_SYSCFG_ITLINE5 << 0x18U) | SYSCFG_ITLINE5_SR_EXTI0)) /*!< External Interrupt 0 */
N#define HAL_ITLINE_EXTI1          ((uint32_t) ((HAL_SYSCFG_ITLINE5 << 0x18U) | SYSCFG_ITLINE5_SR_EXTI1)) /*!< External Interrupt 1 */
N#define HAL_ITLINE_EXTI2          ((uint32_t) ((HAL_SYSCFG_ITLINE6 << 0x18U) | SYSCFG_ITLINE6_SR_EXTI2)) /*!< External Interrupt 2 */
N#define HAL_ITLINE_EXTI3          ((uint32_t) ((HAL_SYSCFG_ITLINE6 << 0x18U) | SYSCFG_ITLINE6_SR_EXTI3)) /*!< External Interrupt 3 */
N#define HAL_ITLINE_EXTI4          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI4)) /*!< EXTI4 Interrupt */
N#define HAL_ITLINE_EXTI5          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI5)) /*!< EXTI5 Interrupt */
N#define HAL_ITLINE_EXTI6          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI6)) /*!< EXTI6 Interrupt */
N#define HAL_ITLINE_EXTI7          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI7)) /*!< EXTI7 Interrupt */
N#define HAL_ITLINE_EXTI8          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI8)) /*!< EXTI8 Interrupt */
N#define HAL_ITLINE_EXTI9          ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI9)) /*!< EXTI9 Interrupt */
N#define HAL_ITLINE_EXTI10         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI10)) /*!< EXTI10 Interrupt */
N#define HAL_ITLINE_EXTI11         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI11)) /*!< EXTI11 Interrupt */
N#define HAL_ITLINE_EXTI12         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI12)) /*!< EXTI12 Interrupt */
N#define HAL_ITLINE_EXTI13         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI13)) /*!< EXTI13 Interrupt */
N#define HAL_ITLINE_EXTI14         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI14)) /*!< EXTI14 Interrupt */
N#define HAL_ITLINE_EXTI15         ((uint32_t) ((HAL_SYSCFG_ITLINE7 << 0x18U) | SYSCFG_ITLINE7_SR_EXTI15)) /*!< EXTI15 Interrupt */
N#define HAL_ITLINE_TSC_EOA        ((uint32_t) ((HAL_SYSCFG_ITLINE8 << 0x18U) | SYSCFG_ITLINE8_SR_TSC_EOA)) /*!< Touch control EOA Interrupt */
N#define HAL_ITLINE_TSC_MCE        ((uint32_t) ((HAL_SYSCFG_ITLINE8 << 0x18U) | SYSCFG_ITLINE8_SR_TSC_MCE)) /*!< Touch control MCE Interrupt */
N#define HAL_ITLINE_DMA1_CH1       ((uint32_t) ((HAL_SYSCFG_ITLINE9 << 0x18U) | SYSCFG_ITLINE9_SR_DMA1_CH1)) /*!< DMA1 Channel 1 Interrupt */
N#define HAL_ITLINE_DMA1_CH2       ((uint32_t) ((HAL_SYSCFG_ITLINE10 << 0x18U) | SYSCFG_ITLINE10_SR_DMA1_CH2)) /*!< DMA1 Channel 2 Interrupt */
N#define HAL_ITLINE_DMA1_CH3       ((uint32_t) ((HAL_SYSCFG_ITLINE10 << 0x18U) | SYSCFG_ITLINE10_SR_DMA1_CH3)) /*!< DMA1 Channel 3 Interrupt */
N#define HAL_ITLINE_DMA2_CH1       ((uint32_t) ((HAL_SYSCFG_ITLINE10 << 0x18U) | SYSCFG_ITLINE10_SR_DMA2_CH1)) /*!< DMA2 Channel 1 Interrupt */
N#define HAL_ITLINE_DMA2_CH2       ((uint32_t) ((HAL_SYSCFG_ITLINE10 << 0x18U) | SYSCFG_ITLINE10_SR_DMA2_CH2)) /*!< DMA2 Channel 2 Interrupt */
N#define HAL_ITLINE_DMA1_CH4       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA1_CH4)) /*!< DMA1 Channel 4 Interrupt */
N#define HAL_ITLINE_DMA1_CH5       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA1_CH5)) /*!< DMA1 Channel 5 Interrupt */
N#define HAL_ITLINE_DMA1_CH6       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA1_CH6)) /*!< DMA1 Channel 6 Interrupt */
N#define HAL_ITLINE_DMA1_CH7       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA1_CH7)) /*!< DMA1 Channel 7 Interrupt */
N#define HAL_ITLINE_DMA2_CH3       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA2_CH3)) /*!< DMA2 Channel 3 Interrupt */
N#define HAL_ITLINE_DMA2_CH4       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA2_CH4)) /*!< DMA2 Channel 4 Interrupt */
N#define HAL_ITLINE_DMA2_CH5       ((uint32_t) ((HAL_SYSCFG_ITLINE11 << 0x18U) | SYSCFG_ITLINE11_SR_DMA2_CH5)) /*!< DMA2 Channel 5 Interrupt */
N#define HAL_ITLINE_ADC            ((uint32_t) ((HAL_SYSCFG_ITLINE12 << 0x18U) | SYSCFG_ITLINE12_SR_ADC)) /*!< ADC Interrupt */
N#define HAL_ITLINE_COMP1          ((uint32_t) ((HAL_SYSCFG_ITLINE12 << 0x18U) | SYSCFG_ITLINE12_SR_COMP1)) /*!< COMP1 Interrupt -> exti[21] */
N#define HAL_ITLINE_COMP2          ((uint32_t) ((HAL_SYSCFG_ITLINE12 << 0x18U) | SYSCFG_ITLINE12_SR_COMP2)) /*!< COMP2 Interrupt -> exti[21] */
N#define HAL_ITLINE_TIM1_BRK       ((uint32_t) ((HAL_SYSCFG_ITLINE13 << 0x18U) | SYSCFG_ITLINE13_SR_TIM1_BRK)) /*!< TIM1 BRK Interrupt */
N#define HAL_ITLINE_TIM1_UPD       ((uint32_t) ((HAL_SYSCFG_ITLINE13 << 0x18U) | SYSCFG_ITLINE13_SR_TIM1_UPD)) /*!< TIM1 UPD Interrupt */
N#define HAL_ITLINE_TIM1_TRG       ((uint32_t) ((HAL_SYSCFG_ITLINE13 << 0x18U) | SYSCFG_ITLINE13_SR_TIM1_TRG)) /*!< TIM1 TRG Interrupt */
N#define HAL_ITLINE_TIM1_CCU       ((uint32_t) ((HAL_SYSCFG_ITLINE13 << 0x18U) | SYSCFG_ITLINE13_SR_TIM1_CCU)) /*!< TIM1 CCU Interrupt */
N#define HAL_ITLINE_TIM1_CC        ((uint32_t) ((HAL_SYSCFG_ITLINE14 << 0x18U) | SYSCFG_ITLINE14_SR_TIM1_CC)) /*!< TIM1 CC Interrupt */
N#define HAL_ITLINE_TIM2           ((uint32_t) ((HAL_SYSCFG_ITLINE15 << 0x18U) | SYSCFG_ITLINE15_SR_TIM2_GLB)) /*!< TIM2 Interrupt */
N#define HAL_ITLINE_TIM3           ((uint32_t) ((HAL_SYSCFG_ITLINE16 << 0x18U) | SYSCFG_ITLINE16_SR_TIM3_GLB)) /*!< TIM3 Interrupt */
N#define HAL_ITLINE_DAC            ((uint32_t) ((HAL_SYSCFG_ITLINE17 << 0x18U) | SYSCFG_ITLINE17_SR_DAC)) /*!< DAC Interrupt */
N#define HAL_ITLINE_TIM6           ((uint32_t) ((HAL_SYSCFG_ITLINE17 << 0x18U) | SYSCFG_ITLINE17_SR_TIM6_GLB)) /*!< TIM6 Interrupt */
N#define HAL_ITLINE_TIM7           ((uint32_t) ((HAL_SYSCFG_ITLINE18 << 0x18U) | SYSCFG_ITLINE18_SR_TIM7_GLB)) /*!< TIM7 Interrupt */
N#define HAL_ITLINE_TIM14          ((uint32_t) ((HAL_SYSCFG_ITLINE19 << 0x18U) | SYSCFG_ITLINE19_SR_TIM14_GLB)) /*!< TIM14 Interrupt */
N#define HAL_ITLINE_TIM15          ((uint32_t) ((HAL_SYSCFG_ITLINE20 << 0x18U) | SYSCFG_ITLINE20_SR_TIM15_GLB)) /*!< TIM15 Interrupt */
N#define HAL_ITLINE_TIM16          ((uint32_t) ((HAL_SYSCFG_ITLINE21 << 0x18U) | SYSCFG_ITLINE21_SR_TIM16_GLB)) /*!< TIM16 Interrupt */
N#define HAL_ITLINE_TIM17          ((uint32_t) ((HAL_SYSCFG_ITLINE22 << 0x18U) | SYSCFG_ITLINE22_SR_TIM17_GLB)) /*!< TIM17 Interrupt */
N#define HAL_ITLINE_I2C1           ((uint32_t) ((HAL_SYSCFG_ITLINE23 << 0x18U) | SYSCFG_ITLINE23_SR_I2C1_GLB)) /*!< I2C1 Interrupt -> exti[23] */
N#define HAL_ITLINE_I2C2           ((uint32_t) ((HAL_SYSCFG_ITLINE24 << 0x18U) | SYSCFG_ITLINE24_SR_I2C2_GLB)) /*!< I2C2 Interrupt */
N#define HAL_ITLINE_SPI1           ((uint32_t) ((HAL_SYSCFG_ITLINE25 << 0x18U) | SYSCFG_ITLINE25_SR_SPI1)) /*!< I2C1 Interrupt -> exti[23] */
N#define HAL_ITLINE_SPI2           ((uint32_t) ((HAL_SYSCFG_ITLINE26 << 0x18U) | SYSCFG_ITLINE26_SR_SPI2)) /*!< SPI1 Interrupt */
N#define HAL_ITLINE_USART1         ((uint32_t) ((HAL_SYSCFG_ITLINE27 << 0x18U) | SYSCFG_ITLINE27_SR_USART1_GLB)) /*!< USART1 GLB Interrupt -> exti[25] */
N#define HAL_ITLINE_USART2         ((uint32_t) ((HAL_SYSCFG_ITLINE28 << 0x18U) | SYSCFG_ITLINE28_SR_USART2_GLB)) /*!< USART2 GLB Interrupt -> exti[26] */
N#define HAL_ITLINE_USART3         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART3_GLB)) /*!< USART3 Interrupt .... */
N#define HAL_ITLINE_USART4         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART4_GLB)) /*!< USART4 Interrupt .... */
N#define HAL_ITLINE_USART5         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART5_GLB)) /*!< USART5 Interrupt .... */
N#define HAL_ITLINE_USART6         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART6_GLB)) /*!< USART6 Interrupt .... */
N#define HAL_ITLINE_USART7         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART7_GLB)) /*!< USART7 Interrupt .... */
N#define HAL_ITLINE_USART8         ((uint32_t) ((HAL_SYSCFG_ITLINE29 << 0x18U) | SYSCFG_ITLINE29_SR_USART8_GLB)) /*!< USART8 Interrupt .... */
N#define HAL_ITLINE_CAN            ((uint32_t) ((HAL_SYSCFG_ITLINE30 << 0x18U) | SYSCFG_ITLINE30_SR_CAN)) /*!< CAN Interrupt */
N#define HAL_ITLINE_CEC            ((uint32_t) ((HAL_SYSCFG_ITLINE30 << 0x18U) | SYSCFG_ITLINE30_SR_CEC)) /*!< CEC Interrupt -> exti[27] */
N/**
N  * @}
N  */
N#endif /* STM32F091xC || STM32F098xx */
N
N/**
N  * @}
N  */  
N
N/* Exported macros -----------------------------------------------------------*/
N/** @defgroup HAL_Exported_Macros HAL Exported Macros
N  * @{  
N  */
N
N/** @defgroup HAL_Freeze_Unfreeze_Peripherals HAL Freeze Unfreeze Peripherals
N  * @brief  Freeze/Unfreeze Peripherals in Debug mode 
N  * @{  
N  */
N  
N#if defined(DBGMCU_APB1_FZ_DBG_CAN_STOP)
X#if 1L
N#define __HAL_FREEZE_CAN_DBGMCU()            (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN_STOP))
N#define __HAL_UNFREEZE_CAN_DBGMCU()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN_STOP))
N#endif /* DBGMCU_APB1_FZ_DBG_CAN_STOP */
N
N#if defined(DBGMCU_APB1_FZ_DBG_RTC_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_RTC()            (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_RTC_STOP))
N#define __HAL_DBGMCU_UNFREEZE_RTC()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_RTC_STOP))
N#endif /* DBGMCU_APB1_FZ_DBG_RTC_STOP */
N
N#if defined(DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_I2C1_TIMEOUT()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
N#define __HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT() (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
N#endif /* DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT */
N
N#if defined(DBGMCU_APB1_FZ_DBG_IWDG_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_IWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_IWDG_STOP))
N#define __HAL_DBGMCU_UNFREEZE_IWDG()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_IWDG_STOP))
N#endif /* DBGMCU_APB1_FZ_DBG_IWDG_STOP */
N
N#if defined(DBGMCU_APB1_FZ_DBG_WWDG_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_WWDG()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_WWDG_STOP))
N#define __HAL_DBGMCU_UNFREEZE_WWDG()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_WWDG_STOP))
N#endif /* DBGMCU_APB1_FZ_DBG_WWDG_STOP */
N
N#if defined(DBGMCU_APB1_FZ_DBG_TIM2_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_TIM2()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM2_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM2()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM2_STOP))
N#endif /* DBGMCU_APB1_FZ_DBG_TIM2_STOP */
N
N#if defined(DBGMCU_APB1_FZ_DBG_TIM3_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_TIM3()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM3_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM3()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM3_STOP))
N#endif /* DBGMCU_APB1_FZ_DBG_TIM3_STOP */
N
N#if defined(DBGMCU_APB1_FZ_DBG_TIM6_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_TIM6()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM6_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM6()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM6_STOP))
N#endif /* DBGMCU_APB1_FZ_DBG_TIM6_STOP */
N
N#if defined(DBGMCU_APB1_FZ_DBG_TIM7_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_TIM7()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM7_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM7()         (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM7_STOP))
N#endif /* DBGMCU_APB1_FZ_DBG_TIM7_STOP */
N
N#if defined(DBGMCU_APB1_FZ_DBG_TIM14_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_TIM14()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM14_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM14()        (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM14_STOP))
N#endif /* DBGMCU_APB1_FZ_DBG_TIM14_STOP */
N
N#if defined(DBGMCU_APB2_FZ_DBG_TIM1_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_TIM1()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM1_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM1()         (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM1_STOP))
N#endif /* DBGMCU_APB2_FZ_DBG_TIM1_STOP */
N
N#if defined(DBGMCU_APB2_FZ_DBG_TIM15_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_TIM15()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM15_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM15()        (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM15_STOP))
N#endif /* DBGMCU_APB2_FZ_DBG_TIM15_STOP */
N
N#if defined(DBGMCU_APB2_FZ_DBG_TIM16_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_TIM16()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM16_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM16()        (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM16_STOP))
N#endif /* DBGMCU_APB2_FZ_DBG_TIM16_STOP */
N
N#if defined(DBGMCU_APB2_FZ_DBG_TIM17_STOP)
X#if 1L
N#define __HAL_DBGMCU_FREEZE_TIM17()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM17_STOP))
N#define __HAL_DBGMCU_UNFREEZE_TIM17()        (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM17_STOP))
N#endif /* DBGMCU_APB2_FZ_DBG_TIM17_STOP */
N
N/**
N  * @}
N  */  
N  
N/** @defgroup Memory_Mapping_Selection Memory Mapping Selection
N  * @{   
N  */
N#if defined(SYSCFG_CFGR1_MEM_MODE)
X#if 1L
N/** @brief  Main Flash memory mapped at 0x00000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_FLASH()        (SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_MEM_MODE))
N#endif /* SYSCFG_CFGR1_MEM_MODE */
N
N#if defined(SYSCFG_CFGR1_MEM_MODE_0)
X#if 1L
N/** @brief  System Flash memory mapped at 0x00000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH()  do {SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_MEM_MODE); \
N                                             SYSCFG->CFGR1 |= SYSCFG_CFGR1_MEM_MODE_0;  \
N                                            }while(0)
X#define __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH()  do {SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_MEM_MODE);                                              SYSCFG->CFGR1 |= SYSCFG_CFGR1_MEM_MODE_0;                                              }while(0)
N#endif /* SYSCFG_CFGR1_MEM_MODE_0 */
N
N#if defined(SYSCFG_CFGR1_MEM_MODE_0) && defined(SYSCFG_CFGR1_MEM_MODE_1)
X#if 1L && 1L
N/** @brief  Embedded SRAM mapped at 0x00000000
N  */
N#define __HAL_SYSCFG_REMAPMEMORY_SRAM()         do {SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_MEM_MODE); \
N                                             SYSCFG->CFGR1 |= (SYSCFG_CFGR1_MEM_MODE_0 | SYSCFG_CFGR1_MEM_MODE_1); \
N                                            }while(0) 
X#define __HAL_SYSCFG_REMAPMEMORY_SRAM()         do {SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_MEM_MODE);                                              SYSCFG->CFGR1 |= (SYSCFG_CFGR1_MEM_MODE_0 | SYSCFG_CFGR1_MEM_MODE_1);                                             }while(0) 
N#endif /* SYSCFG_CFGR1_MEM_MODE_0 && SYSCFG_CFGR1_MEM_MODE_1 */
N/**
N  * @}
N  */ 
N
N
N#if defined(SYSCFG_CFGR1_PA11_PA12_RMP)
X#if 0L
S/** @defgroup HAL_Pin_remap HAL Pin remap 
S  * @brief  Pin remapping enable/disable macros
S  * @param __PIN_REMAP__ This parameter can be a value of @ref HAL_Pin_remapping
S  * @{   
S  */
S#define __HAL_REMAP_PIN_ENABLE(__PIN_REMAP__)          do {assert_param(IS_HAL_REMAP_PIN((__PIN_REMAP__)));                 \
S                                                           SYSCFG->CFGR1 |= (__PIN_REMAP__);                                \
S                                                         }while(0)
X#define __HAL_REMAP_PIN_ENABLE(__PIN_REMAP__)          do {assert_param(IS_HAL_REMAP_PIN((__PIN_REMAP__)));                                                                            SYSCFG->CFGR1 |= (__PIN_REMAP__);                                                                                         }while(0)
S#define __HAL_REMAP_PIN_DISABLE(__PIN_REMAP__)         do {assert_param(IS_HAL_REMAP_PIN((__PIN_REMAP__)));                 \
S                                                           SYSCFG->CFGR1 &= ~(__PIN_REMAP__);                               \
S                                                         }while(0)
X#define __HAL_REMAP_PIN_DISABLE(__PIN_REMAP__)         do {assert_param(IS_HAL_REMAP_PIN((__PIN_REMAP__)));                                                                            SYSCFG->CFGR1 &= ~(__PIN_REMAP__);                                                                                        }while(0)
S/**
S  * @}
S  */  
N#endif /* SYSCFG_CFGR1_PA11_PA12_RMP */
N
N/** @brief  Fast-mode Plus driving capability enable/disable macros
N  * @param __FASTMODEPLUS__ This parameter can be a value of @ref SYSCFG_FastModePlus_GPIO values.
N  *                          That you can find above these macros.
N  */
N#define __HAL_SYSCFG_FASTMODEPLUS_ENABLE(__FASTMODEPLUS__)  do {assert_param(IS_SYSCFG_FASTMODEPLUS((__FASTMODEPLUS__)));\
N                                                                SET_BIT(SYSCFG->CFGR1, (__FASTMODEPLUS__));\
N                                                               }while(0)
X#define __HAL_SYSCFG_FASTMODEPLUS_ENABLE(__FASTMODEPLUS__)  do {assert_param(IS_SYSCFG_FASTMODEPLUS((__FASTMODEPLUS__)));                                                                SET_BIT(SYSCFG->CFGR1, (__FASTMODEPLUS__));                                                               }while(0)
N
N#define __HAL_SYSCFG_FASTMODEPLUS_DISABLE(__FASTMODEPLUS__) do {assert_param(IS_SYSCFG_FASTMODEPLUS((__FASTMODEPLUS__)));\
N                                                                CLEAR_BIT(SYSCFG->CFGR1, (__FASTMODEPLUS__));\
N                                                               }while(0)
X#define __HAL_SYSCFG_FASTMODEPLUS_DISABLE(__FASTMODEPLUS__) do {assert_param(IS_SYSCFG_FASTMODEPLUS((__FASTMODEPLUS__)));                                                                CLEAR_BIT(SYSCFG->CFGR1, (__FASTMODEPLUS__));                                                               }while(0)
N#if defined(SYSCFG_CFGR2_LOCKUP_LOCK)
X#if 1L
N/** @defgroup Cortex_Lockup_Enable Cortex Lockup Enable
N  * @{   
N  */
N/** @brief  SYSCFG Break Lockup lock
N  *         Enables and locks the connection of Cortex-M0 LOCKUP (Hardfault) output to TIM1/15/16/17 Break input
N  * @note   The selected configuration is locked and can be unlocked by system reset
N  */
N#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()   do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_LOCKUP_LOCK); \
N                                               SYSCFG->CFGR2 |= SYSCFG_CFGR2_LOCKUP_LOCK;    \
N                                              }while(0)
X#define __HAL_SYSCFG_BREAK_LOCKUP_LOCK()   do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_LOCKUP_LOCK);                                                SYSCFG->CFGR2 |= SYSCFG_CFGR2_LOCKUP_LOCK;                                                  }while(0)
N/**
N  * @}
N  */  
N#endif /* SYSCFG_CFGR2_LOCKUP_LOCK */
N
N#if defined(SYSCFG_CFGR2_PVD_LOCK)
X#if 1L
N/** @defgroup PVD_Lock_Enable PVD Lock
N  * @{  
N  */
N/** @brief  SYSCFG Break PVD lock
N  *         Enables and locks the PVD connection with Timer1/8/15/16/17 Break Input, , as well as the PVDE and PLS[2:0] in the PWR_CR register
N  * @note   The selected configuration is locked and can be unlocked by system reset
N  */
N#define __HAL_SYSCFG_BREAK_PVD_LOCK()      do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_PVD_LOCK); \
N                                               SYSCFG->CFGR2 |= SYSCFG_CFGR2_PVD_LOCK;    \
N                                              }while(0)
X#define __HAL_SYSCFG_BREAK_PVD_LOCK()      do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_PVD_LOCK);                                                SYSCFG->CFGR2 |= SYSCFG_CFGR2_PVD_LOCK;                                                  }while(0)
N/**
N  * @}
N  */
N#endif /* SYSCFG_CFGR2_PVD_LOCK */
N
N#if defined(SYSCFG_CFGR2_SRAM_PARITY_LOCK)
X#if 1L
N/** @defgroup SRAM_Parity_Lock SRAM Parity Lock
N  * @{
N  */
N/** @brief  SYSCFG Break SRAM PARITY lock
N  *         Enables and locks the SRAM_PARITY error signal with Break Input of TIMER1/8/15/16/17
N  * @note   The selected configuration is locked and can be unlocked by system reset
N  */
N#define __HAL_SYSCFG_BREAK_SRAMPARITY_LOCK() do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_SRAM_PARITY_LOCK); \
N                                                 SYSCFG->CFGR2 |= SYSCFG_CFGR2_SRAM_PARITY_LOCK;    \
N                                                }while(0)
X#define __HAL_SYSCFG_BREAK_SRAMPARITY_LOCK() do {SYSCFG->CFGR2 &= ~(SYSCFG_CFGR2_SRAM_PARITY_LOCK);                                                  SYSCFG->CFGR2 |= SYSCFG_CFGR2_SRAM_PARITY_LOCK;                                                    }while(0)
N/**
N  * @}
N  */
N#endif /* SYSCFG_CFGR2_SRAM_PARITY_LOCK */
N
N#if defined(SYSCFG_CFGR2_SRAM_PEF)
X#if 1L
N/** @defgroup HAL_SYSCFG_Parity_check_on_RAM HAL SYSCFG Parity check on RAM
N  * @brief  Parity check on RAM disable macro
N  * @note   Disabling the parity check on RAM locks the configuration bit.
N  *         To re-enable the parity check on RAM perform a system reset.
N  * @{  
N  */
N#define __HAL_SYSCFG_RAM_PARITYCHECK_DISABLE()   (SYSCFG->CFGR2 |= SYSCFG_CFGR2_SRAM_PEF)
N/**
N  * @}
N  */
N#endif /* SYSCFG_CFGR2_SRAM_PEF */
N
N
N#if defined(STM32F091xC) || defined (STM32F098xx)
X#if 1L || 0L
N/** @defgroup HAL_ISR_wrapper_check HAL ISR wrapper check
N  * @brief  ISR wrapper check
N  * @note This feature is applicable on STM32F09x  
N  * @note Allow to determine interrupt source per line.
N  * @{  
N  */
N#define __HAL_GET_PENDING_IT(__SOURCE__)       (SYSCFG->IT_LINE_SR[((__SOURCE__) >> 0x18U)] & ((__SOURCE__) & 0x00FFFFFF))
N/**
N  * @}
N  */
N#endif /* (STM32F091xC) || defined (STM32F098xx)*/
N
N#if defined(STM32F091xC) || defined (STM32F098xx)
X#if 1L || 0L
N/** @defgroup HAL_SYSCFG_IRDA_modulation_envelope_selection HAL SYSCFG IRDA modulation envelope selection
N  * @brief  selection of the modulation envelope signal macro, using bits [7:6] of SYS_CTRL(CFGR1) register
N  * @note This feature is applicable on STM32F09x
N  * @param __SOURCE__ This parameter can be a value of @ref HAL_IRDA_ENV_SEL
N  * @{  
N  */
N#define __HAL_SYSCFG_IRDA_ENV_SELECTION(__SOURCE__)  do {assert_param(IS_HAL_SYSCFG_IRDA_ENV_SEL((__SOURCE__))); \
N                                                         SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_IRDA_ENV_SEL); \
N                                                         SYSCFG->CFGR1 |= (__SOURCE__);    \
N                                                        }while(0)
X#define __HAL_SYSCFG_IRDA_ENV_SELECTION(__SOURCE__)  do {assert_param(IS_HAL_SYSCFG_IRDA_ENV_SEL((__SOURCE__)));                                                          SYSCFG->CFGR1 &= ~(SYSCFG_CFGR1_IRDA_ENV_SEL);                                                          SYSCFG->CFGR1 |= (__SOURCE__);                                                            }while(0)
N
N#define __HAL_SYSCFG_GET_IRDA_ENV_SELECTION()  ((SYSCFG->CFGR1) & 0x000000C0)
N/**
N  * @}
N  */
N#endif /* (STM32F091xC) || defined (STM32F098xx)*/
N
N/**
N  * @}
N  */  
N  
N/* Exported functions --------------------------------------------------------*/
N
N/** @addtogroup HAL_Exported_Functions
N  * @{
N  */
N
N/** @addtogroup HAL_Exported_Functions_Group1
N  * @{
N  */    
N/* Initialization and de-initialization functions  ******************************/
NHAL_StatusTypeDef HAL_Init(void);
NHAL_StatusTypeDef HAL_DeInit(void);
Nvoid              HAL_MspInit(void);
Nvoid              HAL_MspDeInit(void);
NHAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority);
N/**
N  * @}
N  */  
N
N/** @addtogroup HAL_Exported_Functions_Group2
N  * @{
N  */    
N
N/* Peripheral Control functions  ************************************************/
Nvoid              HAL_IncTick(void);
Nvoid              HAL_Delay(__IO uint32_t Delay);
Xvoid              HAL_Delay(volatile uint32_t Delay);
Nuint32_t          HAL_GetTick(void);
Nvoid              HAL_SuspendTick(void);
Nvoid              HAL_ResumeTick(void);
Nuint32_t          HAL_GetHalVersion(void);
Nuint32_t          HAL_GetREVID(void);
Nuint32_t          HAL_GetDEVID(void);
Nuint32_t          HAL_GetUIDw0(void);
Nuint32_t          HAL_GetUIDw1(void);
Nuint32_t          HAL_GetUIDw2(void);
Nvoid              HAL_DBGMCU_EnableDBGStopMode(void);
Nvoid              HAL_DBGMCU_DisableDBGStopMode(void);
Nvoid              HAL_DBGMCU_EnableDBGStandbyMode(void);
Nvoid              HAL_DBGMCU_DisableDBGStandbyMode(void);
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F0xx_HAL_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 2 "..\Src\BLE.h" 2
N#pragma anon_unions
N
Ntypedef enum {PositioningModeRemote = 0, PositioningModeSelf} PositioningMode;
N
Ntypedef struct
N{
N    uint64_t AdvAddr;
N    uint8_t channel;
N    uint8_t rssi;
N}REPORT;
N
Ntypedef union
N{
N    struct
N    {
N        uint64_t AdvAddr;
N        uint32_t CreateTime;
N        uint8_t channel[4];
N        int8_t rssi[4];
N        int8_t NumOfRecords;
N    };
N    uint8_t rawData[20];
N}QueueItem;
N
N
Nextern void BleInit(UART_HandleTypeDef* _mod0, UART_HandleTypeDef* _mod1, UART_HandleTypeDef* _mod2, UART_HandleTypeDef* _mod3);
Nextern void BleTask(void);
N
Nextern void BleAddressFilterEnable(void);
Nextern void BleAddressFilterDisable(void);
Nextern void BleAddressFilterAdd(uint64_t address);
Nextern void BleResetTicks(void);
N
Nextern QueueItem* FindItem(uint64_t advAddr);
Nextern QueueItem* GetFreeQueueItem(uint64_t id);
N
Nvoid PositioningModeSet(PositioningMode _positioingMode);
W "..\Src\BLE.h" 39 17 Deprecated declaration PositioningModeGet - give arg types
NPositioningMode PositioningModeGet();
L 4 "..\Src\BLE.c" 2
N#include "ZigBee.h"
L 1 "..\Src\ZigBee.h" 1
N#include "stm32f0xx_hal.h"
N
N
Nvoid ZigBeeInit(UART_HandleTypeDef* mod);
Nvoid ZigBeeTask(void);
N
Nvoid ZigBeeQueueNewReport(uint8_t *msg);
N
Nvoid ZigBeeReset(void);
Nvoid ZigBeeStartInit(void);
N
N
W "..\Src\ZigBee.h" 13 34 last line of file ends without a newline
Nvoid ZigBeeReinitializeDMA(void);
L 5 "..\Src\BLE.c" 2
N#include "userConfig.h"
L 1 "..\Src\userConfig.h" 1
W "..\Src\userConfig.h" 1 25 last line of file ends without a newline
N#define ConfigAnchorId 1
L 6 "..\Src\BLE.c" 2
N
N#include "main.h"
L 1 "../Inc/main.h" 1
N/* USER CODE BEGIN Header */
N/**
N  ******************************************************************************
N  * @file           : main.h
N  * @brief          : Header for main.c file.
N  *                   This file contains the common defines of the application.
N  ******************************************************************************
N  ** This notice applies to any and all portions of this file
N  * that are not between comment pairs USER CODE BEGIN and
N  * USER CODE END. Other portions of this file, whether 
N  * inserted by the user or by software development tools
N  * are owned by their respective copyright owners.
N  *
N  * COPYRIGHT(c) 2018 STMicroelectronics
N  *
N  * Redistribution and use in source and binary forms, with or without modification,
N  * are permitted provided that the following conditions are met:
N  *   1. Redistributions of source code must retain the above copyright notice,
N  *      this list of conditions and the following disclaimer.
N  *   2. Redistributions in binary form must reproduce the above copyright notice,
N  *      this list of conditions and the following disclaimer in the documentation
N  *      and/or other materials provided with the distribution.
N  *   3. Neither the name of STMicroelectronics nor the names of its contributors
N  *      may be used to endorse or promote products derived from this software
N  *      without specific prior written permission.
N  *
N  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N  *
N  ******************************************************************************
N  */
N/* USER CODE END Header */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MAIN_H
N#define __MAIN_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f0xx_hal.h"
N
N/* Private includes ----------------------------------------------------------*/
N/* USER CODE BEGIN Includes */
N
N/* USER CODE END Includes */
N
N/* Exported types ------------------------------------------------------------*/
N/* USER CODE BEGIN ET */
N
N/* USER CODE END ET */
N
N/* Exported constants --------------------------------------------------------*/
N/* USER CODE BEGIN EC */
N
N/* USER CODE END EC */
N
N/* Exported macro ------------------------------------------------------------*/
N/* USER CODE BEGIN EM */
N
N/* USER CODE END EM */
N
N/* Exported functions prototypes ---------------------------------------------*/
Nvoid Error_Handler(void);
N
N/* USER CODE BEGIN EFP */
N
N/* USER CODE END EFP */
N
N/* Private defines -----------------------------------------------------------*/
N#define BOOTIN_Pin GPIO_PIN_13
N#define BOOTIN_GPIO_Port GPIOC
N#define OTA_Pin GPIO_PIN_7
N#define OTA_GPIO_Port GPIOA
N#define Reset_Pin GPIO_PIN_0
N#define Reset_GPIO_Port GPIOB
N#define LED_Pin GPIO_PIN_2
N#define LED_GPIO_Port GPIOB
N#define GPIO3_Pin GPIO_PIN_12
N#define GPIO3_GPIO_Port GPIOB
N#define GPIO2_Pin GPIO_PIN_13
N#define GPIO2_GPIO_Port GPIOB
N#define GPIO1_Pin GPIO_PIN_14
N#define GPIO1_GPIO_Port GPIOB
N#define GPIO0_Pin GPIO_PIN_15
N#define GPIO0_GPIO_Port GPIOB
N#define Autorun_Pin GPIO_PIN_8
N#define Autorun_GPIO_Port GPIOA
N#define TXACTIVE_Pin GPIO_PIN_5
N#define TXACTIVE_GPIO_Port GPIOB
N#define GPIO4_Pin GPIO_PIN_6
N#define GPIO4_GPIO_Port GPIOB
N#define ZIGRTS_Pin GPIO_PIN_8
N#define ZIGRTS_GPIO_Port GPIOB
N#define ZIGCTS_Pin GPIO_PIN_9
N#define ZIGCTS_GPIO_Port GPIOB
N/* USER CODE BEGIN Private defines */
N
N/* USER CODE END Private defines */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MAIN_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 8 "..\Src\BLE.c" 2
N
N#define BUFFER_SIZE 256  /* must be power of two */
N#define COMMAND_BUFFER_SIZE 128
N
N#define NUM_OF_MODULES 4
N
N#define QUEUE_SIZE 60
N
Ntypedef enum {DecodeID, DecodeRSSI, DecodeChannel} DecodePart;
Ntypedef enum { Init = 0, ListeningAdv, Reset} BleState;
N
N
Ntypedef struct
N{
N    uint8_t    rxBuffer[BUFFER_SIZE];
X    uint8_t    rxBuffer[256];
N    uint16_t   lastProccessed;
N    uint8_t    commandBuffer[COMMAND_BUFFER_SIZE];
X    uint8_t    commandBuffer[128];
N    uint8_t    commandBufferIndex;
N}COMM_MODULE;
N
N
Ntypedef enum {Module1 = 0, Module2, Module3, Module4} Modules;
N
Nstatic COMM_MODULE mods[NUM_OF_MODULES];
Xstatic COMM_MODULE mods[4];
N
N
N
Nstatic QueueItem queue[QUEUE_SIZE];
Xstatic QueueItem queue[60];
Nstatic uint8_t queueBottom;
Nstatic uint8_t queueTop;
N
Nstatic bool GetDataFromReport(uint8_t *inputString, uint8_t lenght, REPORT *decodedReport);
Xstatic _Bool GetDataFromReport(uint8_t *inputString, uint8_t lenght, REPORT *decodedReport);
N
NUART_HandleTypeDef* mod0;
NUART_HandleTypeDef* mod1;
NUART_HandleTypeDef* mod2;
NUART_HandleTypeDef* mod3;
N
Nstatic BleState bleState;
Nstatic PositioningMode positioingMode = PositioningModeRemote;
N
Nstatic const uint8_t startCmdListen[] = "\rat+run \"adscan\"\r";        //run as listening anchors
Nstatic const uint8_t startCmdTrasmit[] = "\rat+run \"sAnchor\"\r";        //run as trasmitting anchors
Nstatic uint8_t anchorAntenna[] = "iA0A0\r";
N
Nstatic uint8_t *startCmd;
N
Nstatic bool filterEnable;
Xstatic _Bool filterEnable;
Nstatic uint64_t advAddr[255];
Nstatic uint16_t advAddrIndex;
N
Nstatic uint32_t tickReference;
N
Nstatic bool GetDataFromReport(uint8_t *inputString, uint8_t lenght, REPORT *decodedReport);
Xstatic _Bool GetDataFromReport(uint8_t *inputString, uint8_t lenght, REPORT *decodedReport);
Nstatic void ProcessReport(REPORT *report, Modules module);
Nstatic void CheckForCompleteRecord(QueueItem* queue, uint16_t item);
N
Nstatic bool resetModules;
Xstatic _Bool resetModules;
N
N#define ProcessModuleMessage(module, hdma) \
N      if(mods[module].lastProccessed != hdma->Instance->CNDTR) \
N      { \
N          char tmpChar = mods[module].rxBuffer[BUFFER_SIZE - mods[module].lastProccessed--]; \
N          if(mods[module].lastProccessed == 0) \
N          { \
N              mods[module].lastProccessed = BUFFER_SIZE; \
N          } \
N          mods[module].commandBuffer[mods[module].commandBufferIndex++] = tmpChar; \
N          if(tmpChar == '\r') \
N          { \
N              REPORT reportMod; \
N              if (GetDataFromReport(mods[module].commandBuffer, mods[module].commandBufferIndex, &reportMod)) \
N              { \
N                  ProcessReport(&reportMod, module); \
N              }\
N              mods[module].commandBufferIndex = 0; \
N          }else{ \
N               \
N          } \
N      }
X#define ProcessModuleMessage(module, hdma)       if(mods[module].lastProccessed != hdma->Instance->CNDTR)       {           char tmpChar = mods[module].rxBuffer[BUFFER_SIZE - mods[module].lastProccessed--];           if(mods[module].lastProccessed == 0)           {               mods[module].lastProccessed = BUFFER_SIZE;           }           mods[module].commandBuffer[mods[module].commandBufferIndex++] = tmpChar;           if(tmpChar == '\r')           {               REPORT reportMod;               if (GetDataFromReport(mods[module].commandBuffer, mods[module].commandBufferIndex, &reportMod))               {                   ProcessReport(&reportMod, module);               }              mods[module].commandBufferIndex = 0;           }else{                          }       }
N
Nvoid ProcessModuleMessage2(Modules module, DMA_HandleTypeDef *hdma)
N{
N    uint32_t dmaNDTR;
N    __disable_irq();                      //requred for atomic operation
N    dmaNDTR = hdma->Instance->CNDTR;
N    __enable_irq();
N    
N    if(mods[module].lastProccessed != dmaNDTR)
N      {
N          char tmpChar = mods[module].rxBuffer[BUFFER_SIZE - mods[module].lastProccessed--];
X          char tmpChar = mods[module].rxBuffer[256 - mods[module].lastProccessed--];
N          if(mods[module].lastProccessed == 0)
N          {
N              mods[module].lastProccessed = BUFFER_SIZE;
X              mods[module].lastProccessed = 256;
N          }
N          mods[module].commandBuffer[mods[module].commandBufferIndex++] = tmpChar;
N          if(tmpChar == '\r')
N          {
N              REPORT reportMod;
N              if (GetDataFromReport(mods[module].commandBuffer, mods[module].commandBufferIndex, &reportMod))
N              {
N                  ProcessReport(&reportMod, module);
N              }
N              mods[module].commandBufferIndex = 0;
N          }else{
N               
N          }
N      }
N    
N}
N
Nvoid BleInit(UART_HandleTypeDef* _mod0, UART_HandleTypeDef* _mod1, UART_HandleTypeDef* _mod2, UART_HandleTypeDef* _mod3)
N{
N    mod0 = _mod0;
N    mod1 = _mod1;
N    mod2 = _mod2;
N    mod3 = _mod3;
N    
N    __HAL_UART_FLUSH_DRREGISTER(mod0);     //discard any bytes in register which could be generated by power up routins of modules
X    do{ (((mod0)->Instance ->RQR) |= (((uint32_t)(0x1U << (3U))))); (((mod0)->Instance ->RQR) |= (((uint32_t)(0x1U << (4U))))); } while(0);     
N    __HAL_UART_FLUSH_DRREGISTER(mod1);
X    do{ (((mod1)->Instance ->RQR) |= (((uint32_t)(0x1U << (3U))))); (((mod1)->Instance ->RQR) |= (((uint32_t)(0x1U << (4U))))); } while(0);
N    __HAL_UART_FLUSH_DRREGISTER(mod2);
X    do{ (((mod2)->Instance ->RQR) |= (((uint32_t)(0x1U << (3U))))); (((mod2)->Instance ->RQR) |= (((uint32_t)(0x1U << (4U))))); } while(0);
N    __HAL_UART_FLUSH_DRREGISTER(mod3);
X    do{ (((mod3)->Instance ->RQR) |= (((uint32_t)(0x1U << (3U))))); (((mod3)->Instance ->RQR) |= (((uint32_t)(0x1U << (4U))))); } while(0);
N    
N    HAL_UART_Receive_DMA(mod0, mods[Module1].rxBuffer, BUFFER_SIZE);       //start receive DMA channels, RX chars are stored in ring buffer
X    HAL_UART_Receive_DMA(mod0, mods[Module1].rxBuffer, 256);       
N    HAL_UART_Receive_DMA(mod1, mods[Module2].rxBuffer, BUFFER_SIZE);
X    HAL_UART_Receive_DMA(mod1, mods[Module2].rxBuffer, 256);
N    HAL_UART_Receive_DMA(mod2, mods[Module3].rxBuffer, BUFFER_SIZE);
X    HAL_UART_Receive_DMA(mod2, mods[Module3].rxBuffer, 256);
N    HAL_UART_Receive_DMA(mod3, mods[Module4].rxBuffer, BUFFER_SIZE);
X    HAL_UART_Receive_DMA(mod3, mods[Module4].rxBuffer, 256);
N    
N    mods[Module1].lastProccessed = BUFFER_SIZE;
X    mods[Module1].lastProccessed = 256;
N    mods[Module2].lastProccessed = BUFFER_SIZE;
X    mods[Module2].lastProccessed = 256;
N    mods[Module3].lastProccessed = BUFFER_SIZE;
X    mods[Module3].lastProccessed = 256;
N    mods[Module4].lastProccessed = BUFFER_SIZE;
X    mods[Module4].lastProccessed = 256;
N    
N    uint8_t i;
N    for(i = 0; i < QUEUE_SIZE; i++)
X    for(i = 0; i < 60; i++)
N    {
N      queue[i].NumOfRecords = -1;
N      queue[i].rssi[0] = -110;
N      queue[i].rssi[1] = -110;
N      queue[i].rssi[2] = -110;
N      queue[i].rssi[3] = -110;
N
N      queue[i].channel[0] = 0;
N      queue[i].channel[1] = 0;
N      queue[i].channel[2] = 0;
N      queue[i].channel[3] = 0;
N      
N    }
N    
N    //startCmd = (uint8_t*)startCmdListen;
N    bleState = Init;
N    
N}
N
N
N
Nvoid BleTask()
N{
N    switch(bleState)
N    {
N        case Reset:
N            ZigBeeReset();
N            HAL_Delay(100);
N            HAL_GPIO_WritePin(Reset_GPIO_Port, Reset_Pin, GPIO_PIN_RESET);
X            HAL_GPIO_WritePin(((GPIO_TypeDef *) ((((uint32_t)0x40000000U) + 0x08000000) + 0x00000400)), ((uint16_t)0x0001U), GPIO_PIN_RESET);
N            HAL_Delay(200);
N            HAL_GPIO_WritePin(Reset_GPIO_Port, Reset_Pin, GPIO_PIN_SET);
X            HAL_GPIO_WritePin(((GPIO_TypeDef *) ((((uint32_t)0x40000000U) + 0x08000000) + 0x00000400)), ((uint16_t)0x0001U), GPIO_PIN_SET);
N            ZigBeeStartInit();
N            HAL_Delay(500);
N        
N            bleState = Init;
N            break;
N        
N        case Init:
N            __HAL_UART_FLUSH_DRREGISTER(mod0);     //discard any bytes in register which could be generated by power up routins of modules
X            do{ (((mod0)->Instance ->RQR) |= (((uint32_t)(0x1U << (3U))))); (((mod0)->Instance ->RQR) |= (((uint32_t)(0x1U << (4U))))); } while(0);     
N            __HAL_UART_FLUSH_DRREGISTER(mod1);
X            do{ (((mod1)->Instance ->RQR) |= (((uint32_t)(0x1U << (3U))))); (((mod1)->Instance ->RQR) |= (((uint32_t)(0x1U << (4U))))); } while(0);
N            __HAL_UART_FLUSH_DRREGISTER(mod2);
X            do{ (((mod2)->Instance ->RQR) |= (((uint32_t)(0x1U << (3U))))); (((mod2)->Instance ->RQR) |= (((uint32_t)(0x1U << (4U))))); } while(0);
N            __HAL_UART_FLUSH_DRREGISTER(mod3);
X            do{ (((mod3)->Instance ->RQR) |= (((uint32_t)(0x1U << (3U))))); (((mod3)->Instance ->RQR) |= (((uint32_t)(0x1U << (4U))))); } while(0);
N            
N            HAL_UART_Receive_DMA(mod0, mods[Module1].rxBuffer, BUFFER_SIZE);       //start receive DMA channels, RX chars are stored in ring buffer
X            HAL_UART_Receive_DMA(mod0, mods[Module1].rxBuffer, 256);       
N            HAL_UART_Receive_DMA(mod1, mods[Module2].rxBuffer, BUFFER_SIZE);
X            HAL_UART_Receive_DMA(mod1, mods[Module2].rxBuffer, 256);
N            HAL_UART_Receive_DMA(mod2, mods[Module3].rxBuffer, BUFFER_SIZE);
X            HAL_UART_Receive_DMA(mod2, mods[Module3].rxBuffer, 256);
N            HAL_UART_Receive_DMA(mod3, mods[Module4].rxBuffer, BUFFER_SIZE);
X            HAL_UART_Receive_DMA(mod3, mods[Module4].rxBuffer, 256);
N        
N            switch(positioingMode)
N            {
N                case PositioningModeRemote:
N                    HAL_UART_Transmit_DMA(mod0, (uint8_t*)startCmdListen, strlen((const char*)startCmdListen));
N                    HAL_Delay(132);
N                    HAL_UART_Transmit_DMA(mod1, (uint8_t*)startCmdListen, strlen((const char*)startCmdListen));
N                    HAL_Delay(132);
N                    HAL_UART_Transmit_DMA(mod2, (uint8_t*)startCmdListen, strlen((const char*)startCmdListen));
N                    HAL_Delay(132);
N                    HAL_UART_Transmit_DMA(mod3, (uint8_t*)startCmdListen, strlen((const char*)startCmdListen));
N                    HAL_Delay(132);
N                    break;
N                
N                case PositioningModeSelf:
N                    HAL_Delay(20*ConfigAnchorId);
X                    HAL_Delay(20*1);
N                    HAL_UART_Transmit_DMA(mod0, (uint8_t*)startCmdTrasmit, strlen((const char*)startCmdTrasmit));
N                    HAL_Delay(8);
N                    HAL_UART_Transmit_DMA(mod1, (uint8_t*)startCmdTrasmit, strlen((const char*)startCmdTrasmit));
N                    HAL_Delay(8);
N                    HAL_UART_Transmit_DMA(mod2, (uint8_t*)startCmdTrasmit, strlen((const char*)startCmdTrasmit));
N                    HAL_Delay(8);
N                    HAL_UART_Transmit_DMA(mod3, (uint8_t*)startCmdTrasmit, strlen((const char*)startCmdTrasmit));
N                    HAL_Delay(8);
N                
N                    
N                    anchorAntenna[2] = ConfigAnchorId + '0';
X                    anchorAntenna[2] = 1 + '0';
N                    anchorAntenna[4] = '0';
N                    HAL_UART_Transmit_DMA(mod0, anchorAntenna, 6);
N                    HAL_Delay(4);
N                    anchorAntenna[4] = '1';
N                    HAL_UART_Transmit_DMA(mod1, anchorAntenna, 6);
N                    HAL_Delay(4);    
N                    anchorAntenna[4] = '2';
N                    HAL_UART_Transmit_DMA(mod2, anchorAntenna, 6);
N                    HAL_Delay(4);
N                    anchorAntenna[4] = '3';
N                    HAL_UART_Transmit_DMA(mod3, anchorAntenna, 6);
N                       
N                    
N                    break;
N                    
N            }
N            bleState = ListeningAdv;
N            break;
N        
N        case ListeningAdv:
N        {
N            /*=== Process receive ring buffers of BLE modules ===*/
N//            ProcessModuleMessage(Module1, hdma_usart3_rx);
N//            ProcessModuleMessage(Module2, hdma_usart1_rx);
N//            ProcessModuleMessage(Module3, hdma_usart4_rx);
N//            ProcessModuleMessage(Module4, hdma_usart5_rx);
N
N            
N            ProcessModuleMessage2(Module1, mod0->hdmarx);
N            ProcessModuleMessage2(Module2, mod1->hdmarx);
N            ProcessModuleMessage2(Module3, mod2->hdmarx);
N            ProcessModuleMessage2(Module4, mod3->hdmarx);
N
N            uint8_t i;
N            if(queueBottom < queueTop)
N            {  
N                for(i = queueBottom; i < queueTop; i++)
N                {
N                  CheckForCompleteRecord(queue, i);
N                }
N            }
N            else // queue rolled over, not bottom is greater than top
N            {
N                for(i = queueBottom; i < QUEUE_SIZE; i++)
X                for(i = queueBottom; i < 60; i++)
N                {
N                  CheckForCompleteRecord(queue, i);
N                }
N
N                for(i = 0; i < queueTop; i++)
N                {
N                  CheckForCompleteRecord(queue, i);
N                }
N            }
N        
N        }
N        break;
N        
N        
N        default:
N            break;
N    }
N    
N    if(resetModules)
N    {
N        resetModules = false;
X        resetModules = 0;
N        bleState = Reset;
N    }
N}
N
N
Nstatic bool GetDataFromReport(uint8_t *inputString, uint8_t lenght, REPORT *decodedReport)
Xstatic _Bool GetDataFromReport(uint8_t *inputString, uint8_t lenght, REPORT *decodedReport)
N{
N    DecodePart decodePart;
N    uint8_t c;
N    
N    uint64_t localId = 0;
N    int8_t localRssi = 0;
N    uint8_t localChannel = 0;
N    
N    int8_t applySign = 1;
N    
N    if(inputString[0] == ';')
N    {
N        uint8_t i;   
N        decodePart = DecodeID;
N        
N        for(i = 1; i < lenght; i++)
N        {
N            c = inputString[i]; 
N            if((c == ',') || (c == '\r'))
N            {
N                switch(decodePart)
N                {
N                    case DecodeID:
N                        decodedReport->AdvAddr = localId;
N                        decodePart = DecodeRSSI;
N                        break;
N                    
N                    case DecodeRSSI:
N                        decodedReport->rssi = applySign * localRssi;
N                        decodePart = DecodeChannel;
N                        break;
N                    
N                    case DecodeChannel:
N                        decodedReport->channel = localChannel;
N                        return true;
X                        return 1;
N                }
N            }
N            else
N            {
N                switch(decodePart)
N                {
N                    case DecodeID:                
N                        localId <<= 4;
N                        if ((c >= '0') && (c <= '9'))            
N                        {
N                            localId |= (c - '0');
N                        }
N                        else if ((c >= 'A') && (c <= 'F'))
N                        {
N                            localId  |= (10 + c - 'A');
N                        }
N                        else
N                        {
N                            return false;
X                            return 0;
N                        }
N                        break;
N                        
N                    case DecodeRSSI:
N                        localRssi *= 10;
N                        if ((c >= '0') && (c <= '9'))            
N                        {
N                            localRssi += (c - '0');
N                        }
N                        else if (c == '-')
N                        {
N                            applySign = -1;
N                        }else{
N                            return false;
X                            return 0;
N                        }
N                        break;
N                        
N                    case DecodeChannel:
N                        if ((c >= '0') && (c <= '9'))            
N                        {
N                            localChannel = (c - '0');
N                        }
N                        else{
N                            return false;
X                            return 0;
N                        }
N                        break;
N                }
N            }    
N        }
N    }
N    return false;
X    return 0;
N}
N
Nstatic void ProcessReport(REPORT *report, Modules module)
N{
N    QueueItem *qi;
N    
N    if(filterEnable == true)
X    if(filterEnable == 1)
N    {
N        if (report->AdvAddr != advAddr[0])
N        {
N            return;
N        }
N    }    
N    
N    qi = FindItem(report->AdvAddr);
N    if(qi != NULL)
X    if(qi != 0)
N    {
N      qi->channel[module] = report->channel;
N      qi->rssi[module] = report->rssi;
N      qi->NumOfRecords++;
N    }
N}
N
NQueueItem* FindItem(uint64_t advAddr)
N{
N    uint8_t itemsInQueue;
N    uint8_t i;
N    
N    if(queueBottom != queueTop)
N    {
N        if (queueBottom < queueTop)         //all ok bottom is under top
N        {
N            itemsInQueue = queueTop - queueBottom;
N            for(i=queueBottom;i<queueTop;i++) //seach for AdvAddr in queue
N            {               
N                if(advAddr == queue[i].AdvAddr)  //id found, return queue item
N                {
N                    return &queue[i];
N                }
N            }
N        }
N        else
N        {                              //there has been a overflow from top addres to 0, does not mean the queue is full
N            itemsInQueue = QUEUE_SIZE - queueBottom + queueTop;
X            itemsInQueue = 60 - queueBottom + queueTop;
N            
N            for(i=queueBottom;i<QUEUE_SIZE;i++) //seach for AdvAddr in queue, bottom to top slots
X            for(i=queueBottom;i<60;i++) 
N            {
N                if(advAddr == queue[i].AdvAddr)  //id found, return queue item
N                {
N                    return &queue[i];
N                }
N            }
N            
N            for(i=0;i<queueTop;i++) //seach for AdvAddr in queue, form 0 to top slots
N            {
N                if(advAddr ==queue[i].AdvAddr)  //id found, return queue item
N                {
N                    return &queue[i];
N                }
N            }
N        }
N    }
N    return GetFreeQueueItem(advAddr);    //queue is empty or AdvAddr was not found create a new entry for AdvAddr and return the queue slot
W "..\Src\BLE.c" 398 13 variable "itemsInQueue" was set but never used
N}
N
N///Gets a spot in ReportQueue, fills created time (reports from four antennnas need to be received in 4 miliseconds to ensure that they comes from a single advertisement, 
N///                            in case there is received less than 4 reports after 4 miliseconds only 3 reports are sent to system)
N///                          , and fills AdvAddress (id)
N///
NQueueItem* GetFreeQueueItem(uint64_t id)
N{
N    uint8_t tmpQTop;
N    if (queueBottom != queueTop)
N    {
N        if(queueBottom < queueTop)
N        {
N            if((queueTop - queueBottom) >= (QUEUE_SIZE - 1) )
X            if((queueTop - queueBottom) >= (60 - 1) )
N            {
N                return NULL;
X                return 0;
N            }
N        }
N        else
N        {
N            if( (QUEUE_SIZE - queueBottom + queueTop) >= (QUEUE_SIZE - 1) )
X            if( (60 - queueBottom + queueTop) >= (60 - 1) )
N            {
N                return NULL;
X                return 0;
N            }
N        }
N    }
N    queue[queueTop].CreateTime = HAL_GetTick();
N    queue[queueTop].AdvAddr = id;
N    queue[queueTop].NumOfRecords = 0;
N    
N    tmpQTop = queueTop;
N    queueTop++;
N    if (queueTop >= QUEUE_SIZE)
X    if (queueTop >= 60)
N    {
N        queueTop = 0;
N    }
N    return &queue[tmpQTop];
N}
N
Nstatic void CheckForCompleteRecord(QueueItem* queue, uint16_t item)
N{
N    QueueItem *queueItem = &queue[item];
N    
N    
N    
N    if(queueItem->NumOfRecords != -1)
N    {
N        if (((queueItem->CreateTime + 5) < HAL_GetTick()) || (queueItem->NumOfRecords == 4))    //send record if the timeout has elapsaed or all four records has been received
N        {                      
N            //TransmitData(queue[i].rawData, 20);
N            queueItem->CreateTime -= tickReference;
N            ZigBeeQueueNewReport(queueItem->rawData);
N            queueItem->NumOfRecords = -1;
N            queueItem->rssi[0] = -110;
N            queueItem->rssi[1] = -110;
N            queueItem->rssi[2] = -110;
N            queueItem->rssi[3] = -110;
N            
N            queueItem->channel[0] = 0;
N            queueItem->channel[1] = 0;
N            queueItem->channel[2] = 0;
N            queueItem->channel[3] = 0;
N            if(item == queueBottom)
N            {
N                queueBottom++;
N                if (queueBottom >= QUEUE_SIZE)
X                if (queueBottom >= 60)
N                {
N                    queueBottom = 0;
N                }
N            }
N        }
N    }
N    else
N    {
N        if (item == queueBottom)
N        {
N          queueBottom++;
N          if (queueBottom >= QUEUE_SIZE)
X          if (queueBottom >= 60)
N          {
N              queueBottom = 0;
N          }
N        }
N    }
N}
N
N
N
Nvoid BleAddressFilterEnable()
N{
N    filterEnable = true;
X    filterEnable = 1;
N}
N
Nvoid BleAddressFilterDisable()
N{
N    filterEnable = false;
X    filterEnable = 0;
N}
N
Nvoid BleAddressFilterAdd(uint64_t address)
N{
N    advAddr[advAddrIndex] = address;
N}
N
Nvoid BleResetTicks()
N{
N    tickReference = HAL_GetTick();
N}
N
Nvoid PositioningModeSet(PositioningMode _positioingMode)
N{
N    if(positioingMode != _positioingMode)
N    {
N        positioingMode = _positioingMode;
N        resetModules = true;
X        resetModules = 1;
N    }
N//    switch(positioingMode)
N//    {
N//        case PositioningModeRemote:
N//            
N//            break;
N//        
N//        case PositioningModeSelf:
N//            
N//            break;
N//    }
N}
N
NPositioningMode PositioningModeGet()
N{
N    return positioingMode;
N}
W "..\Src\BLE.c" 53 17 variable "startCmd" was declared but never referenced
